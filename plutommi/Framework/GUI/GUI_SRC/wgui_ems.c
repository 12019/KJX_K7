/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * wgui_ems_categories.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for UI wrapper routines for EMS .
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
 /**
 * Copyright Notice
 * (c) 2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,
 * Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.
 *  (It is illegal to remove this copyright notice from this software or any
 *  portion of it)
 */

/**********************************************************************************
   Filename:      wgui_ems_categories.c
   Author:        manju
   Date Created:  March-22-2003
   Contains:      UI wrapper routines for EMS and category screens
**********************************************************************************/




#include "MMI_features.h"

//#include "mmi_platform.h"
//#include "mmi_frm_gprot.h"
//#include "conversions.h"

//#include "CustDataProts.h"
//#include "CustMenuRes.h"
//#include "GlobalDefs.h"
//#include "SettingProfile.h"
//#include "WguiCategoryGprot.h"
//#include "wgui_softkeys.h"
#include "wgui_ems.h"
#include "MessagesResourceData.h"
//#include "CommonScreens.h"
#if defined(__MMI_FILE_MANAGER__)
//#include "FileMgr.h"
//#include "FileManagerDef.h"
//#include "FileManagerGProt.h"
#endif /* defined(__MMI_FILE_MANAGER__) */ 

#include "wgui_inputs.h"

/*PMT IRE START*/
#ifdef __MMI_INDIC_ALG__
#include "IndicEngineGprot.h"
/*PMT IRE END*/
#endif 
//#include "wgui_virtual_keyboard.h"

    #include "MMIDataType.h"
    #include "gui_ems.h"
    #include "ImeGprot.h"
    #include "gui_config.h"
    #include "gui_data_types.h"
    #include "ems.h"
    #include "kal_general_types.h"
    #include "gui.h"
    #include "mmi_frm_events_gprot.h"
    #include "IdleAppResDef.h"
    #include "CommonScreensResDef.h"
    #include "gui_inputs.h"
    #include "string.h"
    #include "GlobalConstants.h"
    #include "Unicodexdcl.h"
    #include "wgui.h"
    #include "mmi_frm_input_gprot.h"    
    #include "mmi_frm_timer_gprot.h"
    #include "ps_public_enum.h"
#ifndef __COSMOS_MMI_PACKAGE__
    #include "mmi_rp_app_sms_def.h"
#endif
    #include "mmi_rp_app_uiframework_def.h"
    #include "wgui_categories_util.h"
    #include "gui_virtual_keyboard_language_type.h"
    #include "gui_theme_struct.h"
    #include "gdi_datatype.h"
    #include "gdi_include.h"
    #include "CustThemesRes.h"
    #include "gui_themes.h"
    #include "PixcomFontEngine.h"
    #include "gui_typedef.h"
    #include "wgui_categories_inputs.h"
    #include "gui_scrollbars.h"
    #include "wgui_categories_fmgr.h"
    #include "kal_public_api.h"
    #include "custom_hw_default.h"
    #include "DebugInitDef_Int.h"

    #include "gui_touch_feedback.h"
    
    #include "gui_inputs_internal.h"

#ifdef UI_EMS_SUPPORT

/* Use file manager category header for Ems header background (08B) */

/* MTK Elvis for R2L characters */
extern BOOL r2lMMIFlag;
/* MTK end */
extern S32 MMI_timer_multitap;



extern void wgui_set_EMS_inputbox_RSK(void);
extern void wgui_EMS_redraw_input_information_bar(void);
extern void gui_EMS_change_DCS(UI_EMS_input_box *b);
extern void wgui_show_input_mode_internal(
                    S32 info_bar_x,
                    S32 info_bar_y,
                    S32 info_bar_width,
                    S32 info_bar_height,
                    mmi_imm_input_mode_enum input_mode, 
                    PU8 inputbox_information_icon);

#ifdef __MMI_MESSAGES_EMS__
extern void EMS_cancel_object_focus(void);
#endif 
/* MTK end */

/* MTK Elvis */
extern void StopTimer(U16 timerid);
/* MTK end */

/* W05.36 Fix Vietnamese Tone Input Issue */
extern void set_current_input_box_type(mmi_editor_inoutbox_enum input_box_type);

extern void dm_set_scr_bg_image_no_draw(U16 image_id, CHAR *file_name, S32 x, S32 y, U8 opacity);        /* 092005 grayscale Calvin */

extern U8 PhnsetGetDefEncodingType(void);

/* MTK Terry for RSK Display */
void handle_category28_input(void);
void handle_category28_input_no_show_counter(void);


/* Temporary: Will be removed later */
UI_string_type temp_EMS_buffer;
EMSData *temp_EMS_data;

/* EMS input box: Low level wrappers   */

void (*EMS_inputbox_input_callback) (void);

static void wgui_inputs_EMS_handle_left_arrow_repeat(void);
static void wgui_inputs_EMS_handle_right_arrow_repeat(void);
static void wgui_inputs_EMS_handle_up_arrow_repeat(void);
static void wgui_inputs_EMS_handle_down_arrow_repeat(void);



#ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
static EMS_HILITE *g_wgui_inputs_EMS_hilite_list;
static U16 g_wgui_inputs_EMS_hilite_list_number;
static U16 g_wgui_inputs_EMS_curr_hilite_idx;
static void (*g_wgui_inputs_EMS_hilite_cb)(S32 idx);
#ifdef __MMI_TOUCH_SCREEN__
static void (*g_wgui_inputs_EMS_hilite_click_cb)(S32 idx);
#endif /* __MMI_TOUCH_SCREEN__ */
#endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */

void (*ems_inputbox_set_key_callback) (void) = NULL;

static wgui_inputs_ems_key_hdlr g_wgui_inputs_ems_pre_key_handler = NULL;
static MMI_BOOL wgui_inputs_ems_pre_key_handler(U16 key_code, U16 key_type);

#if defined(__MMI_IMELODY_SUPPORT__)  /* slim_2_2 */ //
static void EMS_melody_detach_header(U8 *src, U8 *dst, S32 *size);
static void EMS_melody_attach_header(U8 *src, U8 *dst, S32 *size, U8 type);
#endif
/*****************************************************************************
 * FUNCTION
 *  register_EMS_inputbox_input_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  f       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void register_EMS_inputbox_input_callback(void (*f) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMS_inputbox_input_callback = f;
}

#if(!UI_DISABLE_EMS_INPUT_BOX)

/* 072904 Calvin moved for centralized control */
// #define ENABLE_EMS_INPUTBOX_FRAME_SKIPPING                   1
/* Calvin end */

U8 EMS_inputbox_has_changed = 0;
UI_EMS_input_box MMI_EMS_inputbox;
EMSTextFormat wgui_EMS_text_format;

extern void wgui_EMS_redraw_remaining_characters_display(void);

#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING))
S32 wgui_EMS_inputbox_frame_counter = 0;
#endif 


/*****************************************************************************
 * FUNCTION
 *  show_EMS_inputbox
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void show_EMS_inputbox(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_EMS_input_box_current_theme(&MMI_EMS_inputbox);

    gui_show_EMS_input_box(&MMI_EMS_inputbox);
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_BLT_double_buffer(
        MMI_EMS_inputbox.x,
        MMI_EMS_inputbox.y,
        MMI_EMS_inputbox.x + MMI_EMS_inputbox.width - 1,
        MMI_EMS_inputbox.y + MMI_EMS_inputbox.height - 1);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 
}

#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING))


/*****************************************************************************
 * FUNCTION
 *  wgui_EMS_inputbox_end_frame
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_EMS_inputbox_end_frame(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_EMS_inputbox_frame_counter >= 1)
    {
        S32 BLT_y2, y2;

    #if(UI_DOUBLE_BUFFER_SUPPORT)
        gui_lock_double_buffer();
    #endif 
        gui_show_EMS_input_box(&MMI_EMS_inputbox);
        if (EMS_inputbox_has_changed)
        {
            wgui_EMS_redraw_remaining_characters_display();
            EMS_inputbox_has_changed = 0;
        }
    #if(UI_DOUBLE_BUFFER_SUPPORT)
        gui_unlock_double_buffer();
        BLT_y2 = MMI_EMS_inputbox.y + MMI_EMS_inputbox.height;
        y2 = MMI_multitap_y + MMI_multitap_height + 1;
        if (BLT_y2 < y2)
        {
            BLT_y2 = y2;
        }
        gui_BLT_double_buffer(
            MMI_EMS_inputbox.x,
            MMI_EMS_inputbox.y,
            MMI_EMS_inputbox.x + MMI_EMS_inputbox.width - 1,
            BLT_y2);
    #endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 
        wgui_EMS_inputbox_frame_counter = 0;
        gui_start_timer(UI_FRAME_SKIP_TIMEOUT, wgui_EMS_inputbox_end_frame);
    }
}

#endif /* ((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING)) */ 

#if(EMS_INPUTBOX_DEBUG)

#define _DEBUG_PRINT(x) _debug_print x

extern void DisplayToDebugwindow(CHAR *nPrintableStr);


/*****************************************************************************
 * FUNCTION
 *  _debug_print
 * DESCRIPTION
 *  
 * PARAMETERS
 *  fmt     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void _debug_print(CHAR *fmt, ...)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR display_string[2048];
    va_list args;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    va_start(args, fmt);
    vsprintf(display_string, fmt, args);
    va_end(args);
    DisplayToDebugwindow(display_string);
}


/*****************************************************************************
 * FUNCTION
 *  _DUMP_EMS_TEXT_FORMAT_OBJECT
 * DESCRIPTION
 *  
 * PARAMETERS
 *  x       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void _DUMP_EMS_TEXT_FORMAT_OBJECT(EMSTextFormat *x)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (x != NULL)
    {
        _DEBUG_PRINT(("L=%03d ", x->textLength));
        _DEBUG_PRINT(("AL="));
        switch (x->Alignment)
        {
            case EMS_ALIGN_LEFT:
                _DEBUG_PRINT(("L"));
                break;
            case EMS_ALIGN_RIGHT:
                _DEBUG_PRINT(("R"));
                break;
            case EMS_ALIGN_CENTER:
                _DEBUG_PRINT(("C"));
                break;
            case EMS_ALIGN_LANG_DEP:
                _DEBUG_PRINT(("D"));
                break;
        }
        _DEBUG_PRINT((" SZ="));
        switch (x->FontSize)
        {
            case EMS_FONTSIZE_NORMAL:
                _DEBUG_PRINT(("N"));
                break;
            case EMS_FONTSIZE_LARGE:
                _DEBUG_PRINT(("L"));
                break;
            case EMS_FONTSIZE_SMALL:
                _DEBUG_PRINT(("S"));
                break;
        }
        _DEBUG_PRINT((" ST="));
        if (x->isBold)
        {
            _DEBUG_PRINT(("B"));
        }
        if (x->isItalic)
        {
            _DEBUG_PRINT(("I"));
        }
        if (x->isUnderline)
        {
            _DEBUG_PRINT(("U"));
        }
        if (x->isStrikethrough)
        {
            _DEBUG_PRINT(("S"));
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  _DUMP_EMS_OBJECT
 * DESCRIPTION
 *  
 * PARAMETERS
 *  x       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void _DUMP_EMS_OBJECT(EMSObject *x)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (x == NULL)
    {
        _DEBUG_PRINT(("NULL"));
    }
    else
    {
        _DEBUG_PRINT(("%8X OFF=%03d ", x, x->OffsetToText));
        switch (x->Type)
        {
            case EMS_TYPE_TEXT_FORMAT:
                _DEBUG_PRINT(("TXT FMT "));
                _DUMP_EMS_TEXT_FORMAT_OBJECT(&x->data->text_format);
                break;
            case EMS_TYPE_PREDEF_SND:
                _DEBUG_PRINT(("PRE SND %d", x->PredefNo));
                break;
            case EMS_TYPE_USERDEF_SND:
                _DEBUG_PRINT(("USR SND"));
                break;
            case EMS_TYPE_PREDEF_ANM:
                _DEBUG_PRINT(("PRE ANM %d", x->PredefNo));
                break;
            case EMS_TYPE_USERDEF_ANM:
                _DEBUG_PRINT(("USR ANM"));
                break;
            case EMS_TYPE_PIC:
                _DEBUG_PRINT(("EMS PIC"));
                break;
        }
    }
}

#else /* (EMS_INPUTBOX_DEBUG) */ 

#define _DEBUG_PRINT(x)


/*****************************************************************************
 * FUNCTION
 *  _DUMP_EMS_OBJECT
 * DESCRIPTION
 *  
 * PARAMETERS
 *  x       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void _DUMP_EMS_OBJECT(EMSObject *x)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(x);
}

#endif /* (EMS_INPUTBOX_DEBUG) */ 

#ifdef __MMI_FRM_HISTORY__
extern U16 GetExitScrnID(void);
#endif

//#include "IdleAppDef.h"


/*****************************************************************************
 * FUNCTION
 *  redraw_EMS_inputbox
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_EMS_inputbox(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FRM_HISTORY__
    if ((SCR_POPUP_SCREEN != GetExitScrnID()) && (POPUP_SCREENID != GetExitScrnID()))
#endif
    {
    #if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING))
        if (wgui_EMS_inputbox_frame_counter > 0)
        {
            wgui_EMS_inputbox_frame_counter++;
        }
        else
        {
            wgui_EMS_inputbox_frame_counter = 1;
            gui_start_timer(UI_FRAME_START_TIMEOUT, wgui_EMS_inputbox_end_frame);
        }
    #else /* ((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING)) */ 

        gui_show_EMS_input_box(&MMI_EMS_inputbox);
    
#if !defined(__MMI_FTE_SUPPORT__) && !defined(__OP01_FWPBW__)
        if (!(MMI_EMS_inputbox.flags & UI_EMS_INPUT_BOX_VIEW_MODE) && 
            (!(MMI_EMS_inputbox.flags & UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW)))
        {
            wgui_EMS_redraw_remaining_characters_display();
            /* EMS_inputbox_has_changed=0; */
        }
#endif

    #if(UI_DOUBLE_BUFFER_SUPPORT)
        gui_BLT_double_buffer(
            MMI_EMS_inputbox.x,
            MMI_EMS_inputbox.y,
            MMI_EMS_inputbox.x + MMI_EMS_inputbox.width - 1,
            MMI_EMS_inputbox.y + MMI_EMS_inputbox.height - 1);
    #endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 

    #endif /* ((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING)) */ 
    }
}


/*****************************************************************************
 * FUNCTION
 *  show_EMS_inputbox_no_draw
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void show_EMS_inputbox_no_draw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_EMS_inputbox.flags |= (UI_EMS_INPUT_BOX_DISABLE_DRAW);
    gui_show_EMS_input_box(&MMI_EMS_inputbox);
    MMI_EMS_inputbox.flags &= ~(UI_EMS_INPUT_BOX_DISABLE_DRAW);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_ems_is_same_text_format
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL wgui_inputs_ems_is_same_text_format(EMSPosition p_start, EMSPosition p_end)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObject *p1, *p2;
    EMSPosition current_p = MMI_EMS_inputbox.data->CurrentPosition;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    p1 = gui_ems_get_current_text_format_for_position(MMI_EMS_inputbox.data, &p_start);
    gui_EMS_input_box_set_cursor_position(&MMI_EMS_inputbox, &p_start);

#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
    gui_emsc_all_line_update();
#endif
    gui_show_EMS_input_box(&MMI_EMS_inputbox);

    gui_EMS_input_box_next(&MMI_EMS_inputbox);
    while ((MMI_EMS_inputbox.data->CurrentPosition.OffsetToText != p_end.OffsetToText) ||
           (MMI_EMS_inputbox.data->CurrentPosition.Object != p_end.Object))
    {
        p2 = gui_ems_get_current_text_format_for_position(MMI_EMS_inputbox.data, &MMI_EMS_inputbox.data->CurrentPosition);
        if (p1 != p2)
        {
            gui_EMS_input_box_set_cursor_position(&MMI_EMS_inputbox, &current_p);
        #ifdef GUI_INPUT_BOX_CACHE_SUPPORT
            gui_emsc_all_line_update();
        #endif
            gui_show_EMS_input_box(&MMI_EMS_inputbox);
            return MMI_FALSE;
        }
        gui_EMS_input_box_next(&MMI_EMS_inputbox);
    }

    gui_EMS_input_box_set_cursor_position(&MMI_EMS_inputbox, &current_p);
#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
    gui_emsc_all_line_update();
#endif
    gui_show_EMS_input_box(&MMI_EMS_inputbox);

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_previous
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_previous(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SMART_ALPHABETIC_RESELECTION__)  
    EMSPosition back_up_position, temp_position;
    UI_character_type c, temp_c;
	EMSObject *obj;
	U8 ret;
    MMI_BOOL is_valid_cluster = MMI_FALSE;
    S32 word_length = 0;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_inputs_ems_pre_key_handler)
    {
        if (g_wgui_inputs_ems_pre_key_handler(KEY_LEFT_ARROW))
        {
            return;
        }
    }

#if defined(__MMI_SMART_ALPHABETIC_RESELECTION__)   
    if (mmi_imc_is_reselection_input_mode(mmi_imm_get_curr_input_mode())
        && mmi_imc_is_smart_alphabetic_word_reselection_enabled())
    {
		memcpy(&back_up_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));

        /* Get the character or cluster behind cursor and check whether it's a valid string of current input mode */
		if (gui_EMS_input_box_get_next_character(&MMI_EMS_inputbox, &c) != 1)
		{
			c = 0;
		}

        if (c == 0x1b)
        {
            memcpy(&temp_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));

            c = (UI_character_type)((MMI_EMS_inputbox.data->textBuffer[temp_position.OffsetToText + 2]) 
                            | (MMI_EMS_inputbox.data->textBuffer[temp_position.OffsetToText + 3] << 8));

            is_valid_cluster = mmi_imc_is_valid_alphabetic_word_of_current_input_mode((U8 *)&c, 1);
        }
        else if (c != 0x20 && c != 0x0D && c != 0x0A && c != 0)
        {
            gui_EMS_input_box_next(&MMI_EMS_inputbox);
            is_valid_cluster = mmi_imc_is_valid_alphabetic_word_of_current_input_mode((U8 *)&MMI_EMS_inputbox.data->textBuffer[back_up_position.OffsetToText], 
                (MMI_EMS_inputbox.data->CurrentPosition.OffsetToText - back_up_position.OffsetToText)/ENCODING_LENGTH);
            gui_EMS_input_box_previous(&MMI_EMS_inputbox);
        }

        if (c == 0x20 || c == 0x0D || c == 0x0A || c == 0 || !is_valid_cluster)
        {
			memcpy(&temp_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));
			
            if (!TestFirstPosition(MMI_EMS_inputbox.data, &MMI_EMS_inputbox.data->CurrentPosition))
            {
                do
                {
                    ret = gui_EMS_input_box_get_previous_object(MMI_EMS_inputbox.data, &temp_position, &c, &obj);
					
					if (ret == 2 && obj->Type == EMS_TYPE_TEXT_FORMAT)
					{
						ret = gui_EMS_input_box_get_previous_object(MMI_EMS_inputbox.data, &temp_position, &c, &obj);
					}
					
					if (ret == 2)
					{
                        gui_EMS_input_box_get_next_object(MMI_EMS_inputbox.data, &temp_position, &c, &obj);
						c = 0;
						break;
					}	
					else if (ret == 0)
					{
						c = 0;
						break;
					}	
                    else if (c == 0x1b)
                    {
                        if (!TestFirstPosition(MMI_EMS_inputbox.data, &temp_position))
                        {
                            continue;
                        }
                        else
                        {
                            break;
                    }
                    }

                    if (!(c != 0x20 && c != 0x0D && c != 0x0A && c != 0 && mmi_imc_is_valid_alphabetic_word_of_current_input_mode((U8 *)&c, 1)))
                    {
                        break;
                    }

                    word_length++;

                }while (word_length <= mmi_imc_get_max_reselection_word_length() && !TestFirstPosition(MMI_EMS_inputbox.data, &temp_position));
            }

            if (word_length <= mmi_imc_get_max_reselection_word_length() && word_length > 0)
            {
                if(!TestFirstPosition(MMI_EMS_inputbox.data, &temp_position) && c == 0x0A)
                {
                    ret = gui_EMS_input_box_get_previous_object(MMI_EMS_inputbox.data, &temp_position, &temp_c, &obj);

                    if (!(ret == 1 && temp_c == 0x0D))
                    {
                        ret = gui_EMS_input_box_get_next_object(MMI_EMS_inputbox.data, &temp_position, &temp_c, &obj);
                    }
                }

                if(!TestFirstPosition(MMI_EMS_inputbox.data, &temp_position))
                {
                    ret = gui_EMS_input_box_get_previous_object(MMI_EMS_inputbox.data, &temp_position, &temp_c, &obj);

                    if (!(ret == 2 && obj->Type == EMS_TYPE_TEXT_FORMAT))
                    {
                        ret = gui_EMS_input_box_get_next_object(MMI_EMS_inputbox.data, &temp_position, &temp_c, &obj);
                    }
                }

			    MoveCursorToPosition(MMI_EMS_inputbox.data, &temp_position);

            #ifdef GUI_INPUT_BOX_CACHE_SUPPORT
                gui_emsc_all_line_update();
            #endif

                gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);

                gui_show_EMS_input_box(&MMI_EMS_inputbox);

			    if (c != 0 && (c == 0x20 || c == 0x0D || c == 0x0A || !mmi_imc_is_valid_alphabetic_word_of_current_input_mode((U8 *)&c, 1)) 
                    && MMI_EMS_inputbox.data->CurrentPosition.OffsetToText < back_up_position.OffsetToText
                    && MMI_EMS_inputbox.data->CurrentPosition.OffsetToText == temp_position.OffsetToText)
			    {
				    gui_EMS_input_box_next(&MMI_EMS_inputbox);
			    }
            
                if (gui_EMS_input_box_get_next_character(&MMI_EMS_inputbox, &c) != 1)
			    {
				    c = 0;
			    }

                if (c == 0x1b)
                {
                    memcpy(&temp_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));

                    c = (UI_character_type)((MMI_EMS_inputbox.data->textBuffer[temp_position.OffsetToText + 2]) 
                                | (MMI_EMS_inputbox.data->textBuffer[temp_position.OffsetToText + 3] << 8));
                }

                if (c != 0x20 && c != 0x0D && c != 0x0A && (mmi_imc_is_valid_alphabetic_word_of_current_input_mode((U8 *)&c, 1) || c == 0) && MMI_EMS_inputbox.data->CurrentPosition.OffsetToText < back_up_position.OffsetToText)
                {
                    if (MMI_EMS_inputbox.flags & UI_EMS_INPUT_BOX_WORD_HIGHLIGHT)
                    {
                        MMI_EMS_inputbox.flags &= ~UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;
                    
                        gui_ems_input_box_stop_input(&MMI_EMS_inputbox);
                    
					    if (!TestFirstPosition(MMI_EMS_inputbox.data, &MMI_EMS_inputbox.data->CurrentPosition)) 
					    {
						    memcpy(&temp_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));

						    ret = gui_EMS_input_box_get_previous_object(MMI_EMS_inputbox.data, &temp_position, &c, &obj);
						    
						    if (ret == 2 && obj->Type == EMS_TYPE_TEXT_FORMAT)
						    {
							    ret = gui_EMS_input_box_get_previous_object(MMI_EMS_inputbox.data, &temp_position, &c, &obj);
						    }
						    
						    if (ret == 2 || ret == 0)
						    {
							    //break;
						    }	
						    else if (c == 0x20) 
						    {
                                gui_EMS_input_box_previous(&MMI_EMS_inputbox);
						    }
					    }
                    
                        gui_EMS_input_box_set_text_format_cursor_position(&MMI_EMS_inputbox);

                        wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
                    
                        redraw_EMS_inputbox();

                        mmi_imc_key_unhighlight_alphabetic_word();
                    
                        return;
                    }
                    else if (wgui_inputs_ems_is_same_text_format(MMI_EMS_inputbox.data->CurrentPosition, back_up_position) &&
                             mmi_imc_is_valid_alphabetic_word_of_current_input_mode(MMI_EMS_inputbox.data->textBuffer + MMI_EMS_inputbox.data->CurrentPosition.OffsetToText,
																	       (back_up_position.OffsetToText - MMI_EMS_inputbox.data->CurrentPosition.OffsetToText) / ENCODING_LENGTH))
                    {
					    memcpy(&MMI_EMS_inputbox.highlight_end_position, &back_up_position, sizeof(EMSPosition));
					    memcpy(&MMI_EMS_inputbox.highlight_start_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));

					    gui_EMS_input_box_set_cursor_position(&MMI_EMS_inputbox, &back_up_position);

                        MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;
                    
                        gui_ems_input_box_start_input(&MMI_EMS_inputbox);
                    
                        gui_EMS_input_box_set_text_format_cursor_position(&MMI_EMS_inputbox);

                        wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
                    
                        redraw_EMS_inputbox();

                        mmi_imc_key_highlight_alphabetic_word();
                    
                        return;
                    }
				    else
				    {
					    gui_EMS_input_box_set_cursor_position(&MMI_EMS_inputbox, &back_up_position);
				    }
                }
            }
        }
    }

	if (MMI_EMS_inputbox.flags & UI_EMS_INPUT_BOX_WORD_HIGHLIGHT)
	{
        MMI_EMS_inputbox.flags &= ~UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;

        gui_ems_input_box_stop_input(&MMI_EMS_inputbox);
	}
#endif /* #if defined(__MMI_SMART_ALPHABETIC_RESELECTION__)   */

    gui_EMS_input_box_previous(&MMI_EMS_inputbox);
    wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    redraw_EMS_inputbox();
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_next
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_next(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SMART_ALPHABETIC_RESELECTION__)  
    EMSPosition back_up_position, temp_position;
    UI_character_type temp_c;
    EMSObject *obj;
	U8 ret;
    MMI_BOOL is_valid_pre_cluster = MMI_FALSE, is_valid_cluster = MMI_FALSE;
    S32 word_length = 0;
#endif
    UI_character_type c = 0, pre_c = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_inputs_ems_pre_key_handler)
    {
        if (g_wgui_inputs_ems_pre_key_handler(KEY_RIGHT_ARROW))
        {
            return;
        }
    }

#if defined(__MMI_SMART_ALPHABETIC_RESELECTION__)   

	if (mmi_imc_is_reselection_input_mode(mmi_imm_get_curr_input_mode()))
	{
		memcpy(&back_up_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));
		
		if (!TestFirstPosition(MMI_EMS_inputbox.data, &MMI_EMS_inputbox.data->CurrentPosition))
		{
		    /* Get the character or cluster before cursor, and get whether it's a valid string of current input mode */
			if (gui_EMS_input_box_get_previous_character(&MMI_EMS_inputbox, &pre_c) != 1)
			{
				pre_c = 0;
			}

            if (pre_c == 0x1b)
            {
                memcpy(&temp_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));

                pre_c = (UI_character_type)((MMI_EMS_inputbox.data->textBuffer[temp_position.OffsetToText]) 
                                            | (MMI_EMS_inputbox.data->textBuffer[temp_position.OffsetToText + 1] << 8));

                is_valid_pre_cluster = mmi_imc_is_valid_alphabetic_word_of_current_input_mode((U8 *)&pre_c, 1);
            }
            else if (pre_c != 0 && pre_c != 0x20 && pre_c != 0x0D && pre_c != 0x0A)
            {
                gui_EMS_input_box_previous(&MMI_EMS_inputbox);

                /* Invalid character and invalid cluster should be separator of word */
                is_valid_pre_cluster = mmi_imc_is_valid_alphabetic_word_of_current_input_mode((U8 *)&MMI_EMS_inputbox.data->textBuffer[MMI_EMS_inputbox.data->CurrentPosition.OffsetToText], 
                    (back_up_position.OffsetToText - MMI_EMS_inputbox.data->CurrentPosition.OffsetToText)/ENCODING_LENGTH);

                gui_EMS_input_box_next(&MMI_EMS_inputbox);
            }
		}
		

        /* Get the character or cluster behind cursor and check whether it's a valid string of current input mode */
		if (gui_EMS_input_box_get_next_character(&MMI_EMS_inputbox, &c) != 1)
		{
			c = 0;
		}
		
        if (c == 0x1b)
        {
            memcpy(&temp_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));

            c = (UI_character_type)((MMI_EMS_inputbox.data->textBuffer[temp_position.OffsetToText + 2]) 
                            | (MMI_EMS_inputbox.data->textBuffer[temp_position.OffsetToText + 3] << 8));

            is_valid_cluster = mmi_imc_is_valid_alphabetic_word_of_current_input_mode((U8 *)&c, 1);
        }
        else if (c != 0x20 && c != 0x0D && c != 0x0A && c != 0)
        {
            gui_EMS_input_box_next(&MMI_EMS_inputbox);

            is_valid_cluster = mmi_imc_is_valid_alphabetic_word_of_current_input_mode((U8 *)&MMI_EMS_inputbox.data->textBuffer[back_up_position.OffsetToText], 
                (MMI_EMS_inputbox.data->CurrentPosition.OffsetToText - back_up_position.OffsetToText)/ENCODING_LENGTH);

            gui_EMS_input_box_previous(&MMI_EMS_inputbox);
        }

		
        /* The previous character is separator and the next character is valid  */
        /* character of current mode, the current cursor position is starting of a word */
        /* Then we can start to find the ending of the word, otherwise we should just move cursor once */
		if (c != 0 && c != 0x20 && c != 0x0D && c != 0x0A && is_valid_cluster
			&& (pre_c == 0 || pre_c == 0x20 || pre_c == 0x0D || pre_c == 0x0A || !is_valid_pre_cluster))
		{
			memcpy(&temp_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));

			if (!TestLastPosition(MMI_EMS_inputbox.data, &MMI_EMS_inputbox.data->CurrentPosition))
			{
				do
				{
					ret = gui_EMS_input_box_get_next_object(MMI_EMS_inputbox.data, &temp_position, &c, &obj);

					if (ret == 2 && obj->Type == EMS_TYPE_TEXT_FORMAT)
					{
						ret = gui_EMS_input_box_get_next_object(MMI_EMS_inputbox.data, &temp_position, &c, &obj);
					}

					if (ret == 2)
					{
                        gui_EMS_input_box_get_previous_object(MMI_EMS_inputbox.data, &temp_position, &c, &obj);
						c = 0;
						break;
					}	
					else if (ret == 0)
					{
						c = 0;
						break;
					}	
                    else if (c == 0x1b)
                    {
                        continue;
                    }

                    if (!(c != 0 && c != 0x20 && c != 0x0D && c != 0x0A && mmi_imc_is_valid_alphabetic_word_of_current_input_mode((U8 *)&c, 1)))
                    {
                        break;
                    }

                    word_length++;

				}while (word_length <= mmi_imc_get_max_reselection_word_length());
			}

            if (word_length <= mmi_imc_get_max_reselection_word_length() && word_length > 0)
            {
                if (c == 0x0D && !TestLastPosition(MMI_EMS_inputbox.data, &temp_position))
                {
                    ret = gui_EMS_input_box_get_next_object(MMI_EMS_inputbox.data, &temp_position, &temp_c, &obj);

                    if (!(ret == 1 && temp_c == 0x0A))
                    {
                        ret = gui_EMS_input_box_get_previous_object(MMI_EMS_inputbox.data, &temp_position, &temp_c, &obj);
                    }
                }

			    MoveCursorToPosition(MMI_EMS_inputbox.data, &temp_position);

            #ifdef GUI_INPUT_BOX_CACHE_SUPPORT
                gui_emsc_all_line_update();
            #endif
            
                gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);

                gui_show_EMS_input_box(&MMI_EMS_inputbox);
			    
                /* Move the cursor to the end of the word */
			    if (c != 0 && (c == 0x20 || c == 0x0D || c == 0x0A || !mmi_imc_is_valid_alphabetic_word_of_current_input_mode((U8 *)&c, 1)))
			    {
				    gui_EMS_input_box_previous(&MMI_EMS_inputbox);
			    }
                else if (MMI_EMS_inputbox.data->CurrentPosition.OffsetToText != temp_position.OffsetToText) 
                {   
                    /* Cursor may be changed by gui_EMS_input_box_locate_cursor() because of cluster */
                    gui_EMS_input_box_previous(&MMI_EMS_inputbox);
                }
			    
			    if ((c == 0x20 || c == 0 || c == 0x0D || c == 0x0A || !mmi_imc_is_valid_alphabetic_word_of_current_input_mode((U8 *)&c, 1)) && MMI_EMS_inputbox.data->CurrentPosition.OffsetToText > back_up_position.OffsetToText)
			    {
				    if (MMI_EMS_inputbox.flags & UI_EMS_INPUT_BOX_WORD_HIGHLIGHT)
				    {
					    MMI_EMS_inputbox.flags &= ~UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;
					    
                        gui_ems_input_box_stop_input(&MMI_EMS_inputbox);
					    
					    redraw_EMS_inputbox();
					    
					    mmi_imc_key_unhighlight_alphabetic_word();
				    }	
				    
                    /* Check the word validation and highlight it */
				    if (wgui_inputs_ems_is_same_text_format(back_up_position, MMI_EMS_inputbox.data->CurrentPosition) &&
                        mmi_imc_is_valid_alphabetic_word_of_current_input_mode(MMI_EMS_inputbox.data->textBuffer + back_up_position.OffsetToText,
																	       (MMI_EMS_inputbox.data->CurrentPosition.OffsetToText - back_up_position.OffsetToText) / ENCODING_LENGTH))
				    {
					    memcpy(&MMI_EMS_inputbox.highlight_start_position, &back_up_position, sizeof(EMSPosition));
					    memcpy(&MMI_EMS_inputbox.highlight_end_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));
					    MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;

                        gui_ems_input_box_start_input(&MMI_EMS_inputbox);

                        gui_EMS_input_box_set_text_format_cursor_position(&MMI_EMS_inputbox);

					    wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
					    redraw_EMS_inputbox();
					    
					    mmi_imc_key_highlight_alphabetic_word();
					    
					    return;
				    }
				    else
				    {
                        gui_EMS_input_box_set_cursor_position(&MMI_EMS_inputbox, &back_up_position);
				    }	
			    }
            }
		}
	}

    if (MMI_EMS_inputbox.flags & UI_EMS_INPUT_BOX_WORD_HIGHLIGHT)
	{
        MMI_EMS_inputbox.flags &= ~UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;
		
        gui_ems_input_box_stop_input(&MMI_EMS_inputbox);
		
		if (!TestLastPosition(MMI_EMS_inputbox.data, &MMI_EMS_inputbox.data->CurrentPosition)) 
		{
			memcpy(&temp_position, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));
            
			ret = gui_EMS_input_box_get_next_object(MMI_EMS_inputbox.data, &temp_position, &c, &obj);
			
			if (ret == 2 && obj->Type == EMS_TYPE_TEXT_FORMAT)
			{
				ret = gui_EMS_input_box_get_next_object(MMI_EMS_inputbox.data, &temp_position, &c, &obj);
			}
			
			if (ret == 2 || ret == 0)
			{

			}	
			else if (c != 0x20) 
			{

			}
            else
            {
                gui_EMS_input_box_next(&MMI_EMS_inputbox);
		    }
		}

		gui_EMS_input_box_set_text_format_cursor_position(&MMI_EMS_inputbox);
		
		wgui_EMS_text_format = MMI_EMS_inputbox.text_format;

		redraw_EMS_inputbox();
		
        mmi_imc_key_unhighlight_alphabetic_word();
		
		return;
	}	
#endif /* #if defined(__MMI_SMART_ALPHABETIC_RESELECTION__)   */

    if (mmi_imc_is_append_one_more_space_input_mode(mmi_imm_get_curr_input_mode()) &&
        !mmi_imc_is_ime_state())
    {
        U8 ret_val;
        EMSPosition temp_pos;
        EMSObject *object;

        pre_c = 0;
        
        if (!TestFirstPosition(MMI_EMS_inputbox.data, &MMI_EMS_inputbox.data->CurrentPosition))
        {
            if (gui_EMS_input_box_get_previous_character(&MMI_EMS_inputbox, &pre_c) != 1)
            {
                pre_c = 0;
            }
        }

        if (pre_c != 0 && pre_c != L' ')
        {
            memcpy(&temp_pos, &MMI_EMS_inputbox.data->CurrentPosition, sizeof(EMSPosition));
            
            ret_val = gui_EMS_input_box_get_next_object(MMI_EMS_inputbox.data, &temp_pos, &c, &object);
            
            if (ret_val == 0)
            {
                EMS_inputbox_direct_input(L' ');
                    
                return;
            }
		}
    }

    gui_EMS_input_box_next(&MMI_EMS_inputbox);
    wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    redraw_EMS_inputbox();
}

#ifdef __MMI_MESSAGES_EMS__


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_previous_object
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_previous_object(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
    if (MMI_EMS_inputbox.hilite_str_number > 0)
    {
        return;
    }
#endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
    gui_EMS_input_box_view_previous_object(&MMI_EMS_inputbox);
    wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    redraw_EMS_inputbox();
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_next_object
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_next_object(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
    if (MMI_EMS_inputbox.hilite_str_number > 0)
    {
        return;
    }
#endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
    gui_EMS_input_box_view_next_object(&MMI_EMS_inputbox);
    wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    redraw_EMS_inputbox();
}
#endif /* __MMI_MESSAGES_EMS__ */ 


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_previous_line
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_previous_line(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_inputs_ems_pre_key_handler)
    {
        if (g_wgui_inputs_ems_pre_key_handler(KEY_UP_ARROW))
        {
            return;
        }
    }

    gui_EMS_input_box_previous_line(&MMI_EMS_inputbox);
    wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    redraw_EMS_inputbox();
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_next_line
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_next_line(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_inputs_ems_pre_key_handler)
    {
        if (g_wgui_inputs_ems_pre_key_handler(KEY_DOWN_ARROW))
        {
            return;
        }
    }

    gui_EMS_input_box_next_line(&MMI_EMS_inputbox);
    wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    redraw_EMS_inputbox();
}

UI_character_type EMS_GSM_extended_lookup[] = { '[', ']', '{', '}', '~', '\\', '^', '|', 0xA2, 0x20AC, /* Euro character is mapped to 0xA2 */
};


/*****************************************************************************
 * FUNCTION
 *  EMS_GSM_extended_map
 * DESCRIPTION
 *  
 * PARAMETERS
 *  c       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
U8 EMS_GSM_extended_map(UI_character_type c)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, n;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    n = sizeof(EMS_GSM_extended_lookup) / sizeof(UI_character_type);
    for (i = 0; i < n; i++)
    {
        if (c == EMS_GSM_extended_lookup[i])
        {
            return (1);
        }
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_direct_input
 * DESCRIPTION
 *  
 * PARAMETERS
 *  c       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL EMS_inputbox_direct_input(UI_character_type c)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (UI_TEST_LF_CHARACTER(c))
    {
        if (gui_EMS_input_box_insert_new_line(&MMI_EMS_inputbox) == EMS_OK)
        {
            wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
            ret = MMI_TRUE;
        }
    }
    else
    {
        if (gui_EMS_input_box_insert_character(&MMI_EMS_inputbox, c) == EMS_OK)
            ret =  MMI_TRUE;
    }
    redraw_EMS_inputbox();
    EMS_inputbox_input_callback();
    return ret;
}



/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_direct_input_no_draw
 * DESCRIPTION
 *  
 * PARAMETERS
 *  c       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL EMS_inputbox_direct_input_no_draw(UI_character_type c)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (UI_TEST_LF_CHARACTER(c))
    {
        if (gui_EMS_input_box_insert_new_line(&MMI_EMS_inputbox) == EMS_OK)
            ret = MMI_TRUE;
    }
    else
    { 
        if (gui_EMS_input_box_insert_character(&MMI_EMS_inputbox, c) == EMS_OK)
            ret =  MMI_TRUE;
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_direct_input_no_LF_check
 * DESCRIPTION
 *  
 * PARAMETERS
 *  c       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_direct_input_no_LF_check(UI_character_type c)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_EMS_input_box_insert_character(&MMI_EMS_inputbox, c);
    redraw_EMS_inputbox();
    EMS_inputbox_input_callback();
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_backspace
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_backspace(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_EMS_input_box_backspace(&MMI_EMS_inputbox);
    wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    redraw_EMS_inputbox();
    EMS_inputbox_input_callback();
}

/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_backspace_no_draw
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_backspace_no_draw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_EMS_input_box_backspace(&MMI_EMS_inputbox);
    wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
}

/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_delete_all
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_delete_all(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_TOUCH_SCREEN__)
    kal_bool is_enabled, is_pen_down;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_TOUCH_SCREEN__)
    mmi_pen_get_state(&is_enabled, &is_pen_down);
    if (is_pen_down)
#endif
    {
        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_HOLD);
    }
    gui_EMS_input_box_delete_all(&MMI_EMS_inputbox);
    wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    redraw_EMS_inputbox();
    EMS_inputbox_input_callback();
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_toggle_insert_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_toggle_insert_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_EMS_input_box_toggle_insert_mode(&MMI_EMS_inputbox);
    redraw_EMS_inputbox();
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_delete
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_delete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_EMS_input_box_delete(&MMI_EMS_inputbox);
    wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    redraw_EMS_inputbox();
    EMS_inputbox_input_callback();
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_insert_new_line
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_insert_new_line(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_EMS_input_box_insert_new_line(&MMI_EMS_inputbox);
    wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    EMS_inputbox_input_callback();
}

/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_key_handler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  vkey_code       [IN]        
 *  key_state       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_key_handler(S32 vkey_code, S32 key_state)
{
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_state)
    {
        switch (vkey_code)
        {
            case 37:
        #if(ENABLE_EMS_TEST_WORD_HIGHLIGHT)
                MMI_EMS_inputbox.flags &= ~UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;
        #endif 
                EMS_inputbox_previous();
                break;
            case 38:
        #if(ENABLE_EMS_TEST_WORD_HIGHLIGHT)
                gui_EMS_input_box_highlight_cursor_start(&MMI_EMS_inputbox);
                show_EMS_inputbox();
        #else /* (ENABLE_EMS_TEST_WORD_HIGHLIGHT) */ 
                EMS_inputbox_previous_line();
        #endif /* (ENABLE_EMS_TEST_WORD_HIGHLIGHT) */ 
                break;
            case 39:
        #if(ENABLE_EMS_TEST_WORD_HIGHLIGHT)
                MMI_EMS_inputbox.flags &= ~UI_EMS_INPUT_BOX_WORD_HIGHLIGHT;
        #endif 
                EMS_inputbox_next();
                break;
            case 40:
        #if(ENABLE_EMS_TEST_WORD_HIGHLIGHT)
                gui_EMS_input_box_highlight_cursor_end(&MMI_EMS_inputbox);
                show_EMS_inputbox();
        #else /* (ENABLE_EMS_TEST_WORD_HIGHLIGHT) */ 
                EMS_inputbox_next_line();
        #endif /* (ENABLE_EMS_TEST_WORD_HIGHLIGHT) */ 
                break;
            case 36:    /* home */
                break;
            case 35:    /* end */
                break;
            case 33:    /* page up */
                break;
            case 34:    /* page down */
                break;
            case 45:
                EMS_inputbox_toggle_insert_mode();
                break;
            case 46:
                EMS_inputbox_delete();
                break;
        }
    }
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_viewer_key_handler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  vkey_code       [IN]        
 *  key_state       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_viewer_key_handler(S32 vkey_code, S32 key_state)
{
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_state)
    {
        switch (vkey_code)
        {
            case 37:
        #ifdef __MMI_MESSAGES_EMS__
                EMS_inputbox_previous_object();
        #else 
                EMS_inputbox_previous();
        #endif 

                break;
            case 38:
                EMS_inputbox_previous_line();
                break;

            case 39:
        #ifdef __MMI_MESSAGES_EMS__
                EMS_inputbox_next_object();
        #else 
                EMS_inputbox_next();
        #endif 
                break;
            case 40:
                EMS_inputbox_next_line();
                break;
            case 36:    /* home */
                break;
            case 35:    /* end */
                break;
            case 33:    /* page up */
                break;
            case 34:    /* page down */
                break;
            case 45:    /* insert */
                break;
            case 46:    /* delete */
                break;
        }
    }
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_multitap_input
 * DESCRIPTION
 *  
 * PARAMETERS
 *  c       [IN]        
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL EMS_inputbox_multitap_input(UI_character_type c)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U8 ret = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = gui_EMS_input_box_insert_multitap_character(&MMI_EMS_inputbox, c);
    if (ret == EMS_OK)
    {
	    redraw_EMS_inputbox();
	    EMS_inputbox_input_callback();
	    return MMI_TRUE;
	}
	else
	{
		return MMI_FALSE;
	}
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_multitap_input_no_draw
 * DESCRIPTION
 *  
 * PARAMETERS
 *  c       [IN]        
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL EMS_inputbox_multitap_input_no_draw(UI_character_type c)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U8 ret = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = gui_EMS_input_box_insert_multitap_character(&MMI_EMS_inputbox, c);
    if (ret == EMS_OK)
    {
	    EMS_inputbox_input_callback();
	    return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_multitap_input_string
 * DESCRIPTION
 *  
 * PARAMETERS
 *  str       [IN]        String to be inserted
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
S32 EMS_inputbox_multitap_input_string(PU8 str)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U8 ret = 0;
    S32 steps = (S32)MMI_EMS_inputbox.data->CurrentPosition.OffsetToText - (S32)MMI_EMS_inputbox.input_start_position.OffsetToText;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Do sanity if we can insert this  */
    steps /= ENCODING_LENGTH;

    /* Here + steps is added as we will delete the last character entered by multitap */
    if(mmi_ucs2strlen((CHAR*) str) > EMS_get_remaining_length(MMI_EMS_inputbox.data) +  steps)
    {
        UI_editor_play_tone_cannot_insert();
        return steps;
    }

    ret = gui_EMS_input_box_insert_multitap_string_no_draw(&MMI_EMS_inputbox, (UI_string_type)str);
    if (ret == EMS_OK)
    {
        gui_EMS_input_box_locate_cursor(&MMI_EMS_inputbox);
	    redraw_EMS_inputbox();
	    EMS_inputbox_input_callback();
	    return ((S32)mmi_ucs2strlen((CHAR*) str));
	}
	return 0;
}

/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_multitap_input_complete
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_multitap_input_complete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_EMS_input_box_confirm_multitap_character(&MMI_EMS_inputbox);
    redraw_EMS_inputbox();
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_multitap_input_complete_no_draw
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_multitap_input_complete_no_draw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_EMS_input_box_confirm_multitap_character(&MMI_EMS_inputbox);
}


#if defined(__MMI_MULTITAP_ARABIC__)

/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_arabic_numeric_keyboard_input_handler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  keyc        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_arabic_numeric_keyboard_input_handler(S32 keyc)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (keyc >= '0' && keyc <= '9')
    {
        EMS_inputbox_direct_input((UI_character_type)(keyc + 0x0630)); /* Arabic numeric is from 0x0660 to 0x0669 */
    }
    else if (keyc == 0x08)
    {
        EMS_inputbox_backspace();
    }
    else if (keyc == 0x1b)
    {
        EMS_inputbox_delete_all();
    }
}
#endif


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_handle_key_down
 * DESCRIPTION
 *  
 * PARAMETERS
 *  k       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_handle_key_down(MMI_key_code_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_MULTITAP_ARABIC__)
    if (mmi_imm_get_curr_input_mode() == IMM_INPUT_MODE_ARABIC_NUMERIC )
        EMS_inputbox_direct_input((UI_character_type) (0x0660 + k));
    else
#endif
    EMS_inputbox_direct_input((UI_character_type) ('0' + k));
}


/*****************************************************************************
 * FUNCTION
 *  register_EMS_inputbox_keys
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void register_EMS_inputbox_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetKeyHandler(EMS_inputbox_previous, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(EMS_inputbox_next, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(EMS_inputbox_previous_line, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(EMS_inputbox_next_line, KEY_DOWN_ARROW, KEY_EVENT_DOWN);

    SetKeyHandler(wgui_inputs_EMS_handle_left_arrow_repeat, KEY_LEFT_ARROW, KEY_REPEAT);
    SetKeyHandler(wgui_inputs_EMS_handle_right_arrow_repeat, KEY_RIGHT_ARROW, KEY_REPEAT);
    SetKeyHandler(wgui_inputs_fast_del_nav_reset_repeat_count, KEY_LEFT_ARROW, KEY_LONG_PRESS);
    SetKeyHandler(wgui_inputs_fast_del_nav_reset_repeat_count, KEY_RIGHT_ARROW, KEY_LONG_PRESS);

    SetKeyHandler(wgui_inputs_EMS_handle_up_arrow_repeat, KEY_UP_ARROW, KEY_REPEAT);
    SetKeyHandler(wgui_inputs_EMS_handle_down_arrow_repeat, KEY_DOWN_ARROW, KEY_REPEAT);
    SetKeyHandler(wgui_inputs_fast_del_nav_reset_repeat_count, KEY_LEFT_ARROW, KEY_LONG_PRESS);
    SetKeyHandler(wgui_inputs_fast_del_nav_reset_repeat_count, KEY_RIGHT_ARROW, KEY_LONG_PRESS);

    /* SetKeyHandler(EMS_inputbox_backspace,KEY_CLEAR,KEY_EVENT_DOWN); */
    register_keyboard_key_handler(EMS_inputbox_key_handler);

    mmi_imc_key_set_pre_key_handler(wgui_inputs_ems_pre_key_handler);
}


/*****************************************************************************
 * FUNCTION
 *  register_EMS_inputbox_viewer_keys
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void register_EMS_inputbox_viewer_keys(void)
{
#ifdef __MMI_MESSAGES_EMS__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetKeyHandler(EMS_inputbox_previous_object, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(EMS_inputbox_next_object, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
#endif /* __MMI_MESSAGES_EMS__ */ 
    SetKeyHandler(EMS_inputbox_previous_line, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(EMS_inputbox_next_line, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(EMS_inputbox_previous_line, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(EMS_inputbox_next_line, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    SetKeyHandler(EMS_inputbox_previous_line, KEY_UP_ARROW, KEY_REPEAT);
    SetKeyHandler(EMS_inputbox_next_line, KEY_DOWN_ARROW, KEY_REPEAT);
    register_keyboard_key_handler(EMS_inputbox_viewer_key_handler);

    /* Set key for App's */
    if (ems_inputbox_set_key_callback)
    {
        ems_inputbox_set_key_callback();
    }
}


/*****************************************************************************
 * FUNCTION
 *  reset_EMS_inputbox
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void reset_EMS_inputbox(void)
{
#if(UI_BLINKING_CURSOR_SUPPORT)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //gui_cancel_timer(UI_inputbox_blink_cursor);
    //MTK Elvis
    StopTimer(BLINKING_CURSOR);
    /* MTK end */

#endif /* (UI_BLINKING_CURSOR_SUPPORT) */ 
#ifdef __MMI_MESSAGES_EMS__
    EMS_cancel_object_focus();
#endif 

#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
    gui_inputs_cache_destroy();
#endif

    clear_keyboard_key_handler();
    clear_keyboard_input_handler();
    clear_multitap_key_handlers();
    ClearKeyHandler(KEY_CLEAR, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_CLEAR, KEY_EVENT_UP);
    ClearKeyHandler(KEY_CLEAR, KEY_EVENT_LONG_PRESS);
#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING))
    gui_cancel_timer(wgui_EMS_inputbox_end_frame);
    wgui_EMS_inputbox_frame_counter = 0;
#endif /* ((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING)) */ 
    EMS_inputbox_input_callback = UI_dummy_function;
#ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
	wgui_inputs_EMS_reset_hilite_list();
#endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */

#ifdef __MMI_EDITOR_SSP_SUPPORT__
    {
        mmi_pen_point_struct point = {0, 0};
        
        gui_input_box_ssp_pen_translate(point, MMI_PEN_EVENT_ABORT);
    }
    mmi_pen_config_sampling_period(MMI_PEN_SAMPLING_PERIOD_1, MMI_PEN_SAMPLING_PERIOD_2);
#endif

    ems_inputbox_set_key_callback = NULL;

#ifdef __OP01_FWPBW__
    gui_cancel_timer(wgui_inputs_show_current_input_method_timer_handler);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  test_EMS_inputbox_change_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
U8 test_EMS_inputbox_change_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* MTK Elvis */
    if (MMI_EMS_inputbox.UCS2_count == 0)
    {
        if (EMSSetDCS(MMI_EMS_inputbox.data, SMSAL_UCS2_DCS) == EMS_OK &&
            EMS_get_remaining_length(MMI_EMS_inputbox.data) >= 2)
        {
            EMSSetDCS(MMI_EMS_inputbox.data, SMSAL_DEFAULT_DCS);
            return 1;
        }
        else
        {
            EMSSetDCS(MMI_EMS_inputbox.data, SMSAL_DEFAULT_DCS);
            return 0;
        }
    }
    else
    {
        return 1;
    }
    /* MTK end */
}

/* Temporary data: for testing         */
#ifdef __MMI_MESSAGES_EMS__

const U8 EMS_sample_melody_object_PDU_1[] = 
{
    EMS_PREDEFINED_MELODY, 0x74, 0x00,
    'B', 'E', 'G', 'I', 'N', ':', 'I', 'M', 'E', 'L', 'O', 'D', 'Y', '\n',
    'V', 'E', 'R', 'S', 'I', 'O', 'N', ':', '1', '.', '2', '\n',
    'F', 'O', 'R', 'M', 'A', 'T', ':', 'C', 'L', 'A', 'S', 'S', '1', '.', '0', '\n',
    'B', 'E', 'A', 'T', ':', '1', '2', '0', '\n',
    'C', 'O', 'M', 'P', 'O', 'S', 'E', 'R', ':', 'M', 'T', 'K', '(', '2', ')', '\n',
    'M', 'E', 'L', 'O', 'D', 'Y', ':', 'c', '2', 'd', '2', 'e', '2', 'f', '2', 'g', '2', 'a', '2', 'b', '2', '\n',
    'E', 'N', 'D', ':', 'I', 'M', 'E', 'L', 'O', 'D', 'Y', '\n',
};

const U8 EMS_sample_melody_object_PDU_2[] = {EMS_PREDEFINED_MELODY, 0x6c, 0x00,
    'B', 'E', 'G', 'I', 'N', ':', 'I', 'M', 'E', 'L', 'O', 'D', 'Y', '\n',
    'V', 'E', 'R', 'S', 'I', 'O', 'N', ':', '1', '.', '2', '\n',
    'F', 'O', 'R', 'M', 'A', 'T', ':', 'C', 'L', 'A', 'S', 'S', '1', '.', '0', '\n',
    'M', 'E', 'L', 'O', 'D', 'Y', ':', '*', '5', 'f', '0', '*', '5', '#', 'g', '2', '*', '5', 'g', '3', '*', '5', '#',
        'd', '0', '*', '5', '#', 'g', '2', '*', '5', 'g', '3', '*', '5', 'c', '0', '*', '5', '#', 'g', '2', '*', '5',
        'g', '3', '*', '4', '#', 'g', '0', '\n',
    'E', 'N', 'D', ':', 'I', 'M', 'E', 'L', 'O', 'D', 'Y', '\n',
};

const U8 EMS_sample_picture_object_PDU_1[] = {EMS_USERDEFINED_PICTURE, 0x01, 0x10, 0x00, 0x10, 0x00, 0x20, 0x00,
    0x07, 0xE0, 0x08, 0x10, 0x30, 0x0C, 0x20, 0x04, 0x4E, 0x72, 0x9A, 0x59, 0x86, 0x61, 0x80, 0x01,
    0x80, 0x01, 0x90, 0x09, 0x88, 0x11, 0x47, 0xE2, 0x23, 0xC4, 0x30, 0x0C, 0x08, 0x10, 0x07, 0xE0,
};

#if(!ENABLE_EMS_TEST_OBJECTS)

const U8 EMS_sample_picture_object_PDU_2[] = {EMS_PREDEFINED_PICTURE, 0x01, 0x10, 0x00, 0x10, 0x00, 0x20, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0, 0x03, 0xA0, 0x05, 0x90, 0x09, 0x88, 0x11, 0x8C, 0x31,
    0x93, 0xC9, 0xA0, 0x05, 0xC0, 0x03, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

#else /* (!ENABLE_EMS_TEST_OBJECTS) */ 

const U8 EMS_sample_picture_object_PDU_2[] = {EMS_PREDEFINED_MELODY, 0x6a, 0x00,
    'B', 'E', 'G', 'I', 'N', ':', 'I', 'M', 'E', 'L', 'O', 'D', 'Y', '\n',
    'V', 'E', 'R', 'S', 'I', 'O', 'N', ':', '1', '.', '2', '\n',
    'F', 'O', 'R', 'M', 'A', 'T', ':', 'C', 'L', 'A', 'S', 'S', '1', '.', '0', '\n',
    'M', 'E', 'L', 'O', 'D', 'Y', ':', '*', '4', '#', 'f', '2', '*', '4', 'a', '3', '.', '*', '4', '#', 'f', '3', '*',
        '4', '#', 'f', '4', '*', '4', '#', 'a', '3', '*', '4', '#', 'f', '3', '*', '4', 'e', '3', '*', '4', '#', 'f',
        '2', '*', '5', 'c', '3', '\n',
    'E', 'N', 'D', ':', 'I', 'M', 'E', 'L', 'O', 'D', 'Y', '\n',
};

#endif /* (!ENABLE_EMS_TEST_OBJECTS) */ 

#if(!ENABLE_EMS_TEST_OBJECTS)

const U8 EMS_sample_picture_object_PDU_3[] = {EMS_PREDEFINED_PICTURE, 0x01, 0x10, 0x00, 0x10, 0x00, 0x20, 0x00,
    0x01, 0x80, 0x03, 0xC0, 0x03, 0xC0, 0x07, 0xE0, 0x0F, 0xF0, 0x1F, 0xF8, 0x3F, 0xFC, 0x3F, 0xFC,
    0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE, 0x3D, 0xBC, 0x19, 0x98, 0x01, 0x80, 0x01, 0x80, 0x07, 0xE0,
};

#else /* (!ENABLE_EMS_TEST_OBJECTS) */ 

const U8 EMS_sample_picture_object_PDU_3[] = {EMS_PREDEFINED_ANIMATION, 0x01,
};

#endif /* (!ENABLE_EMS_TEST_OBJECTS) */ 

#if(!ENABLE_EMS_TEST_OBJECTS)

const U8 EMS_sample_picture_object_PDU_4[] = {EMS_PREDEFINED_PICTURE, 0x01, 0x10, 0x00, 0x10, 0x00, 0x20, 0x00,
    0x07, 0xE0, 0x08, 0x10, 0x30, 0x0C, 0x20, 0x04, 0x5C, 0x3A, 0x86, 0x61, 0x86, 0x61, 0x80, 0x01,
    0x80, 0x01, 0x81, 0xC1, 0x82, 0x21, 0x44, 0x12, 0x20, 0x04, 0x30, 0x0C, 0x08, 0x10, 0x07, 0xE0,
};

#else /* (!ENABLE_EMS_TEST_OBJECTS) */ 

const U8 EMS_sample_picture_object_PDU_4[] = {EMS_PREDEFINED_MELODY, 0x6c, 0x00,
    'B', 'E', 'G', 'I', 'N', ':', 'I', 'M', 'E', 'L', 'O', 'D', 'Y', '\n',
    'V', 'E', 'R', 'S', 'I', 'O', 'N', ':', '1', '.', '2', '\n',
    'F', 'O', 'R', 'M', 'A', 'T', ':', 'C', 'L', 'A', 'S', 'S', '1', '.', '0', '\n',
    'M', 'E', 'L', 'O', 'D', 'Y', ':', '*', '5', 'f', '0', '*', '5', '#', 'g', '2', '*', '5', 'g', '3', '*', '5', '#',
        'd', '0', '*', '5', '#', 'g', '2', '*', '5', 'g', '3', '*', '5', 'c', '0', '*', '5', '#', 'g', '2', '*', '5',
        'g', '3', '*', '4', '#', 'g', '0', '\n',
    'E', 'N', 'D', ':', 'I', 'M', 'E', 'L', 'O', 'D', 'Y', '\n',
};

#endif /* (!ENABLE_EMS_TEST_OBJECTS) */ 

const U8 EMS_sample_picture_object_PDU_5[] = {EMS_PREDEFINED_PICTURE, 0x01, 0x18, 0x00, 0x18, 0x00, 0x48, 0x00,
    0x05, 0x80, 0x00, 0x10, 0x60, 0x00, 0x42, 0x1D, 0xC0, 0x80, 0x06, 0x30, 0x00, 0x29, 0x8C, 0x98,
    0x02, 0xA2, 0x9E, 0x00, 0xB5, 0x9F, 0x82, 0x77, 0x1F, 0xE1, 0x5B, 0x9F, 0xF9, 0x75, 0x9F, 0xF9,
    0x5B, 0x1F, 0xF9, 0x75, 0x9F, 0xF9, 0x5B, 0x9F, 0xF9, 0x77, 0x1F, 0xF9, 0x5B, 0xC7, 0xF9, 0x75,
    0xA1, 0xF9, 0xBA, 0x38, 0x78, 0xDC, 0x0E, 0x1A, 0xB8, 0x03, 0x81, 0x70, 0x00, 0xF1, 0x50, 0x00,
    0x3D, 0x70, 0x00, 0x0E, 0xE0, 0x00, 0x03, 0x80,
};

#if(!ENABLE_EMS_TEST_OBJECTS)

const U8 EMS_sample_picture_object_PDU_6[] = {EMS_PREDEFINED_PICTURE, 0x01, 0x10, 0x00, 0x10, 0x00, 0x20, 0x00,
    0x07, 0xE0, 0x08, 0x10, 0x30, 0x0C, 0x26, 0x64, 0x48, 0x12, 0x90, 0x09, 0x86, 0x61, 0x86, 0x61,
    0x80, 0x01, 0x83, 0xC1, 0x87, 0xE1, 0x47, 0xE2, 0x23, 0xC4, 0x30, 0x0C, 0x08, 0x10, 0x07, 0xE0,
};

#else /* (!ENABLE_EMS_TEST_OBJECTS) */ 

const U8 EMS_sample_picture_object_PDU_6[] = {EMS_PREDEFINED_SOUND, 0x01,
};

#endif /* (!ENABLE_EMS_TEST_OBJECTS) */ 

#if(!ENABLE_EMS_TEST_OBJECTS)

const U8 EMS_sample_picture_object_PDU_7[] = {EMS_PREDEFINED_PICTURE, 0x01, 0x10, 0x00, 0x10, 0x00, 0x20, 0x00,
    0x07, 0xE0, 0x08, 0x10, 0x30, 0x0C, 0x2C, 0x64, 0x52, 0x92, 0x96, 0xB1, 0x8C, 0x61, 0x80, 0x01,
    0xBF, 0xFD, 0xA9, 0x25, 0x99, 0x29, 0x59, 0x2A, 0x29, 0x34, 0x37, 0xEC, 0x08, 0x10, 0x07, 0xE0,
};

#else /* (!ENABLE_EMS_TEST_OBJECTS) */ 

const U8 EMS_sample_picture_object_PDU_7[] = {EMS_PREDEFINED_ANIMATION, 0x02,
};

#endif /* (!ENABLE_EMS_TEST_OBJECTS) */ 

#if(!ENABLE_EMS_TEST_OBJECTS)

const U8 EMS_sample_picture_object_PDU_8[] = {0x01, 0x01, 0x10, 0x00, 0x10, 0x00, 0x20, 0x00,
    0x03, 0xC0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x03, 0xC0, 0x01, 0x80, 0x19, 0x98, 0x3D, 0xBC,
    0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE, 0x3D, 0xBC, 0x19, 0x98, 0x01, 0x80, 0x01, 0x80, 0x07, 0xE0,
};

#else /* (!ENABLE_EMS_TEST_OBJECTS) */ 

const U8 EMS_sample_picture_object_PDU_8[] = {EMS_USERDEFINED_ANIMATION, 0x01, 0x08, 0x00, 0x08, 0x00, 0x20, 0x00,
    0xFF, 0x81, 0x81, 0x81, 0xF1, 0xD1, 0xF1, 0xFF,

    0xFF, 0x81, 0x81, 0x81, 0x8F, 0x8B, 0x8F, 0xFF,

    0xFF, 0x8F, 0x8B, 0x8F, 0x81, 0x81, 0x81, 0xFF,

    0xFF, 0xF1, 0xD1, 0xF1, 0x81, 0x81, 0x81, 0xFF,
};

#endif /* (!ENABLE_EMS_TEST_OBJECTS) */ 

#if(!ENABLE_EMS_TEST_OBJECTS)

const U8 EMS_sample_picture_object_PDU_9[] = {0x01, 0x01, 0x10, 0x00, 0x10, 0x00, 0x20, 0x00,
    0x07, 0xE0, 0x08, 0x10, 0x30, 0x0C, 0x20, 0x04, 0x79, 0xCE, 0xBF, 0xF9, 0xB9, 0xC1, 0x80, 0x01,
    0x80, 0x01, 0x9F, 0x01, 0x9F, 0x81, 0x4F, 0xC2, 0x27, 0xC4, 0x30, 0x0C, 0x08, 0x10, 0x07, 0xE0,
};

#else /* (!ENABLE_EMS_TEST_OBJECTS) */ 

const U8 EMS_sample_picture_object_PDU_9[] = {EMS_USERDEFINED_ANIMATION, 0x01, 0x10, 0x00, 0x10, 0x00, 0x80, 0x00,
    0x0F, 0xF8, 0x0F, 0xF8, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x02, 0x20, 0x01, 0x40,
    0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x0F, 0xF8, 0x0F, 0xF8,

    0x06, 0x00, 0x0E, 0x00, 0x1F, 0x00, 0x38, 0x80, 0x70, 0x40, 0xE0, 0x40, 0x60, 0x40, 0x10, 0x40,
    0x0F, 0x3C, 0x00, 0x82, 0x00, 0x81, 0x00, 0x83, 0x00, 0x87, 0x00, 0x4E, 0x00, 0x3C, 0x00, 0x38,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 0xFC, 0x3F, 0xC2, 0x43, 0xC1, 0x83, 0xC0, 0x03,
    0xC1, 0x83, 0xC2, 0x43, 0xFC, 0x3F, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x38, 0x00, 0x3C, 0x00, 0x4E, 0x00, 0x87, 0x00, 0x83, 0x00, 0x81, 0x00, 0x82, 0x0F, 0x3C,
    0x10, 0x40, 0x60, 0x40, 0xE0, 0x40, 0x70, 0x40, 0x38, 0x80, 0x1F, 0x00, 0x0E, 0x00, 0x06, 0x00,
};

#endif /* (!ENABLE_EMS_TEST_OBJECTS) */ 

const U8 EMS_sample_picture_object_PDU_10[] = {EMS_PREDEFINED_PICTURE, 0x01, 0x20, 0x00, 0x20, 0x00, 0x80, 0x00,
    0x00, 0xFE, 0x00, 0x00, 0x07, 0xFF, 0x80, 0x00, 0x3F, 0xFF, 0x70, 0x00, 0x7F, 0xFF, 0x8E, 0x00,
    0x47, 0xFF, 0xC1, 0xC0, 0x40, 0xFF, 0xE0, 0x38, 0x40, 0x1F, 0xF0, 0x06, 0x40, 0x03, 0xF8, 0x02,
    0x40, 0x00, 0x7C, 0x0E, 0x40, 0x00, 0x0E, 0x3E, 0x40, 0x00, 0x00, 0xFE, 0x20, 0x78, 0x03, 0xFC,
    0x22, 0x1D, 0x03, 0xFC, 0x27, 0x0F, 0x03, 0xFC, 0x2F, 0x87, 0x03, 0xFC, 0x23, 0xCF, 0x07, 0xF8,
    0x23, 0x03, 0x07, 0xF8, 0x13, 0x00, 0x07, 0xF8, 0x11, 0x00, 0x07, 0xF8, 0x11, 0x08, 0x8F, 0xF0,
    0x10, 0x88, 0x8F, 0xF0, 0x10, 0x59, 0x8F, 0xF0, 0x08, 0x3F, 0x8F, 0xE0, 0x08, 0x1F, 0x1F, 0xE0,
    0x08, 0x0C, 0x1F, 0xE0, 0x04, 0x02, 0x1F, 0xE0, 0x03, 0x00, 0x1F, 0xC0, 0x00, 0xC0, 0x1F, 0xC0,
    0x00, 0x30, 0x3F, 0xC0, 0x00, 0x0C, 0x3F, 0x00, 0x00, 0x03, 0x3C, 0x00, 0x00, 0x00, 0xF0, 0x00,
};

const U8 EMS_sample_picture_object_PDU_11[] = {0x01, 0x01, 0x10, 0x00, 0x10, 0x00, 0x20, 0x00,
    0x00, 0x00, 0x1F, 0xF8, 0x20, 0x06, 0x26, 0x66, 0x23, 0xC6, 0x21, 0x86, 0x23, 0xC6, 0x26, 0x66,
    0x20, 0x06, 0x20, 0x06, 0x2A, 0xAE, 0x20, 0x06, 0x35, 0x56, 0x2A, 0xAE, 0x3F, 0xFE, 0x1F, 0xFC,
};

const U8 EMS_sample_animation_object_PDU_11[] = {EMS_USERDEFINED_ANIMATION, 0x01, 0x08, 0x00, 0x08, 0x00, 0x20, 0x00,
    0xFF, 0x81, 0x81, 0x81, 0xF1, 0xD1, 0xF1, 0xFF,

    0xFF, 0x81, 0x81, 0x81, 0x8F, 0x8B, 0x8F, 0xFF,

    0xFF, 0x8F, 0x8B, 0x8F, 0x81, 0x81, 0x81, 0xFF,

    0xFF, 0xF1, 0xD1, 0xF1, 0x81, 0x81, 0x81, 0xFF,
};

#define MAX_EMS_PREDEFINED_PICTURES    10

#if(ENABLE_EMS_TEST_OBJECTS)

/* Temporary: Needs to populated with actual picture data   */
U8 *EMS_predefined_pictures[MAX_EMS_PREDEFINED_PICTURES] = { (U8 *) EMS_sample_picture_object_PDU_1,
    (U8 *) EMS_sample_picture_object_PDU_2,
    (U8 *) EMS_sample_picture_object_PDU_3,
    (U8 *) EMS_sample_picture_object_PDU_4,
    (U8 *) EMS_sample_picture_object_PDU_5,
    (U8 *) EMS_sample_picture_object_PDU_6,
    (U8 *) EMS_sample_picture_object_PDU_7,
    (U8 *) EMS_sample_picture_object_PDU_8,
    (U8 *) EMS_sample_picture_object_PDU_9,
    (U8 *) EMS_sample_picture_object_PDU_10,
};

#else /* (ENABLE_EMS_TEST_OBJECTS) */ 

/* This gets populated at run time with picture data     */
U8 *EMS_predefined_pictures[MAX_EMS_PREDEFINED_PICTURES] = { (U8 *) EMS_sample_picture_object_PDU_11,
    (U8 *) EMS_sample_picture_object_PDU_11,
    (U8 *) EMS_sample_picture_object_PDU_11,
    (U8 *) EMS_sample_picture_object_PDU_11,
    (U8 *) EMS_sample_picture_object_PDU_11,
    (U8 *) EMS_sample_picture_object_PDU_11,
    (U8 *) EMS_sample_picture_object_PDU_11,
    (U8 *) EMS_sample_picture_object_PDU_11,
    (U8 *) EMS_sample_picture_object_PDU_11,
    (U8 *) EMS_sample_picture_object_PDU_11,
};

#endif /* (ENABLE_EMS_TEST_OBJECTS) */ 

U16 EMS_predefined_images[MAX_EMS_PREDEFINED_PICTURES] = {
#ifndef __COSMOS_MMI_PACKAGE__
    IMG_EMS01_PIC,
    IMG_EMS02_PIC,
    IMG_EMS03_PIC,
    IMG_EMS04_PIC,
    IMG_EMS05_PIC,
    IMG_EMS06_PIC,
    IMG_EMS07_PIC,
    IMG_EMS08_PIC,
    IMG_EMS09_PIC,
    IMG_EMS010_PIC
#else
    0
#endif
};

#define MAX_EMS_PREDEFINED_ANIMATIONS  15

U16 EMS_predefined_animations[MAX_EMS_PREDEFINED_ANIMATIONS] = {
#ifndef __COSMOS_MMI_PACKAGE__
    EMS_BI_ANIMATION_0_ID,
    EMS_BI_ANIMATION_1_ID,
    EMS_BI_ANIMATION_2_ID,
    EMS_BI_ANIMATION_3_ID,
    EMS_BI_ANIMATION_4_ID,
    EMS_BI_ANIMATION_5_ID,
    EMS_BI_ANIMATION_6_ID,
    EMS_BI_ANIMATION_7_ID,
    EMS_BI_ANIMATION_8_ID,
    EMS_BI_ANIMATION_9_ID,
    EMS_BI_ANIMATION_10_ID,
    EMS_BI_ANIMATION_11_ID,
    EMS_BI_ANIMATION_12_ID,
    EMS_BI_ANIMATION_13_ID,
    EMS_BI_ANIMATION_14_ID,
#else
    0
#endif
};

#define MAX_EMS_PREDEFINED_SOUNDS      10

/* Temporary: Needs to be populated with the actual sound IDs  */
U16 EMS_predefined_sounds[MAX_EMS_PREDEFINED_SOUNDS] = 
{
    AUD_ID_EMS_CHIMES_HIGH,
    AUD_ID_EMS_CHIMES_LOW,
    AUD_ID_EMS_DING,
    AUD_ID_EMS_TADA,
    AUD_ID_EMS_NOTIFY,
    AUD_ID_EMS_DRUM,
    AUD_ID_EMS_CLAPS,
    AUD_ID_EMS_FANFAR,
    AUD_ID_EMS_CHORE_HGH,
    AUD_ID_EMS_CHORE_LOW,
};

#define MAX_EMS_PREDEFINED_MELODIES    10

/* Temporary: Needs to be populated with the actual melody data   */
U8 *EMS_predefined_melodies[MAX_EMS_PREDEFINED_MELODIES] = 
{
    (U8 *) EMS_sample_melody_object_PDU_1,
    (U8 *) EMS_sample_melody_object_PDU_2,
    (U8 *) EMS_sample_melody_object_PDU_1,
    (U8 *) EMS_sample_melody_object_PDU_2,
    (U8 *) EMS_sample_melody_object_PDU_1,
    (U8 *) EMS_sample_melody_object_PDU_2,
    (U8 *) EMS_sample_melody_object_PDU_1,
    (U8 *) EMS_sample_melody_object_PDU_2,
    (U8 *) EMS_sample_melody_object_PDU_1,
    (U8 *) EMS_sample_melody_object_PDU_2,
};

/* data used for EMS_USERDEFINED_PICTURE, EMS_USERDEFINED_ANIMATION, EMS_USER_DEFINED_MELODY
   index used for EMS_PREDEFINED_PICTURE, EMS_PREDEFINED_MELODY.
   If index==-1, data is used for EMS_PREDEFINED_PICTURE, EMS_PREDEFINED_MELODY. */


/*****************************************************************************
 * FUNCTION
 *  EMS_load_object
 * DESCRIPTION
 *  
 * PARAMETERS
 *  type        [IN]        
 *  data        [?]         
 *  index       [IN]        
 *  object      [?]         
 * RETURNS
 *  
 *****************************************************************************/
EMSTATUS EMS_load_object(U32 type, U8 *data, S32 index, EMSObjData *object)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 ID;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (type & 0xff)
    {
        case EMS_PREDEFINED_PICTURE:
        {
            if ((index >= MAX_EMS_PREDEFINED_PICTURES))
            {
                return (EMS_INVALID_OBJECT);
            }
            if (index >= 0)
            {
                data = EMS_predefined_pictures[index];
            }
            #if 0 /* slim_2_2 */ //
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #ifdef __EMS_REL5__
/* under construction !*/
/* under construction !*/
            #else /* __EMS_REL5__ */ 
/* under construction !*/
/* under construction !*/
            #endif /* __EMS_REL5__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
             #endif
        }
            //break; /* slim_2_2 */ //

        case EMS_USERDEFINED_PICTURE:
        {
            if (data == NULL)
            {
                return (EMS_NULL_POINTER);
            }
            ID = data[0];
            if (ID == type & 0xff)/* slim_2_2 */ //
            {
                object->picture.bitsPerPixel = data[1];
                object->picture.attribute = data[2];
                object->picture.hDim = data[3] | (data[4] << 8);
                object->picture.vDim = data[5] | (data[6] << 8);
                object->picture.pdu_length = data[7] | (data[8] << 8);
                data += 9;
                object->picture.pdu = data;

                // we don't support bitsPerPixel more than 6
                if (object->picture.bitsPerPixel > 6)
                {
                    return (EMS_INVALID_OBJECT);
                }

            #ifdef __EMS_REL5__
                if ((object->picture.hDim == 0) || (object->picture.vDim == 0)
                    || (object->picture.pdu_length == 0) || (object->picture.attribute == 1))
            #else /* __EMS_REL5__ */ 
                if ((object->picture.hDim == 0) || (object->picture.vDim == 0)
                    || (object->picture.pdu_length == 0) || (object->picture.pdu_length > EMS_MAX_IMELODY_SIZE))
            #endif /* __EMS_REL5__ */ 
                    return (EMS_INVALID_OBJECT);
            }
            else
            {
                return (EMS_INVALID_OBJECT);
            }
        }
            break;

        case EMS_USERDEFINED_ANIMATION:
        {
            if (data == NULL)
            {
                return (EMS_NULL_POINTER);
            }
            ID = data[0];
            if (ID == EMS_USERDEFINED_ANIMATION)
            {
                object->animation.bitsPerPixel = data[1];
                object->animation.attribute = data[2];
                object->animation.cFrame = data[3];
                object->animation.cRepeat = data[4];
                object->animation.Duration = data[5];
                object->animation.hDim = data[6] | (data[7] << 8);
                object->animation.vDim = data[8] | (data[9] << 8);
                object->animation.pdu_length = data[10] | (data[11] << 8);
                data += 12;
                object->animation.pdu = data;
            #ifdef __EMS_REL5__
                if ((object->animation.hDim == 0) || (object->animation.vDim == 0)
                    || (object->animation.pdu_length == 0)
                    || (object->animation.attribute == 1) || (object->animation.cFrame == 0))
            #else /* __EMS_REL5__ */ 
                if ((object->animation.hDim == 0) || (object->animation.vDim == 0)
                    || (object->animation.pdu_length == 0) || (object->animation.pdu_length > EMS_MAX_IMELODY_SIZE))
            #endif /* __EMS_REL5__ */ 
                    return (EMS_INVALID_OBJECT);
            }
            else
            {
                return (EMS_INVALID_OBJECT);
            }
        }
            break;
            /* MTK Joy added for customization, 1014 */
    #if defined(__MMI_IMELODY_SUPPORT__)
        case EMS_PREDEFINED_MELODY:
        {
            if ((index >= MAX_EMS_PREDEFINED_MELODIES))
            {
                return (EMS_INVALID_OBJECT);
            }
            if (index >= 0)
            {
                data = EMS_predefined_melodies[index];
            }
            #if 0 /* slim_2_2 */ //
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #ifdef __EMS_REL5__
/* under construction !*/
            #else 
/* under construction !*/
            #endif 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif 
        }
           // break;/* slim_2_2 */ //

        case EMS_USERDEFINED_MELODY:
        {
            if (data == NULL)
            {
                return (EMS_NULL_POINTER);
            }
            ID = data[0];
            //if (ID == EMS_USERDEFINED_MELODY)
            if (ID == type & 0xff)/* slim_2_2 */ //
            {
                object->sound.attribute = data[1];
                object->sound.pdu_length = data[2] | (data[3] << 8);
                data += 4;
                object->sound.pdu = data;
            #ifdef __EMS_REL5__
                if ((object->sound.pdu_length == 0) || (object->sound.attribute == 1))
            #else 
                if ((object->sound.pdu_length == 0) || (object->sound.pdu_length > EMS_MAX_IMELODY_SIZE))
            #endif 
                    return (EMS_INVALID_OBJECT);
            }
            else
            {
                return (EMS_INVALID_OBJECT);
            }
        }
            break;
    #endif /* defined(__MMI_IMELODY_SUPPORT__) */ 
            /* MTK end */
    }
    return (EMS_OK);
}

#if(ENABLE_EMS_TEST_DEMO || ENABLE_EMS_TEST_OBJECTS)    /* test_block  */

#define MAX_EMS_TEST_OBJECTS  10

U8 EMS_test_object_count = 0;
U8 *EMS_test_objects[MAX_EMS_TEST_OBJECTS] = { (U8 *) EMS_sample_picture_object_PDU_1,
    (U8 *) EMS_sample_picture_object_PDU_2,
    (U8 *) EMS_sample_picture_object_PDU_3,
    (U8 *) EMS_sample_picture_object_PDU_4,
    (U8 *) EMS_sample_picture_object_PDU_5,
    (U8 *) EMS_sample_picture_object_PDU_6,
    (U8 *) EMS_sample_picture_object_PDU_7,
    (U8 *) EMS_sample_picture_object_PDU_8,
    (U8 *) EMS_sample_picture_object_PDU_9,
    (U8 *) EMS_sample_picture_object_PDU_10,
};

#endif /* (ENABLE_EMS_TEST_DEMO || ENABLE_EMS_TEST_OBJECTS) */ 

#if(ENABLE_EMS_TEST_DEMO)       /* test_block  */


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_insert_object
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_insert_object(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS ret;
    U8 *data;
    U8 ID;

    S32 index = EMS_test_object_count++;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (EMS_test_object_count > 9)
    {
        EMS_test_object_count = 0;
    }
    data = EMS_test_objects[index];
    ID = data[0];
    switch (ID)
    {
        case EMS_PREDEFINED_PICTURE:
        case EMS_USERDEFINED_PICTURE:
            ret = EMS_load_object(EMS_PREDEFINED_PICTURE, data, index, &object);
            if (ret == EMS_OK)
            {
                ret = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_PIC, &object, 0);
            }
            break;

        case EMS_USERDEFINED_ANIMATION:
            ret = EMS_load_object(EMS_USERDEFINED_ANIMATION, data, index, &object);
            if (ret == EMS_OK)
            {
                ret = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_USERDEF_ANM, &object, 0);
            }
            break;

        case EMS_PREDEFINED_ANIMATION:
            ret = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_PREDEF_ANM, NULL, data[1]);
            break;

        case EMS_PREDEFINED_SOUND:
            ret = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_PREDEF_SND, NULL, data[1]);
            break;

        case EMS_PREDEFINED_MELODY:
            ret = EMS_load_object(EMS_PREDEFINED_MELODY, data, index, &object);
            if (ret == EMS_OK)
            {
                ret = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_USERDEF_SND, &object, 0);
            }
            break;
    }
    /* show_EMS_inputbox(); */
}

#endif /* (ENABLE_EMS_TEST_DEMO) */ 

#if(ENABLE_EMS_TEST_OBJECTS)


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_insert_predefined_picture
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
EMSTATUS EMS_inputbox_insert_predefined_picture(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS ret;
    U8 *data;
    U8 ID;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (index < 0)
    {
        index = 0;
    }
    if (index > (MAX_EMS_TEST_OBJECTS - 1))
    {
        index = MAX_EMS_TEST_OBJECTS - 1;
    }
    data = EMS_test_objects[index];
    ID = data[0];
    switch (ID)
    {
        case EMS_PREDEFINED_PICTURE:
        case EMS_USERDEFINED_PICTURE:
            ret = EMS_load_object(EMS_PREDEFINED_PICTURE, data, index, &object);
            if (ret == EMS_OK)
            {
                ret = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_PIC, &object, 0);
            }
            break;

        case EMS_USERDEFINED_ANIMATION:
            ret = EMS_load_object(EMS_USERDEFINED_ANIMATION, data, index, &object);
            if (ret == EMS_OK)
            {
                ret = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_USERDEF_ANM, &object, 0);
            }
            break;

        case EMS_PREDEFINED_ANIMATION:
            ret = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_PREDEF_ANM, NULL, data[1]);
            break;

        case EMS_PREDEFINED_SOUND:
            ret = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_PREDEF_SND, NULL, data[1]);
            break;

        case EMS_PREDEFINED_MELODY:
            ret = EMS_load_object(EMS_PREDEFINED_MELODY, data, index, &object);
            if (ret == EMS_OK)
            {
                ret = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_USERDEF_SND, &object, 0);
            }
            break;
    }
    return (ret);
}

#else /* (ENABLE_EMS_TEST_OBJECTS) */ 


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_insert_predefined_picture
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
EMSTATUS EMS_inputbox_insert_predefined_picture(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    U8 *data = NULL;
    EMSTATUS r = EMS_load_object(EMS_PREDEFINED_PICTURE, data, index, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        r = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_PIC, &object, 0);
    }
    return (r);
}

#endif /* (ENABLE_EMS_TEST_OBJECTS) */ 


/*****************************************************************************
 * FUNCTION
 *  EMS_get_object_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  type        [IN]        
 *  objdata     [?]         
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_get_object_size(U8 type, EMSObjData *objdata)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (EMSGetObjectSize(type, objdata));
}


/*****************************************************************************
 * FUNCTION
 *  EMS_check_object_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  type        [IN]        
 *  objdata     [?]         
 *  allowed     [?]         
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_check_object_size(U8 type, EMSObjData *objdata, U8 *allowed)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_bool flag;
    S32 size = EMSGetObjectSizeWithCheck(type, objdata, &flag);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (flag == KAL_TRUE)
    {
        *allowed = 1;
    }
    else
    {
        *allowed = 0;
    }
    return (size);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_load_predefined_picture
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 *  data        [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_load_predefined_picture(S32 index, U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((index >= 0) && (index < MAX_EMS_PREDEFINED_PICTURES))
    {
        EMS_predefined_pictures[index] = data;
    }
}


/*****************************************************************************
 * FUNCTION
 *  EMS_get_predefined_picture_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_get_predefined_picture_size(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    U8 *data = NULL;
    EMSTATUS r = EMS_load_object(EMS_PREDEFINED_PICTURE, data, index, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        return (EMS_get_object_size(EMS_TYPE_PIC, &object));
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_get_predefined_picture_data_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_get_predefined_picture_data_size(U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_PREDEFINED_PICTURE, data, -1, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        return (EMS_get_object_size(EMS_TYPE_PIC, &object));
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_check_predefined_picture_data_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 *  allowed     [?]     
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_check_predefined_picture_data_size(U8 *data, U8 *allowed)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_PREDEFINED_PICTURE, data, -1, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        return (EMS_check_object_size(EMS_TYPE_PIC, &object, allowed));
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_get_userdefined_picture_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_get_userdefined_picture_size(U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_USERDEFINED_PICTURE, data, 0, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        return (EMS_get_object_size(EMS_TYPE_PIC, &object));
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_check_userdefined_picture_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 *  allowed     [?]     
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_check_userdefined_picture_size(U8 *data, U8 *allowed)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_USERDEFINED_PICTURE, data, 0, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        return (EMS_check_object_size(EMS_TYPE_PIC, &object, allowed));
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_insert_userdefined_picture
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  
 *****************************************************************************/
EMSTATUS EMS_inputbox_insert_userdefined_picture(U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_USERDEFINED_PICTURE, data, 0, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        r = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_PIC, &object, 0);
    }
    return (r);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_get_predefined_animation_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_get_predefined_animation_size(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((index < 0) || (index >= MAX_EMS_PREDEFINED_ANIMATIONS))
    {
        return (0);
    }
    return (EMS_get_object_size(EMS_TYPE_PREDEF_ANM, &object));
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_insert_predefined_animation
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
EMSTATUS EMS_inputbox_insert_predefined_animation(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((index < 0) || (index >= MAX_EMS_PREDEFINED_ANIMATIONS))
    {
        return (EMS_INVALID_OBJECT);
    }
    return (gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_PREDEF_ANM, NULL, (U8) index));
}


/*****************************************************************************
 * FUNCTION
 *  EMS_get_userdefined_animation_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_get_userdefined_animation_size(U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_USERDEFINED_ANIMATION, data, 0, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        return (EMS_get_object_size(EMS_TYPE_USERDEF_ANM, &object));
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_check_userdefined_animation_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 *  allowed     [?]     
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_check_userdefined_animation_size(U8 *data, U8 *allowed)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_USERDEFINED_ANIMATION, data, 0, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        return (EMS_check_object_size(EMS_TYPE_USERDEF_ANM, &object, allowed));
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_insert_userdefined_animation
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  
 *****************************************************************************/
EMSTATUS EMS_inputbox_insert_userdefined_animation(U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_USERDEFINED_ANIMATION, data, 0, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        r = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_USERDEF_ANM, &object, 0);
    }
    return (r);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_get_predefined_sound_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_get_predefined_sound_size(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((index < 0) || (index >= MAX_EMS_PREDEFINED_SOUNDS))
    {
        return (0);
    }
    return (EMS_get_object_size(EMS_TYPE_PREDEF_SND, &object));
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_insert_predefined_sound
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
EMSTATUS EMS_inputbox_insert_predefined_sound(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((index < 0) || (index >= MAX_EMS_PREDEFINED_SOUNDS))
    {
        return (EMS_INVALID_OBJECT);
    }
    return (gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_PREDEF_SND, NULL, (U8) index));
}

/* MTK Joy added for customization, 1014 */
#if defined(__MMI_IMELODY_SUPPORT__)


/*****************************************************************************
 * FUNCTION
 *  EMS_load_predefined_melody
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 *  data        [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_load_predefined_melody(S32 index, U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((index >= 0) && (index < MAX_EMS_PREDEFINED_MELODIES))
    {
        EMS_predefined_melodies[index] = data;
    }
}


/*****************************************************************************
 * FUNCTION
 *  EMS_get_predefined_melody_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_get_predefined_melody_size(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    U8 *data = NULL;
    EMSTATUS r = EMS_load_object(EMS_PREDEFINED_MELODY, data, index, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        return (EMS_get_object_size(EMS_TYPE_USERDEF_SND, &object));
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_get_predefined_melody_data_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_get_predefined_melody_data_size(U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_PREDEFINED_MELODY, data, -1, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        return (EMS_get_object_size(EMS_TYPE_USERDEF_SND, &object));
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_check_predefined_melody_data_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 *  allowed     [?]     
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_check_predefined_melody_data_size(U8 *data, U8 *allowed)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_PREDEFINED_MELODY, data, -1, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        return (EMS_check_object_size(EMS_TYPE_USERDEF_SND, &object, allowed));
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_insert_predefined_melody
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
EMSTATUS EMS_inputbox_insert_predefined_melody(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    U8 *data = NULL;
    EMSTATUS r = EMS_load_object(EMS_PREDEFINED_MELODY, data, index, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        r = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_USERDEF_SND, &object, 0);
    }
    return (r);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_get_userdefined_melody_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_get_userdefined_melody_size(U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_USERDEFINED_MELODY, data, 0, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        return (EMS_get_object_size(EMS_TYPE_USERDEF_SND, &object));
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_check_userdefined_melody_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 *  allowed     [?]     
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_check_userdefined_melody_size(U8 *data, U8 *allowed)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_USERDEFINED_MELODY, data, 0, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        return (EMS_check_object_size(EMS_TYPE_USERDEF_SND, &object, allowed));
    }
    return (0);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_insert_userdefined_melody
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  
 *****************************************************************************/
EMSTATUS EMS_inputbox_insert_userdefined_melody(U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;
    EMSTATUS r = EMS_load_object(EMS_USERDEFINED_MELODY, data, 0, &object);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r == EMS_OK)
    {
        r = gui_EMS_inputbox_add_object(&MMI_EMS_inputbox, EMS_TYPE_USERDEF_SND, &object, 0);
    }
    return (r);
}
/*****************************************************************************
 * FUNCTION
 *  EMS_melody_detach_header
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src         [?]     
 *  dst         [?]     
 *  size        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
static void EMS_melody_detach_header(U8 *src, U8 *dst, S32 *size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *size = *size - 4;
    gui_memcpy(dst, src + 4, *size);
}

/*****************************************************************************
 * FUNCTION
 *  EMS_predefined_melody_attach_header
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src         [?]     
 *  dst         [?]     
 *  size        [?]
 *  type        [IN]     EMS_PREDEFINED_MELODY or EMS_USERDEFINED_MELODY 
 * RETURNS
 *  void
 *****************************************************************************/
static void EMS_melody_attach_header(U8 *src, U8 *dst, S32 *size, U8 type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_memcpy(dst + 4, src, *size);
    dst[0] = type;
    dst[1] = 0;
    dst[2] = (U8) ((*size) & 0xff);
    dst[3] = (U8) ((*size) >> 8);
    *size = *size + 4;
}
#if 1  /* slim_2_2 */ //
/*****************************************************************************
 * FUNCTION
 *  EMS_userdefined_melody_attach_header
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src         [?]     
 *  dst         [?]     
 *  size        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_userdefined_melody_attach_header(U8 *src, U8 *dst, S32 *size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_memcpy(dst + 4, src, *size);
    dst[0] = EMS_USERDEFINED_MELODY;
    dst[1] = 0;
    dst[2] = (U8) ((*size) & 0xff);
    dst[3] = (U8) ((*size) >> 8);
    *size = *size + 4;
}


/*****************************************************************************
 * FUNCTION
 *  EMS_userdefined_melody_detach_header
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src         [?]     
 *  dst         [?]     
 *  size        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_userdefined_melody_detach_header(U8 *src, U8 *dst, S32 *size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *size = *size - 4;
    gui_memcpy(dst, src + 4, *size);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_predefined_melody_attach_header
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src         [?]     
 *  dst         [?]     
 *  size        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_predefined_melody_attach_header(U8 *src, U8 *dst, S32 *size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_memcpy(dst + 4, src, *size);
    dst[0] = EMS_PREDEFINED_MELODY;
    dst[1] = 0;
    dst[2] = (U8) ((*size) & 0xff);
    dst[3] = (U8) ((*size) >> 8);
    *size = *size + 4;
}


/*****************************************************************************
 * FUNCTION
 *  EMS_predefined_melody_detach_header
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src         [?]     
 *  dst         [?]     
 *  size        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_predefined_melody_detach_header(U8 *src, U8 *dst, S32 *size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *size = *size - 4;
    gui_memcpy(dst, src + 4, *size);
}
#endif
#endif /* defined(__MMI_IMELODY_SUPPORT__) */ 
/* MTK end */


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_set_text_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  s       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_set_text_size(EMSFONTSIZE s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_EMS_text_format.FontSize = s;
    /* AddString(MMI_EMS_inputbox.data,NULL,0,&wgui_EMS_text_format); */
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_get_text_size
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
EMSFONTSIZE EMS_inputbox_get_text_size(void)
{
#ifdef __MMI_DIALLING_FONT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_EMS_text_format.FontSize == EMS_FONTSIZE_LARGE)
    {
        return (EMS_FONTSIZE_NORMAL);
    }
    else
    {
        return (wgui_EMS_text_format.FontSize);
    }
#else /* __MMI_DIALLING_FONT__ */ 
    return (wgui_EMS_text_format.FontSize);
#endif /* __MMI_DIALLING_FONT__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_set_text_style
 * DESCRIPTION
 *  
 * PARAMETERS
 *  isBold              [IN]        
 *  isItalic            [IN]        
 *  isUnderline         [IN]        
 *  isStrikethrough     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_set_text_style(U8 isBold, U8 isItalic, U8 isUnderline, U8 isStrikethrough)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (isBold)
    {
        wgui_EMS_text_format.isBold = KAL_TRUE;
    }
    else
    {
        wgui_EMS_text_format.isBold = KAL_FALSE;
    }
    if (isItalic)
    {
        wgui_EMS_text_format.isItalic = KAL_TRUE;
    }
    else
    {
        wgui_EMS_text_format.isItalic = KAL_FALSE;
    }
    if (isUnderline)
    {
        wgui_EMS_text_format.isUnderline = KAL_TRUE;
    }
    else
    {
        wgui_EMS_text_format.isUnderline = KAL_FALSE;
    }
    if (isStrikethrough)
    {
        wgui_EMS_text_format.isStrikethrough = KAL_TRUE;
    }
    else
    {
        wgui_EMS_text_format.isStrikethrough = KAL_FALSE;
    }
    /* AddString(MMI_EMS_inputbox.data,NULL,0,&wgui_EMS_text_format); */
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_get_text_style
 * DESCRIPTION
 *  
 * PARAMETERS
 *  isBold              [?]     
 *  isItalic            [?]     
 *  isUnderline         [?]     
 *  isStrikethrough     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_inputbox_get_text_style(U8 *isBold, U8 *isItalic, U8 *isUnderline, U8 *isStrikethrough)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_EMS_text_format.isBold == KAL_TRUE)
    {
        *isBold = 1;
    }
    else
    {
        *isBold = 0;
    }
    if (wgui_EMS_text_format.isItalic == KAL_TRUE)
    {
        *isItalic = 1;
    }
    else
    {
        *isItalic = 0;
    }
    if (wgui_EMS_text_format.isUnderline == KAL_TRUE)
    {
        *isUnderline = 1;
    }
    else
    {
        *isUnderline = 0;
    }
    if (wgui_EMS_text_format.isStrikethrough == KAL_TRUE)
    {
        *isStrikethrough = 1;
    }
    else
    {
        *isStrikethrough = 0;
    }
}
#endif /* __MMI_MESSAGES_EMS__ */ /* endif __MMI_MESSAGES_EMS__ */
U8 EMS_inputbox_alignment_added_flag = 0;
EMSALIGNMENT EMS_inputbox_alignment = EMS_ALIGN_LANG_DEP;


#ifdef __MMI_MESSAGES_EMS__

/*****************************************************************************
 * FUNCTION
 *  initialize_EMS_objects
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void initialize_EMS_objects(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __COSMOS_MMI_PACKAGE__
    EMS_editor_sound_icon = get_image(EMS_EDITOR_SOUND_OBJECT_ID);
    EMS_editor_melody_icon = get_image(EMS_EDITOR_MELODY_OBJECT_ID);
#else
    EMS_editor_sound_icon = NULL;
    EMS_editor_melody_icon = NULL;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_set_text_alignment
 * DESCRIPTION
 *  
 * PARAMETERS
 *  a       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
EMSTATUS EMS_inputbox_set_text_alignment(EMSALIGNMENT a)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSTATUS emsObjectStatus;
    EMSTextFormat saved_wgui_EMS_text_format = wgui_EMS_text_format;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Old code: Used for testing purpose. Leave commented   */
    //      ResetTextFormat(&wgui_EMS_text_format);
    //      wgui_EMS_text_format.Alignment=a;
    /* Old code: ends */
    saved_wgui_EMS_text_format.Alignment = a;
    emsObjectStatus = gui_EMS_input_box_insert_text_alignment(&MMI_EMS_inputbox, &saved_wgui_EMS_text_format);
    /* Old code: Used for testing purpose. Leave commented   */
    //      AddString(MMI_EMS_inputbox.data,NULL,0,&wgui_EMS_text_format);
    //      wgui_EMS_text_format=saved_wgui_EMS_text_format;
    /* Old code: ends */
    if (emsObjectStatus != EMS_OK)
    {
        return emsObjectStatus;
    }
    if (MMI_EMS_inputbox.data->CurrentTextFormatObj != NULL)
    {
        wgui_EMS_text_format.Alignment = MMI_EMS_inputbox.data->CurrentTextFormatObj->data->text_format.Alignment;
    }
    /* HACK: Set a flag to indicate that text alignment has been added   */
    EMS_inputbox_alignment_added_flag = 1;
    EMS_inputbox_alignment = a;
    return emsObjectStatus;
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_get_text_alignment
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
EMSALIGNMENT EMS_inputbox_get_text_alignment(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (wgui_EMS_text_format.Alignment);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_inputbox_create_new_paragraph
 * DESCRIPTION
 *  
 * PARAMETERS
 *  a       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
EMSTATUS EMS_inputbox_create_new_paragraph(EMSALIGNMENT a)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSTATUS emsObjectStatus;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_EMS_text_format.Alignment = a;
    emsObjectStatus = gui_EMS_input_box_insert_new_paragraph(&MMI_EMS_inputbox, &wgui_EMS_text_format);
    /* AddString(MMI_EMS_inputbox.data,NULL,0,&wgui_EMS_text_format); */
    if (emsObjectStatus != EMS_OK)
    {
       wgui_EMS_text_format = MMI_EMS_inputbox.text_format;
    }
    EMS_inputbox_input_callback();
    return emsObjectStatus;
}


/*****************************************************************************
 * FUNCTION
 *  close_EMS_objects
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void close_EMS_objects(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}

/* EMS category screens: Application menus   */

#define EMS_APPLICATION_MENUS_BASE                    (DEMO_APP_BASE+400)
#define EMS_APPLICATION_MENUS_SCREEN_ID_BASE          (EMS_APPLICATION_MENUS_BASE+0)
#define EMS_MAIN_MENU_SCREEN_ID                       (EMS_APPLICATION_MENUS_SCREEN_ID_BASE+1)
#define EMS_OBJECTS_MENU_SCREEN_ID                    (EMS_APPLICATION_MENUS_SCREEN_ID_BASE+2)
#define EMS_TEXT_FORMATTING_MENU_SCREEN_ID               (EMS_APPLICATION_MENUS_SCREEN_ID_BASE+3)
#define EMS_TEXT_ALIGNMENT_SELECTION_MENU_SCREEN_ID         (EMS_APPLICATION_MENUS_SCREEN_ID_BASE+4)
#define EMS_TEXT_SIZE_SELECTION_MENU_SCREEN_ID           (EMS_APPLICATION_MENUS_SCREEN_ID_BASE+5)
#define EMS_TEXT_STYLE_SELECTION_MENU_SCREEN_ID          (EMS_APPLICATION_MENUS_SCREEN_ID_BASE+6)
#define EMS_TEXT_NEW_PARAGRAPH_ALIGNMENT_MENU_SCREEN_ID     (EMS_APPLICATION_MENUS_SCREEN_ID_BASE+7)

#define MAX_EMS_MAIN_MENU_ITEMS  5

#if(EMS_USE_INTERNAL_MENU)

#ifdef __UCS2_ENCODING

U8 *EMS_main_menu_items[] = { (U8 *) "A\0d\0d\0 \0s\0y\0m\0b\0o\0l\0\0",
    (U8 *) "I\0n\0s\0e\0r\0t\0 \0o\0b\0j\0e\0c\0t\0\0",
    (U8 *) "F\0o\0r\0m\0a\0t\0 \0t\0e\0x\0t\0\0",
    (U8 *) "I\0n\0p\0u\0t\0 \0m\0e\0t\0h\0o\0d\0\0",
    (U8 *) "H\0e\0l\0p\0\0",
};

#else /* __UCS2_ENCODING */ 

U8 *EMS_main_menu_items[] = { (U8 *) "Add symbol",
    (U8 *) "Insert object",
    (U8 *) "Formart text",
    (U8 *) "Input method",
    (U8 *) "Help",
};

#endif /* __UCS2_ENCODING */ 


/*****************************************************************************
 * FUNCTION
 *  HandleEMSMainMenuLSK
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HandleEMSMainMenuLSK(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (GetHighlightedItem())
    {
        case 0:
            break;
        case 1: /* Temporary: For testing  */
            EMS_inputbox_insert_object();
            GoBackHistory();
            /* EntryEMSObjectsMenu(); */
            break;
        case 2:
            GotoEMSTextFormattingMenu();
            break;
        case 3:
            break;
        case 4:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMSMainMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMSMainMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecuteCurrExitHandler();
    guiBuffer = GetCurrGuiBuffer(EMS_MAIN_MENU_SCREEN_ID);
    ShowCategory6Screen(
        0,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        MAX_EMS_MAIN_MENU_ITEMS,
        EMS_main_menu_items,
        0,
        guiBuffer);
    SetLeftSoftkeyFunction(HandleEMSMainMenuLSK, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetExitHandler(EMS_MAIN_MENU_SCREEN_ID, ExitEMSMainMenu);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEMSMainMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEMSMainMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    h.scrnID = EMS_MAIN_MENU_SCREEN_ID;
    h.entryFuncPtr = EntryEMSMainMenu;
    h.inputBuffer[0] = '\0';
    GetCategoryHistory(h.guiBuffer);
    AddHistory(h);
}

#define MAX_EMS_OBJECTS_MENU_ITEMS  4

#ifdef __UCS2_ENCODING

U8 *EMS_objects_menu_items[] = { (U8 *) "P\0i\0c\0t\0u\0r\0e\0\0",
    (U8 *) "A\0n\0i\0m\0a\0t\0i\0o\0n\0\0",
    (U8 *) "S\0o\0u\0n\0d\0\0",
    (U8 *) "M\0e\0l\0o\0d\0y\0\0",
};

#else /* __UCS2_ENCODING */ 

U8 *EMS_objects_menu_items[] = { (U8 *) "Picture",
    (U8 *) "Animation",
    (U8 *) "Sound",
    (U8 *) "Melody",
};

#endif /* __UCS2_ENCODING */ 


/*****************************************************************************
 * FUNCTION
 *  EntryEMSObjectsMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMSObjectsMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecuteCurrExitHandler();
    guiBuffer = GetCurrGuiBuffer(EMS_OBJECTS_MENU_SCREEN_ID);
    ShowCategory6Screen(
        0,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        MAX_EMS_OBJECTS_MENU_ITEMS,
        EMS_objects_menu_items,
        0,
        guiBuffer);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetExitHandler(EMS_OBJECTS_MENU_SCREEN_ID, ExitEMSObjectsMenu);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEMSObjectsMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEMSObjectsMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    h.scrnID = EMS_OBJECTS_MENU_SCREEN_ID;
    h.entryFuncPtr = EntryEMSObjectsMenu;
    h.inputBuffer[0] = '\0';
    GetCategoryHistory(h.guiBuffer);
    AddHistory(h);
}

#define MAX_EMS_TEXT_FORMATTING_MENU_ITEMS   4

#ifdef __UCS2_ENCODING

U8 *EMS_text_formatting_menu_items[] = { (U8 *) "T\0e\0x\0t\0 \0s\0i\0z\0e\0\0",
    (U8 *) "T\0e\0x\0t\0 \0s\0t\0y\0l\0e\0\0",
    (U8 *) "A\0l\0i\0g\0n\0m\0e\0n\0t\0\0",
    (U8 *) "N\0e\0w\0 \0p\0a\0r\0a\0g\0r\0a\0p\0h\0\0",
};

#else /* __UCS2_ENCODING */ 

U8 *EMS_text_formatting_menu_items[] = { (U8 *) "Text size",
    (U8 *) "Text style",
    (U8 *) "Alignment",
    (U8 *) "New paragraph",
};

#endif /* __UCS2_ENCODING */ 


/*****************************************************************************
 * FUNCTION
 *  HandleEMSTextFormattingMenuLSK
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HandleEMSTextFormattingMenuLSK(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (GetHighlightedItem())
    {
        case 0:
            EntryEMSTextSizeSelectionMenu();
            break;
        case 1:
            EntryEMSTextStyleSelectionMenu();
            break;
        case 2:
            EntryEMSTextAlignmentSelectionMenu();
            break;
        case 3:
            EntryEMSNewParagraphAlignmentMenu();
            break;
    }
}

/* 0: false, 1: true */
U8 EMSTextFormattingMenu_bold = 0;
U8 EMSTextFormattingMenu_italic = 0;
U8 EMSTextFormattingMenu_underline = 0;
U8 EMSTextFormattingMenu_strikethrough = 0;

/* 1: left, 2: right, 3: center, 0: automatic   */
U8 EMSTextFormattingMenu_alignment = 0;

/* 0: small, 1: medium, 2: large */
U8 EMSTextFormattingMenu_font_size = 1;


/*****************************************************************************
 * FUNCTION
 *  LoadEMSTextFormattingMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void LoadEMSTextFormattingMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSTextFormat *o;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((MMI_EMS_inputbox.data == NULL) || (MMI_EMS_inputbox.data->CurrentTextFormatObj == NULL))
    {
        EMSTextFormattingMenu_bold = 0;
        EMSTextFormattingMenu_italic = 0;
        EMSTextFormattingMenu_strikethrough = 0;
        EMSTextFormattingMenu_underline = 0;
        EMSTextFormattingMenu_alignment = 0;
        EMSTextFormattingMenu_font_size = 1;
    }
    else
    {
        o = &MMI_EMS_inputbox.data->CurrentTextFormatObj->data->text_format;
        if (o->isBold)
        {
            EMSTextFormattingMenu_bold = 1;
        }
        else
        {
            EMSTextFormattingMenu_bold = 0;
        }
        if (o->isItalic)
        {
            EMSTextFormattingMenu_italic = 1;
        }
        else
        {
            EMSTextFormattingMenu_italic = 0;
        }
        if (o->isStrikethrough)
        {
            EMSTextFormattingMenu_strikethrough = 1;
        }
        else
        {
            EMSTextFormattingMenu_strikethrough = 0;
        }
        if (o->isUnderline)
        {
            EMSTextFormattingMenu_underline = 1;
        }
        else
        {
            EMSTextFormattingMenu_underline = 0;
        }

        switch (o->Alignment)
        {
            case EMS_ALIGN_LEFT:
                EMSTextFormattingMenu_alignment = 1;
                break;
            case EMS_ALIGN_RIGHT:
                EMSTextFormattingMenu_alignment = 2;
                break;
            case EMS_ALIGN_CENTER:
                EMSTextFormattingMenu_alignment = 3;
                break;
            case EMS_ALIGN_LANG_DEP:
                EMSTextFormattingMenu_alignment = 0;
                break;
        }
        switch (o->FontSize)
        {
            case EMS_FONTSIZE_NORMAL:
                EMSTextFormattingMenu_font_size = 1;
                break;
            case EMS_FONTSIZE_LARGE:
                EMSTextFormattingMenu_font_size = 2;
                break;
            case EMS_FONTSIZE_SMALL:
                EMSTextFormattingMenu_font_size = 0;
                break;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  StoreEMSTextFormattingMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void StoreEMSTextFormattingMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData object;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ResetTextFormat(&object.text_format);
    object.text_format.bgColor = EMS_BLACK;
    object.text_format.fgColor = EMS_BLACK;
    switch (EMSTextFormattingMenu_alignment)
    {
        case 0:
            object.text_format.Alignment = EMS_ALIGN_LEFT;
            break;
        case 1:
            object.text_format.Alignment = EMS_ALIGN_LEFT;
            break;
        case 2:
            object.text_format.Alignment = EMS_ALIGN_RIGHT;
            break;
        case 3:
            object.text_format.Alignment = EMS_ALIGN_CENTER;
            break;
    }
    switch (EMSTextFormattingMenu_font_size)
    {
        case 0:
            object.text_format.FontSize = EMS_FONTSIZE_SMALL;
            break;
        case 1:
            object.text_format.FontSize = EMS_FONTSIZE_NORMAL;
            break;
        case 2:
            object.text_format.FontSize = EMS_FONTSIZE_LARGE;
            break;
    }
    if (EMSTextFormattingMenu_bold)
    {
        object.text_format.isBold = 1;
    }
    else
    {
        object.text_format.isBold = 0;
    }
    if (EMSTextFormattingMenu_italic)
    {
        object.text_format.isItalic = 1;
    }
    else
    {
        object.text_format.isItalic = 0;
    }
    if (EMSTextFormattingMenu_underline)
    {
        object.text_format.isUnderline = 1;
    }
    else
    {
        object.text_format.isUnderline = 0;
    }
    if (EMSTextFormattingMenu_strikethrough)
    {
        object.text_format.isStrikethrough = 1;
    }
    else
    {
        object.text_format.isStrikethrough = 0;
    }
    object.text_format.textLength = 1;
    wgui_EMS_text_format = object.text_format;
}


/*****************************************************************************
 * FUNCTION
 *  HandleEMSTextFormattingMenuRSK
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HandleEMSTextFormattingMenuRSK(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    StoreEMSTextFormattingMenu();
    GoBackHistory();
    GoBackHistory();
}


/*****************************************************************************
 * FUNCTION
 *  GotoEMSTextFormattingMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void GotoEMSTextFormattingMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    LoadEMSTextFormattingMenu();
    EntryEMSTextFormattingMenu();
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMSTextFormattingMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMSTextFormattingMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecuteCurrExitHandler();
    guiBuffer = GetCurrGuiBuffer(EMS_TEXT_FORMATTING_MENU_SCREEN_ID);
    ShowCategory6Screen(
        0,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        MAX_EMS_TEXT_FORMATTING_MENU_ITEMS,
        EMS_text_formatting_menu_items,
        0,
        guiBuffer);
    SetLeftSoftkeyFunction(HandleEMSTextFormattingMenuLSK, KEY_EVENT_UP);
    SetRightSoftkeyFunction(HandleEMSTextFormattingMenuRSK, KEY_EVENT_UP);
    SetExitHandler(EMS_TEXT_FORMATTING_MENU_SCREEN_ID, ExitEMSTextFormattingMenu);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEMSTextFormattingMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEMSTextFormattingMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    h.scrnID = EMS_TEXT_FORMATTING_MENU_SCREEN_ID;
    h.entryFuncPtr = EntryEMSTextFormattingMenu;
    h.inputBuffer[0] = '\0';
    GetCategoryHistory(h.guiBuffer);
    AddHistory(h);
}

#define MAX_EMS_TEXT_SIZE_MENU_ITEMS   3

#ifdef __UCS2_ENCODING

U8 *EMS_text_size_menu_items[] = { (U8 *) "S\0m\0a\0l\0l\0\0",
    (U8 *) "M\0e\0d\0i\0u\0m\0\0",
    (U8 *) "L\0a\0r\0g\0e\0\0",
};

#else /* __UCS2_ENCODING */ 

U8 *EMS_text_size_menu_items[] = { (U8 *) "Small",
    (U8 *) "Medium",
    (U8 *) "Large",
};

#endif /* __UCS2_ENCODING */ 


/*****************************************************************************
 * FUNCTION
 *  HandleEMSTextSizeSelectionMenuLSK
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HandleEMSTextSizeSelectionMenuLSK(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMSTextFormattingMenu_font_size = (U8) GetHighlightedItem();
    GoBackHistory();
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMSTextSizeSelectionMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMSTextSizeSelectionMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecuteCurrExitHandler();
    guiBuffer = GetCurrGuiBuffer(EMS_TEXT_SIZE_SELECTION_MENU_SCREEN_ID);
    h = EMSTextFormattingMenu_font_size;
    ShowCategory36Screen(
        0,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        MAX_EMS_TEXT_SIZE_MENU_ITEMS,
        EMS_text_size_menu_items,
        h,
        guiBuffer);
    SetLeftSoftkeyFunction(HandleEMSTextSizeSelectionMenuLSK, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetExitHandler(EMS_TEXT_SIZE_SELECTION_MENU_SCREEN_ID, ExitEMSTextSizeSelectionMenu);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEMSTextSizeSelectionMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEMSTextSizeSelectionMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    h.scrnID = EMS_TEXT_SIZE_SELECTION_MENU_SCREEN_ID;
    h.entryFuncPtr = EntryEMSTextSizeSelectionMenu;
    h.inputBuffer[0] = '\0';
    GetCategoryHistory(h.guiBuffer);
    AddHistory(h);
}

#define MAX_EMS_TEXT_STYLE_MENU_ITEMS  4

#ifdef __UCS2_ENCODING

U8 *EMS_text_style_menu_items[] = { (U8 *) "B\0o\0l\0d\0\0",
    (U8 *) "I\0t\0a\0l\0i\0c\0\0",
    (U8 *) "U\0n\0d\0e\0r\0l\0i\0n\0e\0\0",
    (U8 *) "S\0t\0r\0i\0k\0e\0t\0h\0r\0o\0u\0g\0h\0\0",
};

#else /* __UCS2_ENCODING */ 

U8 *EMS_text_style_menu_items[] = { (U8 *) "Bold",
    (U8 *) "Italic",
    (U8 *) "Underline",
    (U8 *) "Strikethrough",
};

#endif /* __UCS2_ENCODING */ 

U8 EMS_text_style_menu_states[] = {0, 0, 0, 0,
};


/*****************************************************************************
 * FUNCTION
 *  HandleEMSTextStyleSelectionMenuRSK
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HandleEMSTextStyleSelectionMenuRSK(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMSTextFormattingMenu_bold = EMS_text_style_menu_states[0];
    EMSTextFormattingMenu_italic = EMS_text_style_menu_states[1];
    EMSTextFormattingMenu_underline = EMS_text_style_menu_states[2];
    EMSTextFormattingMenu_strikethrough = EMS_text_style_menu_states[3];

    #if 0/* slim_2_2 */ //    
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif
    GoBackHistory();
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMSTextStyleSelectionMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMSTextStyleSelectionMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecuteCurrExitHandler();
    guiBuffer = GetCurrGuiBuffer(EMS_TEXT_STYLE_SELECTION_MENU_SCREEN_ID);
    EMS_text_style_menu_states[0] = EMSTextFormattingMenu_bold; 
    EMS_text_style_menu_states[1] = EMSTextFormattingMenu_italic;
    EMS_text_style_menu_states[2] = EMSTextFormattingMenu_underline;
    EMS_text_style_menu_states[3] = EMSTextFormattingMenu_strikethrough;

    #if 0 /* slim_2_2 */ //
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif 
    ShowCategory12Screen(
        0,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        MAX_EMS_TEXT_STYLE_MENU_ITEMS,
        EMS_text_style_menu_items,
        EMS_text_style_menu_states,
        0,
        guiBuffer);
    SetRightSoftkeyFunction(HandleEMSTextStyleSelectionMenuRSK, KEY_EVENT_UP);
    SetExitHandler(EMS_TEXT_STYLE_SELECTION_MENU_SCREEN_ID, ExitEMSTextStyleSelectionMenu);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEMSTextStyleSelectionMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEMSTextStyleSelectionMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    h.scrnID = EMS_TEXT_STYLE_SELECTION_MENU_SCREEN_ID;
    h.entryFuncPtr = EntryEMSTextStyleSelectionMenu;
    h.inputBuffer[0] = '\0';
    GetCategoryHistory(h.guiBuffer);
    AddHistory(h);
}

#define MAX_EMS_TEXT_ALIGNMENT_MENU_ITEMS 4

#ifdef __UCS2_ENCODING

U8 *EMS_text_alignment_menu_items[] = { (U8 *) "A\0u\0t\0o\0m\0a\0t\0i\0c\0\0",
    (U8 *) "L\0e\0f\0t\0\0",
    (U8 *) "R\0i\0g\0h\0t\0\0",
    (U8 *) "C\0e\0n\0t\0e\0r\0\0",
};

#else /* __UCS2_ENCODING */ 

U8 *EMS_text_alignment_menu_items[] = { (U8 *) "Automatic",
    (U8 *) "Left",
    (U8 *) "Right",
    (U8 *) "Center",
};

#endif /* __UCS2_ENCODING */ 


/*****************************************************************************
 * FUNCTION
 *  HandleEMSTextAlignmentSelectionMenuLSK
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HandleEMSTextAlignmentSelectionMenuLSK(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMSTextFormattingMenu_alignment = (U8) GetHighlightedItem();
    GoBackHistory();
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMSTextAlignmentSelectionMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMSTextAlignmentSelectionMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecuteCurrExitHandler();
    guiBuffer = GetCurrGuiBuffer(EMS_TEXT_ALIGNMENT_SELECTION_MENU_SCREEN_ID);
    h = EMSTextFormattingMenu_alignment;
    ShowCategory36Screen(
        0,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        MAX_EMS_TEXT_ALIGNMENT_MENU_ITEMS,
        EMS_text_alignment_menu_items,
        h,
        guiBuffer);
    SetLeftSoftkeyFunction(HandleEMSTextAlignmentSelectionMenuLSK, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetExitHandler(EMS_TEXT_ALIGNMENT_SELECTION_MENU_SCREEN_ID, ExitEMSTextAlignmentSelectionMenu);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEMSTextAlignmentSelectionMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEMSTextAlignmentSelectionMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    h.scrnID = EMS_TEXT_ALIGNMENT_SELECTION_MENU_SCREEN_ID;
    h.entryFuncPtr = EntryEMSTextAlignmentSelectionMenu;
    h.inputBuffer[0] = '\0';
    GetCategoryHistory(h.guiBuffer);
    AddHistory(h);
}


/*****************************************************************************
 * FUNCTION
 *  HandleEMSNewParagraphAlignmentMenuLSK
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HandleEMSNewParagraphAlignmentMenuLSK(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMSTextFormattingMenu_alignment = (U8) GetHighlightedItem();
    GoBackHistory();
    StoreEMSTextFormattingMenu();
    EMS_inputbox_insert_new_line();
    GoBackHistory();
    GoBackHistory();
}


/*****************************************************************************
 * FUNCTION
 *  EntryEMSNewParagraphAlignmentMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMSNewParagraphAlignmentMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    U16 h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecuteCurrExitHandler();
    guiBuffer = GetCurrGuiBuffer(EMS_TEXT_ALIGNMENT_SELECTION_MENU_SCREEN_ID);
    h = EMSTextFormattingMenu_alignment;
    ShowCategory36Screen(
        0,
        0,
        STR_GLOBAL_OK,
        IMG_GLOBAL_OK,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        MAX_EMS_TEXT_ALIGNMENT_MENU_ITEMS,
        EMS_text_alignment_menu_items,
        h,
        guiBuffer);
    SetLeftSoftkeyFunction(HandleEMSNewParagraphAlignmentMenuLSK, KEY_EVENT_UP);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetExitHandler(EMS_TEXT_ALIGNMENT_SELECTION_MENU_SCREEN_ID, ExitEMSTextAlignmentSelectionMenu);
}


/*****************************************************************************
 * FUNCTION
 *  ExitEMSNewParagraphAlignmentMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitEMSNewParagraphAlignmentMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    h.scrnID = EMS_TEXT_ALIGNMENT_SELECTION_MENU_SCREEN_ID;
    h.entryFuncPtr = EntryEMSTextAlignmentSelectionMenu;
    h.inputBuffer[0] = '\0';
    GetCategoryHistory(h.guiBuffer);
    AddHistory(h);
}
#endif /* (EMS_USE_INTERNAL_MENU) */ /* __MMI_MESSAGES_EMS__ */
#endif /* __MMI_MESSAGES_EMS__ */ /* UI_DISABLE_EMS_INPUT_BOX */

/* EMS input box history related functions   */



extern U8 history_valid(U16 history_ID, U16 category_screen_ID);


/*****************************************************************************
 * FUNCTION
 *  get_EMS_inputbox_category_history
 * DESCRIPTION
 *  
 * PARAMETERS
 *  history_ID          [IN]        
 *  history_buffer      [?]         
 *  input_type          [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void get_EMS_inputbox_category_history(U16 history_ID, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        U16 hID = (U16) (history_ID | 0x8000);
        EMS_inputbox_category_history *h = (EMS_inputbox_category_history*) history_buffer;

        h->history_ID = hID;
        h->cursor_ax = (S16) MMI_EMS_inputbox.cursor_ax;
        h->cursor_ay = (S16) MMI_EMS_inputbox.cursor_ay;
        h->cursor_line_height = (S16) MMI_EMS_inputbox.cursor_line_height;
        h->display_y = (S16) MMI_EMS_inputbox.display_y;
    #ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
        h->current_hilite_idx = MMI_EMS_inputbox.current_hilite_idx;
    #endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
        mmi_imc_get_input_method_history(&(h->ime_history));
        
        h->UCS2_count = (S16) MMI_EMS_inputbox.UCS2_count;
        if (MMI_EMS_inputbox.data != NULL 
            && (MMI_EMS_inputbox.flags & UI_EMS_INPUT_BOX_VIEW_MODE))
        {
            h->text_offset = (S16) MMI_EMS_inputbox.data->CurrentPosition.OffsetToText;
        }

		if (mmi_imc_is_multitap_state(h->ime_history.state))
		{
			h->input_mode_text_offset = MMI_EMS_inputbox.input_mode_position.OffsetToText;
		}

    #if defined(__MMI_VIRTUAL_KEYBOARD__)
        //W05.32 Virtual Keyboard History Issue
        //W05.41 Do not Strore Virtual Keyboard into History when View Mode
        if (MMI_EMS_inputbox.flags & UI_EMS_INPUT_BOX_VIEW_MODE)
        {
            h->ime_history.vk_type = GUI_VIRTUAL_KEYBOARD_EMPTY_TRAY;
        }
    #endif /* defined(__MMI_VIRTUAL_KEYBOARD__) */ 
    }
}


/*****************************************************************************
 * FUNCTION
 *  set_EMS_inputbox_category_history
 * DESCRIPTION
 *  
 * PARAMETERS
 *  history_ID          [IN]        
 *  history_buffer      [?]         
 *  input_type          [?]         
 * RETURNS
 *  
 *****************************************************************************/
U8 set_EMS_inputbox_category_history(U16 history_ID, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (history_buffer != NULL)
    {
        EMS_inputbox_category_history *h = (EMS_inputbox_category_history*) history_buffer;

        if (history_valid(h->history_ID, history_ID))
        {
            MMI_EMS_inputbox.cursor_ax = h->cursor_ax;
            MMI_EMS_inputbox.cursor_ay = h->cursor_ay;
            MMI_EMS_inputbox.cursor_line_height = h->cursor_line_height;
            MMI_EMS_inputbox.display_y = h->display_y;
            MMI_EMS_inputbox.UCS2_count = h->UCS2_count;
        #ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
            MMI_EMS_inputbox.current_hilite_idx = h->current_hilite_idx;
        #endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */
            if (MMI_EMS_inputbox.data != NULL && 
                (MMI_EMS_inputbox.flags & UI_EMS_INPUT_BOX_VIEW_MODE))
            {
                MMI_EMS_inputbox.data->CurrentPosition.OffsetToText = h->text_offset;
            }
            
			if (mmi_imc_is_multitap_state(h->ime_history.state))
			{
				MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_INPUT_METHOD_MODE;
				MMI_EMS_inputbox.input_mode_position.OffsetToText = h->input_mode_text_offset;
                MMI_EMS_inputbox.input_mode_position.Object = NULL;
			}

            return (1);
        }
    }
    return (0);
}

#endif /* (!UI_DISABLE_EMS_INPUT_BOX) */ /* UI_DISABLE_EMS_CATEGORY_SCREENS  */


S32 wgui_EMS_inputbox_information_bar_x;
S32 wgui_EMS_inputbox_information_bar_y;
S32 wgui_EMS_inputbox_information_bar_width;
S32 wgui_EMS_inputbox_information_bar_height;
U8 wgui_EMS_inputbox_information_flag = 0;
PU8 wgui_EMS_inputbox_information_icon = NULL;


/*****************************************************************************
 * FUNCTION
 *  wgui_EMS_setup_input_information
 * DESCRIPTION
 *  
 * PARAMETERS
 *  x           [IN]        
 *  y           [IN]        
 *  width       [IN]        
 *  height      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_EMS_setup_input_information(S32 x, S32 y, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_EMS_inputbox_information_bar_x = x;
    wgui_EMS_inputbox_information_bar_y = y;
    wgui_EMS_inputbox_information_bar_width = width;
    wgui_EMS_inputbox_information_bar_height = height;
}



/*****************************************************************************
 * FUNCTION
 *  wgui_EMS_reset_input_information
 * DESCRIPTION
 *  Reset EMS inputbox information bar param
 * PARAMETERS
 *  x           [IN]        
 *  y           [IN]        
 *  width       [IN]        
 *  height      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_EMS_reset_input_information(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_EMS_inputbox_information_bar_x = 0;
    wgui_EMS_inputbox_information_bar_y = 0;
    wgui_EMS_inputbox_information_bar_width = 0;
    wgui_EMS_inputbox_information_bar_height = 0;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_EMS_input_information_background
 * DESCRIPTION
 *  
 * PARAMETERS
 *  x1      [IN]        
 *  y1      [IN]        
 *  x2      [IN]        
 *  y2      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_EMS_input_information_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /* Now reads color from the theme structure  */
    color c = current_information_bar_theme->background_color;
    U32 alpha = ((U32) current_information_bar_theme->background_alpha) * 255 / 100;
	gdi_handle act_layer, src_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_reset_clip();

    gdi_layer_get_active(&act_layer);
    gdi_get_alpha_blending_source_layer(&src_layer);

    if ((act_layer != src_layer) && src_layer)
    {
        gdi_effect_alpha_blending_rect(src_layer, x1, y1, x2, y2, alpha, c.r, c.g, c.b);
    }
    else if (act_layer)
    {
        gdi_effect_alpha_blending_rect(act_layer, x1, y1, x2, y2, 255, c.r, c.g, c.b);
    }

    gui_pop_clip();
}


#if defined(__MMI_TOUCH_SCREEN__)
extern UI_filled_area information_bar_BG_filler;
#endif 

#ifdef __OP01_FWPBW__

/*****************************************************************************
 * FUNCTION
 *  wgui_EMS_redraw_remaining_characters_display
 * DESCRIPTION
 *  in 128X64 project, the remaining counter is display on CSK
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_EMS_redraw_remaining_characters_display(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w, h, n, max_n;
    UI_character_type str[32];
    S32 csk_x, csk_y, csk_width, csk_height;
    S32 text_x, text_y;
    S32 str_width, str_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* reassign MMI_EMS_inputbox.available_length because it might be one byte difference per segment for EMS 5.1 */
    gui_EMS_change_DCS(&MMI_EMS_inputbox);

#ifdef __MMI_MESSAGES_EMS_REMAINING_COUNTER__
    n = EMS_get_last_segment_remaining_char(&MMI_EMS_inputbox);
    max_n = EMS_get_required_segment(&MMI_EMS_inputbox);
#else /*__MMI_MESSAGES_EMS_REMAINING_COUNTER__*/
    n = MMI_EMS_inputbox.available_length - EMS_get_remaining_length(MMI_EMS_inputbox.data);
    if (MMI_EMS_inputbox.UCS2_count > 0)
    {
        n = MMI_EMS_inputbox.available_length - (EMS_get_remaining_length(MMI_EMS_inputbox.data) >> 1);
    }
    else if (MMI_EMS_inputbox.GSM_ext_count > 0)
    {
        n = MMI_EMS_inputbox.available_length - EMS_get_remaining_length(MMI_EMS_inputbox.data);
    }
    max_n = MMI_EMS_inputbox.available_length;
#endif /*__MMI_MESSAGES_EMS_REMAINING_COUNTER__*/

    g_wgui_inputs_remaining_characters_str[0] = 0;
    gui_sprintf(g_wgui_inputs_remaining_characters_str, "%d/%d", n, max_n);

    // show remaining counter on csk
    wgui_softkey_get_position(MMI_CENTER_SOFTKEY, &csk_x, &csk_y);
    wgui_softkey_get_dimension(MMI_CENTER_SOFTKEY, &csk_width, &csk_height);
    gui_push_clip();
    gui_set_clip(csk_x, csk_y, csk_x + csk_width - 1, csk_y + csk_height - 1);
    // clear background
    gui_fill_rectangle(csk_x, csk_y, csk_x + csk_width - 1, csk_y + csk_height - 1, gui_color(255, 255, 255));

    // show text
    gui_set_font(&MMI_small_font);
    gui_measure_string(g_wgui_inputs_remaining_characters_str, &str_width, &str_height);
    str_width = str_width + 2; /* 2 is border width */
    text_x = csk_x + ((csk_width - str_width)>>1);
    text_y = csk_y + ((csk_height - str_height)>>1);
    gui_set_text_color(gui_color(0, 0, 0));
    gui_move_text_cursor(text_x, text_y);
    gui_print_text(g_wgui_inputs_remaining_characters_str);
    gui_pop_clip();

    // start time to display the input method
    gui_start_timer(1000, wgui_inputs_show_current_input_method_timer_handler);

    gui_BLT_double_buffer(csk_x, csk_y, csk_x + csk_width - 1, csk_y + csk_height - 1);
}

#else

/*****************************************************************************
 * FUNCTION
 *  wgui_EMS_redraw_remaining_characters_display
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_EMS_redraw_remaining_characters_display(void)
{
#ifndef __MMI_HIDE_EMS_REMAINING_CHAR__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    color c;

    /* MTK Elvis for R2L characters */
    S32 x1;
    S32 x2;
    S32 y1 = wgui_EMS_inputbox_information_bar_y;
    S32 y2 = wgui_EMS_inputbox_information_bar_y + wgui_EMS_inputbox_information_bar_height - 1;

    /* MTK end */
#if !defined(__MMI_TOUCH_SCREEN__)
    stFontAttribute *f = &MMI_small_font;
#else /* !defined(__MMI_TOUCH_SCREEN__) */ 
    stFontAttribute *f = &MMI_medium_font;
#endif /* !defined(__MMI_TOUCH_SCREEN__) */
    S32 w, h, n, max_n;
    UI_character_type str[32];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Return if information bar with is zero. Eg: In clipboard mode EMS viewer screen, it should not display counter */
    if (wgui_EMS_inputbox_information_bar_width == 0)
    {
        return;
    }
    /* MTK Elvis for R2L characters */
    if (!r2lMMIFlag)
    {
        x1 = wgui_EMS_inputbox_information_bar_x + (wgui_EMS_inputbox_information_bar_width >> 1);
        x2 = wgui_EMS_inputbox_information_bar_x + wgui_EMS_inputbox_information_bar_width - 1;

    }
    else
    {
        x1 = wgui_EMS_inputbox_information_bar_x;
        x2 = wgui_EMS_inputbox_information_bar_x + (wgui_EMS_inputbox_information_bar_width / 2) - 1;

    }
    /* MTK end */

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 
#if(UI_DISABLE_EMS_INPUT_BOX)
#ifdef __UCS2_ENCODING
    n = (MMI_multiline_inputbox.text_length >> 1) - 1;
    if (MMI_multiline_inputbox.UCS2_count > 0)
    {
        max_n = 268;
    }
    else
    {
        max_n = 612;
    }
#endif /* __UCS2_ENCODING */ 
#ifdef __ASCII
    n = MMI_multiline_inputbox.text_length - 1;
    if (MMI_multiline_inputbox.UCS2_count > 0)
    {
        max_n = 268;
    }
    else
    {
        max_n = 612;
    }
#endif /* __ASCII */ 
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    /* reassign MMI_EMS_inputbox.available_length because it might be one byte difference per segment for EMS 5.1 */
    gui_EMS_change_DCS(&MMI_EMS_inputbox);

/* Mude Lin(MBJ06016) Add For SMS Remaining Count Display In EMS Editor*/
#ifdef __MMI_MESSAGES_EMS_REMAINING_COUNTER__
    n = EMS_get_last_segment_remaining_char(&MMI_EMS_inputbox);
    max_n = EMS_get_required_segment(&MMI_EMS_inputbox);
#else /*__MMI_MESSAGES_EMS_REMAINING_COUNTER__*/
/*End Mude Lin(MBJ06016) Add*/
    n = MMI_EMS_inputbox.available_length - EMS_get_remaining_length(MMI_EMS_inputbox.data);
    if (MMI_EMS_inputbox.UCS2_count > 0)
    {
        n = MMI_EMS_inputbox.available_length - (EMS_get_remaining_length(MMI_EMS_inputbox.data) >> 1);
    }
    else if (MMI_EMS_inputbox.GSM_ext_count > 0)
    {
        n = MMI_EMS_inputbox.available_length - EMS_get_remaining_length(MMI_EMS_inputbox.data);
    }
    max_n = MMI_EMS_inputbox.available_length;
#endif /*__MMI_MESSAGES_EMS_REMAINING_COUNTER__*/
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    wgui_EMS_input_information_background(x1, y1, x2, y2);
    gui_reset_text_clip();
    gui_sprintf(str, "%d/%d", n, max_n);
    c = *current_MMI_theme->remaining_length_text_color;
    gui_set_font(f);
    gui_set_text_color(c);
    gui_set_text_clip(0, 0, UI_device_width - 1, UI_device_height - 1);

    gui_measure_string(str, &w, &h);

    /* MTK Elvis for R2L characters */
    if (!r2lMMIFlag)
    {
        gui_move_text_cursor(x2 - 2 - w, y1 + (wgui_inputbox_information_bar_height - h) / 2);
    }
    else
    {
        gui_move_text_cursor(x1 + 2 + w, y1 + (wgui_inputbox_information_bar_height - h) / 2);
    }
    /* MTK end */
    gui_print_text(str);
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1, x2, y2);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */ 
#endif /* __MMI_HIDE_EMS_REMAINING_CHAR__ */ 
}

#endif

/*****************************************************************************
 * FUNCTION
 *  wgui_EMS_redraw_input_information_bar
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_EMS_redraw_input_information_bar(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1 = wgui_EMS_inputbox_information_bar_x;
    S32 y1 = wgui_EMS_inputbox_information_bar_y;
    S32 x2 = wgui_EMS_inputbox_information_bar_x + wgui_EMS_inputbox_information_bar_width - 1;
    S32 y2 = wgui_EMS_inputbox_information_bar_y + wgui_EMS_inputbox_information_bar_height - 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();
    wgui_EMS_input_information_background(x1, y1, x2, y2);
    wgui_show_input_mode_internal(wgui_EMS_inputbox_information_bar_x, 
                                                        wgui_EMS_inputbox_information_bar_y,
                                                        wgui_EMS_inputbox_information_bar_width, 
                                                        wgui_EMS_inputbox_information_bar_height, 
                                                        mmi_imm_get_curr_input_mode(), 
                                                        wgui_EMS_inputbox_information_icon);
    wgui_EMS_redraw_remaining_characters_display();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1, x2, y2);
}





#if(EMS_USE_STUB_MENU)


/*****************************************************************************
 * FUNCTION
 *  EntryEMSEditOptionsMenu
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EntryEMSEditOptionsMenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}

#endif /* (EMS_USE_STUB_MENU) */ 


/*****************************************************************************
 * FUNCTION
 *  temp_ems_insert_character
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void temp_ems_insert_character(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_character_type symbol = 0xabc;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(!UI_DISABLE_EMS_INPUT_BOX)
    EMS_inputbox_direct_input(symbol);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  AppendEMSString
 * DESCRIPTION
 *  
 * PARAMETERS
 *  input_type          [IN]        
 *  data                [?]         
 *  s                   [?]         
 *  dcs                 [IN]        
 *  history_buffer      [?]         
 * RETURNS
 *  
 *****************************************************************************/
U8 AppendEMSString(U32 input_type, EMSData *data, U8 *s, U8 dcs, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l, box_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    l = gui_strlen((UI_string_type) s);
    box_height = MMI_content_height - MMI_multitap_height - 10;
    gui_create_EMS_input_box(&MMI_EMS_inputbox, 0, (MMI_title_y + MMI_title_height) + 12, UI_device_width, box_height);
    gui_set_EMS_input_box_data(&MMI_EMS_inputbox, data);
    EMSSetDCS(MMI_EMS_inputbox.data, dcs);

    if (AddString(MMI_EMS_inputbox.data, s, (U16) l, NULL) == EMS_OK)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  move_EMS_inputbox
 * DESCRIPTION
 *  
 * PARAMETERS
 *  x       [IN]        
 *  y       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void move_EMS_inputbox(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_move_EMS_input_box(&MMI_EMS_inputbox, x, y);
}


/*****************************************************************************
 * FUNCTION
 *  resize_EMS_inputbox
 * DESCRIPTION
 *  
 * PARAMETERS
 *  width       [IN]        
 *  height      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void resize_EMS_inputbox(S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_resize_EMS_input_box(&MMI_EMS_inputbox, width, height);
}



extern U8 category28_RSK_label_clear;

/*****************************************************************************
 * FUNCTION
 *  wgui_set_EMS_inputbox_RSK
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_set_EMS_inputbox_RSK(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    category28_RSK_label_clear = 0;
    if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
    {
        SetKeyHandler(handle_category28_right_softkey_down, KEY_CLEAR, KEY_EVENT_DOWN);
        SetKeyHandler(handle_category28_right_softkey_long_press, KEY_CLEAR, KEY_LONG_PRESS);
        set_right_softkey_function(handle_category28_right_softkey_up, KEY_EVENT_UP);
    }
    else
    {
        set_right_softkey_function(handle_category28_right_softkey_down, KEY_EVENT_DOWN);
        set_right_softkey_function(handle_category28_right_softkey_long_press, KEY_LONG_PRESS);
    }
    register_EMS_inputbox_input_callback(handle_category28_input);
    handle_category28_input();
    if (gui_EMS_inputbox_empty(&MMI_EMS_inputbox))
    {
        if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
        {
            SetKeyHandler(UI_dummy_function, KEY_CLEAR, KEY_EVENT_UP);
            SetKeyHandler(UI_dummy_function, KEY_CLEAR, KEY_EVENT_LONG_PRESS);
            SetKeyHandler(handle_category28_right_softkey_down, KEY_CLEAR, KEY_EVENT_DOWN);
        }
        else
        {
            set_right_softkey_function(register_category28_handle_right_softkey_up, KEY_EVENT_DOWN);
            set_right_softkey_function(UI_dummy_function, KEY_EVENT_LONG_PRESS);
        }
    }

}

#ifdef __OP01_FWPBW__
/*****************************************************************************
 * FUNCTION
 *  wgui_set_EMS_inputbox_RSK_no_show_counter
 * DESCRIPTION
 *  Do not show counter in handle input
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_set_EMS_inputbox_RSK_no_show_counter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    category28_RSK_label_clear = 0;
    if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
    {
        SetKeyHandler(handle_category28_right_softkey_down, KEY_CLEAR, KEY_EVENT_DOWN);
        SetKeyHandler(handle_category28_right_softkey_long_press, KEY_CLEAR, KEY_LONG_PRESS);
        set_right_softkey_function(handle_category28_right_softkey_up, KEY_EVENT_UP);
    }
    else
    {
        set_right_softkey_function(handle_category28_right_softkey_down, KEY_EVENT_DOWN);
        set_right_softkey_function(handle_category28_right_softkey_long_press, KEY_LONG_PRESS);
    }
    register_EMS_inputbox_input_callback(handle_category28_input);

    handle_category28_input_no_show_counter();

    if (gui_EMS_inputbox_empty(&MMI_EMS_inputbox))
    {
        if (mmi_frm_kbd_is_key_supported(KEY_CLEAR))
        {
            SetKeyHandler(UI_dummy_function, KEY_CLEAR, KEY_EVENT_UP);
            SetKeyHandler(UI_dummy_function, KEY_CLEAR, KEY_EVENT_LONG_PRESS);
        }
        else
        {
            set_right_softkey_function(register_category28_handle_right_softkey_up, KEY_EVENT_DOWN);
            set_right_softkey_function(UI_dummy_function, KEY_EVENT_LONG_PRESS);
        } 
    }

}
#endif

#if(ENABLE_EMS_TEST_DEMO)
/* Removed by Leo useless code..... */


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory29Screen
 * DESCRIPTION
 *  Redraws the MT EMS/SMS screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory29Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    clear_screen();
    show_title_status_icon();
    draw_title();
    show_softkey_background();
    show_left_softkey();
    show_right_softkey();
#if(UI_DISABLE_EMS_INPUT_BOX)
    show_multiline_inputbox();
#else 
    show_EMS_inputbox();
#endif 
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory29Screen
 * DESCRIPTION
 *  Displays the MT EMS/SMS screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  data                    [IN]        EMSData (Pre-allocated and initialized)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory29Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        EMSData *data,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

#if(UI_DISABLE_EMS_INPUT_BOX)
    S32 length;
    S32 i, j, h, fh;

    UI_UNUSED_PARAMETER(history_buffer);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    U8 h;
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMS_inputbox_has_changed = 0;
#ifdef __MMI_MESSAGES_EMS__
    initialize_EMS_objects();
#endif 
    wgui_title_set_menu_shortcut_number(-1);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);

#if(UI_DISABLE_EMS_INPUT_BOX)
    length = (data->textBufferSize >> 1);
    if (length == 0)
    {
        UI_string_type s = (UI_string_type) "EMS Data not initialized";
        S32 l = gui_strlen((UI_string_type) s);

        temp_EMS_buffer = (UI_string_type) gui_malloc(l * sizeof(UI_character_type));
        gui_strcpy((UI_string_type) temp_EMS_buffer, (UI_string_type) s);
        length = l + 1;
        i = l;
    }
    else
    {
        temp_EMS_buffer = (UI_string_type) gui_malloc(length * sizeof(UI_character_type));
        i = j = 0;
        while (j < data->textLength)
        {
            if ((data->textBuffer[j] == '\0') && (data->textBuffer[j + 1] == '\0'))
            {
                temp_EMS_buffer[i] = '\0';
                break;
            }
            else
            {
                temp_EMS_buffer[i] = data->textBuffer[j + 1];
            }
            i++;
            j += 2;
        }
    }
    temp_EMS_data = data;
    create_multiline_inputbox_set_buffer(temp_EMS_buffer, length, i, 0);
    register_multiline_inputbox_keys();
    move_multiline_inputbox(0, (MMI_title_y + MMI_title_height) + 2);
    h = MMI_content_height - MMI_multitap_height - 8;
    gui_set_font(MMI_multiline_inputbox.text_font);
    fh = gui_get_character_height();
    h = ((h / fh) * fh) + 8;
    resize_multiline_inputbox(MMI_multiline_inputbox.width, h);
    set_multiline_inputbox_mask(0);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
#if((UI_ENABLE_FRAME_SKIPPING) && (ENABLE_EMS_INPUTBOX_FRAME_SKIPPING))
    wgui_EMS_inputbox_frame_counter = 0;
#endif 
    h = set_EMS_inputbox_category_history(MMI_CATEGORY29_ID, history_buffer);
    gui_create_EMS_input_box(
        &MMI_EMS_inputbox,
        0,
        (MMI_title_y + MMI_title_height),
        MMI_content_width,
        MMI_content_height + 2);
    MMI_EMS_inputbox.flags |= UI_EMS_INPUT_BOX_VIEW_MODE;
    if (!h)
    {
        gui_set_EMS_input_box_data(&MMI_EMS_inputbox, data);
        ResetCurrentPosition(MMI_EMS_inputbox.data);
    }
    register_EMS_inputbox_viewer_keys();
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    ExitCategoryFunction = ExitCategory29Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory29History, GetCategory29HistorySize);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY29_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  CloseCategory29Screen
 * DESCRIPTION
 *  Releases data used by the MT EMS/SMS screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void CloseCategory29Screen(void)
{
#if(UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 length;
    S32 i, j;
    U8 *buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    length = MMI_multiline_inputbox.text_length;
    buffer = (U8*) gui_malloc((length << 1) + 2);
    i = j = 0;
    ResetCurrentPosition(temp_EMS_data);
    while (i < length)
    {
        buffer[j++] = 0;
        buffer[j++] = (U8) temp_EMS_buffer[i++];
    }
    buffer[j++] = 0;
    buffer[j++] = '\0';
    AddString(temp_EMS_data, buffer, (U16) length, NULL);
    gui_free(buffer);
    gui_free(temp_EMS_buffer);
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory29Screen
 * DESCRIPTION
 *  Exits the MT EMS/SMS screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory29Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(!UI_DISABLE_EMS_INPUT_BOX)
    reset_EMS_inputbox();
#endif 
#ifdef __MMI_MESSAGES_EMS__
    close_EMS_objects();
#endif 
    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory29HistorySize
 * DESCRIPTION
 *  Gets the history buffer size for the MT EMS/SMS screen
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
S32 GetCategory29HistorySize(void)
{
#if(UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (0);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    return (sizeof(EMS_inputbox_category_history));
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 

}


/*****************************************************************************
 * FUNCTION
 *  GetCategory29History
 * DESCRIPTION
 *  Gets the history buffer for the MT EMS/SMS screen
 * PARAMETERS
 *  history_buffer      [IN]        Is the buffer into which the history data is stored (pre-allocated)
 * RETURNS
 *  pointer to the history buffer
 *****************************************************************************/
U8 *GetCategory29History(U8 *history_buffer)
{
#if(UI_DISABLE_EMS_INPUT_BOX)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (history_buffer);
#else /* (UI_DISABLE_EMS_INPUT_BOX) */ 
    get_EMS_inputbox_category_history(MMI_CATEGORY28_ID, history_buffer);
    return (history_buffer);
#endif /* (UI_DISABLE_EMS_INPUT_BOX) */ 
}
#endif /* (ENABLE_EMS_TEST_DEMO) */ 

/* If EMS_VIEWER_HEADER_HEIGHT_AUTO is 1, then EMS_VIEWER_HEADER_HEIGHT defines
   the maximum possible height for the header. Otherwise, it defines the fixed
   height of the header */

#define EMS_VIEWER_HEADER_HEIGHT          48
#define EMS_VIEWER_HEADER_HEIGHT_AUTO        1

/* If 1, uses multiline input box to display the header (word wrapping, no truncation),
   else uses normal text output (no word wrapping, truncation for lines longer than screen width)     */

#define EMS_VIEWER_HEADER_MULTILINE_INPUTBOX 0

UI_filled_area EMS_viewer_header_background_filler = {UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {180, 220, 220, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    0
};

#if(EMS_VIEWER_HEADER_MULTILINE_INPUTBOX)

multi_line_input_box EMS_viewer_header_inputbox;

UI_multi_line_input_box_theme EMS_viewer_header_theme = { &EMS_viewer_header_background_filler,
    &EMS_viewer_header_background_filler,
    &EMS_viewer_header_background_filler,
    {0, 0, 0, 100},
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    &MMI_default_font,
    1,
    0,
    '*',
    1
};

/* EMS header implementation using multi-line input box  */


/*****************************************************************************
 * FUNCTION
 *  create_EMS_viewer_header
 * DESCRIPTION
 *  
 * PARAMETERS
 *  message     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void create_EMS_viewer_header(U8 *message)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l, ll;

#if(EMS_VIEWER_HEADER_HEIGHT_AUTO)
    S32 fh, n_lines, h;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    l = gui_strlen((UI_string_type) message);
    ll = (l + 1) * ENCODING_LENGTH;
    gui_create_multi_line_input_box_set_buffer(
        &EMS_viewer_header_inputbox,
        0,
        0,
        MMI_EMS_inputbox.width - MMI_EMS_inputbox.vbar.width,
        EMS_VIEWER_HEADER_HEIGHT,
        (UI_string_type) message,
        ll,
        ll,
        0);
    gui_set_multi_line_input_box_theme(&EMS_viewer_header_inputbox, &EMS_viewer_header_theme);
    EMS_viewer_header_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR |
         UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW);
#if(EMS_VIEWER_HEADER_HEIGHT_AUTO)
    gui_set_font(EMS_viewer_header_inputbox.text_font);
    fh = gui_get_character_height();
    EMS_viewer_header_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW;
    gui_show_multi_line_input_box(&EMS_viewer_header_inputbox);
    EMS_viewer_header_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW;
    n_lines = EMS_viewer_header_inputbox.n_lines;
    if (n_lines > 3)
    {
        n_lines = 3;
    }
    h = n_lines * fh + 6;
    if (h > EMS_VIEWER_HEADER_HEIGHT)
    {
        h = EMS_VIEWER_HEADER_HEIGHT;
    }
    gui_resize_multi_line_input_box(&EMS_viewer_header_inputbox, EMS_viewer_header_inputbox.width, h);
#endif /* (EMS_VIEWER_HEADER_HEIGHT_AUTO) */ 
}


/*****************************************************************************
 * FUNCTION
 *  EMS_viewer_show_header
 * DESCRIPTION
 *  
 * PARAMETERS
 *  x1      [IN]        
 *  y1      [IN]        
 *  x2      [IN]        
 *  y2      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_viewer_show_header(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ex1, ey1, ex2, ey2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ex1 = MMI_EMS_inputbox.x + 1;
    ex2 = ex1 + MMI_EMS_inputbox.width - 2;
    ey1 = MMI_EMS_inputbox.y + 1;
    ey2 = ey1 + MMI_EMS_inputbox.height - 2;
    gui_set_text_clip(ex1, ey1, ex2, ey2);
    gui_set_clip(ex1, ey1, ex2, ey2);
    gui_move_multi_line_input_box(&EMS_viewer_header_inputbox, x1, y1);
    gui_show_multi_line_input_box(&EMS_viewer_header_inputbox);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_viewer_measure_header
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_viewer_measure_header(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (EMS_viewer_header_inputbox.height);
}

#else /* (EMS_VIEWER_HEADER_MULTILINE_INPUTBOX) */ 

/* EMS header implementation using normal text output          */
/* Requires message to contain line breaks where ever necessary   */

#define EMS_VIEWER_HEADER_MAX_LINES          4
#define EMS_VIEWER_HEADER_MAX_LINE_LENGTH    60 * ENCODING_LENGTH

U8 EMS_header_text_strings[EMS_VIEWER_HEADER_MAX_LINES][EMS_VIEWER_HEADER_MAX_LINE_LENGTH];
S32 EMS_header_text_string_heights[EMS_VIEWER_HEADER_MAX_LINES];
S32 EMS_header_height = 0;
S32 EMS_header_n_lines = 0;

/* Returns true when end of string is reached   */
/* loads \n delimited strings             */
/*****************************************************************************
 * FUNCTION
 *  load_EMS_viewer_header_string
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src                 [IN]        
 *  dst                 [IN]        
 *  max_dst_length      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
U8 load_EMS_viewer_header_string(U8 **src, U8 **dst, S32 max_dst_length)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_buffer_type text = *src;
    UI_buffer_type out_text = *dst;
    U8 inner_done = 0;
    S32 j = 0;
    U8 done = 0;
    UI_character_type c;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while (!inner_done)
    {
        if (j >= (max_dst_length - ENCODING_LENGTH))
        {
            break;
        }
        UI_STRING_GET_NEXT_CHARACTER(text, c);
        if (UI_STRING_LINE_BREAK_CHARACTER(c))
        {
            inner_done = 1;
            break;
        }
        if (UI_STRING_END_OF_STRING_CHARACTER(c))
        {
            inner_done = 1;
            done = 1;
            break;
        }
        UI_STRING_INSERT_CHARACTER(out_text, c);
        j += ENCODING_LENGTH;
    }
    UI_STRING_INSERT_CHARACTER(out_text, '\0');
    while (!inner_done)
    {
        UI_STRING_GET_NEXT_CHARACTER(text, c);
        if (UI_STRING_LINE_BREAK_CHARACTER(c))
        {
            inner_done = 1;
            break;
        }
        if (UI_STRING_END_OF_STRING_CHARACTER(c))
        {
            inner_done = 1;
            done = 1;
            break;
        }
    }
    *src = text;
    *dst = out_text;
    return (done);
}

#define UI_EMS_HEADER_NUMBER_OF_BREAK_CHARACTERS      (1)

UI_character_type EMS_header_break_characters[] = { ' '
};

#define UI_EMS_HEADER_BREAK_CHARACTER(c,flag)                                                   \
{  S32 _ii_;                                                                                    \
   flag=0;                                                                                      \
   for(_ii_=0;_ii_<UI_EMS_HEADER_NUMBER_OF_BREAK_CHARACTERS;_ii_++)                             \
   {  if((UI_character_type)c==(UI_character_type)EMS_header_break_characters[_ii_])            \
      {  flag=1;                                                                                \
         break;                                                                                 \
      }                                                                                         \
   }                                                                                            \
}

/* Assumes the following format:
   From:\n
   Name/number\n
   Date\n
   Time\n
   Attempts to combine first two lines */


/*****************************************************************************
 * FUNCTION
 *  create_EMS_viewer_header
 * DESCRIPTION
 *  
 * PARAMETERS
 *  message     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void create_EMS_viewer_header(U8 *message)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 done = 0;
    U8 inner_done;
    S32 i, j;/* slim_2_2 */ //
    UI_buffer_type text = message;
    UI_buffer_type out_text;
    S32 sw, sh, break_count;
    UI_character_type c;
    S32 l1_w, l1_h, l2_w, l2_h;
    U8 temp_string[EMS_VIEWER_HEADER_MAX_LINE_LENGTH];

    /* U8             space_string[]={' ',0,'\0',0};   */
    /* U8             blank_string[]={'\0',0};      */
    S32 character_width, character_height;
    S32 box_width = (MMI_EMS_inputbox.width - MMI_EMS_inputbox.vbar.width - 2);
    UI_buffer_type temp_text1, temp_text2;
    U8 break_flag;
    U16 name_number_len = 0;
#ifdef __MMI_VECTOR_FONT_SUPPORT__
    mmi_fe_glyph_metrics_struct matrix;
#endif /* __MMI_VECTOR_FONT_SUPPORT__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_font(&MMI_default_font);
    EMS_header_n_lines = 0;
    EMS_header_height = 0;
    out_text = (UI_buffer_type) EMS_header_text_strings[EMS_header_n_lines];
    /* "From:"  */
    done = load_EMS_viewer_header_string(&text, &out_text, EMS_VIEWER_HEADER_MAX_LINE_LENGTH);
    gui_measure_string((UI_string_type) EMS_header_text_strings[EMS_header_n_lines], &l1_w, &l1_h);
    l1_h++;
    EMS_header_height += l1_h;
    EMS_header_text_string_heights[EMS_header_n_lines] = l1_h;
    /* "Name/number"  */
    if (!done)
    {
        out_text = (UI_buffer_type) temp_string;
        done = load_EMS_viewer_header_string(&text, &out_text, EMS_VIEWER_HEADER_MAX_LINE_LENGTH);
        gui_measure_string((UI_string_type) temp_string, &l2_w, &l2_h);
        name_number_len = mmi_ucs2strlen((CHAR*) temp_string);
        if ((l2_w <= box_width) && (name_number_len < EMS_VIEWER_HEADER_MAX_LINE_LENGTH / ENCODING_LENGTH))
        {
            EMS_header_n_lines++;
            gui_strcpy((UI_string_type) EMS_header_text_strings[EMS_header_n_lines], (UI_string_type) temp_string);
            gui_measure_string((UI_string_type) EMS_header_text_strings[EMS_header_n_lines], &sw, &sh);
            sh++;
            EMS_header_height += sh;
            EMS_header_text_string_heights[EMS_header_n_lines] = sh;
            EMS_header_n_lines++;
        }
        else    /* break "Name/number" into two lines  */
        {
            out_text = (UI_buffer_type) temp_string;
            break_count = 0;
            inner_done = 0;
            sw = l1_w;
            j = 0;
            while (!inner_done)
            {
                UI_STRING_GET_NEXT_CHARACTER(out_text, c);
                if (UI_STRING_END_OF_STRING_CHARACTER(c))
                {
                    break_count = j;
                    inner_done = 1;
                    done = 1;
                    break;
                }
                UI_EMS_HEADER_BREAK_CHARACTER(c, break_flag);
                if (break_flag)
                {
                    break_count = j + 1;
                }
                gui_measure_character(c, &character_width, &character_height);

                /* Space character width in Vector font is zero, we should caculate its actual width */
            #ifdef __MMI_VECTOR_FONT_SUPPORT__
                if ((c == 0x20) && (character_width == 0))
                {
                    GDI_LOCK;
                    mmi_fe_get_glyph_metrics(c, &matrix);
                    character_width += matrix.adv_x;
                    GDI_UNLOCK;
                }
            #endif /* __MMI_VECTOR_FONT_SUPPORT__ */

                character_width += 1;
                if ((sw + character_width) > box_width)
                {
                    inner_done = 1;
                    break;
                }
                sw += character_width;
                j++;
            }
            if (break_count == 0)
            {
                break_count = j;
            }
            temp_text1 = (UI_buffer_type) EMS_header_text_strings[EMS_header_n_lines + 1];
            temp_text2 = (UI_buffer_type) temp_string;
            for (j = 0; j < break_count; j++)
            {
                UI_STRING_GET_NEXT_CHARACTER(temp_text2, c);
                UI_STRING_INSERT_CHARACTER(temp_text1, c);
            }
            UI_STRING_INSERT_CHARACTER(temp_text1, '\0');
            gui_strcat(
                (UI_string_type) EMS_header_text_strings[EMS_header_n_lines],
                (UI_string_type) EMS_header_text_strings[EMS_header_n_lines + 1]);
            inner_done = 0;
            temp_text1 = (UI_buffer_type) EMS_header_text_strings[EMS_header_n_lines + 1];
            while (!inner_done)
            {
                UI_STRING_GET_NEXT_CHARACTER(temp_text2, c);
                if (UI_STRING_END_OF_STRING_CHARACTER(c))
                {
                    inner_done = 1;
                    break;
                }
                if (UI_STRING_LINE_BREAK_CHARACTER(c))
                {
                    inner_done = 1;
                    break;
                }
                UI_STRING_INSERT_CHARACTER(temp_text1, c);
            }
            UI_STRING_INSERT_CHARACTER(temp_text1, '\0');
            gui_measure_string((UI_string_type) EMS_header_text_strings[EMS_header_n_lines], &sw, &sh);
            sh++;
            EMS_header_text_string_heights[EMS_header_n_lines] = sh;
            EMS_header_height -= l1_h;
            EMS_header_height += sh;
            gui_measure_string((UI_string_type) EMS_header_text_strings[EMS_header_n_lines + 1], &sw, &sh);
            sh++;
            EMS_header_text_string_heights[EMS_header_n_lines + 1] = sh;
            EMS_header_height += sh;
            EMS_header_n_lines += 2;
        }
    }
    else
    {
        EMS_header_n_lines++;
    }
    i = 0;
    while (!done && i < 2)
    {
        out_text = (UI_buffer_type) EMS_header_text_strings[EMS_header_n_lines];
        done = load_EMS_viewer_header_string(&text, &out_text, EMS_VIEWER_HEADER_MAX_LINE_LENGTH);
        gui_measure_string((UI_string_type) EMS_header_text_strings[EMS_header_n_lines], &sw, &sh);
        sh++;
        EMS_header_height += sh;
        EMS_header_text_string_heights[EMS_header_n_lines] = sh;
        EMS_header_n_lines++;
        i++;
    }
    #if 0 /* slim_2_2 */ //
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif
    if (EMS_header_height > 0)
    {
        EMS_header_height += 2;
    }
}


/*****************************************************************************
 * FUNCTION
 *  EMS_viewer_show_header
 * DESCRIPTION
 *  
 * PARAMETERS
 *  x1      [IN]        
 *  y1      [IN]        
 *  x2      [IN]        
 *  y2      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_viewer_show_header(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ex1, ey1, ex2, ey2, x, y, xwidth, i;
    S32 top_image_width, top_image_height;
    S32 bottom_image_width, bottom_image_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (EMS_header_height <= 0)
    {
        return;
    }
    ex1 = x1;
    ex2 = x2 - 1;
    gui_push_clip();
    gui_set_font(&MMI_default_font);
#if !defined(__MMI_MAINLCD_128X128__)
    gui_set_text_color(current_header_information_text_theme->text_color);
    gdi_image_get_dimension_id(WGUI_IMG_TEXT_BG_TOP, &top_image_width, &top_image_height);
    gdi_image_get_dimension_id(WGUI_IMG_TEXT_BG_BOTTOM, &bottom_image_width, &bottom_image_height);
    ey1 = y1 - top_image_height - 1;
    ey2 = y2 + bottom_image_height + 1;
    gui_set_clip(ex1, ey1, ex2, ey2);
    DrawTextAreaBackground(ex1, y1 - top_image_height, ex2, y2 + bottom_image_height);
#else
    ey1 = y1 + 1;
    ey2 = y2 - 1;
    gui_set_clip(ex1, ey1, ex2, ey2);
    gui_set_text_color(UI_COLOR_BLACK);
    gui_draw_filled_area(ex1, y1, ex2, y2, &EMS_viewer_header_background_filler);
#endif
    /* MTK Elvis for R2L characters */
    if (r2lMMIFlag)
    {
        x = ex2 - 1;
    }
    else
    {
        x = ex1 + 1;
    }
    /* MTK end */
    y = y1 + 3;
    xwidth = (ex2 - ex1 - 3);
    gui_move_text_cursor(x, y);
    for (i = 0; i < EMS_header_n_lines; i++)
    {
        gui_print_truncated_text(x, y, xwidth, (UI_string_type) EMS_header_text_strings[i]);
        y += EMS_header_text_string_heights[i];
    }
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  EMS_viewer_measure_header
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
S32 EMS_viewer_measure_header(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (EMS_header_height);
}

#endif /* (EMS_VIEWER_HEADER_MULTILINE_INPUTBOX) */ 




#if(ENABLE_EMS_TEST_DEMO)

#define EMS_TEST_DEMO_SCREEN_ID           (MAIN_MENU_BASE+80)
#define EMS_OBJECT_LIST_TEST_SCREEN_ID    (MAIN_MENU_BASE+81)

EMSData EMS_demo_EMS_data;
S32 EMS_demo_object_index;
S32 EMS_demo_n_objects;

void EMS_demo_exit_category28(void);
void EMS_demo_exit_category29(void);
void EMS_demo_exit_object_list(void);
void EMS_demo_enter_object_list(void);
void EMS_demo_exit_object_list2(void);
void EMS_demo_enter_object_list2(void);


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_close_category28
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_close_category28(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory28Screen();
    GoBackHistory();
}

#define EMS_GSM_ASCII_TEST    0
#define EMS_OBJECT_VIEWER_TEST   0


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_category28
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_category28(void)
{
#if(EMS_GSM_ASCII_TEST)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 s[2] = {0, 0};
    S32 i;
#endif /* (EMS_GSM_ASCII_TEST) */ 

    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecuteCurrExitHandler();
    guiBuffer = GetCurrGuiBuffer(EMS_TEST_DEMO_SCREEN_ID);
    if (guiBuffer == NULL)
    {
        InitializeEMSData(&EMS_demo_EMS_data, SMSAL_DEFAULT_DCS);
    }
#if(EMS_GSM_ASCII_TEST)
    for (i = 0; i < 128; i++)
    {
        s[0] = (U8) i;
        AddString(&EMS_demo_EMS_data, s, 1, NULL);
    }
    ResetCurrentPosition(&EMS_demo_EMS_data);
    EMS_ConvertGSM7BitDefaultEncodingToAscii(&EMS_demo_EMS_data);
    EMS_ConvertAsciiEncodingToGSM7BitDefault(&EMS_demo_EMS_data);
    EMS_ConvertGSM7BitDefaultEncodingToAscii(&EMS_demo_EMS_data);
#endif /* (EMS_GSM_ASCII_TEST) */ 

    ShowCategory28Screen(0, 0, STR_GLOBAL_OK, 0, STR_GLOBAL_BACK, 0, &EMS_demo_EMS_data, guiBuffer);
    SetCategory28RightSoftkeyFunction(EMS_demo_close_category28, KEY_EVENT_UP);
    //      SetKeyHandler(EntryInputMethodScreen,KEY_STAR,KEY_EVENT_UP);
    //      RegisterInputMethodScreenCloseFunction(GoBackHistory);
    SetExitHandler(EMS_TEST_DEMO_SCREEN_ID, EMS_demo_exit_category28);
#if(EMS_OBJECT_VIEWER_TEST)
    SetLeftSoftkeyFunction(EMS_demo_enter_object_list2, KEY_EVENT_UP);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_exit_category28
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_exit_category28(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    h.scrnID = EMS_TEST_DEMO_SCREEN_ID;
    h.entryFuncPtr = EMS_demo_category28;
    GetCategoryHistory(h.guiBuffer);
    AddHistory(h);
}

#define EMS_DEMO_HIDE_PREDEFINED_OBJECTS  1

EMSObject *EMS_demo_object_list;


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_enter_object_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_enter_object_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecuteCurrExitHandler();
    guiBuffer = GetCurrGuiBuffer(EMS_OBJECT_LIST_TEST_SCREEN_ID);
    EMS_demo_object_index = 0;
    EMS_demo_n_objects = 0;
#if(EMS_DEMO_HIDE_PREDEFINED_OBJECTS)
    CreateCategory143ObjectList(&EMS_demo_EMS_data, &EMS_demo_object_list);
#else 
    EMS_demo_object_list = EMS_demo_EMS_data.listHead;
#endif 
    ShowCategory143Screen(
        0,
        0,
        0,
        0,
        STR_GLOBAL_BACK,
        0,
        EMS_demo_object_list,
        &EMS_demo_n_objects,
        &EMS_demo_object_index,
        guiBuffer);
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetExitHandler(EMS_OBJECT_LIST_TEST_SCREEN_ID, EMS_demo_exit_object_list);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_exit_object_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_exit_object_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(EMS_DEMO_HIDE_PREDEFINED_OBJECTS)
    FreeCategory143ObjectList(&EMS_demo_object_list);
#endif 
    h.scrnID = EMS_OBJECT_LIST_TEST_SCREEN_ID;
    h.entryFuncPtr = EMS_demo_enter_object_list;
    GetCategoryHistory(h.guiBuffer);
    AddHistory(h);
}

U16 EMS_demo_object_list2[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, };
U8 *EMS_demo_object_list3[10];


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_object_list2_loader
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
U8 *EMS_demo_object_list2_loader(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (EMS_predefined_pictures[index]);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_enter_object_list2
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_enter_object_list2(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecuteCurrExitHandler();
    guiBuffer = GetCurrGuiBuffer(EMS_OBJECT_LIST_TEST_SCREEN_ID);
    EMS_demo_object_index = 0;
    EMS_demo_n_objects = 10;

    RegisterCategory144ObjectLoader(EMS_demo_object_list2_loader);
    ShowCategory144Screen(
        0,
        0,
        STR_GLOBAL_OK,
        0,
        STR_GLOBAL_BACK,
        0,
        /* EMS_PREDEFINED_PICTURE */ 0,
        EMS_demo_n_objects,
        NULL,
        EMS_demo_object_list2,
        EMS_demo_object_list3,
        &EMS_demo_object_index,
        guiBuffer);

    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetExitHandler(EMS_OBJECT_LIST_TEST_SCREEN_ID, EMS_demo_exit_object_list2);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_exit_object_list2
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_exit_object_list2(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    h.scrnID = EMS_OBJECT_LIST_TEST_SCREEN_ID;
    h.entryFuncPtr = EMS_demo_enter_object_list2;
    GetCategoryHistory(h.guiBuffer);
    AddHistory(h);
}

/* Cat29 Demo Entry and Exit functions */

CHAR EMS_demo_test_string[] = 
{
    'S', 0, 'a', 0, 'm', 0, 'p', 0, 'l', 0, 'e', 0, ' ', 0, 'S', 0, 'M', 0, 'S', 0, ' ', 0, 't', 0, 'e', 0, 's', 0, 't',
        0, ' ', 0, 'm', 0, 'e', 0, 's', 0, 's', 0, 'a', 0, 'g', 0, 'e', 0, '.', 0, ' ', 0, '1', 0, '2', 0, '3', 0, '4',
        0, ' ', 0, '5', 0, '6', 0, '7', 0, '8', 0, ' ', 0, '9', 0, '0', 0, '1', 0, '2', 0, ' ', 0, 'A', 0, 'B', 0, 'C',
        0, 'D', 0, ' ', 0, 'e', 0, 'f', 0, 'g', 0, 'h', 0, ' ', 0, 'I', 0, 'J', 0, 'K', 0, 'L', 0, ' ', 0, 'm', 0, 'n',
        0, 'o', 0, 'p', 0, ' ', 0, 'Q', 0, 'R', 0, 'S', 0, 'T', 0, ' ', 0, 'u', 0, 'v', 0, 'w', 0, 'x', 0, ' ', 0, 'Y',
        0, 'Z', 0, '\0', 0
};


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_close_category29
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_close_category29(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory29Screen();
    GoBackHistory();
}


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_category29
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_category29(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecuteCurrExitHandler();
    guiBuffer = GetCurrGuiBuffer(EMS_TEST_DEMO_SCREEN_ID);
    InitializeEMSData(&EMS_demo_EMS_data, SMSAL_DEFAULT_DCS);
    AddString(&EMS_demo_EMS_data, (U8*) EMS_demo_test_string, sizeof(EMS_demo_test_string) / 2, NULL);
    ShowCategory29Screen(0, 0, 0, 0, STR_GLOBAL_BACK, 0, &EMS_demo_EMS_data, guiBuffer);
    SetRightSoftkeyFunction(EMS_demo_close_category29, KEY_EVENT_UP);
    SetExitHandler(EMS_TEST_DEMO_SCREEN_ID, EMS_demo_exit_category29);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_exit_category29
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_exit_category29(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    h.scrnID = EMS_TEST_DEMO_SCREEN_ID;
    h.entryFuncPtr = EMS_demo_category29;
    h.inputBuffer[0] = '\0';
    GetCategoryHistory(h.guiBuffer);
    AddHistory(h);
}

CHAR EMS_demo_header_string[] =
    { 'S', 0, 'a', 0, 'm', 0, 'p', 0, 'l', 0, 'e', 0, ' ', 0, 'h', 0, 'e', 0, 'a', 0, 'd', 0, 'e', 0, 'r', 0, '\n', 0,
'm', 0, 'e', 0, 's', 0, 's', 0, 'a', 0, 'g', 0, 'e', 0, ' ', 0, 's', 0, 't', 0, 'r', 0, 'i', 0, 'n', 0, 'g', 0, '\n', 0, '1', 0, '2', 0,
'3', 0, '4', 0, '5', 0, '6', 0, '\0', 0
};

CHAR EMS_demo_header_ASCII_string[] = "From: \nABCDE FGHIJKLMNOP\n03/04/2003\n08:24:35\n";

U8 EMS_demo_header_temp_string[1024];

void EMS_demo_exit_category39(void);


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_close_category39
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_close_category39(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    CloseCategory39Screen();
    GoBackHistory();
}


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_category39
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_category39(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ExecuteCurrExitHandler();
    guiBuffer = GetCurrGuiBuffer(EMS_TEST_DEMO_SCREEN_ID);
    InitializeEMSData(&EMS_demo_EMS_data, SMSAL_DEFAULT_DCS);
    AddString(&EMS_demo_EMS_data, (U8*) EMS_demo_test_string, sizeof(EMS_demo_test_string) / 2, NULL);
    mmi_asc_to_ucs2(EMS_demo_header_temp_string, EMS_demo_header_ASCII_string);
    ShowCategory39Screen(0, 0, 0, 0, STR_GLOBAL_BACK, 0, &EMS_demo_EMS_data, EMS_demo_header_temp_string, guiBuffer);
    SetRightSoftkeyFunction(EMS_demo_close_category39, KEY_EVENT_UP);
    SetExitHandler(EMS_TEST_DEMO_SCREEN_ID, EMS_demo_exit_category39);
}


/*****************************************************************************
 * FUNCTION
 *  EMS_demo_exit_category39
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_demo_exit_category39(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    h.scrnID = EMS_TEST_DEMO_SCREEN_ID;
    h.entryFuncPtr = EMS_demo_category39;
    h.inputBuffer[0] = '\0';
    GetCategoryHistory(h.guiBuffer);
    AddHistory(h);
}

#endif /* (ENABLE_EMS_TEST_DEMO) */ 


/*****************************************************************************
 * FUNCTION
 *  is_EMS_inputbox_in_view_mode
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL is_EMS_inputbox_in_view_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_EMS_inputbox.flags & UI_EMS_INPUT_BOX_VIEW_MODE)
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_EMS_set_text_format
 * DESCRIPTION
 *  
 * PARAMETERS
 *  text_format     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_EMS_set_text_format(EMSTextFormat text_format)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_EMS_text_format = text_format;
}


/*****************************************************************************
* FUNCTION
*  wgui_inputs_ems_insert_string
* DESCRIPTION
*  Insert string at current cursor position.
* PARAMETERS
* str           [in]        string to insert
* len           [in]        string length
* is_redraw     [in]        if need redraw after insert        
* RETURNS
*  characters inserted
*****************************************************************************/
U32 wgui_inputs_ems_insert_string(UI_string_type str, U32 len, MMI_BOOL is_redraw)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i, total_len = 0;
    U32 old_show_action_flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    old_show_action_flag = MMI_EMS_inputbox.show_action_flag;
    MMI_EMS_inputbox.show_action_flag = 0;
    for (i = 0; i < len; i++)
    {
        if (MMI_TRUE == wgui_inputs_is_input_char_valid((UI_character_type)str[i]))
        {
            if (((UI_character_type)str[i] == 0x0D) || ((UI_character_type)str[i] == 0x1b))
            {
                continue;
            }
            else if (MMI_TRUE == EMS_inputbox_direct_input_no_draw((UI_character_type)str[i]))
            {
                total_len ++;
            }
            else
            {
                break;
            }
        }
        else
        {
            UI_editor_play_tone_cannot_insert();
            break;
        }
    }
    MMI_EMS_inputbox.show_action_flag = old_show_action_flag;

    if (is_redraw)
    {
#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
        gui_emsc_all_line_update();
#endif
        redraw_EMS_inputbox();
    }

    EMS_inputbox_input_callback();

    return total_len;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_EMS_handle_right_arrow_repeat
 * DESCRIPTION
 *  handle right arrow key repeat of EMS input box
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inputs_EMS_handle_right_arrow_repeat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_NAV_RIGHT, WGUI_INPUTS_EDITOR_EMS, WGUI_INPUTS_KPD_REPEAT_PERIOD);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_EMS_handle_left_arrow_repeat
 * DESCRIPTION
 *  handle left arrow key repeat of EMS input box
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inputs_EMS_handle_left_arrow_repeat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_NAV_LEFT, WGUI_INPUTS_EDITOR_EMS, WGUI_INPUTS_KPD_REPEAT_PERIOD);
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_EMS_handle_up_arrow_repeat
 * DESCRIPTION
 *  handle up arrow key repeat of EMS input box
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inputs_EMS_handle_up_arrow_repeat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_NAV_UP, WGUI_INPUTS_EDITOR_EMS, WGUI_INPUTS_KPD_REPEAT_PERIOD);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_EMS_handle_down_arrow_repeat
 * DESCRIPTION
 *  handle down arrow key repeat of EMS input box
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_inputs_EMS_handle_down_arrow_repeat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_NAV_DOWN, WGUI_INPUTS_EDITOR_EMS, WGUI_INPUTS_KPD_REPEAT_PERIOD);
}



/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_EMS_handle_right_softkey_repeat
 * DESCRIPTION
 *  handle right softkey repeat of EMS input box
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inputs_EMS_handle_right_softkey_repeat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (gui_EMS_inputbox_empty(&MMI_EMS_inputbox))
    {
        return;
    }
    wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_DEL, WGUI_INPUTS_EDITOR_EMS, WGUI_INPUTS_KPD_REPEAT_PERIOD);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_EMS_handle_right_softkey_touch_repeat
 * DESCRIPTION
 *  handle right softkey repeat of EMS input box (Touch panel RSK)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inputs_EMS_handle_right_softkey_touch_repeat(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (gui_EMS_inputbox_empty(&MMI_EMS_inputbox))
    {
        return;
    }

    wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_DEL, WGUI_INPUTS_EDITOR_EMS, WGUI_INPUTS_TP_REPEAT_PERIOD);
}


/*****************************************************************************
* FUNCTION
*  wgui_inputs_EMS_disalbe_show
* DESCRIPTION
*  Disable show or not
* PARAMETERS
*  b_disable       [IN]        disable or not
* RETURNS
*  void
*****************************************************************************/
void wgui_inputs_EMS_disalbe_show(MMI_BOOL b_disable)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_EMS_input_box_disalbe_show(b_disable);
}


#ifdef __UI_EMS_HIGHLIGHT_LIST_SUPPORT__
/*****************************************************************************
* FUNCTION
*  wgui_inputs_EMS_set_hilite_list
* DESCRIPTION
*  Set EMS highlight list, Called by App
* PARAMETERS
*  hilite_list       	[IN]  
*  number_of_list       [IN]  
*  curr_hilite_idx      [IN]  
*  hilite_cb       		[IN]  
*  click_cb       		[IN]       
* RETURNS
*  void
*****************************************************************************/
void wgui_inputs_EMS_set_hilite_list(
        EMS_HILITE *hilite_list,
        U16 number_of_list,
        U16 curr_hilite_idx,
        void (*hilite_cb)(S32 idx),
        void (*click_cb)(S32 idx))
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_inputs_EMS_hilite_list = hilite_list;
    g_wgui_inputs_EMS_hilite_list_number = number_of_list;
    g_wgui_inputs_EMS_curr_hilite_idx = curr_hilite_idx;
    g_wgui_inputs_EMS_hilite_cb = hilite_cb;
#ifdef __MMI_TOUCH_SCREEN__
    g_wgui_inputs_EMS_hilite_click_cb = click_cb;
#endif /* __MMI_TOUCH_SCREEN__ */
}


/*****************************************************************************
* FUNCTION
*  wgui_inputs_EMS_set_hilite_list
* DESCRIPTION
*  Set EMS highlight list, Called by App
* PARAMETERS
*  hilite_list       	[IN]
*  number_of_list       [IN]  
*  curr_hilite_idx      [IN]  
*  hilite_cb       		[IN]  
*  click_cb       		[IN]       
* RETURNS
*  void
*****************************************************************************/
void wgui_inputs_EMS_reset_hilite_list(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_inputs_EMS_hilite_list = NULL;
    g_wgui_inputs_EMS_hilite_list_number = 0;
    g_wgui_inputs_EMS_curr_hilite_idx = 0;
    g_wgui_inputs_EMS_hilite_cb = NULL;
#ifdef __MMI_TOUCH_SCREEN__
    g_wgui_inputs_EMS_hilite_click_cb = NULL;
#endif /* __MMI_TOUCH_SCREEN__ */
}


/*****************************************************************************
* FUNCTION
*  wgui_inputs_EMS_set_hilite_list
* DESCRIPTION
*  Set EMS highlight list to EMS structure, Called by Editor category
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void wgui_inputs_EMS_set_hilite_info(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_inputs_EMS_hilite_list)
    {
	    MMI_EMS_inputbox.hilite_list = g_wgui_inputs_EMS_hilite_list;
	    MMI_EMS_inputbox.hilite_str_number = g_wgui_inputs_EMS_hilite_list_number;
	    MMI_EMS_inputbox.current_hilite_idx = g_wgui_inputs_EMS_curr_hilite_idx;
	    MMI_EMS_inputbox.hilite_cb = g_wgui_inputs_EMS_hilite_cb;
    #ifdef __MMI_TOUCH_SCREEN__
	    MMI_EMS_inputbox.hilite_click_cb = g_wgui_inputs_EMS_hilite_click_cb;
	#endif /* __MMI_TOUCH_SCREEN__ */
    }
}
#endif /* __UI_EMS_HIGHLIGHT_LIST_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_ems_register_set_key_callback
 * DESCRIPTION
 *  Set key handler for App in editor screen
 * PARAMETERS
 *  f       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inputs_ems_register_set_key_callback(void (*f) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ems_inputbox_set_key_callback = f;
}


/*****************************************************************************
* FUNCTION
*  wgui_inputs_ems_register_pre_key_handler
* DESCRIPTION
*  Register EMS inputbox pre key handler
* PARAMETERS
*  wgui_inputs_ems_key_hdlr     [IN]       pre key handler   
* RETURNS
*  void
*****************************************************************************/
void wgui_inputs_ems_register_pre_key_handler(wgui_inputs_ems_key_hdlr f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_inputs_ems_pre_key_handler = f;
}


/*****************************************************************************
* FUNCTION
*  wgui_inputs_ems_reset_pre_key_handler
* DESCRIPTION
*  Reset EMS inputbox pre key handler
* PARAMETERS
*  void       
* RETURNS
*  void
*****************************************************************************/
void wgui_inputs_ems_reset_pre_key_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_inputs_ems_pre_key_handler = NULL;
}


/*****************************************************************************
* FUNCTION
*  wgui_inputs_ems_pre_key_handler
* DESCRIPTION
*  EMS inputbox pre key handler. 
* PARAMETERS
*  void        
* RETURNS
*  MMI_BOOL
*****************************************************************************/
static MMI_BOOL wgui_inputs_ems_pre_key_handler(U16 key_code, U16 key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (key_type == KEY_EVENT_DOWN)
    {
        if (g_wgui_inputs_ems_pre_key_handler)
        {
            if (g_wgui_inputs_ems_pre_key_handler(key_code))
            {
                return MMI_TRUE;
            }
        }
    }

    return ret;
}


/*****************************************************************************
* FUNCTION
*  wgui_inputs_EMS_disable
* DESCRIPTION
*  Disable EMS inputbox. 
*  Only hide the cursor and change the background filler to disabled_filler 
* PARAMETERS
*  void        
* RETURNS
*  void
*****************************************************************************/
void wgui_inputs_EMS_disable(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_EMS_inputbox.flags |= (UI_EMS_INPUT_BOX_STATE_DISABLED | UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW);
    StopTimer(BLINKING_CURSOR);
}

/*****************************************************************************
* FUNCTION
*  wgui_inputs_EMS_enable
* DESCRIPTION
*  Enable EMS inputbox. 
*  Show the cursor and reset the background filler to normal_filler
* PARAMETERS
*  void        
* RETURNS
*  void
*****************************************************************************/
void wgui_inputs_EMS_enable(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_EMS_inputbox.flags &= ~(UI_EMS_INPUT_BOX_STATE_DISABLED | UI_EMS_INPUT_BOX_DISABLE_CURSOR_DRAW);
}

/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_EMS_is_area_visible
 * DESCRIPTION
 *  Check the area is visible or not
 * PARAMETERS
 *  x               [IN]               
 *  y               [IN]
 *  width           [IN]
 *  height          [IN]
 *  gap             [IN]
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
S32 wgui_inputs_EMS_is_area_visible(S32 x, S32 y, S32 width, S32 height, S32 gap)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((y - gap) > 0)
    {
        y -= gap;
        height += (gap << 1);
    }
    else
    {
        height += gap ;
    }

    if ( y >= (-MMI_EMS_inputbox.display_y) &&
        y <= (-MMI_EMS_inputbox.display_y + MMI_EMS_inputbox.height) &&
        (y + height) >= (-MMI_EMS_inputbox.display_y) &&
        (y + height) <= (-MMI_EMS_inputbox.display_y + MMI_EMS_inputbox.height))
    {
        return 0;
    }
    else
    {
        if (y < (-MMI_EMS_inputbox.display_y))
        {
            return (y + MMI_EMS_inputbox.display_y);
        }
        else if (y > (-MMI_EMS_inputbox.display_y + MMI_EMS_inputbox.height))
        {
            return (y + MMI_EMS_inputbox.display_y - MMI_EMS_inputbox.height + height);
        }
        else if ((y + height) < (-MMI_EMS_inputbox.display_y))
        {
            return (y + MMI_EMS_inputbox.display_y);
        }
        else if ((y + height) > (-MMI_EMS_inputbox.display_y + MMI_EMS_inputbox.height))
        {
            return (y + height + MMI_EMS_inputbox.display_y - MMI_EMS_inputbox.height);
        }
        else
        {
            return 0;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_inputs_EMS_move_cursor
 * DESCRIPTION
 *  Move the EMS editor cursor
 * PARAMETERS
 *  pos             [IN]                              cursor position
 *                  WGUI_INPUTS_CURSOR_POS_START   start position
 *                  WGUI_INPUTS_CURSOR_POS_END     end position
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_inputs_EMS_move_cursor(wgui_inputs_cursor_pos_enum pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSPosition p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (pos == WGUI_INPUTS_CURSOR_POS_START)
    {
        p.OffsetToText = 0;
        if ((MMI_EMS_inputbox.data->listHead) && (MMI_EMS_inputbox.data->listHead->OffsetToText == 0))
        {
            p.Object = MMI_EMS_inputbox.data->listHead;
        }
        else
        {
            p.Object = NULL;
        }
    }
    else if(pos == WGUI_INPUTS_CURSOR_POS_END)
    {
        p.OffsetToText = MMI_EMS_inputbox.data->textLength;
        p.Object = MMI_EMS_inputbox.data->listTail;
    }
    else
    {
        MMI_ASSERT(0);
    }
    
    gui_EMS_input_box_set_cursor_position(&MMI_EMS_inputbox, &p);
    gui_EMS_input_box_set_text_format_cursor_position(&MMI_EMS_inputbox);
}
#endif /* UI_EMS_SUPPORT */

