/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   wgui_categories_idlescreen_op.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 * Operator idle screen related categories.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
 
#include "MMI_features.h"
#include "Wgui_include.h"
#include "Gui_themes.h"
#include "Wgui_draw_manager.h"
#include "Wgui_inputs.h"
#include "wgui_fixed_menus.h"
#include "Wgui_categories_util.h"
#include "Wgui_dynamic_menus.h"
#include "Wgui_fixed_menuitems.h"
#include "Wgui_touch_screen.h"
#include "Gui_dynamic_menus.h"
#include "wgui_categories_idlescreen_op.h"
#if defined(__MMI_TOUCH_SCREEN__)
#include "wgui_virtual_keyboard.h"
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
#include "TimerEvents.h"
#include "wgui_dynamic_menuitems.h"
#include "wgui_categories_inputs.h"

#include "MMIDataType.h"
#include "gdi_const.h"
#include "gdi_datatype.h"
#include "gui_windows.h"
#include "gui_data_types.h"
#include "gui_typedef.h"
#include "custom_mmi_default_value.h"
#include "kal_general_types.h"
#include "mmi_frm_input_gprot.h"
#include "wgui_side_bar.h"
#include "gdi_include.h"
#include "gui.h"
#include "CustThemesRes.h"
#include "wgui.h"
#include "gui_switch.h"
#include "PixcomFontEngine.h"
#include "lcd_sw_inc.h"
#include "Gui_Setting.h"
#include "wgui_categories_idlescreen.h"
#include "app_datetime.h"
#include "mmi_rp_srv_status_icons_def.h"
#include "CustDataRes.h"
#include "Unicodexdcl.h"
#include "kal_public_api.h"
#include "DebugInitDef_Int.h"
#include "lcd_sw_rnd.h"
#include "gdi_lcd_config.h"
#include "mmi_frm_mem_gprot.h"
#include "gui_side_bar.h"
#include "wgui_categories_list.h"
#include "string.h"
#include "GlobalConstants.h"
#include "mmi_frm_events_gprot.h"
#include "wgui_categories_enum.h"
#include "gui_theme_struct.h"
#include "gui_fixed_menus.h"
#include "gui_buttons.h"
#include "gui_inputs.h"
#include "TimerEvents.h"
#include "mmi_frm_timer_gprot.h"
#include "gui_fixed_menuitems.h"
#include "GlobalResDef.h"
#include "wgui_dynamic_menuitems.h"
#include "gui_config.h"
#include "ImeGprot.h"
#include "gui_scrollbars.h"
#include "mmi_rp_app_uiframework_def.h"
#include "wgui_categories_inputs.h"


#if defined(__MMI_COSMOS_KEYPAD_SUPPORT_VK__)
#include "Imc.h"
#endif /*__MMI_COSMOS_KEYPAD_SUPPORT_VK__*/


#if defined(__MMI_OP11_CAT433_SUPPORT__)
typedef struct
{
    S32 options;
    U8* sb_mem;
    GDI_HANDLE* sb_layer;
    scrolling_text* extra_scrolling_text_ptr;  /* extra information string */
    scrolling_text extra_scrolling_text;       /* extra information string */	
} wgui_cat433_context_struct;


static wgui_cat433_context_struct *g_wgui_cat433_p = NULL;
static UI_string_type g_pre_extra_string = NULL;

static U32 wgui_cat433_clock_local_time = WGUI_CLOCK_INVALID_INDEX;
static U32 wgui_cat433_clock_local_date = WGUI_CLOCK_INVALID_INDEX;
static U32 wgui_cat433_clock_dual_day = WGUI_CLOCK_INVALID_INDEX;
static U32 wgui_cat433_clock_dual_time = WGUI_CLOCK_INVALID_INDEX;
#if defined(__MMI_DUAL_CLOCK__) 
extern void mmi_wc_get_foreign_city_info(MYTIME *foreign_time, PU8 *city_name);
#endif
extern UI_string_type idle_screen_network_name;

#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_ctrl_area_pen_down_hdlr
 * DESCRIPTION
 *  Pen down events handler function for category433 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat433_ctrl_area_pen_down_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return wgui_side_bar_pen_handler(point, MMI_PEN_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_ctrl_area_pen_up_hdlr
 * DESCRIPTION
 *  Pen up events handler function for category433 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat433_ctrl_area_pen_up_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return wgui_side_bar_pen_handler(point, MMI_PEN_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_ctrl_area_pen_long_tap_hdlr
 * DESCRIPTION
 *  Pen long-tap events handler function for category433 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat433_ctrl_area_pen_long_tap_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return wgui_side_bar_pen_handler(point, MMI_PEN_EVENT_LONG_TAP);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_ctrl_area_pen_repeat_hdlr
 * DESCRIPTION
 *  Pen repeat events handler function for category433 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat433_ctrl_area_pen_repeat_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return wgui_side_bar_pen_handler(point, MMI_PEN_EVENT_REPEAT);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_ctrl_area_pen_move_hdlr
 * DESCRIPTION
 *  Pen move events handler function for category433 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat433_ctrl_area_pen_move_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return wgui_side_bar_pen_handler(point, MMI_PEN_EVENT_MOVE);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_ctrl_area_pen_abort_hdlr
 * DESCRIPTION
 *  Pen abort events handler function for category433 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat433_ctrl_area_pen_abort_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return wgui_side_bar_pen_handler(point, MMI_PEN_EVENT_ABORT);
}
#endif /* __MMI_TOUCH_SCREEN__ */ 

/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_handle_extra_text_scroll 
 * DESCRIPTION
 *  Handle extra information scrolling
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat433_handle_extra_text_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&g_wgui_cat433_p->extra_scrolling_text);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_redraw_extra_text_background 
 * DESCRIPTION
 *  Redraw extra text (scrolling text) background 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat433_redraw_extra_text_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_show_bracket
 * DESCRIPTION
 *  show bracket of extra information line
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat433_show_bracket(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y;
    S32 bracket_width = 0, bracket_height = 0;	

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    S32 x1 = 0, y1 = 0, x2 = 0, y2 = 0;
       
    gui_set_font(&MMI_medium_font);
    gui_set_text_color(*current_MMI_theme->idle_scr_network_extra_color);
    gui_set_text_border_color(*current_MMI_theme->idle_scr_network_extra_border_color);

     x1 = WGUI_CAT433_BAR_MAX_WIDTH + MMI_IDLE_STRING_MARGIN_GAP ;
     y1 = WGUI_CAT433_STRING_EXTRA_Y;
     x2 = MMI_CONTENT_WIDTH - MMI_IDLE_STRING_MARGIN_GAP - 1;
     y2 = y1 + WGUI_CAT433_STRING_HEIGHT;
       
     gdi_layer_push_clip();
     gdi_layer_set_clip(x1, y1, x2, y2);
     gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
       
     gui_measure_character((UI_character_type)'[', &bracket_width, &bracket_height);
     bracket_width += 2;  /* border text */
     bracket_height += 2; /* border text */
     x =  (x1 + 1) ;
     y = y1 + ((WGUI_CAT433_STRING_HEIGHT - bracket_height) >> 1);   /* central y in refresh region */
     gui_move_text_cursor(x, y);
     gui_print_bordered_text(L"[");
            
      /* print "]" */
      gui_measure_character((UI_character_type)']', &bracket_width, &bracket_height);
      bracket_width += 2;  /* border text */
      bracket_height += 2; /* border text */
      x = (x2 - bracket_width);
      y = y1 + ((WGUI_CAT433_STRING_HEIGHT - bracket_height) >> 1);
      gui_move_text_cursor(x, y);
      gui_print_bordered_text(L"]");
      gdi_layer_pop_clip();
}

static void wgui_cat433_draw_extra_information(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w;
    S32 bracket_width = 0, bracket_height = 0;	
    UI_string_type extra_string = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_pre_extra_string = extra_string = wgui_cat033_get_extra_text();
    //extra_string = (L"extra_extra_extra_extra_extra");
    g_wgui_cat433_p->extra_scrolling_text_ptr = &(g_wgui_cat433_p->extra_scrolling_text);
    
    /* show extra information */
    if (extra_string != NULL && g_wgui_cat433_p->extra_scrolling_text_ptr != NULL)
    {           
        S32 x1 = 0, y1 = 0, x2 = 0, y2 = 0;
        
        gui_set_font(&MMI_medium_font);
        gui_set_text_color(*current_MMI_theme->idle_scr_network_extra_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_extra_border_color);

        w = gui_get_string_width(extra_string) ;
	 gui_measure_character((UI_character_type)'[', &bracket_width, &bracket_height);
	 bracket_width += 2;  /* border text */
	 
        x1 = WGUI_CAT433_BAR_MAX_WIDTH + MMI_IDLE_STRING_MARGIN_GAP ;
        y1 = WGUI_CAT433_STRING_EXTRA_Y;
        x2 = MMI_CONTENT_WIDTH - MMI_IDLE_STRING_MARGIN_GAP - 1;
        y2 = y1 + WGUI_CAT433_STRING_HEIGHT;
        
        wgui_cat433_show_bracket();

        if (w < ((x2 - x1) - bracket_width * 4 - 1))
        {
            /* align in center */
            x = x1 + (((x2 - x1)  >> 1) - (w >> 1));
            y = y1 + 3; /* border text */
            gui_move_text_cursor(x, y);
            gui_print_bordered_text(extra_string);
        }
        else
        {
            /* scrolling text */
            w = (x2 - x1) - bracket_width * 4 - 1;	     
            gui_create_scrolling_text(
                g_wgui_cat433_p->extra_scrolling_text_ptr,
                x1 + ((x2 - x1)  - w)/2, /* scrolling text reserve 4 pixels in x-coordinate, x have to move 2 pixels */
                y1 + 1, /* scrolling text reserve 2 pixels in y-coordinate, y have to move 1 pixel */
                w, /* scrolling text reserve 4 pixels in x-coordinate */
                WGUI_CAT433_STRING_HEIGHT, /* scrolling text reserve 2 pixels in y-coordinate */
                extra_string,
                wgui_cat433_handle_extra_text_scroll,
                wgui_cat433_redraw_extra_text_background,
                *current_MMI_theme->idle_scr_network_extra_color,
                *current_MMI_theme->idle_scr_network_extra_border_color);
            (g_wgui_cat433_p->extra_scrolling_text_ptr)->scroll_gap = 20;
	     (g_wgui_cat433_p->extra_scrolling_text_ptr)->flags |= UI_SCROLLING_TEXT_BORDERED_TEXT;
            gui_show_scrolling_text(g_wgui_cat433_p->extra_scrolling_text_ptr);
        }           
    } 
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_draw_details 
 * DESCRIPTION
 *  Draw the displayed details of category 433,
 *  including date time, operator name, world clock, alram indicator.
 *  After drawing details, please remember to redraw side-bar again.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat433_draw_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h;
    UI_string_type str;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* assume the layout is the same as coordinates */
    x = MMI_CONTENT_X;
    y = MMI_STATUS_BAR_HEIGHT;
    w = MMI_CONTENT_WIDTH;
    h = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - MMI_STATUS_BAR_HEIGHT;

    gdi_layer_lock_frame_buffer();

    /* assume base layer */
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);

    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, x + w - 1, y + h - 1);

    /* clear area */
    gdi_draw_solid_rect(x + w - 1 - WGUI_CAT433_STRING_MAX_OPNAME_W - WGUI_CAT433_STRING_H_GAP, y, x + w - 1, y + h - 1, GDI_COLOR_TRANSPARENT);

    gdi_draw_solid_rect(WGUI_CAT433_BAR_MAX_WIDTH + MMI_IDLE_STRING_MARGIN_GAP, 
                                      WGUI_CAT433_STRING_EXTRA_Y, 
                                      MAIN_LCD_DEVICE_WIDTH,
                                      MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - 1, 
                                      GDI_COLOR_TRANSPARENT);
	
    /* display date time */
    wgui_clock_show_main_lcd();

    /* display operator name */
    str = idle_screen_network_name;
    if (str != NULL)
    {
        S32 str_w, str_x, str_y;

        /* set font */
        gui_set_font(&MMI_medium_font);

        gui_set_text_border_color(gui_color(0, 0, 0));
        gui_set_text_color(gui_color(255, 255, 255));

        /* display text */
        str_y = WGUI_CAT433_STRING_OPNAME_Y;
        str_w = gui_get_string_width(str) + 2;
        if (str_w < WGUI_CAT433_STRING_MAX_OPNAME_W)
        {
            str_x = (r2lMMIFlag) ? (UI_device_width - WGUI_CAT433_STRING_H_GAP) : (UI_device_width - WGUI_CAT433_STRING_H_GAP - str_w);
            gui_move_text_cursor(str_x + 1, str_y + 1);
            gui_print_bordered_text(str);
        }
        else
        {
            str_x = (r2lMMIFlag) ? (UI_device_width - WGUI_CAT433_STRING_H_GAP) : (UI_device_width - WGUI_CAT433_STRING_H_GAP - WGUI_CAT433_STRING_MAX_OPNAME_W);
            gui_print_truncated_borderd_text(str_x + 1, str_y + 1, WGUI_CAT433_STRING_MAX_OPNAME_W, str);
        }
    }

    /* display city */
#if defined(__MMI_DUAL_CLOCK__)     
    if (g_wgui_cat433_p->options & WGUI_CAT433_DISPLAY_DUAL_CLOCK)
    {
        applib_time_struct foreign_time;
        PU8 city_name;
        S32 str_w, str_x, str_y;

        /* get city name */

        /* get dual clock information */
        mmi_wc_get_foreign_city_info((MYTIME *)&foreign_time, &city_name);
        str = (UI_string_type)city_name;

        /* set font */
        gui_set_font(&MMI_medium_font);

        gui_set_text_border_color(gui_color(0, 0, 0));
        gui_set_text_color(gui_color(255, 255, 255));

        /* display text */
        str_y = WGUI_CAT433_STRING_CITYNAME_Y;
        str_w = gui_get_string_width(str) + 2;
        if (str_w < WGUI_CAT433_STRING_MAX_OPNAME_W)
        {
            str_x = (r2lMMIFlag) ? (UI_device_width - WGUI_CAT433_STRING_H_GAP) : (UI_device_width - WGUI_CAT433_STRING_H_GAP - str_w);
            gui_move_text_cursor(str_x + 1, str_y + 1);
            gui_print_bordered_text(str);
        }
        else
        {
            str_x = (r2lMMIFlag) ? (UI_device_width - WGUI_CAT433_STRING_H_GAP) : (UI_device_width - WGUI_CAT433_STRING_H_GAP - WGUI_CAT433_STRING_MAX_OPNAME_W);
            gui_print_truncated_borderd_text(str_x + 1, str_y + 1, WGUI_CAT433_STRING_MAX_OPNAME_W, str);
        }
    }
#endif
    /* display alarm indicator */
    if (g_wgui_cat433_p->options & WGUI_CAT433_DISPLAY_ALARM)
    {
        S32 img_x, img_y, img_w, img_h, clock_x, clock_y;
        U16 img_id = IMG_SI_ALARM_ACTIVATED;

        wgui_clock_get_position(wgui_cat433_clock_local_time, &clock_x, &clock_y);
        gdi_image_get_dimension_id(img_id, &img_w, &img_h);
        img_x = clock_x - img_w - 2 /* gap */;
        img_y = clock_y;
        gdi_image_draw_id(img_x, img_y, img_id);
    }

    /* draw extra information */
    do
    {
        /* previous scroll process */
        if (g_wgui_cat433_p->extra_scrolling_text_ptr != NULL)
        {
            UI_string_type extra_string = NULL;
            extra_string = wgui_cat033_get_extra_text();
		    
            if ((extra_string != NULL) && (g_pre_extra_string != NULL) && (mmi_wcscmp(extra_string, g_pre_extra_string) == 0) && ((g_wgui_cat433_p->extra_scrolling_text_ptr)->flags & UI_SCROLLING_TEXT_ENABLE_SCROLL))
            {
                wgui_cat433_show_bracket();
                gui_redraw_scrolling_text(g_wgui_cat433_p->extra_scrolling_text_ptr);
                break;
            }
            else
            {
                 /* refresh to new string: stop previous text scrolling */
                gui_scrolling_text_stop(g_wgui_cat433_p->extra_scrolling_text_ptr);
                g_wgui_cat433_p->extra_scrolling_text_ptr = NULL;
            }
        }
        wgui_cat433_draw_extra_information();
    } while(0);
	
    gdi_layer_pop_clip();

    gdi_layer_pop_and_restore_active();

    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_update_details 
 * DESCRIPTION
 *  Update the displayed details of category 433,
 *  including redrawing the side bar.
 *  This API is for application to update the operator name, etc.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat433_update_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* draw details */
    wgui_cat433_draw_details();

    /* redraw side bar */
    wgui_side_bar_redraw();

    gdi_layer_unlock_frame_buffer();

    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_update_indicators 
 * DESCRIPTION
 *  Update the indicators, including operator name, etc.
 * PARAMETERS
 *  index   [IN] index of indicators
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat433_update_indicators(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* update indicators */
    wgui_side_bar_update_indicators(index);

    /* draw details */
    wgui_cat433_draw_details();

    gdi_layer_unlock_frame_buffer();

    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_draw_ctrl_area1 
 * DESCRIPTION
 *  draw category 433 screen control area 1
 * PARAMETERS
 *  coordinate  [IN/OUT]    coordinate
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat433_draw_ctrl_area1(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    /* assume the layout is the same as coordinates */
    x = MMI_CONTENT_X;
    y = MMI_STATUS_BAR_HEIGHT;
    w = MMI_CONTENT_WIDTH;
    h = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - MMI_STATUS_BAR_HEIGHT;

    /* set softkey layer */
    wgui_softkey_set_target_layer(dm_get_layer_handle(1));      /* assume base layer */

    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, x + w - 1, y + h - 1);

    /* clear area */
    gdi_draw_solid_rect(x, y, x + w - 1, y + h - 1, GDI_COLOR_TRANSPARENT);

    gdi_layer_pop_clip();

    /* display details */
    wgui_cat433_draw_details();

    /* allocate memory */
    MMI_ASSERT(g_wgui_cat433_p->sb_mem == NULL);
    g_wgui_cat433_p->sb_mem = mmi_frm_scrmem_alloc_framebuffer(SCRMEM_CAT433_POOL_SIZE);
    MMI_ASSERT(g_wgui_cat433_p->sb_mem);

    /* create layer */
    MMI_ASSERT(g_wgui_cat433_p->sb_layer == NULL);
    dm_create_layer_using_outside_memory(
            0, 0, GDI_LCD_WIDTH, GDI_LCD_HEIGHT,
            &g_wgui_cat433_p->sb_layer,
            g_wgui_cat433_p->sb_mem,
            SCRMEM_CAT433_POOL_SIZE,
            DM_LAYER_TOP);
    MMI_ASSERT(g_wgui_cat433_p->sb_layer);

    /* init layer */
    gdi_layer_push_and_set_active(*g_wgui_cat433_p->sb_layer);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();

    /* setup side bar layout information */
    wgui_side_bar_move(coordinate->s16X, coordinate->s16Y);
    wgui_side_bar_resize(coordinate->s16Width, coordinate->s16Height);
    wgui_side_bar_set_layers(
            dm_get_layer_handle(1),     /* assume base layer */
            *g_wgui_cat433_p->sb_layer,
            dm_get_layer_handle(0));    /* assume new layer */

    /* display side bar component */
    wgui_side_bar_show();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_blt_before_cb 
 * DESCRIPTION
 *  draw category 433 BLT before callback
 * PARAMETERS
 *  result      [IN] GDI result
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat433_blt_before_cb(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* redraw details */
    wgui_cat433_draw_details();

    /* redraw side bar */
    wgui_side_bar_redraw();

    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_blt_before_dummy_cb 
 * DESCRIPTION
 *  draw category 433 BLT before dummy callback
 * PARAMETERS
 *  result      [IN] GDI result
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat433_blt_before_dummy_cb(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_draw_ctrl_area2 
 * DESCRIPTION
 *  draw category 433 screen control area 2
 * PARAMETERS
 *  coordinate  [IN/OUT]    coordinate
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat433_draw_ctrl_area2(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* register blt before callback */
    gdi_anim_set_blt_before_callback(wgui_cat433_blt_before_cb);

    /* draw wallpaper */
    draw_wallpaper();

    /* reset blt before callback */
    gdi_anim_set_blt_before_callback(wgui_cat433_blt_before_dummy_cb);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_hide_date_time 
 * DESCRIPTION
 *  Hide function for category 433 date time component
 * PARAMETERS
 *  x1      [IN]
 *  y1      [IN]
 *  x2      [IN]
 *  y2      [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat433_hide_date_time(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_init_datetime 
 * DESCRIPTION
 *  Init category 433 date time component
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat433_init_datetime(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w = 0, h = 0, x = 0, y = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Local time */
    wgui_clock_create(
        &wgui_cat433_clock_local_time,          /* local time */
        0, 0, 0, 0,                             /* will move & assign layer */
        GUI_CLOCK_MAINLCD_TYPE_DIGITAL_TIME);   /* only display time */

    wgui_clock_set_text_border_enable(wgui_cat433_clock_local_time, MMI_TRUE);
    wgui_clock_set_time_text_border_color(wgui_cat433_clock_local_time, gui_color(0, 0, 0));
    wgui_clock_set_time_text_color(wgui_cat433_clock_local_time, gui_color(255, 255, 255));
    wgui_clock_set_time_text_font(wgui_cat433_clock_local_time, &MMI_medium_font);

    wgui_clock_set_hide_function(wgui_cat433_clock_local_time, wgui_cat433_hide_date_time);

    wgui_clock_measure_time_text(wgui_cat433_clock_local_time, &w, &h, &MMI_medium_font);
    x = UI_device_width - WGUI_CAT433_STRING_H_GAP - w;
    y = WGUI_CAT433_STRING_LOCALTIME_Y;
    wgui_clock_move(wgui_cat433_clock_local_time, x, y);
    wgui_clock_resize(wgui_cat433_clock_local_time, w, h);

    wgui_clock_set_digital_align_type(wgui_cat433_clock_local_time, GUI_CLOCK_DIGITAL_ALIGN_RIGHT);

    /* Local date and day */
    wgui_clock_create(
        &wgui_cat433_clock_local_date,          /* local date */
        0, 0, 0, 0,                             /* will move & assign layer */
        GUI_CLOCK_MAINLCD_TYPE_DIGITAL_DATE);   /* display date and day */

    wgui_clock_set_text_border_enable(wgui_cat433_clock_local_date, MMI_TRUE);
    wgui_clock_set_date_text_border_color(wgui_cat433_clock_local_date, gui_color(0, 0, 0));
    wgui_clock_set_date_text_color(wgui_cat433_clock_local_date, gui_color(255, 255, 255));
    wgui_clock_set_date_text_font(wgui_cat433_clock_local_date, &MMI_small_font);

    wgui_clock_set_hide_function(wgui_cat433_clock_local_date, wgui_cat433_hide_date_time);

    wgui_clock_measure_date_text(wgui_cat433_clock_local_date, &w, &h, &MMI_medium_font);
    x = UI_device_width - WGUI_CAT433_STRING_H_GAP - w;
    y = WGUI_CAT433_STRING_LOCALDATE_Y;
    wgui_clock_move(wgui_cat433_clock_local_date, x, y);
    wgui_clock_resize(wgui_cat433_clock_local_date, w, h);

    wgui_clock_set_digital_align_type(wgui_cat433_clock_local_date, GUI_CLOCK_DIGITAL_ALIGN_RIGHT);

    /* dual clock */
#if defined(__MMI_DUAL_CLOCK__)
    if (g_wgui_cat433_p->options & WGUI_CAT433_DISPLAY_DUAL_CLOCK)
    {
        applib_time_struct foreign_time;
        PU8 city_name;

        /* get dual clock information */
        mmi_wc_get_foreign_city_info((MYTIME *)&foreign_time, &city_name);

        /* Dual day */
        wgui_clock_create(
            &wgui_cat433_clock_dual_day,            /* dual day */
            0, 0, 0, 0,                             /* will move & assign layer */
            GUI_CLOCK_MAINLCD_TYPE_DIGITAL_DATE);   /* display date and day */

        wgui_clock_set_text_border_enable(wgui_cat433_clock_dual_day, MMI_TRUE);
        wgui_clock_set_date_text_border_color(wgui_cat433_clock_dual_day, gui_color(0, 0, 0));
        wgui_clock_set_date_text_color(wgui_cat433_clock_dual_day, gui_color(255, 255, 255));
        wgui_clock_set_date_text_font(wgui_cat433_clock_dual_day, &MMI_small_font);

        wgui_clock_set_hide_function(wgui_cat433_clock_dual_day, wgui_cat433_hide_date_time);

        wgui_clock_measure_date_text(wgui_cat433_clock_dual_day, &w, &h, &MMI_medium_font);
        x = UI_device_width - WGUI_CAT433_STRING_H_GAP - w;
        y = WGUI_CAT433_STRING_DUALDAY_Y;
        wgui_clock_move(wgui_cat433_clock_dual_day, x, y);
        wgui_clock_resize(wgui_cat433_clock_dual_day, w, h);

        wgui_clock_set_digital_align_type(wgui_cat433_clock_dual_day, GUI_CLOCK_DIGITAL_ALIGN_RIGHT);

        wgui_clock_set_time(wgui_cat433_clock_dual_day, foreign_time);

        /* Dual time */
        wgui_clock_create(
            &wgui_cat433_clock_dual_time,           /* dual day */
            0, 0, 0, 0,                             /* will move & assign layer */
            GUI_CLOCK_MAINLCD_TYPE_DIGITAL_TIME);   /* display date and day */

        wgui_clock_set_text_border_enable(wgui_cat433_clock_dual_time, MMI_TRUE);
        wgui_clock_set_time_text_border_color(wgui_cat433_clock_dual_time, gui_color(0, 0, 0));
        wgui_clock_set_time_text_color(wgui_cat433_clock_dual_time, gui_color(255, 255, 255));
        wgui_clock_set_time_text_font(wgui_cat433_clock_dual_time, &MMI_medium_font);

        wgui_clock_set_hide_function(wgui_cat433_clock_dual_time, wgui_cat433_hide_date_time);

        wgui_clock_measure_time_text(wgui_cat433_clock_dual_time, &w, &h, &MMI_medium_font);
        x = UI_device_width - WGUI_CAT433_STRING_H_GAP - w;
        y = WGUI_CAT433_STRING_DUALTIME_Y;
        wgui_clock_move(wgui_cat433_clock_dual_time, x, y);
        wgui_clock_resize(wgui_cat433_clock_dual_time, w, h);

        wgui_clock_set_digital_align_type(wgui_cat433_clock_dual_time, GUI_CLOCK_DIGITAL_ALIGN_RIGHT);

        wgui_clock_set_time(wgui_cat433_clock_dual_time, foreign_time);
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_get_history_size
 * DESCRIPTION
 *  Gets the size of history data for category 433
 * PARAMETERS
 *  void
 * RETURNS
 *  history size
 *****************************************************************************/
static S32 wgui_cat433_get_history_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return sizeof(wgui_side_bar_history_struct);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat433_get_history
 * DESCRIPTION
 *  Gets the history data for category 433 into the given history buffer
 * PARAMETERS
 *  buffer      [OUT]   Buffer of history data.
 * RETURNS
 *  history
 *****************************************************************************/
static U8* wgui_cat433_get_history(U8* buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_side_bar_get_history((wgui_side_bar_history_struct*)buffer);

    return buffer;
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory433Screen 
 * DESCRIPTION
 *  Exit category 433 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory433Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* stop wallpaper animation */
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
        animation_handle = GDI_ERROR_HANDLE;
    }

    /* stop scrolling text */
    if (g_wgui_cat433_p->extra_scrolling_text_ptr)
    {
        gui_scrolling_text_stop(g_wgui_cat433_p->extra_scrolling_text_ptr);
        g_wgui_cat433_p->extra_scrolling_text_ptr = NULL;
    }
	
    /* close side bar component */
    wgui_side_bar_close();

    /* free layer */
    g_wgui_cat433_p->sb_layer = NULL;

    /* free memory */
    if (g_wgui_cat433_p->sb_mem != NULL)
    {
        mmi_frm_scrmem_free(g_wgui_cat433_p->sb_mem);
        g_wgui_cat433_p->sb_mem = NULL;
    }

    /* close date time component */
    wgui_clock_set_digital_align_type(wgui_cat433_clock_local_time, GUI_CLOCK_DIGITAL_ALIGN_CENTER);
    wgui_clock_set_digital_align_type(wgui_cat433_clock_local_date, GUI_CLOCK_DIGITAL_ALIGN_CENTER);
    wgui_clock_set_digital_align_type(wgui_cat433_clock_dual_day, GUI_CLOCK_DIGITAL_ALIGN_CENTER);
    wgui_clock_set_digital_align_type(wgui_cat433_clock_dual_time, GUI_CLOCK_DIGITAL_ALIGN_CENTER);

    wgui_clock_close(wgui_cat433_clock_local_time);
    wgui_clock_close(wgui_cat433_clock_local_date);
    wgui_clock_close(wgui_cat433_clock_dual_day);
    wgui_clock_close(wgui_cat433_clock_dual_time);
    wgui_cat433_clock_local_time = WGUI_CLOCK_INVALID_INDEX;
    wgui_cat433_clock_local_date = WGUI_CLOCK_INVALID_INDEX;
    wgui_cat433_clock_dual_day = WGUI_CLOCK_INVALID_INDEX;
    wgui_cat433_clock_dual_time = WGUI_CLOCK_INVALID_INDEX;

    /* free global context */
    if (g_wgui_cat433_p)
    {
        OslMfree(g_wgui_cat433_p);
        g_wgui_cat433_p = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory433Screen
 * DESCRIPTION
 *  Show category 433 screen
 * PARAMETERS
 *  left_softkey                [IN] Left softkey label
 *  left_softkey_icon           [IN] Icon for the left softkey
 *  right_softkey               [IN] Right softkey label
 *  right_softkey_icon          [IN] Icon for the right softkey
 *  number_of_items             [IN] Number of side bar menu items
 *  normal_side_bar_icons       [IN] Normal icons of side bar menu items
 *  highlighted_side_bar_icons  [IN] Highlighted icons of side bar menu items
 *  get_popout_menu             [IN] Get pop-out menu callback
 *  get_indicator               [IN] Get indicator callback
 *  sidebar_highlight_cb        [IN] Highlight side bar menu item callback
 *  left_arrow_down_handler     [IN] Pre-defined left arrow handler, used before navigating sid-bar. Currently we only deal with KEY_EVENT_DOWN.
 *  right_arrow_down_handler    [IN] Pre-defined right arrow handler, used before navigating sid-bar. Currently we only deal with KEY_EVENT_DOWN.
 *  options                     [IN] Flags, please refer to WGUI_CAT433_XXX
 *  history_guffer              [IN] GUI history buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory433Screen(
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        S32 number_of_items,
        PU8* normal_side_bar_icons,
        PU8* highlighted_side_bar_icons,
        wgui_sidebar_getmenudata_funcptr_type *get_menu_cb,
        wgui_sidebar_getindicator_funcptr_type *get_indicator_cb,
        wgui_sidebar_popout_menu_highlighthandler_funcptr_type *get_highlight_cb,
        wgui_sidebar_popout_side_bar_highlighthandler_funcptr_type sidebar_highlight_cb,
        FuncPtr left_arrow_down_handler,
        FuncPtr right_arrow_down_handler,
        S32 options,
        U8* history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat433_p = OslMalloc(sizeof(wgui_cat433_context_struct));
    MMI_ASSERT(g_wgui_cat433_p);
    memset(g_wgui_cat433_p, 0, sizeof(wgui_cat433_context_struct));

    g_wgui_cat433_p->options = options;
    
    gdi_layer_lock_frame_buffer();

    /* set softkey */
    dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);

    /* create date time component */
    wgui_cat433_init_datetime();

    /* create side bar component */
    wgui_side_bar_create(
            0, 0,   /* will move later */
            0, 0,   /* will resize later */
            GDI_NULL_HANDLE, GDI_NULL_HANDLE, GDI_NULL_HANDLE,  /* will set layer later */
            number_of_items, normal_side_bar_icons, highlighted_side_bar_icons,
            get_indicator_cb, get_menu_cb, get_highlight_cb);

    wgui_side_bar_register_highlight_handler(sidebar_highlight_cb);

    /* set history */
    if (history_buffer)
    {
        wgui_side_bar_set_history((wgui_side_bar_history_struct*)history_buffer);
    }

    /* set arrow key */
    wgui_side_bar_register_left_arrow_key_handler(left_arrow_down_handler, KEY_EVENT_DOWN);
    wgui_side_bar_register_right_arrow_key_handler(right_arrow_down_handler, KEY_EVENT_DOWN);

    gdi_layer_unlock_frame_buffer();

    /* Setup category/draw manager data */
    ExitCategoryFunction = ExitCategory433Screen;
    dm_setup_category_functions(MMI_dummy_function, wgui_cat433_get_history, wgui_cat433_get_history_size);
    dm_register_category_controlled_callback(wgui_cat433_draw_ctrl_area1);
    dm_register_category_controlled2_callback(wgui_cat433_draw_ctrl_area2);

    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY433_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_SET_AS_ABM_LAYER;
    dm_setup_data(&dm_data);

    /* register pen event handler */
#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat433_ctrl_area_pen_down_hdlr,
            MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat433_ctrl_area_pen_up_hdlr,
            MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat433_ctrl_area_pen_long_tap_hdlr,
            MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat433_ctrl_area_pen_repeat_hdlr,
            MMI_PEN_EVENT_REPEAT);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat433_ctrl_area_pen_move_hdlr,
            MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat433_ctrl_area_pen_abort_hdlr,
            MMI_PEN_EVENT_ABORT);
#endif /* __MMI_TOUCH_SCREEN__ */

    dm_redraw_category_screen();
}
#endif /* defined(__MMI_OP11_CAT433_SUPPORT__) */


#ifdef __MMI_OP12_CAT533_SUPPORT__


#define WGUI_CAT533_STRING_W_GAP (2)
#define WGUI_CAT533_STRING_H_GAP (2)
#define WGUI_CAT533_STRING_MAX_H (Get_CharDisplayHeightOfAllLangAndType(MMI_medium_font.size))

#define WGUI_CAT533_TOOLBAR_Y (MMI_STATUS_BAR_HEIGHT + 9)
#define WGUI_CAT533_STRING_NETWORK_NAME_Y (WGUI_CAT533_TOOLBAR_Y + MMI_STATUS_BAR_HEIGHT * 3)
#define WGUI_CAT533_STRING_NETWORK_STATUS_Y (WGUI_CAT533_STRING_NETWORK_NAME_Y + WGUI_CAT533_STRING_MAX_H + WGUI_CAT533_STRING_H_GAP)
#define WGUI_CAT533_STRING_EXTRA_Y (WGUI_CAT533_STRING_NETWORK_STATUS_Y + WGUI_CAT533_STRING_MAX_H + WGUI_CAT533_STRING_H_GAP)


typedef struct _wgui_cat533_cntx_struct
{
    U8* popout_menu_memory;                    /* popup menu memory */
    GDI_HANDLE* popout_menu_layer;             /* popup menu layer */ 
    MMI_BOOL from_history;
    scrolling_text* extra_scrolling_text_ptr;  /* extra information string */
    scrolling_text extra_scrolling_text;       /* extra information string */
    MMI_BOOL animation_callback;
} wgui_cat533_context_struct;

typedef struct _wgui_cat533_history_struct
{
    BOOL wallpaper_opacity_enable;                 /* wallpaper opacity */
    U8 wallpaper_opacity_value;                    /* wallpaper opacity value */
    gdi_color background_color;                    /* background color */
} wgui_cat533_history_struct;

static wgui_cat533_context_struct* g_wgui_cat533_cntx_p = NULL;
static wgui_cat533_history_struct* g_wgui_cat533_history_p = NULL;
static U32 wgui_cat533_clock_time = WGUI_CLOCK_INVALID_INDEX;
static U32 wgui_cat533_clock_date = WGUI_CLOCK_INVALID_INDEX;

extern UI_string_type idle_screen_network_status;
extern UI_string_type idle_screen_network_name;

/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_pause_wallpaper 
 * DESCRIPTION
 *  pause animation wallpaper
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat533_pause_wallpaper(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_anim_pause(animation_handle);
    }
#endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_resume_wallpaper 
 * DESCRIPTION
 *  resume animation wallpaper
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat533_resume_wallpaper(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_anim_resume(animation_handle);
    }
#endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_get_toolbar_history 
 * DESCRIPTION
 *  Get toolbar history pointer
 * PARAMETERS
 *  buffer    [IN]  history buffer
 * RETURNS
 *  wgui_toolbar_history_struct
 *****************************************************************************/
wgui_toolbar_history_struct* wgui_cat533_get_toolbar_history(U8* buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* toolbar data */    
    size = ((sizeof(wgui_cat533_history_struct) + 3) / 4) * 4;
    return ((wgui_toolbar_history_struct*)(buffer + size));
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_handle_extra_text_scroll 
 * DESCRIPTION
 *  Handle extra information scrolling
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat533_handle_extra_text_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&g_wgui_cat533_cntx_p->extra_scrolling_text);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_redraw_extra_text_background 
 * DESCRIPTION
 *  Redraw extra text (scrolling text) background 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat533_redraw_extra_text_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_set_wallpaper_opacity 
 * DESCRIPTION
 *  Set category533 wallpaper opacity
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat533_set_wallpaper_opacity(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    GDI_HANDLE wallpaper_layer;
    
    wgui_cat533_context_struct* cntx_p = g_wgui_cat533_cntx_p;
    wgui_cat533_history_struct* history_p = g_wgui_cat533_history_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Dimmed out effect */
    wallpaper_layer = dm_get_layer_handle(0);    
    gdi_layer_push_and_set_active(wallpaper_layer);

    if (cntx_p->from_history == MMI_TRUE)
    {
        gdi_layer_set_background(history_p->background_color);
        gdi_layer_set_opacity(history_p->wallpaper_opacity_enable, history_p->wallpaper_opacity_value);
        cntx_p->from_history = MMI_FALSE;
    }
    else
    {
        if (wgui_toolbar_is_active() == MMI_TRUE)
        {    
            /* when toolbar is active, make wallpaper layer darker */
            history_p->background_color = GDI_COLOR_BLACK;
            history_p->wallpaper_opacity_enable = TRUE;
            history_p->wallpaper_opacity_value = (U8)(220);
        }
        else
        {
            /* when toolbar is inactive, reset wallpaper layer and background to original setting */
            history_p->background_color = GDI_COLOR_WHITE;
            history_p->wallpaper_opacity_enable = FALSE;
            history_p->wallpaper_opacity_value = 0;
        }
        gdi_layer_set_background(history_p->background_color);        
        gdi_layer_set_opacity(history_p->wallpaper_opacity_enable, history_p->wallpaper_opacity_value);
    }        
    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_draw_string_center_align 
 * DESCRIPTION
 *  Draw border text in given region
 *  If the string width is shorter than given region, it will be center aligned.
 *  If the string width is longer than giver region, it will show trancated text.
 * PARAMETERS
 *  string    [IN]    string
 *  x1        [IN]    start x
 *  y1        [IN]    start y
 *  x2        [IN]    end x
 *  y2        [IN]    end y
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat533_draw_string_center_align(UI_string_type string, S32 x1, S32 y1, S32 x2, S32 y2, color text_color, color border_color)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 string_w = 0, string_h = 0, w = 0, x = 0, y = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (string != NULL)
    {     
        /* set attribute */
        gui_set_font(&MMI_medium_font);
        gui_set_text_border_color(border_color);
        gui_set_text_color(text_color);

        /* get string information */
        gui_measure_string(string, &string_w, &string_h);
        string_w += 2; /* border text */
        string_h += 2; /* border text */       
        
        gdi_layer_push_clip();
        gdi_layer_set_clip(x1, y1, x2, y2);
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);

        /* calculate position */
        y = y1 + ((y2 - y1 + 1) >> 1) - (string_h >> 1) + 1 /* border text */;
        if (string_w < x2 - x1 + 1)
        {
            /* align in center */
            x = (r2lMMIFlag) ? (x1 + ((x2 - x1 + 1) >> 1) + (string_w >> 1)) : (x1 + ((x2 - x1 + 1) >> 1) - (string_w >> 1));
            x += (r2lMMIFlag) ? (-1) : (1); /* border text */            
            gui_move_text_cursor(x, y);
            gui_print_bordered_text(string);
        }
        else
        {
            x = (r2lMMIFlag) ? (x2) : (x1);
            x += (r2lMMIFlag) ? (-1) : (1); /* border text */
            w = x2 - x1 + 1;
            gui_print_truncated_borderd_text(x, y, w, string);
        }
        gdi_layer_pop_clip();
    }
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_show_bracket
 * DESCRIPTION
 *  show bracket of extra information line
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat533_show_bracket(void)
{
     /*----------------------------------------------------------------*/
     /* Local Variables                                                */
     /*----------------------------------------------------------------*/
     S32 x, y;	 
     S32 bracket_width = 0, bracket_height = 0;	

     /*----------------------------------------------------------------*/
     /* Code Body                                                      */
     /*----------------------------------------------------------------*/
     S32 x1 = 0, y1 = 0, x2 = 0, y2 = 0;
       
     gui_set_font(&MMI_medium_font);
     gui_set_text_color(*current_MMI_theme->idle_scr_network_extra_color);
     gui_set_text_border_color(*current_MMI_theme->idle_scr_network_extra_border_color);

      x1 = MMI_IDLE_STRING_MARGIN_GAP;
      y1 = WGUI_CAT533_STRING_EXTRA_Y;
      x2 = UI_device_width - MMI_IDLE_STRING_MARGIN_GAP - 1;
      y2 = y1 + WGUI_CAT533_STRING_MAX_H;
       
     gdi_layer_push_clip();
     gdi_layer_set_clip(x1, y1, x2, y2);
     gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
       
     gui_measure_character((UI_character_type)'[', &bracket_width, &bracket_height);
     bracket_width += 2;  /* border text */
     bracket_height += 2; /* border text */
     x =  (x1 + 1) ;
     y = y1 + ((WGUI_CAT533_STRING_MAX_H - bracket_height) >> 1) + 1;   /* central y in refresh region */
     gui_move_text_cursor(x, y);
     gui_print_bordered_text(L"[");
            
      /* print "]" */
      gui_measure_character((UI_character_type)']', &bracket_width, &bracket_height);
      bracket_width += 2;  /* border text */
      bracket_height += 2; /* border text */
      x = (x2 - bracket_width);
      y = y1 + ((WGUI_CAT533_STRING_MAX_H - bracket_height) >> 1) + 1;
      gui_move_text_cursor(x, y);
      gui_print_bordered_text(L"]");
      gdi_layer_pop_clip();
}

static void wgui_cat533_draw_extra_information(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w;
    S32 bracket_width = 0, bracket_height = 0;	
    UI_string_type extra_string = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    extra_string = wgui_cat033_get_extra_text();
    //extra_string = (L"extra_stringextra_stringextra_stringextra_stringextra_string");
    g_wgui_cat533_cntx_p->extra_scrolling_text_ptr = &(g_wgui_cat533_cntx_p->extra_scrolling_text);
    
    /* show extra information */
    if (extra_string != NULL && g_wgui_cat533_cntx_p->extra_scrolling_text_ptr != NULL)
    {           
        S32 x1 = 0, y1 = 0, x2 = 0, y2 = 0;
        
        gui_set_font(&MMI_medium_font);
        gui_set_text_color(*current_MMI_theme->idle_scr_network_extra_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_extra_border_color);
        
        w = gui_get_string_width(extra_string) + 2;
        x1 = MMI_IDLE_STRING_MARGIN_GAP;
        y1 = WGUI_CAT533_STRING_EXTRA_Y;
        x2 = UI_device_width - MMI_IDLE_STRING_MARGIN_GAP - 1;
        y2 = y1 + WGUI_CAT533_STRING_MAX_H;
        
        gui_measure_character((UI_character_type)'[', &bracket_width, &bracket_height);
        bracket_width += 2;  /* border text */

        wgui_cat533_show_bracket();  // show bracket

        if (w < (UI_device_width - ((MMI_IDLE_STRING_MARGIN_GAP + bracket_width+2) * 2)))
        {
            /* align in center */
            x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (w >> 1)) : ((UI_device_width >> 1) - (w >> 1));
            x += (r2lMMIFlag) ? (-1) : (1); /* border text */
            y = y1 + 1; /* border text */
            gui_move_text_cursor(x, y);
            gui_print_text(extra_string);
        }
        else
        {
            /* scrolling text */
            w = UI_device_width - (MMI_IDLE_STRING_MARGIN_GAP + bracket_width + 4) * 2;
            gui_create_scrolling_text(
                g_wgui_cat533_cntx_p->extra_scrolling_text_ptr,
                (UI_device_width - w)/2, /* scrolling text reserve 4 pixels in x-coordinate, x have to move 2 pixels */
                y1 + 1, /* scrolling text reserve 2 pixels in y-coordinate, y have to move 1 pixel */
                w, /* scrolling text reserve 4 pixels in x-coordinate */
                WGUI_CAT533_STRING_MAX_H - 2, /* scrolling text reserve 2 pixels in y-coordinate */
                extra_string,
                wgui_cat533_handle_extra_text_scroll,
                wgui_cat533_redraw_extra_text_background,
                *current_MMI_theme->idle_scr_network_extra_color,
                *current_MMI_theme->idle_scr_network_extra_border_color);
            (g_wgui_cat533_cntx_p->extra_scrolling_text_ptr)->scroll_gap = 20;
            gui_show_scrolling_text(g_wgui_cat533_cntx_p->extra_scrolling_text_ptr);
        }           
    } 
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_draw_details 
 * DESCRIPTION
 *  Draw the displayed details of category533,
 *  including date, time, network name, extra information(if needed).
 *  After drawing details, please remember to redraw toolbar again.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat533_draw_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* assume base layer */
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    
    gdi_layer_push_clip();
    gdi_layer_set_clip(
              0, 
              MMI_STATUS_BAR_HEIGHT,
              MAIN_LCD_DEVICE_WIDTH - 1,
              MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - 1);
    
    /* clear operator name area */
    gdi_draw_solid_rect(
              0, 
              WGUI_CAT533_STRING_NETWORK_NAME_Y, 
              MAIN_LCD_DEVICE_WIDTH - 1, 
              WGUI_CAT533_STRING_NETWORK_NAME_Y + WGUI_CAT533_STRING_MAX_H - 1, 
              GDI_COLOR_TRANSPARENT);

    /* clear operator status area */
    gdi_draw_solid_rect(
              0, 
              WGUI_CAT533_STRING_NETWORK_STATUS_Y, 
              MAIN_LCD_DEVICE_WIDTH - 1, 
              WGUI_CAT533_STRING_NETWORK_STATUS_Y + WGUI_CAT533_STRING_MAX_H - 1, 
              GDI_COLOR_TRANSPARENT);

    /* clear extra area */
    gdi_draw_solid_rect(
              0, 
              WGUI_CAT533_STRING_EXTRA_Y, 
              MAIN_LCD_DEVICE_WIDTH - 1, 
              WGUI_CAT533_STRING_EXTRA_Y + WGUI_CAT533_STRING_MAX_H - 1, 
              GDI_COLOR_TRANSPARENT);

    /* clear date time area */
    gdi_draw_solid_rect(
              0, 
              MAIN_LCD_DEVICE_HEIGHT- MMI_BUTTON_BAR_HEIGHT - WGUI_CAT533_STRING_H_GAP - WGUI_CAT533_STRING_MAX_H,
              MAIN_LCD_DEVICE_WIDTH - 1, 
              MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - WGUI_CAT533_STRING_H_GAP - 1,
              GDI_COLOR_TRANSPARENT);

    if (wgui_toolbar_is_active() == MMI_FALSE)
    {        
        /* When toolbar is inactive, draw date, time, network name, extra information */
    
        /* draw date time */         
        wgui_clock_measure_time_text(wgui_cat533_clock_time, &w, &h, &MMI_medium_font);
        x = UI_device_width - WGUI_CAT533_STRING_W_GAP - w;
        y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - WGUI_CAT533_STRING_H_GAP - h;
        wgui_clock_move(wgui_cat533_clock_time, x, y);
        wgui_clock_resize(wgui_cat533_clock_time, w, h);
        
        wgui_clock_measure_date_text(wgui_cat533_clock_date, &w, &h, &MMI_medium_font);
        x = WGUI_CAT533_STRING_W_GAP;
        y = UI_device_height - MMI_BUTTON_BAR_HEIGHT -WGUI_CAT533_STRING_H_GAP - h;
        wgui_clock_move(wgui_cat533_clock_date, x, y);
        wgui_clock_resize(wgui_cat533_clock_date, w, h);

        wgui_clock_show_main_lcd();
		
		/* draw network name */
		if (idle_screen_network_name != NULL)
		{        
            wgui_cat533_draw_string_center_align(
                          idle_screen_network_name, 
                          WGUI_CAT533_STRING_W_GAP * 2,
                          WGUI_CAT533_STRING_NETWORK_NAME_Y,
                          UI_device_width - WGUI_CAT533_STRING_W_GAP * 2 + 1,
                          WGUI_CAT533_STRING_NETWORK_NAME_Y + WGUI_CAT533_STRING_MAX_H - 1,
						  *current_MMI_theme->idle_scr_network_name_color,
						  *current_MMI_theme->idle_scr_network_name_border_color);
		}

        /* draw network status */
        //idle_screen_network_status = (L"idle_screen_network_statusidle_screen_network_status");
        if (idle_screen_network_status != NULL)
        {
            wgui_cat533_draw_string_center_align(
                          idle_screen_network_status, 
                          WGUI_CAT533_STRING_W_GAP * 2,
                          WGUI_CAT533_STRING_NETWORK_STATUS_Y,
                          UI_device_width - WGUI_CAT533_STRING_W_GAP * 2 + 1,
                          WGUI_CAT533_STRING_NETWORK_STATUS_Y + WGUI_CAT533_STRING_MAX_H - 1,
						  *current_MMI_theme->idle_scr_network_status_color,
						  *current_MMI_theme->idle_scr_network_status_border_color);
        }

        /* draw extra information */
        do
        {
            /* previous scroll process */
            if (g_wgui_cat533_cntx_p->extra_scrolling_text_ptr != NULL)
            {
                if (g_wgui_cat533_cntx_p->animation_callback == MMI_TRUE
                    && ((g_wgui_cat533_cntx_p->extra_scrolling_text_ptr)->flags & UI_SCROLLING_TEXT_ENABLE_SCROLL))
                {
		    wgui_cat533_show_bracket();  // show bracket
                    /* animation callback -> redraw scrolling text */
                    gui_redraw_scrolling_text(g_wgui_cat533_cntx_p->extra_scrolling_text_ptr);
                    break;
                }
                else
                {
                    /* refresh to new string: stop previous text scrolling */
                    gui_scrolling_text_stop(g_wgui_cat533_cntx_p->extra_scrolling_text_ptr);
                    g_wgui_cat533_cntx_p->extra_scrolling_text_ptr = NULL;
                }
            }
            wgui_cat533_draw_extra_information();
        } while(0);
    }
    else
    {
        /* when toolbar is active, date time is not displayed in the screen.
         * So move date time to the invisible area.
         */
        wgui_clock_move(wgui_cat533_clock_time, -UI_device_width, -UI_device_height);
        wgui_clock_move(wgui_cat533_clock_date, -UI_device_width, -UI_device_height);

        /* stop scrolling text */
        if (g_wgui_cat533_cntx_p->extra_scrolling_text_ptr != NULL)
        {
            gui_scrolling_text_stop(g_wgui_cat533_cntx_p->extra_scrolling_text_ptr);
            g_wgui_cat533_cntx_p->extra_scrolling_text_ptr = NULL;
        }
    }
    gdi_layer_pop_clip();
    
    gdi_layer_pop_and_restore_active();
    
    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_update_details 
 * DESCRIPTION
 *  Update the displayed details of category533,
 *  including redrawing the tool bar.
 *  This API is for application to update the operator name, extra information, and so on.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat533_update_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* draw details */
    wgui_cat533_draw_details();

    /* redraw toolbar */
    wgui_toolbar_redraw();

    gdi_layer_unlock_frame_buffer();
    
    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_draw_controlled_area1 
 * DESCRIPTION
 *  draw category 433 screen controlled area 1
 *  controlled area 1 is used to draw date, time, operator name, tool bar
 * PARAMETERS
 *  coordinate  [IN]    coordinate
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat533_draw_controlled_area1(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    x = coordinate->s16X;
    y = coordinate->s16Y;
    w = coordinate->s16Width;
    h = coordinate->s16Height;
    
    /* set softkey layer */
    wgui_softkey_set_target_layer(dm_get_layer_handle(1));  /* assume base layer */

    /* clear */
    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, x + w - 1, y + h - 1);    
    gdi_draw_solid_rect(x, y, x + w - 1, y + h - 1, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_clip();

    /* display details */
    wgui_cat533_draw_details();

    /* allocate toolbar popup menu memory */
    MMI_ASSERT(g_wgui_cat533_cntx_p->popout_menu_memory == NULL);
    g_wgui_cat533_cntx_p->popout_menu_memory = mmi_frm_scrmem_alloc(SCRMEM_CAT533_POOL_SIZE);
    MMI_ASSERT(g_wgui_cat533_cntx_p->popout_menu_memory);

    /* create toolbar popup menu layer */
    MMI_ASSERT(g_wgui_cat533_cntx_p->popout_menu_layer == NULL);
    dm_create_layer_using_outside_memory(
            0, 0, GDI_LCD_WIDTH, GDI_LCD_HEIGHT,
            &g_wgui_cat533_cntx_p->popout_menu_layer,
            g_wgui_cat533_cntx_p->popout_menu_memory,
            SCRMEM_CAT533_POOL_SIZE,
            DM_LAYER_TOP);
    MMI_ASSERT(g_wgui_cat533_cntx_p->popout_menu_layer);

    /* init layer */
    gdi_layer_push_and_set_active(*g_wgui_cat533_cntx_p->popout_menu_layer);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();

    /* setup tool bar layout information */
    wgui_toolbar_move(coordinate->s16X, WGUI_CAT533_TOOLBAR_Y);
    wgui_toolbar_resize(coordinate->s16Width, UI_device_height - WGUI_CAT533_TOOLBAR_Y - MMI_BUTTON_BAR_HEIGHT + 1);
    wgui_toolbar_set_layers(
            dm_get_layer_handle(1),     /* tool bar layer is base layer */
            *g_wgui_cat533_cntx_p->popout_menu_layer,
            dm_get_layer_handle(0));    /* wallpaper layer is new layer */

    /* display toolbar component */
    wgui_toolbar_show();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_blt_before_callback 
 * DESCRIPTION
 *  draw category533 BLT before callback
 * PARAMETERS
 *  result   [IN]  GDI result
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat533_blt_before_callback(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    wgui_status_icon_bar_update();
    gdi_layer_pop_and_restore_active();
	
    g_wgui_cat533_cntx_p->animation_callback = MMI_TRUE;
    wgui_cat533_draw_details();
    g_wgui_cat533_cntx_p->animation_callback = MMI_FALSE;

    /* redraw tool bar */
    wgui_toolbar_redraw();

    /* dimmed out wallpaper */
    wgui_cat533_set_wallpaper_opacity();

   
    show_softkey_background();
    redraw_left_softkey();
    redraw_right_softkey();
    redraw_center_softkey();

    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_draw_controlled_area2 
 * DESCRIPTION
 *  draw category 533 screen controlled area 2
 *  controlled area 2 is used to draw wallpaper
 * PARAMETERS
 *  coordinate  [IN]    coordinate
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat533_draw_controlled_area2(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* register blt before callback */
    gdi_anim_set_blt_before_callback(wgui_cat533_blt_before_callback);

    /* draw wallpaper */
    draw_wallpaper();

    wgui_cat533_set_wallpaper_opacity();

    /* reset blt before callback */
    gdi_anim_set_blt_before_callback(wgui_category_dummy_callback);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_init_date_and_time 
 * DESCRIPTION
 *  Init category533 date & time component
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat533_init_date_and_time(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w = 0, h = 0, x = 0, y = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* time */
    wgui_clock_create(
        &wgui_cat533_clock_time,         /* time */
        0, 0, 0, 0,                     /* will move & assign layer */
        GUI_CLOCK_MAINLCD_TYPE_DIGITAL_TIME);   /* display digital time */

    /* set time string attribute */
    wgui_clock_set_text_border_enable(wgui_cat533_clock_time, MMI_TRUE);
    wgui_clock_set_time_text_border_color(wgui_cat533_clock_time, *current_MMI_theme->idle_scr_time_border_color);
    wgui_clock_set_time_text_color(wgui_cat533_clock_time, *current_MMI_theme->idle_scr_time_color);
    wgui_clock_set_time_text_font(wgui_cat533_clock_time, &MMI_medium_font);

    /* set time string clear function */
    wgui_clock_set_hide_function(wgui_cat533_clock_time, wgui_category_clear_region_with_transparent_color);

    /* set time string position & size */
    wgui_clock_measure_time_text(wgui_cat533_clock_time, &w, &h, &MMI_medium_font);
    x = UI_device_width - WGUI_CAT533_STRING_W_GAP - w;
    y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - WGUI_CAT533_STRING_H_GAP - h;
    wgui_clock_move(wgui_cat533_clock_time, x, y);
    wgui_clock_resize(wgui_cat533_clock_time, w, h);

    wgui_clock_set_digital_align_type(wgui_cat533_clock_time, GUI_CLOCK_DIGITAL_ALIGN_RIGHT);

    /* date */
    wgui_clock_create(
        &wgui_cat533_clock_date,               /* local date */
        0, 0, 0, 0,                           /* will move & assign layer */
        GUI_CLOCK_MAINLCD_TYPE_DIGITAL_DATE);         /* display date and day */

    /* set date string attribute */
    wgui_clock_set_text_border_enable(wgui_cat533_clock_date, MMI_TRUE);
    wgui_clock_set_date_text_border_color(wgui_cat533_clock_date, *current_MMI_theme->idle_scr_date_border_color);
    wgui_clock_set_date_text_color(wgui_cat533_clock_date, *current_MMI_theme->idle_scr_date_color);
    wgui_clock_set_date_text_font(wgui_cat533_clock_date, &MMI_medium_font);

    /* set date string clear function */
    wgui_clock_set_hide_function(wgui_cat533_clock_date, wgui_category_clear_region_with_transparent_color);

    /* set date string position & size */
    wgui_clock_measure_date_text(wgui_cat533_clock_date, &w, &h, &MMI_medium_font);
    x = WGUI_CAT533_STRING_W_GAP;
    y = UI_device_height - MMI_BUTTON_BAR_HEIGHT -WGUI_CAT533_STRING_H_GAP - h;
    wgui_clock_move(wgui_cat533_clock_date, x, y);
    wgui_clock_resize(wgui_cat533_clock_date, w, h);

    wgui_clock_set_digital_align_type(wgui_cat533_clock_date, GUI_CLOCK_DIGITAL_ALIGN_LEFT);    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_set_toolbar_status 
 * DESCRIPTION
 *  set toolbar state in category533
 * PARAMETERS
 *  state    [IN]  toolbar state
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat533_set_toolbar_state(mmi_gui_toolbar_state_enum state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* set toolbar state */
    wgui_toolbar_set_bar_state(state);

    /* draw detail: becase wgui_toolbar_set_bar_state() will blt to LCD,
                    wgui_cat533_draw_details() must be after wgui_toolbar_set_bar_state() */
    wgui_cat533_draw_details();    

    /* redraw toolbar */
    wgui_toolbar_redraw();

    /* dimmed out wallpaper */
    wgui_cat533_set_wallpaper_opacity();
    
    gdi_layer_unlock_frame_buffer();

    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_set_popout_menu_state 
 * DESCRIPTION
 *  set popout menu state in category533
 * PARAMETERS
 *  index    [IN]  menu index
 *  state    [IN]  menu state
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat533_set_popout_menu_state(S32 index, mmi_gui_toolbar_popout_menu_state_enum state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* draw details */
    wgui_cat533_draw_details();

    /* set popout menu state */
    wgui_toolbar_set_popout_menu_state(index, state);

    /* redraw toolbar */
    wgui_toolbar_redraw();
    
    gdi_layer_unlock_frame_buffer();    

    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_set_history 
 * DESCRIPTION
 *  Set category533 screen data from history
 * PARAMETERS
 *  buffer                    [IN]   history buffer
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat533_set_history(U8* buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 size;
    wgui_cat533_history_struct* history;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* set wallpaper layer data */
    history = (wgui_cat533_history_struct*)buffer;
    g_wgui_cat533_history_p->background_color = history->background_color;
    g_wgui_cat533_history_p->wallpaper_opacity_enable = history->wallpaper_opacity_enable;
    g_wgui_cat533_history_p->wallpaper_opacity_value = history->wallpaper_opacity_value;    

    /* set toolbar data */    
    size = ((sizeof(wgui_cat533_history_struct) + 3) / 4) * 4;
    wgui_toolbar_set_history((wgui_toolbar_history_struct*)(buffer + size));      
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_get_history_size
 * DESCRIPTION
 *  Gets the size of history data for category533
 * PARAMETERS
 *  void
 * RETURNS
 *  history size
 *****************************************************************************/
S32 wgui_cat533_get_history_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(wgui_cat533_history_struct) + 3) / 4) * 4 + sizeof(wgui_toolbar_history_struct));
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat533_get_history
 * DESCRIPTION
 *  Set the data for category533 into history buffer
 * PARAMETERS
 *  buffer      [OUT]   history buffer
 * RETURNS
 *  history
 *****************************************************************************/
U8* wgui_cat533_get_history(U8* buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 size;
    wgui_cat533_history_struct* history;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* wallpaper layer data */
    history = (wgui_cat533_history_struct*)buffer;
    history->background_color = g_wgui_cat533_history_p->background_color;
    history->wallpaper_opacity_enable = g_wgui_cat533_history_p->wallpaper_opacity_enable;
    history->wallpaper_opacity_value = g_wgui_cat533_history_p->wallpaper_opacity_value;

    /* toolbar data */    
    size = ((sizeof(wgui_cat533_history_struct) + 3) / 4) * 4;
    wgui_toolbar_get_history((wgui_toolbar_history_struct*)(buffer + size));
    
    return buffer;
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory533Screen 
 * DESCRIPTION
 *  Exit category533 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory533Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* stop wallpaper animation */
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
        animation_handle = GDI_ERROR_HANDLE;
    }

    /* stop scrolling text */
    if (g_wgui_cat533_cntx_p->extra_scrolling_text_ptr)
    {
        gui_scrolling_text_stop(g_wgui_cat533_cntx_p->extra_scrolling_text_ptr);
        g_wgui_cat533_cntx_p->extra_scrolling_text_ptr = NULL;
    }

    /* close toolbar component */
    wgui_toolbar_close();

    /* free toolbar popout menu layer */
    g_wgui_cat533_cntx_p->popout_menu_layer = NULL;

    /* free toolbar popout menu memory */
    if (g_wgui_cat533_cntx_p->popout_menu_memory != NULL)
    {
        mmi_frm_scrmem_free(g_wgui_cat533_cntx_p->popout_menu_memory);
        g_wgui_cat533_cntx_p->popout_menu_memory = NULL;
    }

    /* close date time component */
    wgui_clock_close(wgui_cat533_clock_time);
    wgui_clock_close(wgui_cat533_clock_date);
    wgui_cat533_clock_time = WGUI_CLOCK_INVALID_INDEX;
    wgui_cat533_clock_date = WGUI_CLOCK_INVALID_INDEX;

    /* free global context */
    if (g_wgui_cat533_cntx_p)
    {
        OslMfree(g_wgui_cat533_cntx_p);
        g_wgui_cat533_cntx_p = NULL;
    }

    /* free global context */
    if (g_wgui_cat533_history_p)
    {
        OslMfree(g_wgui_cat533_history_p);
        g_wgui_cat533_history_p = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory533Screen 
 * DESCRIPTION
 *  Show category533 screen (Vodafone homescreen)
 *  This category only support in non-touch project
 * PARAMETERS
 *  left_softkey                    [IN]   left softkey string
 *  left_softkey_icon               [IN]   left softkey icon
 *  right_softkey                   [IN]   right softkey string
 *  right_softkey_icon              [IN]   right softkey icon
 *  number_of_toolbar_menu          [IN]   number of toolbar menu
 *  icons_of_toolbar_menu_normal    [IN]   icon of toolbar menu icon in normal state
 *  icons_of_toolbar_menu_highlight [IN]   icon of toolbar menu icon in highlight state
 *  icons_of_toolbar_menu_state     [IN]   toolbar menu state
 *  get_menu_data_callback          [IN]   get menu data callback function
 *  menu_highlight_handler          [IN]   menu highlight handler
 *  history_buffer                  [IN]   history buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory533Screen(
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        S32 number_of_toolbar_menu,
        PU8* icons_of_toolbar_menu_normal,
        PU8* icons_of_toolbar_menu_highlight,
        mmi_gui_toolbar_popout_menu_state_enum* icons_of_toolbar_menu_state,
        wgui_toolbar_getmenudata_funcptr_type* get_menu_data_callback,
        wgui_toolbar_popout_menu_highlighthandler_funcptr_type* menu_highlight_handler,
        U8* history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* pre-process memory */
    if (g_wgui_cat533_cntx_p != NULL)
    {
        OslMfree(g_wgui_cat533_cntx_p);
		g_wgui_cat533_cntx_p = NULL;
    }   
    /* allocate context memory */
    g_wgui_cat533_cntx_p = OslMalloc(sizeof(wgui_cat533_context_struct));
    MMI_ASSERT(g_wgui_cat533_cntx_p);
    memset(g_wgui_cat533_cntx_p, 0, sizeof(wgui_cat533_context_struct));
    g_wgui_cat533_cntx_p->animation_callback = MMI_FALSE;

    /* pre-process memory */
    if (g_wgui_cat533_history_p != NULL)
    {
        OslMfree(g_wgui_cat533_history_p);
	    g_wgui_cat533_history_p = NULL;
    }   
    /* allocate context memory */
    g_wgui_cat533_history_p = OslMalloc(sizeof(wgui_cat533_history_struct));
    MMI_ASSERT(g_wgui_cat533_history_p);
    memset(g_wgui_cat533_history_p, 0, sizeof(wgui_cat533_history_struct));
        
    gdi_layer_lock_frame_buffer();

    /* set softkey */
    dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);

    /* create date time component */
    wgui_cat533_init_date_and_time();

    /* create side bar component */
    wgui_toolbar_create(
            0, 0,   /* will move later */
            0, 0,   /* will resize later */
            GDI_NULL_HANDLE, GDI_NULL_HANDLE, GDI_NULL_HANDLE,  /* will set layer later */
            number_of_toolbar_menu,
            icons_of_toolbar_menu_normal,
            icons_of_toolbar_menu_highlight,
            get_menu_data_callback,
            menu_highlight_handler,
            icons_of_toolbar_menu_state);

    /* set history */
    if (history_buffer)
    {        
        wgui_cat533_set_history(history_buffer);  
        g_wgui_cat533_cntx_p->from_history = MMI_TRUE;
    }   
    else
    {
        g_wgui_cat533_cntx_p->from_history = MMI_FALSE;
    }

    wgui_set_wallpaper_on_bottom(MMI_TRUE);

    gdi_layer_unlock_frame_buffer();

    /* Setup category/draw manager data */
    ExitCategoryFunction = ExitCategory533Screen;
    dm_setup_category_functions(MMI_dummy_function, wgui_cat533_get_history, wgui_cat533_get_history_size);
    dm_register_category_controlled_callback(wgui_cat533_draw_controlled_area1);
    dm_register_category_controlled2_callback(wgui_cat533_draw_controlled_area2);

    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY533_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_SET_AS_ABM_LAYER;
    dm_setup_data(&dm_data);

    dm_redraw_category_screen();
}
#endif /* __MMI_OP12_CAT533_SUPPORT__ */

#ifdef __MMI_CAT203_SUPPORT__

#ifdef __MMI_TOUCH_SCREEN__
static MMI_BOOL g_wgui_cat203_is_vk_input = MMI_FALSE;
#endif

S32 (*g_wgui_cat203_search_function) (UI_buffer_type) = NULL;
void (*g_wgui_cat203_resize_and_draw_func) (S32) = NULL;

#ifdef __MMI_FTE_SUPPORT__
void (*g_wgui_cat203_highlight_handler) (S32) = NULL;
U16 g_wgui_cat203_button_id = 0;
#endif

UI_filled_area string_bg_filler = {UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {50, 50, 50, 100},
    0
};
#ifndef __MMI_FTE_SUPPORT__
UI_string_type g_info = NULL;
#endif


UI_multi_line_input_box_theme MMI_ml_inputbox_theme = 
{ 
    (UI_filled_area *)NULL,
    (UI_filled_area *)NULL,
    (UI_filled_area *)NULL,
    {0, 0, 0, 100},
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    {0, 0, 255, 100},
    &UI_DEFAULT_FONT,
    1,
    0,
    '*',
    5
};

#ifdef __MMI_TOUCH_SCREEN__
mmi_pen_hdlr g_wui_cat203_original_pen_long_tap_handler = NULL;
mmi_pen_hdlr g_wui_cat203_original_pen_up_handler = NULL;
#endif /* __MMI_TOUCH_SCREEN__ */

#if (defined __MMI_TOUCH_SCREEN__)
static U16 g_wgui_cat203_center_string = 0;
static U16 g_wgui_cat203_center_icon = 0;
static MMI_BOOL g_wgui_cat203_enable_center_softkey = MMI_FALSE;
#endif /* (defined __MMI_TOUCH_SCREEN__) */

#if (defined __MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_enable_center_softkey
 * DESCRIPTION
 *  set center softkey parameter
 * PARAMETERS
 *  string     [IN]    center softkey string
 *  icon       [IN]    center softkey icon
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_enable_center_softkey(U16 string, U16 icon)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	g_wgui_cat203_enable_center_softkey = MMI_TRUE;
	g_wgui_cat203_center_string = string;
    g_wgui_cat203_center_icon = icon;
}
#endif /* (defined __MMI_TOUCH_SCREEN__) */


#ifdef __MMI_FTE_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_register_highlight_handler
 * DESCRIPTION
 *  register category203 highlight handler
 * PARAMETERS
 *  f      [IN]   highlight handler function
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_register_highlight_handler(void (*f) (S32))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat203_highlight_handler = f;
    RegisterHighlightHandler(f);
}
#endif /* __MMI_FTE_SUPPORT__ */ 

/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_get_hw_area
 * DESCRIPTION
 *  Get hand writing area 
 * PARAMETERS
 *  x       [IN/OUT]   X coordinate of hand writing area
 *  y       [IN/OUT]   Y coordinate of hand writing area
 *  w       [IN/OUT]   Width of hand writing area
 *  h       [IN/OUT]   Height of  hand writing area
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_get_hw_area(S32 *x, S32 *y, S32 *w, S32 *h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *x = MMI_fixed_list_menu.x;
    *y = MMI_fixed_list_menu.y;
    *w = MMI_fixed_list_menu.width - current_MMI_theme->scrollbar_size;
    *h = MMI_fixed_list_menu.height;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_resize_and_draw
 * DESCRIPTION
 *  1. resize dynamic list 
 *  2. redraw all component in the screen
 * PARAMETERS
 *  virtual_keyboard_h            [IN]          Height of virtual keyboard
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_resize_and_draw(S32 virtual_keyboard_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_h;
    #ifdef __MMI_FTE_SUPPORT__
    icontext_button *bs_bt;
    #endif
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    gdi_layer_lock_frame_buffer();    
#ifndef __MMI_FTE_SUPPORT__    
    /* set dynamic list position and resize it */    
    menu_h = UI_device_height - MMI_STATUS_BAR_HEIGHT - CAT203_MULTI_LINE_INPUTBOX_H - CAT203_STRING_H - virtual_keyboard_h - MMI_BUTTON_BAR_HEIGHT;
    wgui_dynamic_list_move_icontext_menu(CAT203_CONTENT_X, CAT203_DYNAMIC_LIST_Y);
    wgui_dynamic_list_resize_icontext_menu(CAT203_CONTENT_W, menu_h);
    dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);

    /* clear background and show singleline inputbox */
    gdi_draw_solid_rect(
        CAT203_CONTENT_X, 
        CAT203_MULTI_LINE_INPUTBOX_Y, 
        CAT203_CONTENT_X + CAT203_CONTENT_W - 1, 
        CAT203_MULTI_LINE_INPUTBOX_Y + CAT203_MULTI_LINE_INPUTBOX_H - 1, 
        GDI_COLOR_TRANSPARENT); 
    show_multiline_inputbox();

    /* clear background and show dynamic list */
    gdi_draw_solid_rect(
        CAT203_CONTENT_X, 
        CAT203_DYNAMIC_LIST_Y, 
        CAT203_CONTENT_X + CAT203_CONTENT_W - 1, 
        CAT203_DYNAMIC_LIST_Y + menu_h - 1, 
        GDI_COLOR_TRANSPARENT);
    redraw_dynamic_list();
#else /* __MMI_FTE_SUPPORT__ */ 
    /* set dynamic list position and resize it */    
    menu_h = UI_device_height - MMI_STATUS_BAR_HEIGHT - CAT203_BACKSPACE_H - virtual_keyboard_h - MMI_BUTTON_BAR_HEIGHT;
    if ((MMI_fixed_list_menu.width != CAT203_DYNAMIC_LIST_W) || (MMI_fixed_list_menu.height != menu_h))
    {
        wgui_dynamic_list_resize_icontext_menu(CAT203_DYNAMIC_LIST_W, menu_h);
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
    }

    if (wgui_cat203_is_editor_active())
    {
        MMI_fixed_list_menu.highlighted_item = WGUI_LIST_INVALID_HIGHLIGHT;
    }
    
    /* clear background and show singleline inputbox */
    gdi_draw_solid_rect(
        CAT203_CONTENT_X, 
        CAT203_DYNAMIC_LIST_Y + menu_h, 
        CAT203_CONTENT_X + CAT203_CONTENT_W - 1, 
        CAT203_DYNAMIC_LIST_Y + menu_h + CAT203_BACKSPACE_H - 1, 
        GDI_COLOR_TRANSPARENT); 
    //wgui_inputs_sl_move(CAT203_SL_INPUTBOX_X, CAT203_DYNAMIC_LIST_Y + menu_h - 1);
    wgui_inputs_sl_move(CAT203_SL_INPUTBOX_X, CAT203_DYNAMIC_LIST_Y + menu_h);
    
    //if (mmi_imc_get_vk_present() == MMI_IMC_VK_DEFAULT_HIDE)
    if (virtual_keyboard_h < CAT203_VK_DEFAULE_H)
    {
        wgui_inputs_sl_resize(UI_device_width - (CAT203_SL_INPUTBOX_X << 1), MMI_singleline_inputbox.height);
    }
    else
    {
        wgui_inputs_sl_resize(CAT203_SL_INPUTBOX_W, MMI_singleline_inputbox.height);
    }
    wgui_inputs_sl_show();
    
    /* setup backspace button */
#ifdef __MMI_TOUCH_SCREEN__
    bs_bt = dm_get_button(g_wgui_cat203_button_id);
    //if (mmi_imc_get_vk_present() == MMI_IMC_VK_DEFAULT_HIDE)
    if (virtual_keyboard_h < CAT203_VK_DEFAULE_H)
    {
        gui_move_icontext_button(bs_bt, 0, 0);
        gui_resize_icontext_button(bs_bt, 0, 0);
        gui_icontext_button_overwirte_pen_response_area(bs_bt, 0, 0, 0, 0);
    }
    else
    { 
        gui_move_icontext_button(
            bs_bt, 
            CAT203_BACKSPACE_X,
            MMI_singleline_inputbox.y + CAT203_BACKSPACE_Y_BASED_ON_SL - 1);
        gui_resize_icontext_button(bs_bt, CAT203_BACKSPACE_W, CAT203_BACKSPACE_H);
        gui_icontext_button_overwirte_pen_response_area(
            bs_bt,
            bs_bt->x,
            bs_bt->y,
            bs_bt->x + bs_bt->width,
            bs_bt->y + bs_bt->height);
        gui_show_icontext_button(bs_bt);
    }
#endif

    /* clear background and show dynamic list */
    gdi_draw_solid_rect(
        CAT203_CONTENT_X, 
        CAT203_DYNAMIC_LIST_Y, 
        CAT203_CONTENT_X + CAT203_CONTENT_W - 1, 
        CAT203_DYNAMIC_LIST_Y + menu_h - 1, 
        GDI_COLOR_TRANSPARENT);
    redraw_dynamic_list();
    RegisterHighlightHandler(g_wgui_cat203_highlight_handler);
    
#endif /* __MMI_FTE_SUPPORT__ */ 
    gdi_layer_unlock_frame_buffer();
}


#ifndef __MMI_FTE_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_set_editor_focus_state
 * DESCRIPTION
 *  set editor status (focus or unfocus)
 * PARAMETERS
 *  active     [IN]   focus or unfocus
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_set_editor_focus_state(MMI_BOOL active)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_font_type cur_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    if (active == MMI_TRUE)
    {
        MMI_ml_inputbox_theme.normal_filler = current_MMI_theme->inputbox_filler;
        MMI_ml_inputbox_theme.selected_filler = current_MMI_theme->inputbox_filler;
        MMI_ml_inputbox_theme.text_font = MMI_multiline_inputbox.text_font;
        MMI_ml_inputbox_theme.cursor_color = (*current_MMI_theme->inputbox_cursor_color);

        gui_set_multi_line_input_box_theme(&MMI_multiline_inputbox, &MMI_ml_inputbox_theme);
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_STATE_FOCUSSED;
        MMI_multiline_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_STATE_NORMAL;
        MMI_multiline_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW;

        wgui_inputs_ml_register_keys();
#ifndef __OP11__
        wgui_inputs_ml_set_RSK();    
#endif
    }
    else
    {             
        cur_font = MMI_multiline_inputbox.text_font;
        gui_set_multi_line_input_box_current_theme(&MMI_multiline_inputbox);
        MMI_multiline_inputbox.text_font = cur_font;

        MMI_multiline_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_STATE_FOCUSSED;
        MMI_multiline_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_STATE_NORMAL | UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW);

        ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
        ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_DOWN);
        StopTimer(BLINKING_CURSOR); /* disable cursor */
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_set_menu_focus_state
 * DESCRIPTION
 *  set menu status (focus or unfocus)
 * PARAMETERS
 *  active     [IN]   focus or unfocus
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_set_menu_focus_state(MMI_BOOL active)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    if (active == MMI_TRUE)
    {
        MMI_fixed_icontext_menuitem.flags &= ~UI_MENUITEM_DISABLE_HIGHLIGHT;
        MMI_fixed_icontext_menuitem.ext_flags &= ~UI_MENUITEM_EXT_DISABLED_SCROLL;
        register_dynamic_list_keys();
#ifndef __OP11__
        set_right_softkey_label(get_string(STR_GLOBAL_BACK));
        //set_right_softkey_icon(wgui_singleline_inputbox_RSK_label_icon);
        redraw_right_softkey();
        set_right_softkey_function(wgui_inputs_ml_register_handle_right_softkey_up, KEY_EVENT_DOWN);
        set_right_softkey_function(NULL, KEY_LONG_PRESS);
#endif
        wgui_inputs_ml_move_cursor(WGUI_INPUTS_CURSOR_POS_END);
    }
    else
    {
        MMI_fixed_icontext_menuitem.flags |= UI_MENUITEM_DISABLE_HIGHLIGHT;
        MMI_fixed_icontext_menuitem.ext_flags |= UI_MENUITEM_EXT_DISABLED_SCROLL;
    }
}

#else /* #ifndef __MMI_FTE_SUPPORT__ */

/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_set_editor_focus_state
 * DESCRIPTION
 *  set editor status (focus or unfocus)
 * PARAMETERS
 *  active     [IN]   focus or unfocus
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_set_editor_focus_state(MMI_BOOL active)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_font_type cur_font;
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    if (active == MMI_TRUE)
    {
        ret = wgui_cat203_is_editor_active();
        MMI_singleline_inputbox.flags &= ~UI_SINGLE_LINE_INPUT_BOX_STATE_NORMAL;
        MMI_singleline_inputbox.flags &= ~UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW;

        wgui_inputs_sl_register_keys();
#ifndef __OP11__
        if (ret == MMI_FALSE)
        {
            wgui_inputs_sl_set_RSK();
        }
#endif
    }
    else
    {                
        MMI_singleline_inputbox.flags |= (UI_SINGLE_LINE_INPUT_BOX_STATE_NORMAL | UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW);

        ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
        ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_DOWN);
        StopTimer(BLINKING_CURSOR); /* disable cursor */
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_set_menu_focus_state
 * DESCRIPTION
 *  set menu status (focus or unfocus)
 * PARAMETERS
 *  active     [IN]   focus or unfocus
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_set_menu_focus_state(MMI_BOOL active)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    if (active == MMI_TRUE)
    {
        MMI_fixed_icontext_menuitem.flags &= ~UI_MENUITEM_DISABLE_HIGHLIGHT;
        MMI_fixed_icontext_menuitem.ext_flags &= ~UI_MENUITEM_EXT_DISABLED_SCROLL;
        register_dynamic_list_keys();
#ifndef __OP11__
        set_right_softkey_label(get_string(STR_GLOBAL_BACK));
        //set_right_softkey_icon(wgui_singleline_inputbox_RSK_label_icon);
        redraw_right_softkey();
        set_right_softkey_function(NULL, KEY_EVENT_DOWN);
        set_right_softkey_function(wgui_singleline_inputbox_RSK_function, KEY_EVENT_UP);
        set_right_softkey_function(NULL, KEY_LONG_PRESS);
#endif
        wgui_inputs_sl_move_cursor(WGUI_INPUTS_CURSOR_POS_END);
    }
    else
    {
        MMI_fixed_icontext_menuitem.flags |= UI_MENUITEM_DISABLE_HIGHLIGHT;
        MMI_fixed_icontext_menuitem.ext_flags |= UI_MENUITEM_EXT_DISABLED_SCROLL;
        //MMI_fixed_list_menu.highlighted_item = WGUI_LIST_INVALID_HIGHLIGHT;
        if (g_wgui_cat203_highlight_handler)
        {
            g_wgui_cat203_highlight_handler(WGUI_LIST_INVALID_HIGHLIGHT);
        }
        gui_pop_up_description_stop_scroll();
        gui_fixed_icontext_menuitem_stop_scroll();
    }
}

#endif /* #ifndef __MMI_FTE_SUPPORT__ */
/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_is_editor_active
 * DESCRIPTION
 *  get if focus on editor
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat203_is_editor_active(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
#ifndef __MMI_FTE_SUPPORT__
    if (MMI_multiline_inputbox.flags & UI_MULTI_LINE_INPUT_BOX_STATE_FOCUSSED)
    {
        result = MMI_TRUE;        
    }
#else
    if (!(MMI_singleline_inputbox.flags & (UI_SINGLE_LINE_INPUT_BOX_STATE_NORMAL | UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW)))
    {
        result = MMI_TRUE;        
    }
#endif
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_is_menu_active
 * DESCRIPTION
 *  get if focus on menu
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat203_is_menu_active(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    if (MMI_fixed_icontext_menuitem.flags & ~UI_MENUITEM_DISABLE_HIGHLIGHT)
    {
        result = MMI_TRUE;        
	}
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_refresh_search_list
 * DESCRIPTION
 *  refresh search list
 * PARAMETERS
 *  input_number   [IN]   input number for searching
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_refresh_search_list(U8 *input_number)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 no_entries = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    no_entries = g_wgui_cat203_search_function(input_number);
    init_dynamic_item_buffer(no_entries, dynamic_item_buffer.load_func, dynamic_item_buffer.hint_func, UI_dummy_function);
    MMI_fixed_list_menu.n_items = no_entries;           
    dynamic_list_goto_item_no_redraw(0);
    
#if(UI_ENABLE_POP_UP_DESCRIPTIONS)
    gui_pop_up_description_stop_scroll();
#endif 
    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
    redraw_dynamic_list();
}

#ifndef __MMI_FTE_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_singleline_inputbox_input_callback
 * DESCRIPTION
 *  When singleline inputbox changed, this function will be called to set 
 *  highlight on editor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_multiline_inputbox_input_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_ml_handle_input();

    gdi_layer_lock_frame_buffer();    

    wgui_cat203_refresh_search_list(MMI_multiline_inputbox.text);

    /* set editor active */
    wgui_cat203_set_editor_focus_state(MMI_TRUE);
    redraw_multiline_inputbox();
    /* set menu inactive */
    wgui_cat203_set_menu_focus_state(MMI_FALSE);    
    dynamic_list_goto_item_no_redraw(0);
    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
    redraw_dynamic_list();

    gdi_layer_unlock_frame_buffer();   
    gdi_lcd_repaint_all();
}
#else /* __MMI_FTE_SUPPORT__ */
/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_singleline_inputbox_input_callback
 * DESCRIPTION
 *  When singleline inputbox changed, this function will be called to set 
 *  highlight on editor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_singleline_inputbox_input_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();    

    wgui_cat203_refresh_search_list(MMI_singleline_inputbox.text);

    /* set editor active */
    wgui_cat203_set_editor_focus_state(MMI_TRUE);
    wgui_inputs_sl_handle_input();
    wgui_inputs_sl_redraw();
    /* set menu inactive */
    wgui_cat203_set_menu_focus_state(MMI_FALSE);    
    dynamic_list_goto_item_no_redraw(0);
    MMI_fixed_list_menu.highlighted_item = WGUI_LIST_INVALID_HIGHLIGHT;
    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
    redraw_dynamic_list();

    gdi_layer_unlock_frame_buffer();    
    gdi_lcd_repaint_all();
}

#endif /* __MMI_FTE_SUPPORT__ */


#ifndef __MMI_FTE_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_menu_pre_key_handler
 * DESCRIPTION
 *  pre-key handler for menu
 *  when up/down/left/right, this function will be called to set highlight
 * PARAMETERS
 *  key_code     [IN]  key code
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat203_menu_pre_key_handler(MMI_key_code_type key_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE; /* when result = MMI_TRUE, menu or editor will not process key event */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (key_code)
    {
        /* menu key */    
        case KEY_UP_ARROW:
        case KEY_VOL_UP:
            if (wgui_cat203_is_menu_active() == MMI_TRUE)
            {
                if (MMI_fixed_list_menu.highlighted_item == 0) /* highilight on the first item */
                {
                    /* set menu inactive */                    
                    wgui_cat203_set_menu_focus_state(MMI_FALSE);
                    dynamic_list_goto_item_no_redraw(0);
                    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
                    redraw_dynamic_list();
                    
                    /* set editor active */
                    wgui_cat203_set_editor_focus_state(MMI_TRUE);
                    redraw_multiline_inputbox();
                    result = MMI_TRUE;
                }
            }
            break;
        case KEY_DOWN_ARROW:
        case KEY_VOL_DOWN:   
            if (wgui_cat203_is_menu_active() == MMI_TRUE)/* highlight on menu */
            {
                /* set editor inactive */
                if (MMI_fixed_list_menu.highlighted_item == MMI_fixed_list_menu.n_items - 1)
                {
                    /* set menu inactive */                    
                    wgui_cat203_set_menu_focus_state(MMI_FALSE);
                    dynamic_list_goto_item_no_redraw(0);
                    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
                    redraw_dynamic_list();
                    
                    /* set editor active */
                    wgui_cat203_set_editor_focus_state(MMI_TRUE);
                    redraw_multiline_inputbox();
                    result = MMI_TRUE;                

                }
            }
            break;
        default:
            break; 
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_editor_pre_key_handler
 * DESCRIPTION
 *  pre-key handler for menu
 *  when up/down/left/right, this function will be called to set highlight
 * PARAMETERS
 *  key_code     [IN]  key code
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat203_editor_pre_key_handler(S16 key_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE; /* when result = MMI_TRUE, menu or editor will not process key event */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (key_code)
    {
        /* menu key */    
        case KEY_UP_ARROW:
        case KEY_VOL_UP:
            if (gui_multi_line_input_box_test_first_line(&MMI_multiline_inputbox))  /* cursor at first line */
            {
                if(MMI_fixed_list_menu.n_items > 0)
                {
                    gdi_layer_lock_frame_buffer();

                    /* set editor inactive */
                    wgui_cat203_set_editor_focus_state(MMI_FALSE);
                    redraw_multiline_inputbox();            
                    /* set menu active and highlight on the first item */
                    wgui_cat203_set_menu_focus_state(MMI_TRUE);
                    dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.n_items - 1);
                    redraw_dynamic_list();                    

                    gdi_layer_unlock_frame_buffer();
                    gdi_lcd_repaint_all();
                    result = MMI_TRUE;
                }
                
            }            
            break;
        case KEY_DOWN_ARROW:
        case KEY_VOL_DOWN:   
            if (gui_multi_line_input_box_test_last_line(&MMI_multiline_inputbox))  /* cursor at first line */
            {
                if(MMI_fixed_list_menu.n_items > 0)
                {
                    gdi_layer_lock_frame_buffer();

                    /* set editor inactive */
                    wgui_cat203_set_editor_focus_state(MMI_FALSE);
                    redraw_multiline_inputbox();            
                    /* set menu active and highlight on the first item */
                    wgui_cat203_set_menu_focus_state(MMI_TRUE);
                    dynamic_list_goto_item_no_redraw(0);
                    redraw_dynamic_list();

                    gdi_layer_unlock_frame_buffer();
                    gdi_lcd_repaint_all();
                    result = MMI_TRUE;
                }
            }
            break;
        default:
            break; 
    }
    return result;
}

#else /* #ifndef __MMI_FTE_SUPPORT__ */

/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_menu_pre_key_handler
 * DESCRIPTION
 *  menu pre-key handler
 * PARAMETERS
 *  key_code    [IN]   key code
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat203_menu_pre_key_handler(MMI_key_code_type key_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE; /* when result = MMI_TRUE, menu will not process key event */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (key_code)
    {
        /* menu key */    
        case KEY_UP_ARROW:
        case KEY_VOL_UP:
            if (wgui_cat203_is_editor_active() == MMI_TRUE)
            {   
                /* set menu inactive */
                wgui_cat203_set_menu_focus_state(MMI_TRUE);
                wgui_cat203_set_editor_focus_state(MMI_FALSE);
                //dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.n_items - 1);
                dynamic_list_goto_item_no_redraw(0);
                redraw_dynamic_list();

                wgui_inputs_sl_redraw();
                
                result = MMI_TRUE;
            }            
            else if (wgui_cat203_is_menu_active() == MMI_TRUE)
            {
                if (MMI_fixed_list_menu.highlighted_item == 0) /* highilight on the first item */
                {
                    /* editor do what? */
                    wgui_cat203_set_editor_focus_state(MMI_TRUE);
                    g_wgui_cat203_highlight_handler(WGUI_LIST_INVALID_HIGHLIGHT);
                    wgui_inputs_sl_redraw();
                    
                    /* set menu inactive */
                    wgui_cat203_set_menu_focus_state(MMI_FALSE);
                    dynamic_list_goto_item_no_redraw(0);
                    MMI_fixed_list_menu.highlighted_item = WGUI_LIST_INVALID_HIGHLIGHT;
                    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
                    redraw_dynamic_list();

                    result = MMI_TRUE;
                }
            }
            break;
        case KEY_DOWN_ARROW:
        case KEY_VOL_DOWN: 
            if (wgui_cat203_is_editor_active() == MMI_TRUE)
            {
                /* set menu active*/
                wgui_cat203_set_menu_focus_state(MMI_TRUE);

                /* set editor inactive */
                wgui_cat203_set_editor_focus_state(MMI_FALSE);

                dynamic_list_goto_item_no_redraw(0);
                redraw_dynamic_list();

                wgui_inputs_sl_redraw();
                
                result = MMI_TRUE;
            }
            else if (wgui_cat203_is_menu_active() == MMI_TRUE)/* highlight on menu */
            {
                if (MMI_fixed_list_menu.highlighted_item == MMI_fixed_list_menu.n_items - 1)
                {
                    /* set editor active */
                    wgui_cat203_set_editor_focus_state(MMI_TRUE);
                    g_wgui_cat203_highlight_handler(WGUI_LIST_INVALID_HIGHLIGHT);
                    wgui_inputs_sl_redraw();

                    /* set menu inactive */
                    wgui_cat203_set_menu_focus_state(MMI_FALSE);                    
                    dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.n_items - 1);
                    MMI_fixed_list_menu.highlighted_item = WGUI_LIST_INVALID_HIGHLIGHT;
                    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
                    redraw_dynamic_list();

                    result = MMI_TRUE;
                }
            }
            break;
        default:
            break; 
    }
    return result;
}
#endif /* #ifndef __MMI_FTE_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_is_vk_input
 * DESCRIPTION
 *  input by vk or key
 * PARAMETERS
 *  
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/ 
MMI_BOOL wgui_cat203_is_vk_input(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TOUCH_SCREEN__
    return g_wgui_cat203_is_vk_input;
#else
    return MMI_FALSE;
#endif
}


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_vk_pen_long_tap_handler
 * DESCRIPTION
 *  pen long tap handler to execute idle APP long tap handler
 *  only support 0~9, #, *
 * PARAMETERS
 *  pos            [IN]        pen postion
 * RETURNS
 *  void
 *****************************************************************************/ 
void wgui_cat203_vk_pen_long_tap_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_character_type character;
    FuncPtr key_handler = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_VIRTUAL_KEYBOARD__)
    /* get the character on virtual keyboard */
    wgui_virtual_keyboard_get_current_character(point.x, point.y, &character);
#endif

    /* execute pen lone tap handler of IME */
    if (g_wui_cat203_original_pen_long_tap_handler != NULL)
    {
        g_wui_cat203_original_pen_long_tap_handler(point);
    }

    /* if character is KEY_1 ~ KEY_9, KEY_POUND, KEY_STAR execute idle APP key long press handler */
    if (character >= 0x31 && character <= 0x39)   /* KEY_0 ~ KEY_9 */
    {  
        key_handler = GetKeyHandler((U16)(character - 0x30), KEY_EVENT_LONG_PRESS);
        if (key_handler != NULL)
        {
            g_wgui_cat203_is_vk_input = MMI_TRUE;
            SetkeyInfo((U16)(character - 0x30), KEY_EVENT_LONG_PRESS);
            key_handler();
            g_wgui_cat203_is_vk_input = MMI_FALSE;
        }
    }
    else if (character == 0x23)  /* KEY_POUND */
    {
        key_handler = GetKeyHandler(KEY_POUND, KEY_EVENT_LONG_PRESS);
        if (key_handler != NULL)
        {
            g_wgui_cat203_is_vk_input = MMI_TRUE;
            SetkeyInfo(KEY_POUND, KEY_EVENT_LONG_PRESS);
            key_handler();
            g_wgui_cat203_is_vk_input = MMI_FALSE;
        }
    }
    else if (character == 0x2A)  /* KEY_STAR */
    {
        key_handler = GetKeyHandler(KEY_STAR, KEY_EVENT_LONG_PRESS);
        if (key_handler != NULL)
        {
            SetkeyInfo(KEY_STAR, KEY_EVENT_LONG_PRESS);
            key_handler();
        }
    }    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_vk_pen_up_handler
 * DESCRIPTION
 *  pen up handler to execute idle APP up handler
 *  only support 0~9, #, *, +, p, w
 * PARAMETERS
 *  pos            [IN]        pen postion
 * RETURNS
 *  void
 *****************************************************************************/ 
void wgui_cat203_vk_pen_up_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_character_type character;
    FuncPtr key_handler = NULL;
    S32 old_highlight;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_VIRTUAL_KEYBOARD__)
    /* get the character on virtual keyboard */
    wgui_virtual_keyboard_get_current_character(point.x, point.y, &character);
#endif

    /* execute pen up handler of IME */
    if (g_wui_cat203_original_pen_up_handler != NULL)
    {
#ifdef __MMI_FTE_SUPPORT__
        register_dynamic_list_keys();
#endif
        old_highlight = MMI_fixed_list_menu.highlighted_item;
        g_wui_cat203_original_pen_up_handler(point);
        if ((g_dm_data.s32CatId == MMI_CATEGORY203_ID)  && (!wgui_cat203_is_editor_active()))
        {
            MMI_fixed_list_menu.highlighted_item = old_highlight;
            if (MMI_fixed_list_menu.highlighted_item == WGUI_LIST_INVALID_HIGHLIGHT)
            {
                wgui_cat203_set_editor_focus_state(MMI_TRUE);

#ifdef __MMI_FTE_SUPPORT__
                if (!mmi_imc_is_clipboard_state())
                {
                    wgui_inputs_sl_redraw();
                }
#endif
                wgui_cat203_set_menu_focus_state(MMI_FALSE);
            }
        }
    }	

    /* if character key handler is registed by APP, execute idle APP key up handler */
    if (character == 0x23) /* # => KEY_POUND */
    {
        key_handler = GetKeyHandler(KEY_POUND, KEY_EVENT_UP);
        if (key_handler != NULL)
        {
            SetkeyInfo(KEY_POUND, KEY_EVENT_UP);
            key_handler();
            SetkeyInfo(KEY_POUND, MAX_KEY_TYPE);
        }
    }
    else if (character >= 0x30 && character <= 0x39)   /* 0 ~ 9 => KEY_0 ~ KEY_9 */
    {  
        key_handler = GetKeyHandler((character - 0x30), KEY_EVENT_UP);
        if (key_handler != NULL)
        {
            SetkeyInfo((character - 0x30), KEY_EVENT_UP);
            key_handler();
            SetkeyInfo((character - 0x30), MAX_KEY_TYPE);
        }
    }
    else if (character == 0x2A || character == 0x2B || character == 0x70 || character == 0x77) /* multitap: *, +, p, w  => KEY_STAR */
    {  
        key_handler = GetKeyHandler(KEY_STAR, KEY_EVENT_UP);
        if (key_handler != NULL)
        {
            SetkeyInfo(KEY_STAR, KEY_EVENT_UP);
            key_handler();
            SetkeyInfo(KEY_STAR, MAX_KEY_TYPE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_virtual_keypad_callback
 * DESCRIPTION
 *  show virtual keypad
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_virtual_keypad_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_imc_redraw_screen_by_state();
    
#ifndef __MMI_FTE_SUPPORT__
    if (wgui_cat203_is_editor_active() == MMI_TRUE)
    {            
        register_multiline_inputbox_keys();
    }
    else
    {       
        ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
        ClearKeyHandler(KEY_LEFT_ARROW, KEY_EVENT_DOWN);
        StopTimer(BLINKING_CURSOR); /* disable cursor */
    }
#endif
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_vk_pause_scolling_callback
 * DESCRIPTION
 *  when vk popup displays, need to pause scolling
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL wgui_cat203_vk_pause_scolling_callback(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    extern S32 gblock_list_effect;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
    S32 temp;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_cat203_is_editor_active() == MMI_FALSE)
    {            
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        temp = gblock_list_effect;
        gblock_list_effect = 1;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
      
        gui_fixed_icontext_menuitem_start_scroll();
#if(UI_ENABLE_POP_UP_DESCRIPTIONS)
        gui_pop_up_description_stop_scroll();
#endif 
        wgui_dynamic_list_show_icontext_menu();
#if(UI_ENABLE_POP_UP_DESCRIPTIONS)		
        gui_pop_up_description_stop_scroll();
#endif
        gui_fixed_icontext_menuitem_stop_scroll();

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gblock_list_effect = temp;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
        return MMI_TRUE;
    }
    return MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_vk_resume_scolling_callback
 * DESCRIPTION
 *  when vk popup displays, need to resume scolling
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_vk_resume_scolling_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //S32 temp;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_cat203_is_editor_active() == MMI_FALSE)
    {            
        gui_fixed_icontext_menuitem_start_scroll();
        show_dynamic_list();
    }
}


#ifndef __MMI_FTE_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_controlled_area_pen_down_handler
 * DESCRIPTION
 *  pen down handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat203_controlled_area_pen_down_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    gui_list_pen_enum menu_event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_fixed_list_menu.pen_redraw_menu_function = wgui_dynamic_list_show_icontext_menu;
    gui_vertical_scrollbar_set_pen_self_scroll(&MMI_fixed_list_menu.vbar, MMI_TRUE);
    gui_fixed_list_menu_set_pen_scroll_delay(&MMI_fixed_list_menu, /*GUI_DYNAMIC_LIST_PEN_SCROLL_DELAY*/0);

    ret = gui_dynamic_list_menu_translate_pen_event(
            &MMI_fixed_list_menu,
            MMI_PEN_EVENT_DOWN,
            point.x,
            point.y,
            &menu_event);
    if (ret)
    {
        if (menu_event == GUI_LIST_PEN_HIGHLIGHT_CHANGED || menu_event == GUI_LIST_PEN_NEED_REDRAW)
        {
            wgui_cat203_set_menu_focus_state(MMI_TRUE);
            dynamic_list_highlight_handler(MMI_fixed_list_menu.highlighted_item);
            //redraw_dynamic_list();
            MMI_fixed_list_menu.pen_redraw_menu_function();
            wgui_cat203_set_editor_focus_state(MMI_FALSE);
            redraw_multiline_inputbox();
        }
        else if (wgui_cat203_is_editor_active() == MMI_TRUE)
        {
            /* set editor inactive */
            wgui_cat203_set_editor_focus_state(MMI_FALSE);
            redraw_multiline_inputbox();
            /* set menu active and highlight on the first item */
            wgui_cat203_set_menu_focus_state(MMI_TRUE);
            dynamic_list_goto_item_no_redraw(0);
            redraw_dynamic_list();
        }
            
        return MMI_TRUE;
    }
	else
	{
        return MMI_FALSE;
	}
}

#else /* __MMI_FTE_SUPPORT__ */

/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_controlled_area_pen_down_handler
 * DESCRIPTION
 *  pen down handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat203_controlled_area_pen_down_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    gui_list_pen_enum menu_event;
    S32 list_h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CLIPBOARD__
    if (mmi_imc_is_clipboard_state())
    {
        return ret;
    }
#endif /* __MMI_CLIPBOARD__ */

    MMI_fixed_list_menu.pen_redraw_menu_function = wgui_dynamic_list_show_icontext_menu;
    gui_vertical_scrollbar_set_pen_self_scroll(&MMI_fixed_list_menu.vbar, MMI_TRUE);
    gui_fixed_list_menu_set_pen_scroll_delay(&MMI_fixed_list_menu, GUI_DYNAMIC_LIST_PEN_SCROLL_DELAY);

    if ((MMI_fixed_list_menu.n_items * MMI_MENUITEM_HEIGHT) > MMI_fixed_list_menu.height)
    {
        list_h = MMI_fixed_list_menu.height;
    }
    else
    {
        list_h = MMI_fixed_list_menu.n_items * MMI_MENUITEM_HEIGHT;
    }
    
#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
    if (PEN_CHECK_BOUND(
            point.x, 
            point.y, 
            MMI_fixed_list_menu.x, 
            MMI_fixed_list_menu.y, 
            MMI_fixed_list_menu.width, 
            list_h))
    {
        if (wgui_cat203_is_editor_active() == MMI_TRUE)
        {
            gui_lock_double_buffer();
            wgui_cat203_set_menu_focus_state(MMI_TRUE);
            dynamic_list_highlight_handler(MMI_fixed_list_menu.highlighted_item);
            wgui_cat203_set_editor_focus_state(MMI_FALSE);
            redraw_singleline_inputbox();
            gui_unlock_double_buffer();
        }
    }
    return MMI_FALSE;
#else
    ClearHighlightHandler();
    ret = gui_dynamic_list_menu_translate_pen_event(
            &MMI_fixed_list_menu,
            MMI_PEN_EVENT_DOWN,
            point.x,
            point.y,
            &menu_event);
    RegisterHighlightHandler(g_wgui_cat203_highlight_handler);
    if (ret)
    {
        if (menu_event == GUI_LIST_PEN_HIGHLIGHT_CHANGED 
            || menu_event == GUI_LIST_PEN_NEED_REDRAW 
            || wgui_cat203_is_editor_active() == MMI_TRUE)
        {
            wgui_cat203_set_menu_focus_state(MMI_TRUE);
            dynamic_list_highlight_handler(MMI_fixed_list_menu.highlighted_item);
            redraw_dynamic_list();
            wgui_cat203_set_editor_focus_state(MMI_FALSE);
            redraw_singleline_inputbox();
        }
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }    
#endif /* GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN */
}
#endif /* __MMI_FTE_SUPPORT__ */

/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_controlled_area_pen_up_handler
 * DESCRIPTION
 *  pen up handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat203_controlled_area_pen_up_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_UP);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_controlled_area_pen_move_handler
 * DESCRIPTION
 *  pen move handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat203_controlled_area_pen_move_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_MOVE);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_controlled_area_pen_long_tap_handler
 * DESCRIPTION
 *  pen long tap handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat203_controlled_area_pen_long_tap_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_LONG_TAP);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_controlled_area_pen_repeat_handler
 * DESCRIPTION
 *  pen repeat handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/ 
MMI_BOOL wgui_cat203_controlled_area_pen_repeat_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_REPEAT);
    return ret;
}
#endif /* __MMI_TOUCH_SCREEN__ */


#ifndef __MMI_FTE_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_draw_info_string 
 * DESCRIPTION
 *  show info string
 * PARAMETERS
 *  info
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat203_draw_info_string(UI_string_type info)
{
    S32 string_width, string_height;
    S32 x, y;
    
    gui_push_text_clip();
    gui_push_clip();

    gui_set_clip(
            CAT203_CONTENT_X,
            CAT203_STRING_Y,
            CAT203_CONTENT_X + CAT203_CONTENT_W - 1,
            CAT203_STRING_Y + CAT203_STRING_H - 1);
    
    gui_draw_filled_area(
            CAT203_CONTENT_X,
            CAT203_STRING_Y,
            CAT203_CONTENT_X + CAT203_CONTENT_W - 1,
            CAT203_STRING_Y + CAT203_STRING_H - 1,
            &string_bg_filler);

    gui_set_font(&MMI_medium_font);
    gui_measure_string(info, &string_width, &string_height);

    if (r2lMMIFlag)
    {
        x = CAT203_CONTENT_X + CAT203_CONTENT_W - 1;
    }
    else
    {
        x = 0;
    }
    y = CAT203_STRING_Y + ((CAT203_STRING_H - string_height)>>1);

    gui_set_text_clip(
        CAT203_CONTENT_X,
        CAT203_STRING_Y,
        CAT203_CONTENT_X + CAT203_CONTENT_W - 1,
        CAT203_STRING_Y + CAT203_STRING_H - 1);

    gui_set_text_color(UI_COLOR_BLACK);
    
    gui_move_text_cursor(x, y);
    gui_set_line_height(string_height);

    if (string_width > CAT203_CONTENT_W)
    {
        gui_print_truncated_text(x, y, string_width, info);
    }
    else
    {
        gui_print_text(info);
    }

    gui_pop_text_clip();
    gui_pop_clip();

}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_draw_ctrl_area2 
 * DESCRIPTION
 *  draw category 203 screen control area 2
 * PARAMETERS
 *  coordinate  [IN/OUT]    coordinate
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat203_draw_ctrl_area2(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat203_draw_info_string(g_info);
}
#endif


#ifdef __MMI_FTE_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_backspace_button_down_handler
 * DESCRIPTION
 *  search button handler.
 * PARAMETERS
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  hitsory buffer
 *****************************************************************************/
static void wgui_cat203_backspace_button_down_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_sl_delete_character();
   // gui_start_timer(CAT203_DELETE_ALL_TIMER, wgui_inputs_sl_delete_all_characters);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_backspace_button_repeat_handler
 * DESCRIPTION
 *  search button handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  hitsory buffer
 *****************************************************************************/
static void wgui_cat203_backspace_button_repeat_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_inputs_sl_is_empty())
    {
        return;
    }

    wgui_inputs_fast_del_nav_handler(WGUI_INPUTS_OPER_FAST_DEL, WGUI_INPUTS_EDITOR_SL, WGUI_INPUTS_TP_REPEAT_PERIOD);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_backspace_button_down_handler
 * DESCRIPTION
 *  search button handler.
 * PARAMETERS
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  hitsory buffer
 *****************************************************************************/
static void wgui_cat203_backspace_button_up_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(wgui_inputs_sl_delete_all_characters);
}


extern UI_filled_area* dm_get_current_scr_bg_filler(void);
/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_clear_search_button_bg
 * DESCRIPTION
 *  clear button area.
 * PARAMETERS
 *  button   [IN]   button information
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat203_clear_search_button_bg(void *button)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button *b = (icontext_button*) button;
    S32 x1 = b->x;
    S32 y1 = b->y;
    S32 x2 = b->x + b->width - 1;
    S32 y2 = b->y + b->height - 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer(); 

    /* draw the background */  
    //gui_fill_rectangle(x1, y1, x2 + 1, y2 + 1, (*(current_MMI_theme->lite_disp_scr_bg_color)));
    
    //To do: use VK background theme after VK's theme is ready.
    //gdi_draw_solid_rect(x1, y1, x2 + 1, y2 + 1, GDI_COLOR_BLACK);
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height -1 , dm_get_current_scr_bg_filler());
    gdi_layer_pop_clip();

    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_backspace_button_down_handler
 * DESCRIPTION
 *  draw pen down of button
 * PARAMETERS
 *  button_object       [IN]        The target button
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat203_backspace_button_draw_down(void *button_object)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button *current_bt;
    GDI_HANDLE act_layer = GDI_NULL_HANDLE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_bt = dm_get_button(g_wgui_cat203_button_id);
    
    if (button_object != (void*)current_bt)
    {
        return MMI_TRUE;
    }
    
    mmi_imc_reset_ime_state();
    
    gdi_layer_get_active(&act_layer);
    
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_push_and_set_alpha_blending_source_layer(act_layer);
    }
    gui_icontext_button_show_down_by_pen((void*)current_bt);
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_pop_and_restore_alpha_blending_source_layer();
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_backspace_button_up_handler
 * DESCRIPTION
 *  draw pen up of button
 * PARAMETERS
 *  button_object       [IN]        The target button
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat203_backspace_button_draw_up(void *button_object)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button *current_bt;
    GDI_HANDLE act_layer = GDI_NULL_HANDLE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(wgui_inputs_sl_delete_all_characters);
    current_bt = dm_get_button(g_wgui_cat203_button_id);
    
    if (button_object != (void*)current_bt)
    {
        return MMI_TRUE;
    }
    
    gdi_layer_get_active(&act_layer);
    
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_push_and_set_alpha_blending_source_layer(act_layer);
    }
    gui_icontext_button_show_up_by_pen((void*)current_bt);
    if (act_layer != GDI_NULL_HANDLE)
    {
        gdi_pop_and_restore_alpha_blending_source_layer();
    }
    return MMI_TRUE;

}

/*****************************************************************************
* FUNCTION
*  wgui_cat203_draw_virtual_keypad_background
* DESCRIPTION
*  Draw the virtual keypad area by IME.
* PARAMETERS
*  x1      [IN]        start X
*  y1      [IN]        start Y
*  x2      [IN]        end X
*  y2      [IN]        end Y
* RETURNS
*  void
*****************************************************************************/
static void wgui_cat203_draw_virtual_keypad_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gui_fill_rectangle(x1, y1, x2, y2, (gui_color(0, 0, 255)));
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_stop_scroll
 * DESCRIPTION
 *  stop list scrolling text
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat203_stop_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_fixed_icontext_menuitem_stop_scroll();
    gui_pop_up_description_stop_scroll();
    //wgui_dynamic_list_show_icontext_menu();
    //gui_pop_up_description_stop_scroll();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_resume_scroll
 * DESCRIPTION
 *  resume list scrolling text
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat203_resume_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //gui_pop_up_description_stop_scroll();
    if ((MMI_fixed_list_menu.n_items > 0) && (MMI_fixed_list_menu.highlighted_item != WGUI_LIST_INVALID_HIGHLIGHT))
    {
        gui_fixed_icontext_menuitem_start_scroll();
    }
    wgui_dynamic_list_show_icontext_menu();
}
#endif /* __MMI_FTE_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  ShowCategory203Screen
 * DESCRIPTION
 *  category screen of orange dialer search
 * PARAMETERS
 *  left_softkey            [IN]        Left soft key label
 *  left_softkey_icon       [IN]        Left soft key icon
 *  right_softkey           [IN]        Right soft key label
 *  right_softkey_icon      [IN]        Right soft key icon
 *  message                 [IN]        Message between singleline inputbox & list menu
 *  number_of_items         [IN]        Number of items
 *  get_item_func           [IN]        Get menu item function
 *  get_hint_func           [IN]        Get menu hint funtion
 *  get_underline_func      [IN]        Get menu underline function
 *  search_func             [IN]        Search result function
 *  input_buffer            [IN]        Buffer for input
 *  input_buffer_max_length [IN]        Max length for input
 *  history_buffer          [IN]        Histpry buffer
 * RETURNS
 *  void
 *****************************************************************************/    
void ShowCategory203Screen(
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        UI_string_type message,
        S32 number_of_items,    
        GetItemFuncPtr get_item_func,
        GetHintFuncPtr get_hint_func,
        GetUnderLineFuncPtr get_underline_func,        
        S32(*search_func) (UI_buffer_type),
        U8 *input_buffer,
        S32 input_buffer_max_length,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    U8 h_flag;
    S32 no_entries;
#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    icontext_button *backspace_bt;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_PREFER_WRITING_LANG__) || defined(__MMI_MIXED_LANG_SUPPORT__)
    extern void mmi_imm_reset_user_desired_writing_language();
    mmi_imm_reset_user_desired_writing_language();
#endif
    
    gdi_layer_lock_frame_buffer();
#ifdef __MMI_MAINLCD_128X160__    
    ShowStatusIconsTitle();
#endif
    /* softkey */
    dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);

#ifndef __MMI_FTE_SUPPORT__
    /* string */    
    g_info = message;
#else
#if defined(__MMI_TOUCH_SCREEN__)
    /* setup button */
    g_wgui_cat203_button_id = dm_add_button(
                    NULL,
                    //get_image(IMG_BACKSPACE_BG_NORMAL),
                    //get_image(IMG_BACKSPACE_BG_DOWN),
                    get_image(IMG_CAT203_BS_BUTTON_NORMAL),
                    get_image(IMG_CAT203_BS_BUTTON_DOWN),
                    wgui_cat203_clear_search_button_bg);
    dm_register_button_functions(g_wgui_cat203_button_id, KEY_EVENT_DOWN, wgui_cat203_backspace_button_down_handler);
    dm_register_button_functions(g_wgui_cat203_button_id, KEY_EVENT_UP, wgui_cat203_backspace_button_up_handler);
    dm_register_button_functions(g_wgui_cat203_button_id, KEY_EVENT_LONG_PRESS, wgui_inputs_fast_del_nav_reset_repeat_count);
    dm_register_button_functions(g_wgui_cat203_button_id, KEY_EVENT_REPEAT, wgui_cat203_backspace_button_repeat_handler);
    backspace_bt = dm_get_button(g_wgui_cat203_button_id);
    backspace_bt->draw_down_fp = wgui_cat203_backspace_button_draw_down;
    backspace_bt->draw_up_fp = wgui_cat203_backspace_button_draw_up;
    backspace_bt->flags |= UI_BUTTON_NO_SHIFT_BUTTON;

    /* set VK default value */
    mmi_imc_set_vk_present(MMI_IMC_VK_DEFAULT_ENLARGE);
#endif /* defined(__MMI_TOUCH_SCREEN__) */
#endif

    /* register search function */
    if (search_func != NULL)
    {
        g_wgui_cat203_search_function = search_func;
    }    
    g_wgui_cat203_resize_and_draw_func = wgui_cat203_resize_and_draw;

    /* dynamic icontext list */
    wgui_dynamic_list_create_icontext_menu(
        number_of_items, 
        get_item_func, 
        get_hint_func, 
        WGUI_LIST_INVALID_HIGHLIGHT, 
        MMI_TRUE, 
        UI_dummy_function,
        WGUI_LIST_MENU_DISABLE_SHORTCUT,
        0,
        NULL);
            
    wgui_fixed_list_register_pre_key_handler(wgui_cat203_menu_pre_key_handler);

    wgui_fixed_list_register_get_underline_function(get_underline_func);
       
#ifdef __MMI_TOUCH_SCREEN__
    /* Because the list menu is resized according to virtual keyboard */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
    mmi_imc_disable_handwriting();
#endif /* __MMI_TOUCH_SCREEN__ */ 

#ifndef __MMI_FTE_SUPPORT__
    wgui_dynamic_list_resize_icontext_menu(CAT203_CONTENT_W, CAT203_DYNAMIC_LIST_H);
    wgui_dynamic_list_move_icontext_menu(CAT203_CONTENT_X, CAT203_DYNAMIC_LIST_Y);
#else
    wgui_dynamic_list_resize_icontext_menu(CAT203_DYNAMIC_LIST_W, CAT203_DYNAMIC_LIST_H);
    wgui_dynamic_list_move_icontext_menu(CAT203_DYNAMIC_LIST_X, CAT203_DYNAMIC_LIST_Y);
#endif    
    resize_dynamic_icontext_menuitems_to_list_width();

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_block_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */

#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
    gui_inputs_cache_switch(1);
#endif

    h_flag = set_list_menu_category_history(MMI_CATEGORY203_ID, history_buffer);
    if (!h_flag) /* initial */
    {
        /* menu */
        wgui_cat203_set_menu_focus_state(MMI_FALSE);
        dynamic_list_goto_item_no_redraw(0);
        
#ifndef __MMI_FTE_SUPPORT__
        /* multiline inputbox */ 
        wgui_inputs_ml_setup(
                    CAT203_CONTENT_X,
                    CAT203_MULTI_LINE_INPUTBOX_Y,
                    CAT203_CONTENT_W,
                    CAT203_MULTI_LINE_INPUTBOX_H,
                    input_buffer,
                    input_buffer_max_length,
                    MMI_CATEGORY203_ID,
                    right_softkey,
                    right_softkey_icon,
		            IMM_INPUT_TYPE_PHONE_NUMBER | INPUT_TYPE_PLUS_CHARACTER_HANDLING,
                    NULL,
                    0);
    #ifdef __MMI_EDITOR_MULTILINE_DIALER_STYLE_SUPPORT__
        /* Set dialer style */
        wgui_inputs_ml_set_style(UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR, GUI_MULTI_LINE_INPUT_BOX_DIALER_STYLE);
    #endif
        wgui_cat203_set_editor_focus_state(MMI_TRUE);

        /* need to redraw dynamic list when "input_buffer" has been entered
            (number has been dialed before 'dialer search' switches on)*/ 
        if (g_wgui_cat203_search_function)
        {
            no_entries = g_wgui_cat203_search_function((U8*) MMI_multiline_inputbox.text);
            init_dynamic_item_buffer(no_entries, dynamic_item_buffer.load_func, dynamic_item_buffer.hint_func, UI_dummy_function);
            MMI_fixed_list_menu.n_items = no_entries;
            dynamic_list_goto_item_no_redraw(0);
            redraw_dynamic_list();
        }
#else  /* __MMI_FTE_SUPPORT__ */
       /* singleline inputbox */ 
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_setup(
                    CAT203_SL_INPUTBOX_X,
                    CAT203_SL_INPUTBOX_Y,
                    CAT203_SL_INPUTBOX_W,
                    CAT203_SL_INPUTBOX_H,
                    input_buffer,
                    input_buffer_max_length,
                    MMI_CATEGORY203_ID,
                    right_softkey,
                    right_softkey_icon,
                    IMM_INPUT_TYPE_PHONE_NUMBER,////revise by Praney's patch
                    NULL,
                    0);

        gui_inputs_register_redraw_background_filler(wgui_cat203_draw_virtual_keypad_background);

        /* need to redraw dynamic list when "input_buffer" has been entered
            (number has been dialed before 'dialer search' switches on)*/ 
        if (g_wgui_cat203_search_function)
        {
            no_entries = g_wgui_cat203_search_function((U8*) MMI_singleline_inputbox.text);
            init_dynamic_item_buffer(no_entries, dynamic_item_buffer.load_func, dynamic_item_buffer.hint_func, UI_dummy_function);
            MMI_fixed_list_menu.n_items = no_entries;
            dynamic_list_goto_item_no_redraw(0);
            redraw_dynamic_list();
        }
        
#endif  /* __MMI_FTE_SUPPORT__ */    
    }
    else
    {  
        S32 s = sizeof(list_menu_category_history);
        s = (s + 3) / 4;
        s *= 4;

#ifndef __MMI_FTE_SUPPORT__
        /* multiline inputbox */
        wgui_inputs_ml_setup(
                    CAT203_CONTENT_X,
                    CAT203_MULTI_LINE_INPUTBOX_Y,
                    CAT203_CONTENT_W,
                    CAT203_MULTI_LINE_INPUTBOX_H,
                    input_buffer,
                    input_buffer_max_length,
                    MMI_CATEGORY203_ID,
                    get_string(STR_GLOBAL_BACK),
                    right_softkey_icon,
		            IMM_INPUT_TYPE_PHONE_NUMBER | INPUT_TYPE_PLUS_CHARACTER_HANDLING,
                    (U8*) (history_buffer + s),
                    0);
        
    #ifdef __MMI_EDITOR_MULTILINE_DIALER_STYLE_SUPPORT__
        /* Set dialer style */
        wgui_inputs_ml_set_style(UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR, GUI_MULTI_LINE_INPUT_BOX_DIALER_STYLE);
    #endif
        
        if (wgui_cat203_is_editor_active() == MMI_TRUE)  /* highlight on editor */
        {
            wgui_cat203_set_editor_focus_state(MMI_TRUE);
            wgui_cat203_set_menu_focus_state(MMI_FALSE);
            dynamic_list_goto_item_no_redraw(0);
        }
        else /* highlight on menu */
        {
            wgui_cat203_set_editor_focus_state(MMI_FALSE);
            wgui_cat203_set_menu_focus_state(MMI_TRUE);
        }
        
        if (g_wgui_cat203_search_function)
        {
            no_entries = g_wgui_cat203_search_function((U8*) MMI_multiline_inputbox.text);
            init_dynamic_item_buffer(no_entries, dynamic_item_buffer.load_func, dynamic_item_buffer.hint_func, UI_dummy_function);
            MMI_fixed_list_menu.n_items = no_entries;
            wgui_dynamic_list_resize_icontext_menu(MMI_fixed_list_menu.width, MMI_fixed_list_menu.height - wgui_inputs_get_current_imui_height(MMI_EDITOR_MULTILINE_INPUT_BOX));
            dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
            if (no_entries == 0)  /* when no result, highlight should back to editor */
            {
                wgui_cat203_set_editor_focus_state(MMI_TRUE);
                wgui_cat203_set_menu_focus_state(MMI_FALSE);
                dynamic_list_goto_item_no_redraw(0);
            }
            redraw_dynamic_list();
        }
#else  /* __MMI_FTE_SUPPORT__ */
        /* singleline inputbox */
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_setup(
                    CAT203_SL_INPUTBOX_X,
                    CAT203_SL_INPUTBOX_Y,
                    CAT203_SL_INPUTBOX_W,
                    CAT203_SL_INPUTBOX_H,
                    input_buffer,
                    input_buffer_max_length,
                    MMI_CATEGORY203_ID,
                    right_softkey,
                    right_softkey_icon,
                    IMM_INPUT_TYPE_PHONE_NUMBER,
                    (U8*) (history_buffer + s),
                    0);
        gui_inputs_register_redraw_background_filler(wgui_cat203_draw_virtual_keypad_background);

        if (wgui_cat203_is_editor_active() == MMI_TRUE)  /* highlight on editor */
        {
            wgui_cat203_set_editor_focus_state(MMI_TRUE);
            wgui_cat203_set_menu_focus_state(MMI_FALSE);
            dynamic_list_goto_item_no_redraw(0);
        }
        else /* highlight on menu */
        {
            wgui_cat203_set_editor_focus_state(MMI_FALSE);
            wgui_cat203_set_menu_focus_state(MMI_TRUE);
        }

        if (g_wgui_cat203_search_function)
        {
            no_entries = g_wgui_cat203_search_function((U8*) MMI_singleline_inputbox.text);
            init_dynamic_item_buffer(no_entries, dynamic_item_buffer.load_func, dynamic_item_buffer.hint_func, UI_dummy_function);
            MMI_fixed_list_menu.n_items = no_entries;
            wgui_dynamic_list_resize_icontext_menu(MMI_fixed_list_menu.width, MMI_fixed_list_menu.height - wgui_inputs_get_current_imui_height(MMI_EDITOR_MULTILINE_INPUT_BOX));
            dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
            set_list_menu_category_history(MMI_CATEGORY203_ID, history_buffer);
            if (no_entries == 0)  /* when no result, highlight should back to editor */
            {
                wgui_cat203_set_editor_focus_state(MMI_TRUE);
                wgui_cat203_set_menu_focus_state(MMI_FALSE);
                dynamic_list_goto_item_no_redraw(0);
            }
            redraw_dynamic_list();
        }
#endif  /* __MMI_FTE_SUPPORT__ */
    }

#ifndef __MMI_FTE_SUPPORT__
    /* multiline inputbox callback */
    wgui_inputs_ml_register_input_callback(wgui_cat203_multiline_inputbox_input_callback);
    wgui_inputs_ml_register_navigate_callback(wgui_cat203_multiline_inputbox_input_callback);
    wgui_inputs_ml_register_pre_key_handler(wgui_cat203_editor_pre_key_handler);
    
    /* In order to in keeping with dialer behavior (when the first character is "+", buffer should be inserted 41 characters) */
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_PLUS_CHARACTER_HANDLING;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR;
#else  /* __MMI_FTE_SUPPORT__ */
    /* singleline inputbox callback */
    wgui_inputs_sl_register_input_callback(wgui_cat203_singleline_inputbox_input_callback);
    wgui_inputs_sl_register_navigate_callback(wgui_cat203_singleline_inputbox_input_callback);
    RegisterHighlightHandler(g_wgui_cat203_highlight_handler);

    /* In order to in keeping with dialer behavior (when the first character is "+", buffer should be inserted 41 characters) */
    MMI_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_PLUS_CHARACTER_HANDLING;
#endif  /* __MMI_FTE_SUPPORT__ */

#if (defined __MMI_TOUCH_SCREEN__)
    /* disable IME to process center softkey, center softkey will reserve for APP */	
	if (g_wgui_cat203_enable_center_softkey == MMI_TRUE)
	{
		mmi_imc_disable_csk();
        EnableCenterSoftkey(g_wgui_cat203_center_string, g_wgui_cat203_center_icon);
	}
#endif /* (defined __MMI_TOUCH_SCREEN__) */


#if defined(__MMI_COSMOS_KEYPAD_SUPPORT_VK__)
mmi_imc_set_slider_status(OPEN);
#endif /*__MMI_COSMOS_KEYPAD_SUPPORT_VK__*/



#ifdef __MMI_FTE_SUPPORT__
    if (wgui_cat203_is_editor_active() == MMI_TRUE)
    {
        g_wgui_cat203_highlight_handler(WGUI_LIST_INVALID_HIGHLIGHT);
    }
    else if (wgui_cat203_is_menu_active() == MMI_TRUE)
    {
        g_wgui_cat203_highlight_handler(MMI_fixed_list_menu.highlighted_item);
    }
    
    wgui_icon_bar_register_pause_interactive_UI_callback(wgui_cat203_stop_scroll);
    wgui_icon_bar_register_resume_interactive_UI_callback(wgui_cat203_resume_scroll);

#endif 
    gdi_layer_unlock_frame_buffer();
    
    ExitCategoryFunction = ExitCategory203Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory203History, GetCategory203HistorySize);    

#ifndef __MMI_FTE_SUPPORT__
    dm_register_category_controlled2_callback(wgui_cat203_draw_ctrl_area2);
#endif

    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY203_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
#ifdef __MMI_VIRTUAL_KEYBOARD__
    dm_data.s32flags |= DM_SHOW_VKPAD;
    dm_register_vkpad_callback(wgui_cat203_virtual_keypad_callback);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat203_vk_resume_scolling_callback);
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat203_vk_pause_scolling_callback); 
#else 
    #ifdef __MMI_FTE_SUPPORT__
        dm_data.s32flags |= DM_SHOW_VKPAD;
        dm_register_vkpad_callback(mmi_imc_redraw_screen_by_state);
    #endif    
#endif 
    dm_setup_data(&dm_data);

#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(
        wgui_cat203_controlled_area_pen_down_handler, 
        MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(
        wgui_cat203_controlled_area_pen_up_handler, 
        MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(
        wgui_cat203_controlled_area_pen_move_handler,
        MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(
        wgui_cat203_controlled_area_pen_long_tap_handler,
        MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(
        wgui_cat203_controlled_area_pen_repeat_handler,
        MMI_PEN_EVENT_REPEAT);

    /* take pen up and pen long tap handler, and register a new handler */
    g_wui_cat203_original_pen_long_tap_handler = mmi_pen_get_pen_handler(MMI_PEN_EVENT_LONG_TAP);
    g_wui_cat203_original_pen_up_handler = mmi_pen_get_pen_handler(MMI_PEN_EVENT_UP);
    mmi_pen_register_long_tap_handler(wgui_cat203_vk_pen_long_tap_handler);
    mmi_pen_register_up_handler(wgui_cat203_vk_pen_up_handler);

#endif /* __MMI_TOUCH_SCREEN__ */ 
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory203Screen
 * DESCRIPTION
 *  exit function of category203
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory203Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
#if (defined __MMI_TOUCH_SCREEN__)
	g_wgui_cat203_enable_center_softkey = MMI_FALSE;
	g_wgui_cat203_center_string = 0;
	g_wgui_cat203_center_icon = 0;
#endif /* (defined __MMI_TOUCH_SCREEN__) */

    /* enable loop menu */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_LOOP;

    ClearHighlightHandler();
    reset_fixed_list();
    reset_dynamic_list();
    reset_pop_up_descriptions();
#ifndef __MMI_FTE_SUPPORT__
    wgui_inputs_ml_close();
#else
    /* set VK default value */
    mmi_imc_set_vk_present(MMI_IMC_VK_PRESENT_DEFAULT);
    wgui_inputs_sl_close();
    g_wgui_cat203_highlight_handler = NULL;
#endif

    g_wgui_cat203_search_function = NULL; 
    g_wgui_cat203_resize_and_draw_func = NULL;
#ifdef __MMI_TOUCH_SCREEN__
    g_wui_cat203_original_pen_long_tap_handler = NULL;
    g_wui_cat203_original_pen_up_handler = NULL;    
#endif /* __MMI_TOUCH_SCREEN__ */

#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    reset_all_force_flags_for_hints();
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */
#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
    gui_inputs_cache_switch(0);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory203HistorySize
 * DESCRIPTION
 *  Gets the history size of category203
 * PARAMETERS
 *  void
 * RETURNS
 *  S32
 *****************************************************************************/
S32 GetCategory203HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__
    return (((sizeof(list_menu_category_history) + 3) / 4) * 4 + sizeof(singleline_inputbox_category_history));
#else
    return (((sizeof(list_menu_category_history) + 3) / 4) * 4 + sizeof(multiline_inputbox_category_history));
#endif
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory203History
 * DESCRIPTION
 *  Gets the history buffer of category203
 * PARAMETERS
 *  history_buffer     [OUT]     Is the buffer into which the history data is stored
 * RETURNS
 *  return history buffer
 *****************************************************************************/
U8 *GetCategory203History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_list_menu_category_history(MMI_CATEGORY203_ID, history_buffer);
    s = sizeof(list_menu_category_history);
    s = (s + 3) / 4;
    s *= 4;
#ifdef __MMI_FTE_SUPPORT__
    wgui_inputs_sl_get_category_history(MMI_CATEGORY203_ID, (U8*) (history_buffer + s));
#else
    wgui_inputs_ml_get_category_history(MMI_CATEGORY203_ID, (U8*) (history_buffer + s));
#endif
    return (history_buffer);
}
#endif /* __MMI_CAT203_SUPPORT__ */


