/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *  HomeScreenOp11V32.c
 *
 * Project:
 * -------- 
 *  MAUI
 *
 * Description:
 * ------------
 *  OP11 HomeScreen version 3.1 & 3.2 main source file
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/****************************************************************************
* Include Files                                                                
*****************************************************************************/

#include "MMI_features.h"

#if defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)

/* Venus MMI headers: */
//#include "ui_core\base\vfx_base.h"
//#include "pluto_adapter\HomeScreen\vadp_p2v_op11_hs.h"
#include "vadp_p2v_op11_hs.h"
//#include "pluto_adapter\HomeScreen\vadp_v2p_op11_hs.h"
#include "vadp_v2p_op11_hs.h"

/* Pluto MMI headers: */
#include "SATGProts.h"
//#include "SimDetectionGexdcl.h"     /* g_charbat_context */
#include "PhoneSetupGprots.h"
//#include "IdleAppResDef.h"
#include "FileMgrSrvGProt.h"

#include "IdleGprot.h"

#include "common_nvram_editor_data_item.h"
#include "USBDeviceGprot.h"
#include "HomeScreenOp11V32Gprot.h"
#include "HomeScreenOp11V32.h"
#include "HomeScreenOp11V32Setting.h"
#include "mmi_rp_app_op11_hs32_def.h"

#ifdef __MMI_OP11_HS32_MEM_SHARE_MED__
#include "med_utility.h"
#endif

#include "ScrLockerGprot.h"
#include "MainMenuProt.h"

#include "nwinfosrvgprot.h"
#include "simctrlsrvgprot.h"

/* AP's headers  */
#include "PhoneBookGprot.h"
#include "phbcuigprot.h"
#include "PhoneBookResDef.h"
#include "custom_ecc.h"

#include "CallLogGprot.h" /* mmi_clog_op11_hs32_sb_check_num, mmi_clog_op11_hs32_shct_query_data, mmi_clog_mclt_launch */

//#include "CallManagementGprot.h" /* mmi_gsm_ussd_request_from_menu */
#include "SsGprot.h" /* mmi_ss_ussd_request_from_menu */
#include "UCMGProt.h" /* for launch call */
//#include "MMSAppExt.h" /* mmi_umms_pre_entry_inbox */

#ifdef __MMI_EMAIL__
#include "EmailAppGProt.h"  /* mmi_email_app_entry_inbox */
#endif

#include "AlarmGprot.h"  /* AP Alarms [ALM] */

#ifdef __MMI_BT_SUPPORT__
#include "BTMMIScrGprots.h"  /* AP Connections [CNX] */
#endif

#include "FlightModeGProt.h"  /* AP Connections [CNX] */

#include "ToDoListGprot.h"  /* AP Calendar [CAL] */
#include "CalendarGprot.h"  /* AP Calendar [CAL] */

#include "UMGProt.h"  /* mmi_um_pre_entry_sms_inbox */
//#include "UnifiedComposerGProt.h"  /* AP Message [MES] UC, include UMGProt.h first  */
#include "UcAppGProt.h" /* AP Message [MES] UC, 10A revise  */

#include "SmsAppGprot.h"  /* AP Message [MES] SMS  */
#include "MessagesMiscell.h"  /* AP Message [MES] SMS  */

#include "MMSAppOp.h"  /* AP Message [MES] MMS  */

#include "ImpsAppGprot.h"  /* AP Orange Messenger [OMR]  */

#include "Browser_api.h"       /* AP Orange World [OWD]  */
#include "ProfilesSrvGprot.h"     /* AP Profile [PRO]  */

#include "SATGProts.h"     /* AP SIM Toolkit [STK]  */

#if defined(__MMI_CAMCORDER__)
#include "mmi_features_camcorder.h"
#include "gdi_include.h"
#include "CamcorderGprot.h"  /* AP Photography [PHO] */
#elif defined(__MMI_CAMERA__)
#include "CameraApp.h"  /* AP Photography [PHO] */
#endif

#ifdef __MMI_IMAGE_VIEWER__
#include "ImageViewerGprot.h"  /* AP Photography [PHO] */
#endif

#ifdef __MMI_VIDEO_PLAYER__
#include "VdoPlyGProt.h"  /* AP Photography [PHO] */
#endif

#ifdef __MMI_MEDIA_PLAYER__
#include "MediaPlayerGProt.h"  /* AP Music [MUS]  */
#endif

#include "filemgrcuigprot.h"

#include "PhnsetGPIO.h" /* need menucuigprot.h firstly */

#include "modeswitchsrvgprot.h"
#include "mmi_rp_srv_flight_mode_def.h"

// auto add by kw_check begin
#include "MMIDataType.h"
#include "kal_general_types.h"
#include "HomeScreenOp11V32Def.h"
#include "GlobalConstants.h"
#include "Unicodexdcl.h"
#include "custom_mmi_default_value.h"
#include "string.h"
#include "PhbSrvIprot.h"
#include "PhbSrvGprot.h"
#include "kal_public_api.h"
#include "DebugInitDef_Int.h"
#include "DateTimeType.h"
#include "app_datetime.h"
#include "MediaAppWidgetDef.h"
#include "MMI_common_app_trc.h"
#include "kal_trace.h"
#include "mmi_common_app_trc.h"
#include "MediaPlayerEnumDef.h"
#include "BtcmSrvGprot.h"
#include "Conversions.h"
#include "app_mem.h"
#include "mmi_frm_scenario_gprot.h"
#include "mmi_rp_app_idle_def.h"
#include "AlertScreen.h"
#include "mmi_frm_events_gprot.h"
#include "GlobalResDef.h"
    #include "wgui_categories_util.h"
#include "mmi_frm_history_gprot.h"
#include "kal_public_defs.h"
#include "mmi_frm_mem_gprot.h"
#include "TimerEvents.h"
#include "mmi_frm_timer_gprot.h"
#include "med_smalloc.h"
#include "mmi_frm_input_gprot.h"
#include "gui_typedef.h"
#include "mmi_rp_file_type_def.h"
#include "fs_type.h"
#include "fs_func.h"
#include "stdio.h"
#include "FileMgrType.h"
#include "CustDataRes.h"
    #include "wgui_categories_list_op.h"
#include "gui_data_types.h"
#include "wgui_draw_manager.h"
#include "gui.h"
//#include "SimDetectionDef.h"
#include "device.h"
#include "custom_phb_config.h"
#include "UcmSrvGprot.h"
#include "CustMenuRes.h"
#include "wgui_categories_list.h"
#include "vfx_datatype.h"
#include "mmi_rp_app_phonebook_def.h"
#include "MediaPlayerPlayList.h"
#include "wgui_categories_popup.h"
#include "custom_events_notify.h"
// auto add by kw_check end 

#include "USBSrvGprot.h"

#ifdef __MMI_WLAN_FEATURES__
#include "DataAccountGProt.h"
#endif

#include "CommonScreens.h"

extern void mmi_uc_pre_entry_write_msg(void);

extern void mmi_medply_app_pre_entry(void);


/* SMS */
extern void mmi_sms_query_sidebar_info(S32 sidebar_id, S32 indctr_id);
extern void mmi_op11_hs32_get_sms_shct_data(S32 sidebar_id,S32 shct_id, void *shct_data);
extern void mmi_op11_hs32_get_voicemail_shct_data(S32 sidebar_id,S32 shct_id, void *shct_data);
extern void DialVoiceMail(void);
/* end SMS */

/* MMS */
extern void mmi_umms_op_hs32_shct_cb(S32 index);
/* end MMS */


#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

void mmi_op11_hs32_query_sidebar_temp(S32 sidebar_id, S32 indctr_id);

void mmi_op11_hs32_indctr_cb_temp(void);


void mmi_op11_hs32_get_shct_data_temp(S32 sidebar_id,S32 shct_id, void *shct_data_p);


void mmi_op11_hs32_shct_cb_temp(void);


/*----------------------------------------------------------------*/
/* Interaction Functions define                                                       */
/*----------------------------------------------------------------*/

/*****************************************************************************
 *  AP Contacts [CON] Functions
 *****************************************************************************/
static void mmi_op11_hs32_query_sidebar_con(S32 sidebar_id, S32 indctr_id);
static void mmi_op11_hs32_get_shct_data_con_vip(S32 sidebar_id,S32 shct_id, void *shct_data);
static void mmi_op11_hs32_sidebar_answer_con(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info);
static void mmi_op11_hs32_update_shct_history_con(void);


/*****************************************************************************
 *  AP Message [MES] Functions
 *****************************************************************************/
static void mmi_op11_hs32_query_sidebar_mes(S32 sidebar_id, S32 indctr_id);
static void mmi_op11_hs32_get_shct_data_mes(S32 sidebar_id,S32 shct_id, void *shct_data);
static void mmi_op11_hs32_answer_shct_data_mes(S32 sidebar_id, S32 shct_id, mmi_op11_hs32_shct_data_struct *shct_data_p);
static void mmi_op11_hs32_merge_shct_data_mes(void);
static void mmi_op11_hs32_copy_single_mes_item(
                mmi_op11_hs32_shct_data_struct *des_buffer, 
                U8 des_index, 
                mmi_op11_hs32_shct_data_struct *src_buffer, 
                U8 src_index,
                S8 sms_flag);

static void mmi_op11_hs32_enter_write_sms_screen(void);


/*****************************************************************************
 *  AP Email [EML] Functions
 *****************************************************************************/
static void mmi_op11_hs32_sidebar_answer_eml(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info);
static void mmi_op11_hs32_update_shct_history_eml(void);


/**********************************************************************
 * AP Orange Messenger [OMR] Functions
 **********************************************************************/
static void mmi_op11_hs32_sidebar_answer_omr(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info);

/*****************************************************************************
 * AP Orange World [OWD] Functions
 *****************************************************************************/
//static void mmi_op11_hs32_query_sidebar_owd(S32 sidebar_id, S32 indctr_id);
static void mmi_op11_hs32_get_shct_data_owd(S32 sidebar_id,S32 shct_id, void *shct_data);
static void mmi_op11_hs32_get_shct_data_owd_mb(S32 sidebar_id,S32 shct_id, void *shct_data);

//extern S32 wap_browser_get_num_of_op_default_bookmarks(void);
extern kal_bool srv_brw_get_default_bookmark_by_index(int index, kal_uint8 *title_buf, kal_uint16 title_buf_len, kal_uint8 *url_buf, kal_uint16 url_buf_len);
extern void mmi_brw_enter_web_address(void);
extern void mmi_brw_enter_user_defined_bookmark_list(void);
extern int srv_brw_get_num_of_user_defined_bookmarks(void);


/*****************************************************************************
 * AP Music [MUS]  Functions
 *****************************************************************************/
static void mmi_op11_hs32_query_mus_sidebar_info(S32 sidebar_id, S32 indctr_id);


/*****************************************************************************
 *  AP Profile [PRO] Functions
 *****************************************************************************/
static void mmi_op11_hs32_query_sidebar_pro(S32 sidebar_id, S32 indctr_id);
static void mmi_op11_hs32_toggle_pro_shct(void);

/*****************************************************************************
 * AP Connections [CNX] BT Functions
 *****************************************************************************/
static void mmi_bt_op11_hs32_get_shct_data(S32 sidebar_id,S32 shct_id, void *shct_data_p);
static void mmi_bt_op11_hs32_update_shct_data(void);

/*****************************************************************************
 * AP Connections [CNX] WIFI Functions
 *****************************************************************************/
static void mmi_wifi_op11_hs32_get_shct_data(S32 sidebar_id,S32 shct_id, void *shct_data_p);
static void mmi_wifi_op11_hs32_update_shct_data(void);
static void mmi_op11_hs32_entry_wifi_power_switch(void);

/*****************************************************************************
 * AP Device Status [DST] Functions
 *****************************************************************************/
static void mmi_op11_hs32_entry_dev_screen_group(void);
static void mmi_op11_hs32_entry_dev_screen(void);
static void mmi_op11_hs32_exit_dev_screen(void);

/*****************************************************************************
 * AP SIM Toolkit [STK] Functions
 *****************************************************************************/


/*****************************************************************************
 * AP VIP Contacts [VIP] VIP Functions
 *****************************************************************************/
static void mmi_op11_hs32_query_sidebar_vip(S32 sidebar_id, S32 indctr_id);
static void mmi_op11_hs32_sidebar_answer_vip(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info);


/*****************************************************************************
 *  For Photography Camera/Camcorder Functions internal wrapper
 *****************************************************************************/
static void mmi_op11_hs32_shct_cb_tp(void);
static void mmi_op11_hs32_enter_video_lib_screen(void);

/*****************************************************************************
 *  For CON VIP Screens
 *****************************************************************************/
static void mmi_op11_hs32_enter_set_con_vip_screen(void);
static void mmi_op11_hs32_enter_edit_con_vip_screen(void);
static void mmi_op11_hs32_enter_set_con_vip_screen_group(void);
static void mmi_op11_hs32_enter_edit_con_vip_screen_group(void);

static void mmi_op11_hs32_vip_list_highlight_hdlr(S32 index);
static void mmi_op11_hs32_vip_remove_select(void);
static void mmi_op11_hs32_enter_vip_select_screen(void);
//static mmi_ret mmi_op11_hs32_vip_select_contact_proc(mmi_event_struct *evt);
//static mmi_ret mmi_op11_hs32_vip_view_contact_proc(mmi_event_struct *evt);


/*****************************************************************************
 *  For EML Account Screens
 *****************************************************************************/
static void mmi_op11_hs32_enter_set_eml_account_screen(void);
static void mmi_op11_hs32_enter_edit_eml_account_screen(void);
static void mmi_op11_hs32_enter_set_eml_account_screen_group(void);
static void mmi_op11_hs32_enter_edit_eml_account_screen_group(void);
static void mmi_op11_hs32_eml_account_list_highlight_hdlr(S32 index);
static void mmi_op11_hs32_eml_account_remove_select(void);
static void mmi_op11_hs32_enter_eml_account_select_screen(void);


/*----------------------------------------------------------------*/
/* Internal use Functions define                                                       */
/*----------------------------------------------------------------*/
static void mmi_op11_hs32_answer_us_shct_data(S32 sidebar_id, S32 shct_id, mmi_op11_hs32_shct_data_struct *shct_data_p);


//static void mmi_op11_hs32_sidebar_answer_mes(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info);
static void mmi_op11_hs32_sidebar_answer_alm(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info);
static void mmi_op11_hs32_sidebar_answer_state(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info);


static void mmi_op11_hs32_query_all_sidebar_info(void);
static void mmi_op11_hs32_pre_fill_sidebar_info(void);
static void mmi_op11_hs32_coordinate_sidebar_info(mmi_op11_hs32_sidebar_struct *sidebar_info);
static void mmi_op11_hs32_alloc_shct_and_pre_fill(mmi_op11_hs32_sidebar_struct *sidebar_info);

static void mmi_op11_hs32_shct_data_pre_fill_eml(S32 shct_id, mmi_op11_hs32_shct_data_struct *data_p);
static void mmi_op11_hs32_shct_data_pre_fill_alm(S32 shct_id, mmi_op11_hs32_shct_data_struct *data_p);

static void mmi_op11_hs32_shct_data_pre_fill_mes(mmi_op11_hs32_sidebar_struct *sidebar_info);


static void mmi_op11_hs32_query_shct_data_each_sidebar(mmi_op11_hs32_sidebar_struct *sidebar_info);
static void mmi_op11_hs32_query_shct_data_each_single(S32 sidebar_id, S32 shct_id);

static void mmi_op11_hs32_read_cout(void);

static void mmi_op11_hs32_coordinate_shct_data(void);

static void mmi_op11_hs32_adm_free(void);
static void mmi_op11_hs32_adm_free_shct(mmi_op11_hs32_sidebar_struct *sidebar_info);

static void mmi_op11_hs32_revert_timeout(void);

extern void mmi_op11_hs32_vip_after_call_cb(mmi_ucm_after_make_call_cb_struct *make_call_cb_para);

static void mmi_op11_hs32_us_vip_init(void);
static void mmi_op11_hs32_us_vip_sync(void);

//static void mmi_op11_hs32_app_mem_success_callback_vip(void);
static void mmi_op11_hs32_exit_us_vip_screen(void);
static void mmi_op11_hs32_enter_us_vip_screen(void);

static void mmi_op11_hs32_us_vip_send_mes(void);
static void mmi_op11_hs32_us_vip_switch(void);
static void mmi_op11_hs32_us_vip_remove(void);

static void mmi_op11_hs32_create_csk_root_gid(void);
static mmi_ret mmi_op11_hs32_csk_grp_proc(mmi_event_struct *evt);

static void mmi_op11_hs32_create_flight_mode_gid(void);
static mmi_ret mmi_op11_hs32_flight_mode_grp_proc(mmi_event_struct *evt);
static void mmi_op11_hs32_entry_flight_mode_progress();
static mmi_ret mmi_op11_hs32_switch_mode_callback(mmi_event_struct *evt);


#if (defined(__MMI_OP11_HOMESCREEN_0302__) && !defined(__MMI_OP11_HOMESCREEN_US__))
static void mmi_op11_hs32_sync_wp_alm(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p);
#endif

const static CHAR *g_op11_hs32_proprietary_sim[] =
    {
        "20801",    /* Orange France */
        "20610",    /* Belgium */
        "26003",    /* Poland */
        "26803",    /* Portugal */
        "22610",    /* Romania */
        "23101",    /* Slovakia */
        "21403",    /* Spain */
        "22803",    /* Switzerland */
        "23433",    /* Orange UK */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    };



const mmi_op11_hs32_indctr_cb_func_t mmi_op11_hs32_indctr_sel_func_tbl[MMI_OP11_HS32_AP_TYPE_MAX][MMI_OP11_HS32_AP_INDCTR_MAX]=
{
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_CLL,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_CON,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_MES,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_EML,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_OMR,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_OWD,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_PRO,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_ALM,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_CAL,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_MUS,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_PHO,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_CNX,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_DST,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_STK,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_TPH,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_VIP,
    MMI_OP11_HS32_INDCTR_SEL_FUNCT_USCON

};

const mmi_op11_hs32_shct_cb_func_t mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_TYPE_MAX][MMI_OP11_HS32_AP_SHCT_MAX]=
{
    MMI_OP11_HS32_SHCT_SEL_FUNCT_CLL,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_CON,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_MES,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_EML,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_OMR,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_OWD,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_PRO,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_ALM,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_CAL,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_MUS,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_PHO,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_CNX,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_DST,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_STK,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_TPH,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_VIP,
    MMI_OP11_HS32_SHCT_SEL_FUNCT_USCON
};


const static mmi_op11_hs32_query_sidebar_func_t mmi_op11_hs32_query_sidebar_func_tbl[MMI_OP11_HS32_AP_TYPE_MAX]=
{
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_CLL,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_CON,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_MES,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_EML,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_OMR,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_OWD,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_PRO,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_ALM,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_CAL,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_MUS,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_PHO,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_CNX,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_DST,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_STK,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_TPH,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_VIP,
    MMI_OP11_HS32_SIDEBAR_QUERY_FUNCT_USCON
};



const static mmi_op11_hs32_get_shct_func_t mmi_op11_hs32_get_shct_func_tbl[MMI_OP11_HS32_AP_TYPE_MAX][MMI_OP11_HS32_AP_SHCT_MAX]=
{
    MMI_OP11_HS32_SHCT_GET_FUNCT_CLL,
    MMI_OP11_HS32_SHCT_GET_FUNCT_CON,
    MMI_OP11_HS32_SHCT_GET_FUNCT_MES,
    MMI_OP11_HS32_SHCT_GET_FUNCT_EML,
    MMI_OP11_HS32_SHCT_GET_FUNCT_OMR,
    MMI_OP11_HS32_SHCT_GET_FUNCT_OWD,
    MMI_OP11_HS32_SHCT_GET_FUNCT_PRO,
    MMI_OP11_HS32_SHCT_GET_FUNCT_ALM,
    MMI_OP11_HS32_SHCT_GET_FUNCT_CAL,
    MMI_OP11_HS32_SHCT_GET_FUNCT_MUS,
    MMI_OP11_HS32_SHCT_GET_FUNCT_PHO,
    MMI_OP11_HS32_SHCT_GET_FUNCT_CNX,
    MMI_OP11_HS32_SHCT_GET_FUNCT_DST,
    MMI_OP11_HS32_SHCT_GET_FUNCT_STK,
    MMI_OP11_HS32_SHCT_GET_FUNCT_TPH,
    MMI_OP11_HS32_SHCT_GET_FUNCT_VIP,
    MMI_OP11_HS32_SHCT_GET_FUNCT_USCON
};

extern nvram_ef_op11_hs32_hist_struct  g_hs_hist_cntx;

extern U8 *g_hs_sdbr_hist_p;

extern U8 subMenuData[MAX_SUB_MENUS][MAX_SUB_MENU_SIZE];

mmi_op11_hs_context_struct g_mmi_op11_hs32_cntx;

#ifdef __MMI_OP11_HS32_MEM_MONOPOLY__
static U8 g_mmi_op11_hs32_data_mem[MMI_OP11_HS32_APP_MEM_TOTAL_SIZE];
#endif

/*****************************************************************************
 *  Temp variables & functions
 *****************************************************************************/

void mmi_op11_hs32_query_sidebar_temp(S32 sidebar_id, S32 indctr_id)
{
    return;
}

void mmi_op11_hs32_get_shct_data_temp(S32 sidebar_id,S32 shct_id, void *shct_data_p)
{
    return;
}

void mmi_op11_hs32_indctr_cb_temp(void)
{
    return;

}

void mmi_op11_hs32_shct_cb_temp(void)
{
    return;

}


void mmi_op11_hs32_get_shct_data_temp_sms(S32 sidebar_id,S32 shct_id, void *shct_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p = (mmi_op11_hs32_shct_data_struct *)shct_data;
    S32 n,i;
    MMI_BOOL ready = MMI_TRUE;
    U8 name_flag = 1;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(ready)
    {
        shct_data_p->item_count = 1;

        n = MIN(shct_data_p ->item_count, MMI_OP11_HS32_SHCT_ITEM_COUNT_MAX);
        for(i=0; i<n; i++)
        {
            shct_data_p->item_uid[i] = i /* email unique id, now just for view latest email, but future extensibility */;

//            shct_data_p->item_icon[i] = IMG_ID_MMS/* IMG_ID_MMS */;

            if(name_flag)
            {
                mmi_ucs2ncpy((CHAR*)shct_data_p->item_name[i], (CHAR*)L"SMS1", MMI_OP11_HS32_SHCT_NAME_STRLEN_MAX);
            }

            mmi_ucs2ncpy((CHAR*)shct_data_p->item_content[i], (CHAR*)L"Content1 SMS Sir...", MMI_OP11_HS32_SHCT_CONTENT_STRLEN_MAX);

            shct_data_p->item_time[i].nYear = 2009;
            shct_data_p->item_time[i].nMonth= 11;
            shct_data_p->item_time[i].nDay= 14;
            shct_data_p->item_time[i].nHour= (U8)24-i;
            shct_data_p->item_time[i].nMin= 03;
            shct_data_p->item_time[i].nSec= 55;
            shct_data_p->item_time[i].DayIndex= 6;
        }

        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_OK;
        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
    }
    else /* if not ready, or get data is non-block operation */
    {
        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
        /* e.g. send message  */
    }
}


void mmi_op11_hs32_get_shct_data_temp_mms(S32 sidebar_id,S32 shct_id, void *shct_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p = (mmi_op11_hs32_shct_data_struct *)shct_data;
    S32 n,i;
    MMI_BOOL ready = MMI_TRUE;
    U8 name_flag = 1;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(ready)
    {
        shct_data_p->item_count = 1;

        n = MIN(shct_data_p ->item_count, MMI_OP11_HS32_SHCT_ITEM_COUNT_MAX);
        for(i=0; i<n; i++)
        {
            shct_data_p->item_uid[i] = i /* email unique id, now just for view latest email, but future extensibility */;

//            shct_data_p->item_icon[i] = IMG_ID_MMS/* IMG_ID_MMS */;

            if(name_flag)
            {
                mmi_ucs2ncpy((CHAR*)shct_data_p->item_name[i], (CHAR*)L"MMS1", MMI_OP11_HS32_SHCT_NAME_STRLEN_MAX);
            }

            mmi_ucs2ncpy((CHAR*)shct_data_p->item_content[i], (CHAR*)L"Content2 MMS...", MMI_OP11_HS32_SHCT_CONTENT_STRLEN_MAX);

            shct_data_p->item_time[i].nYear = 2009;
            shct_data_p->item_time[i].nMonth= 11;
            shct_data_p->item_time[i].nDay= 14;
            shct_data_p->item_time[i].nHour= (U8)24-i;
            shct_data_p->item_time[i].nMin= 02;
            shct_data_p->item_time[i].nSec= 55;
            shct_data_p->item_time[i].DayIndex= 6;
        }

        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_OK;
        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
    }
    else /* if not ready, or get data is non-block operation */
    {
        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
        /* e.g. send message  */
    }
}







/************************************************************/
/*															*/
/*			HS external functions implement     					*/
/*															*/
/************************************************************/

void dummp_func(void)
{
    return;
}


/*****************************************************************************
 *  For Photography Camera/Camcorder Functions internal wrapper
 *****************************************************************************/
static void mmi_op11_hs32_shct_cb_tp(void)
{
#if defined(__MMI_CAMCORDER__)
    mmi_camco_launch();
#elif defined(__MMI_CAMERA__)
    mmi_camera_lauch();
#endif
    return;

}


/*****************************************************************************
 *  AP Contacts [CON] Functions
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_con_vip_update
 * DESCRIPTION
 *  for phonebook update sidebar
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_con_vip_update(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_query_info_struct sidebar_answer;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(mmi_idle_is_active()&&mmi_op11_hs32_is_enable()))
    {
        return;
    }

    sidebar_answer.result_flag = MMI_OP11_HS32_RESULT_UPDATE;
    mmi_op11_hs32_answer_sidebar(MMI_OP11_HS32_AP_CON, 0, &sidebar_answer);

#ifdef __MMI_OP11_HOMESCREEN_US__
    mmi_op11_hs32_answer_sidebar(MMI_OP11_HS32_AP_VIP, 0, &sidebar_answer);
#endif    

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_update_shct_history_con
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_update_shct_history_con(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i,j,count=0;
    U8 shct_history_temp[MMI_OP11_HS32_SHCT_CON_TYPE_MAX];
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(shct_history_temp, 0xFF, MMI_OP11_HS32_SHCT_CON_TYPE_MAX);

    if (g_mmi_op11_hs32_cntx.shct_phb_reordered== 0)
    {
        count=0;
        for(i=0; i<MMI_OP11_HS32_AP_CON_VIP_MAX; i++)
        {
            if (srv_phb_vip_contact_is_sync(i)) 
            {
                count ++;
            }
        }
        if (count == 0)
        {
            /* no vip exist, so there is only two shct */
            i=0;
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i] = MMI_OP11_HS32_SHCT_CON_LIST;
            i++;
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i] = MMI_OP11_HS32_SHCT_CON_SET_VIP;
            i++;
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i] = 0xFF;
        }
        else
        {
            i = 0;
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i] = MMI_OP11_HS32_SHCT_CON_LIST;
            i ++;
            for (j=0; j<MMI_OP11_HS32_AP_CON_VIP_MAX; j++)
            {
                if (srv_phb_vip_contact_is_sync(j))
                {
                    g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i] = MMI_OP11_HS32_SHCT_CON_VIP1+j;
                    i++;
                }
            }
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i] = MMI_OP11_HS32_SHCT_CON_EDIT_VIP;
            i++;
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i] = 0xFF;
        }
         g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_CON] = i;

        return;
    }


    count = 0;
    for(i=0; i<MMI_OP11_HS32_AP_CON_VIP_MAX; i++)
    {
        if (srv_phb_vip_contact_is_sync(i)) 
        {
            count ++;
             /* vip exist */
            for(j=0; j<g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_CON]; j++)
            {
                if(g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][j] == (MMI_OP11_HS32_SHCT_CON_VIP1+i))
                {
                    /* vip exist in history */
                    break; 
                }
            }

            if (j == g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_CON])
            {
                /* vip not exist in history, add into history last */
                g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][j] = (MMI_OP11_HS32_SHCT_CON_VIP1+i);
                g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_CON] ++;
                g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_CON]] = 0xFF;
            }
        }
        else  /* vip not exist, need revise shct history (label the bad data) */
        {
             /* vip not exist */
            for(j=0; j<g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_CON]; j++)
            {
                if(g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][j] == (MMI_OP11_HS32_SHCT_CON_VIP1+i))
                {
                    /* vip exist in history, label the bad data  */
                    g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][j] = 0xFE;
                    break;
                }
            }
        }
    }

    if (count == 0)
    {
        for (i=0; i<g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_CON]; i++)
        {
            if (g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i] == MMI_OP11_HS32_SHCT_CON_EDIT_VIP)
            {
                /* no account exist, but previous history has account exist  */
                g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i] = MMI_OP11_HS32_SHCT_CON_SET_VIP;
                break;
            }
        }
    }
    else
    {
        for (i=0; i<g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_CON]; i++)
        {
            if (g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i] == MMI_OP11_HS32_SHCT_CON_SET_VIP)
            {
                /* at least one account exist, and previous history is no account exist  */
                g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i] = MMI_OP11_HS32_SHCT_CON_EDIT_VIP;
                break;
            }
        }
    }

    for (i=0,j =0; i<g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_CON]; i++)
    {
        if (g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i] != 0xFE)
        {
            shct_history_temp[j] = g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][i];
            j++;
        }
    }

    g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_CON] = j;

    memcpy(g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON], shct_history_temp, MMI_OP11_HS32_SHCT_CON_TYPE_MAX*sizeof(U8));
//    g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_CON][g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_CON] ] = 0xFF;

}



/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_indicator_answer
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_query_sidebar_con(S32 sidebar_id, S32 indctr_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_query_info_struct sidebar_answer;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (!srv_phb_startup_is_phb_ready())
    {
        sidebar_answer.result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
        mmi_op11_hs32_answer_sidebar(sidebar_id, indctr_id, &sidebar_answer);
    }
    else
    {
        sidebar_answer.result_flag = MMI_OP11_HS32_RESULT_OK;
        mmi_op11_hs32_answer_sidebar(sidebar_id, indctr_id, &sidebar_answer);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_sidebar_answer_con
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_sidebar_answer_con(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_NOT_READY)
    {
        sidebar_info->sidebar_status = MMI_OP11_HS32_RESULT_NOT_READY;
    }

    if((sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_OK) || (sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE))
    {
        sidebar_info->sidebar_status = MMI_OP11_HS32_RESULT_OK;
        /* history and account sync */
        mmi_op11_hs32_update_shct_history_con();
        /* save account to NVRAM */
        mmi_op11_hs_save_id_history();
    }


    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
    {
        mmi_op11_hs32_realloc_and_update_shct(sidebar_info);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_get_shct_data_con_vip
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_get_shct_data_con_vip(S32 sidebar_id,S32 shct_id, void *shct_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p = (mmi_op11_hs32_shct_data_struct *)shct_data;
    U16 vip_index, store_index;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(srv_phb_startup_is_phb_ready())
    {
        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_OK;
        shct_data_p->item_count = 1;

        /* get index */
        vip_index = shct_id - MMI_OP11_HS32_SHCT_CON_VIP1;
        store_index = srv_phb_vip_contact_get_store_index(vip_index);

        /* fill contact store index */
        shct_data_p->query_index = (S32)store_index;
        /* fill contact name */
        mmi_ucs2ncpy((CHAR*)shct_data_p->item_name[0], (CHAR*)srv_phb_vip_contact_get_name(vip_index), MMI_OP11_HS32_SHCT_NAME_STRLEN_MAX);
        /* fill contact number */
        mmi_ucs2ncpy((CHAR*)shct_data_p->item_name[1], (CHAR*)srv_phb_vip_contact_get_number(vip_index), MMI_OP11_HS32_SHCT_NAME_STRLEN_MAX);

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
        /* fill contact image resource id */
//            srv_phb_get_image_id(store_index, (U16*)&shct_data_p->item_uid[0]);
            shct_data_p->item_uid[0] = 0;
//        if (shct_data_p->item_uid[0] == IMG_PHB_DEFAULT)
            /* fill contact image file path */
//            srv_phb_get_image_path(store_index, (U16*)shct_data_p->item_content);
            srv_phb_get_image(store_index, NULL, (U16*)shct_data_p->item_content, NULL);
//        MMI_ASSERT(shct_data_p->file_path);
//        srv_phb_get_image_path(store_index, (U16*)shct_data_p->file_path);
  
        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
    }
    else
    {
        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
    }
}


/*****************************************************************************
 *  AP Message [MES] Functions
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_query_sidebar_mes
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  indctr_id         : [IN] short id
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_query_sidebar_mes(S32 sidebar_id, S32 indctr_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_sms_query_sidebar_info(MMI_OP11_HS32_AP_MES, MMI_OP11_HS32_INDCTR_MES_NEW_SMS);
    mmi_mms_query_sidebar_info(MMI_OP11_HS32_AP_MES, MMI_OP11_HS32_INDCTR_MES_NEW_MMS);

    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_get_shct_data_con_vip
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_get_shct_data_mes(S32 sidebar_id,S32 shct_id, void *shct_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    mmi_op11_hs32_get_sms_shct_data(MMI_OP11_HS32_AP_MES, MMI_OP11_HS32_SHCT_MES_NEW_SMS, g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_SMS]);
    mmi_op11_hs32_get_mms_shct_data(MMI_OP11_HS32_AP_MES, MMI_OP11_HS32_SHCT_MES_NEW_MMS, g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_MMS]);

//    mmi_op11_hs32_get_shct_data_temp_sms(MMI_OP11_HS32_AP_MES, MMI_OP11_HS32_SHCT_MES_NEW_SMS, g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_SMS]);
//    mmi_op11_hs32_get_shct_data_temp_mms(MMI_OP11_HS32_AP_MES, MMI_OP11_HS32_SHCT_MES_NEW_MMS, g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_MMS]);

    return;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_get_shct_data_con_vip
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_answer_shct_data_mes(S32 sidebar_id, S32 shct_id, mmi_op11_hs32_shct_data_struct *shct_data_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_struct *sidebar_info;
    S32 hightlight_index;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* trace */
    MMI_ASSERT(shct_data_p == g_mmi_op11_hs32_cntx.mes_data_p[shct_id]);
    if ((shct_data_p->result_flag == MMI_OP11_HS32_RESULT_OK) || (shct_data_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE))
    {
        if (g_mmi_op11_hs32_cntx.mes_data_p[1 - shct_id]->result_flag != MMI_OP11_HS32_RESULT_NOT_READY)
        {
            mmi_op11_hs32_merge_shct_data_mes();

            if (shct_data_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
            {
                #ifndef __MMI_OP11_HOMESCREEN_US__
                    if(shct_data_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
                    {
                        sidebar_info = mmi_op11_hs32_get_sidebar_info_pointer(sidebar_id);
                        hightlight_index = vadp_v2p_op11_hs_shct_get_def_hlt_shct_index(sidebar_info);
                        setHighlightedShortcut(sidebar_id, hightlight_index);
                    }
                #endif
                updateViewItem(sidebar_id, 0);
            }
        }
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_merge_shct_data_mes
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void  : 
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_merge_shct_data_mes(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *sms_temp;
    mmi_op11_hs32_shct_data_struct *mms_temp;
    mmi_op11_hs32_shct_data_struct *mes_inbox;
    S32 sms_i, mms_i, mes_i, mes_n;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    sms_temp = g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_SMS];
    mms_temp = g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_MMS];
    mes_inbox = mmi_op11_hs32_get_shct_data_pointer_internal(MMI_OP11_HS32_AP_MES, MMI_OP11_HS32_SHCT_MES_INBOX);
    /* start merge SMS and MMS */
    if (mms_temp->item_count == 0)
    {
        /* no mms, all sms or noting */
        memcpy(mes_inbox, sms_temp, sizeof(mmi_op11_hs32_shct_data_struct));
        mes_inbox->result_flag = MMI_OP11_HS32_RESULT_UPDATE;
        mes_inbox->query_index = MMI_OP11_HS32_SHCT_MES_NEW_SMS;
        for (mes_i = 0; mes_i < MMI_OP11_HS32_SHCT_ITEM_COUNT_MAX; mes_i ++)
        {
            mes_inbox->item_flag[mes_i] = 1;
        }
        return;
    }
    if (sms_temp->item_count == 0)
    {
        /* no sms, all mms */
        memcpy(mes_inbox, mms_temp, sizeof(mmi_op11_hs32_shct_data_struct));
        mes_inbox->result_flag = MMI_OP11_HS32_RESULT_UPDATE;
        mes_inbox->query_index = MMI_OP11_HS32_SHCT_MES_NEW_MMS;
        for (mes_i = 0; mes_i < MMI_OP11_HS32_SHCT_ITEM_COUNT_MAX; mes_i ++)
        {
            mes_inbox->item_flag[mes_i] = 0;
        }
        return;
    }

    /* at least 1 sms, and 1 mms */
    mes_inbox->result_flag = MMI_OP11_HS32_RESULT_UPDATE;
    mes_inbox->item_count = sms_temp->item_count + mms_temp->item_count;
    if (CompareTime(sms_temp->item_time[0], mms_temp->item_time[0], NULL) >= 0)
    {
        /* if latest sms time == latest mms time, sms will be count into latest message */
        mes_inbox->query_index = MMI_OP11_HS32_SHCT_MES_NEW_SMS;
    }
    else
    {
        mes_inbox->query_index = MMI_OP11_HS32_SHCT_MES_NEW_MMS;
    }

    mes_n = MIN(mes_inbox->item_count, MMI_OP11_HS32_SHCT_ITEM_COUNT_MAX);

    for (mes_i = 0, sms_i =0, mms_i = 0; mes_i < mes_n; mes_i++)
    {
        if (sms_i == sms_temp->item_count)
        {
            mmi_op11_hs32_copy_single_mes_item(mes_inbox, mes_i, mms_temp, mms_i, 0);
            mms_i ++;
            continue;
        }
        if (mms_i == mms_temp->item_count)
        {
            mmi_op11_hs32_copy_single_mes_item(mes_inbox, mes_i, sms_temp, sms_i, 1);
            sms_i ++;
            continue;
        }

        if (CompareTime(sms_temp->item_time[sms_i], mms_temp->item_time[mms_i], NULL) >= 0)
        {
            /* if latest sms time == latest mms time, sms will be count into latest message */
            mmi_op11_hs32_copy_single_mes_item(mes_inbox, mes_i, sms_temp, sms_i, 1);
            sms_i ++;
        }
        else
        {
            mmi_op11_hs32_copy_single_mes_item(mes_inbox, mes_i, mms_temp, mms_i, 0);
            mms_i ++;
        }

    }

    /* end merge SMS and MMS */


}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_copy_single_mes_item
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void  : 
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_copy_single_mes_item(
                mmi_op11_hs32_shct_data_struct *des_buffer, 
                U8 des_index, 
                mmi_op11_hs32_shct_data_struct *src_buffer, 
                U8 src_index,
                S8 sms_flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    des_buffer->item_uid[des_index] = src_buffer->item_uid[src_index];
    des_buffer->item_flag[des_index] = sms_flag;
    memcpy(des_buffer->item_name[des_index], src_buffer->item_name[src_index], sizeof(WCHAR)*MMI_OP11_HS32_SHCT_NAME_STRLEN_MAX);
    memcpy(&des_buffer->item_time[des_index], &src_buffer->item_time[src_index], sizeof(MYTIME));
    memcpy(des_buffer->item_content[des_index], src_buffer->item_content[src_index], sizeof(WCHAR)*MMI_OP11_HS32_SHCT_CONTENT_STRLEN_MAX);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_sidebar_answer_eml
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_sidebar_answer_eml(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_NOT_READY)
    {
        if (indctr_id & MMI_OP11_HS32_EML_NOTIFY_SYNC_ACCOUNT)
        {
//            g_mmi_op11_hs32_cntx.sidebar_flag[MMI_OP11_HS32_AP_EML] = SPECIAL_AP_SYNC_NOTREADY;
            sidebar_info->sidebar_status = MMI_OP11_HS32_RESULT_NOT_READY;
        }
    }

    if((sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_OK) || (sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE))
    {
        if (indctr_id & MMI_OP11_HS32_EML_NOTIFY_SYNC_ACCOUNT)
        {
//            g_mmi_op11_hs32_cntx.sidebar_flag[MMI_OP11_HS32_AP_EML] = SPECIAL_AP_SYNC_DONE;
            sidebar_info->sidebar_status = MMI_OP11_HS32_RESULT_OK;
            /* account sync */
            MMI_ASSERT(sidebar_answer_p->sync_data);
            memcpy(g_mmi_op11_hs32_cntx.eml_account, sidebar_answer_p->sync_data, MMI_OP11_HS32_AP_EML_ACCOUNT_MAX*sizeof(S32));
            mmi_op11_hs32_update_shct_history_eml();
            /* save email account to NVRAM */
            mmi_op11_hs_save_id_history();
        }

        if (indctr_id & MMI_OP11_HS32_EML_NOTIFY_INDICATOR)
        {
            MMI_ASSERT(sidebar_info->sidebar_id == sidebar_id);
            sidebar_info->indicator_data[0] = sidebar_answer_p->indicator_value;
        }
    }

    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
    {
        if (indctr_id & MMI_OP11_HS32_EML_NOTIFY_SYNC_ACCOUNT)
        {
            mmi_op11_hs32_coordinate_sidebar_info(sidebar_info);
            /* update email viewitem  */
            mmi_op11_hs32_realloc_and_update_shct(sidebar_info);
        }

        if (indctr_id & MMI_OP11_HS32_EML_NOTIFY_INDICATOR)
        {
            updateIndicator(sidebar_id);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_update_shct_history_eml
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_update_shct_history_eml(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i,j,count=0;
    U8 shct_history_temp[MMI_OP11_HS32_SHCT_EML_TYPE_MAX];
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(shct_history_temp, 0xFF, MMI_OP11_HS32_SHCT_EML_TYPE_MAX);

    if (g_mmi_op11_hs32_cntx.shct_eml_reordered == 0)
    {
        count=0;
        for(i=0; i<MMI_OP11_HS32_AP_EML_ACCOUNT_MAX; i++)
        {
            if (g_mmi_op11_hs32_cntx.eml_account[i] != 0) 
            {
                count ++;
            }
        }
        if (count == 0)
        {
            /* no account exist, so there is only one shct: MMI_OP11_HS32_SHCT_EML_SET_ACCOUNT  */
            i=0;
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][i] = MMI_OP11_HS32_SHCT_EML_SET_ACCOUNT;
            i++;
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][i] = 0xFF;
        }
        else
        {
            i = 0;
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][i] = MMI_OP11_HS32_SHCT_EML_WRITE_EMAIL;
            i ++;
            for (j=0; j<MMI_OP11_HS32_AP_EML_ACCOUNT_MAX; j++)
            {
                if (g_mmi_op11_hs32_cntx.eml_account[j] != 0)
                {
                    g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][i] = MMI_OP11_HS32_SHCT_EML_ACCOUNT1_NEWEMAIL+j;
                    i++;
                }
            }
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][i] = MMI_OP11_HS32_SHCT_EML_EDIT_ACCOUNT;
            i++;
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][i] = 0xFF;
        }
         g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_EML] = i;

        return;
    }

    count = 0;
    for(i=0; i<MMI_OP11_HS32_AP_EML_ACCOUNT_MAX; i++)
    {
        if (g_mmi_op11_hs32_cntx.eml_account[i] != 0) 
        {
            count ++;
             /* account exist */
            for(j=0; j<g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_EML]; j++)
            {
                if(g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][j] == (MMI_OP11_HS32_SHCT_EML_ACCOUNT1_NEWEMAIL+i))
                {
                    /* account exist in history */
                    break; 
                }
            }

            if (j == g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_EML])
            {
                /* account not exist in history, add into history last position*/
                g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][j] = (MMI_OP11_HS32_SHCT_EML_ACCOUNT1_NEWEMAIL+i);
                g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_EML] ++;
                g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_EML]] = 0xFF;
            }
        }
        else  /* account not exist, need revise shct history(label the bad data) */
        {
             /* account not exist */
            for(j=0; j<g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_EML]; j++)
            {
                if(g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][j] == (MMI_OP11_HS32_SHCT_EML_ACCOUNT1_NEWEMAIL+i))
                {
                    /* account exist in history, label the bad data  */
                    g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][j] = 0xFE;
                    break;
                }
            }
        }
    }

    if (count == 0)
    {
        /* no account exist, so there is only one shct: MMI_OP11_HS32_SHCT_EML_SET_ACCOUNT  */
        g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][0] = MMI_OP11_HS32_SHCT_EML_SET_ACCOUNT;
        g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][1] = 0xFF;
        g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_EML] = 1;
        return;
    }
    else
    {
        MMI_ASSERT(count<= MMI_OP11_HS32_AP_EML_ACCOUNT_MAX);
        if (g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][0] == MMI_OP11_HS32_SHCT_EML_SET_ACCOUNT)
        {
            /* at least one account exist, and previous history is no account exist  */
            /* create new shortcut sequence */
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][0] = MMI_OP11_HS32_SHCT_EML_WRITE_EMAIL;
            for (j=0; j<count; j++)
            {
                g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][1+j] = MMI_OP11_HS32_SHCT_EML_ACCOUNT1_NEWEMAIL+j;
             
            }
                g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][1+j] = MMI_OP11_HS32_SHCT_EML_EDIT_ACCOUNT;
                g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_EML] ++;
                g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_EML]] = 0xFF;
            return;
        }
    }

    /* at least one account exist, and previous history also has account exist  */

    for (i=0,j =0; i<g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_EML]; i++)
    {
        if (g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][i] != 0xFE)
        {
            shct_history_temp[j] = g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][i];
            j++;
        }
    }
    g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_EML] = j;
    memcpy(g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML], shct_history_temp, MMI_OP11_HS32_SHCT_EML_TYPE_MAX*sizeof(U8));
//    g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_EML][g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_EML]] = 0xFF;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_sidebar_answer_con
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_op11_hs32_email_get_shct_id_by_account(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(mmi_idle_is_active()&&mmi_op11_hs32_is_enable()))
    {
        return -1;
    }


    for(i=0; i<MMI_OP11_HS32_AP_EML_ACCOUNT_MAX; i++)
    {
        if (g_mmi_op11_hs32_cntx.eml_account[i] == index)
        {
            return MMI_OP11_HS32_SHCT_EML_ACCOUNT1_NEWEMAIL+i;
        }
    }

    return -1;
}



/**********************************************************************
 * AP Orange Messenger [OMR] Functions
 **********************************************************************/

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_sidebar_answer_con
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_sidebar_answer_omr(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(sidebar_info->sidebar_id == sidebar_id);

    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_NOT_READY)
    {
        if (indctr_id & MMI_OP11_HS32_OMR_NOTIFY_AP_STATUS)
        {
            sidebar_info->indicator_data[0] = 0;
            sidebar_info->sidebar_status = MMI_OP11_HS32_STATUS_OMR_OFF;
            updateIndicator(sidebar_id);
        }
    }


    if((sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_OK) || (sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE))
    {
        if (indctr_id & MMI_OP11_HS32_OMR_NOTIFY_AP_STATUS)
        {
            sidebar_info->sidebar_status = sidebar_answer_p->ap_status;
        }

        if (indctr_id & MMI_OP11_HS32_OMR_NOTIFY_INDICATOR)
        {
            sidebar_info->indicator_data[0] = sidebar_answer_p->indicator_value;
        }
    }


    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
    {
        if (indctr_id & MMI_OP11_HS32_OMR_NOTIFY_INDICATOR)
        {
            updateIndicator(sidebar_id);
        }

        if (indctr_id & MMI_OP11_HS32_OMR_NOTIFY_AP_STATUS)
        {
            mmi_op11_hs32_realloc_and_update_shct(sidebar_info);
        }
    }

}


#if defined(__MMI_OP11_HS32_OWD__)
/*****************************************************************************
 *  AP Orange World [OWD] Functions
 *****************************************************************************/

static void mmi_op11_hs32_get_shct_data_owd(S32 sidebar_id,S32 shct_id, void *shct_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p = (mmi_op11_hs32_shct_data_struct *)shct_data;
    MMI_BOOL ready = MMI_TRUE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(ready)
    {
        shct_data_p->item_count = 1;

        srv_brw_get_default_bookmark_by_index(shct_id-MMI_OP11_HS32_SHCT_OWD_BK1, (kal_uint8*)shct_data_p->item_name, MMI_OP11_HS32_SHCT_ITEM_COUNT_MAX*(MMI_OP11_HS32_SHCT_NAME_STRLEN_MAX+1)*2, (kal_uint8*)shct_data_p->item_content, MMI_OP11_HS32_SHCT_ITEM_COUNT_MAX*(MMI_OP11_HS32_SHCT_CONTENT_STRLEN_MAX+1)*2);

        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_OK;
        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
    }
    else /* if not ready, or get data is non-block operation */
    {
        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
        /* e.g. send message  */
    }
}

static void mmi_op11_hs32_get_shct_data_owd_mb(S32 sidebar_id,S32 shct_id, void *shct_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p = (mmi_op11_hs32_shct_data_struct *)shct_data;
    MMI_BOOL ready = MMI_TRUE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(ready)
    {
        shct_data_p->item_count = srv_brw_get_num_of_user_defined_bookmarks();

        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_OK;
        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
    }
    else /* if not ready, or get data is non-block operation */
    {
        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
        /* e.g. send message  */
    }
}
#endif


#ifdef __MMI_MEDIA_PLAYER__
/*****************************************************************************
 * AP Music [MUS]  Functions
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  mmi_mus_update_op11_hs32_sidebar_info
 * DESCRIPTION
 *  for update mus sidebar
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_mus_update_op11_hs32_sidebar_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_query_info_struct sidebar_answer;
    S32 data_value = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    sidebar_answer.result_flag = MMI_OP11_HS32_RESULT_UPDATE;
    if(mmi_medply_widget_is_plst_ready())
    {
        mmi_medply_widget_get_value(MMI_WIDGET_PLAYER_CUR_STATE, &data_value);

        MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_MUS_UPDATE, data_value);

        switch(data_value)
        {
            case MEDPLY_WIDGET_STATE_IDLE:
                sidebar_answer.ap_status = MMI_OP11_HS32_STATUS_MUS_NOT_PROGRESS;
                break;

            case MEDPLY_WIDGET_STATE_PLAY:
            case MEDPLY_WIDGET_STATE_PROCESSING:
                sidebar_answer.ap_status = MMI_OP11_HS32_STATUS_MUS_PROGRESS;
                break;

            default:
                sidebar_answer.ap_status = MMI_OP11_HS32_STATUS_MUS_STANDARD;
                break;
        }

        mmi_op11_hs32_answer_sidebar(MMI_OP11_HS32_AP_MUS, 0, &sidebar_answer);
    }
    else
    {
        sidebar_answer.ap_status = MMI_OP11_HS32_STATUS_MUS_STANDARD;
        mmi_op11_hs32_answer_sidebar(MMI_OP11_HS32_AP_MUS, 0, &sidebar_answer);
    }

#if (defined(__MMI_OP11_HOMESCREEN_0302__) && !defined(__MMI_OP11_HOMESCREEN_US__))
    mmi_op11_hs32_answer_sidebar(MMI_OP11_HS32_AP_MUS, 1, &sidebar_answer);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_query_mus_sidebar_info
 * DESCRIPTION
 *  for query mus sidebar
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_query_mus_sidebar_info(S32 sidebar_id, S32 indctr_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_query_info_struct sidebar_answer;
    S32 data_value = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(mmi_medply_widget_is_plst_ready())
    {
        sidebar_answer.result_flag = MMI_OP11_HS32_RESULT_OK;

        mmi_medply_widget_get_value(MMI_WIDGET_PLAYER_CUR_STATE, &data_value);

        MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_MUS_QUERY, data_value);

        switch(data_value)
        {
            case MEDPLY_WIDGET_STATE_IDLE:
                sidebar_answer.ap_status = MMI_OP11_HS32_STATUS_MUS_NOT_PROGRESS;
                break;

            case MEDPLY_WIDGET_STATE_PLAY:
            case MEDPLY_WIDGET_STATE_PROCESSING:
                sidebar_answer.ap_status = MMI_OP11_HS32_STATUS_MUS_PROGRESS;
                break;

            default:
                sidebar_answer.ap_status = MMI_OP11_HS32_STATUS_MUS_STANDARD;
                break;

        }

        mmi_op11_hs32_answer_sidebar(sidebar_id, indctr_id, &sidebar_answer);
    }
    else
    {
        sidebar_answer.result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
        mmi_op11_hs32_answer_sidebar(sidebar_id, indctr_id, &sidebar_answer);
    }

}

#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_indicator_answer
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_sidebar_answer_state(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 previous_status;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_OK) ||(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE))
    {
        /* fill viewitem info to data buffer  */
        MMI_ASSERT(sidebar_info->sidebar_id == sidebar_id);

        previous_status = sidebar_info->sidebar_status;
        sidebar_info->sidebar_status = sidebar_answer_p->ap_status;
    }

    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
    {
        if (previous_status != sidebar_info->sidebar_status)
        {
            updateViewItem(sidebar_id, 0);
        }
    }

}



/*****************************************************************************
 *  AP Profile [PRO] Functions
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_pro_update
 * DESCRIPTION
 *  for update profile sidebar
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_pro_update(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_query_info_struct sidebar_answer;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sidebar_answer.result_flag = MMI_OP11_HS32_RESULT_UPDATE;

        if (srv_prof_is_profile_activated(SRV_PROF_SILENT_MODE) > 0)
        {
            sidebar_answer.ap_status = MMI_OP11_HS32_STATUS_PRO_SILENT;
        }
        else
        {
            sidebar_answer.ap_status = MMI_OP11_HS32_STATUS_PRO_NON_SILENT;
        }
        mmi_op11_hs32_answer_sidebar(MMI_OP11_HS32_AP_PRO, 0, &sidebar_answer);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_query_sidebar_pro
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_query_sidebar_pro(S32 sidebar_id, S32 indctr_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_query_info_struct sidebar_answer;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sidebar_answer.result_flag = MMI_OP11_HS32_RESULT_OK;

        if (srv_prof_is_profile_activated(SRV_PROF_SILENT_MODE) > 0)
        {
            sidebar_answer.ap_status = MMI_OP11_HS32_STATUS_PRO_SILENT;
        }
        else
        {
            sidebar_answer.ap_status = MMI_OP11_HS32_STATUS_PRO_NON_SILENT;
        }

        mmi_op11_hs32_answer_sidebar(sidebar_id, indctr_id, &sidebar_answer);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_toggle_pro_shct
 * DESCRIPTION
 *  for update profile sidebar
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_toggle_pro_shct(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_struct *sidebar_info;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sidebar_info = mmi_op11_hs32_get_sidebar_info_pointer(MMI_OP11_HS32_AP_PRO);

    if (sidebar_info != NULL)
    {
        if (sidebar_info->sidebar_status == MMI_OP11_HS32_STATUS_PRO_SILENT)
        {
            sidebar_info->sidebar_status = MMI_OP11_HS32_STATUS_PRO_NON_SILENT;
            srv_prof_deactivate_profile_by_external_module(SRV_PROF_SILENT_MODE);
            updateViewItem(MMI_OP11_HS32_AP_PRO, 0);
            setSilentPanel(0);
        }
        else
        {
            sidebar_info->sidebar_status = MMI_OP11_HS32_STATUS_PRO_SILENT;
            srv_prof_activate_profile_by_external_module(SRV_PROF_SILENT_MODE);
            updateViewItem(MMI_OP11_HS32_AP_PRO, 0);
            setSilentPanel(1);
        }
    }
}




#ifdef __MMI_BT_SUPPORT__
/*****************************************************************************
 * AP Connections [CNX] BT Functions
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_cnx_bt_update
 * DESCRIPTION
 *  for bt update sidebar
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_cnx_bt_update(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(mmi_idle_is_active()&&mmi_op11_hs32_is_enable()))
    {
        return;
    }
    mmi_bt_op11_hs32_update_shct_data();

#if (defined(__MMI_OP11_HOMESCREEN_0302__) && !defined(__MMI_OP11_HOMESCREEN_US__))
    updateWpPanel(MMI_OP11_HS32_AP_CNX);
#endif

}

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_op11_hs32_get_shct_data
 * DESCRIPTION
 *  This function is to get BT info for shortcut data
 * PARAMETERS
 *  sidebar_id  [IN]:   short cut sidebar info from home screen.
 *  shct_id     [IN]:   short cut id from home screen
 *  shct_data_p [IN]:   short cut data
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_bt_op11_hs32_get_shct_data(S32 sidebar_id,S32 shct_id, void *shct_data_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_bt_cm_dev_struct *dev_p;

    mmi_op11_hs32_shct_data_struct * data_p = (mmi_op11_hs32_shct_data_struct *)shct_data_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(mmi_bt_is_hw_ready(MMI_FALSE))
    {
        data_p->item_uid[0] = (srv_bt_cm_get_power_status() == SRV_BT_CM_POWER_ON?MMI_TRUE : MMI_FALSE);
        //data_p->item_uid[1] = srv_bt_cm_is_vis() || srv_bt_cm_get_ram_flag(SRV_BT_CM_RAMMASK_IS_TEMP_VIS);
        data_p->item_uid[1] = (srv_bt_cm_get_visibility() == SRV_BT_CM_VISIBILITY_ON ||
            srv_bt_cm_get_visibility() == SRV_BT_CM_VISIBILITY_TEMPORARY_ON);
        if (srv_bt_cm_is_profile_connected(SRV_BT_CM_A2DP_CONNECTION))
        {
            data_p->item_uid[1] = 0;
        }
        
        dev_p = srv_bt_cm_get_host_dev_info ();        
        mmi_chset_utf8_to_ucs2_string(
            (kal_uint8*) data_p->item_content[0],
            SRV_BT_CM_BD_NAME_UCS2_LEN,
            (kal_uint8*) dev_p->name);        
        data_p->result_flag = MMI_OP11_HS32_RESULT_OK;
        mmi_op11_hs32_answer_shct_data(sidebar_id,shct_id,data_p);
    }
    else
    {
        data_p->result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
        mmi_op11_hs32_answer_shct_data(sidebar_id,shct_id,data_p);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_bt_op11_hs32_update_shct_data
 * DESCRIPTION
 *  This function is to update BT info for shortcut data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_bt_op11_hs32_update_shct_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_bt_cm_dev_struct *dev_p;
    mmi_op11_hs32_shct_data_struct *shct_data_p;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* All update HS32 shortcut fucntion, please get the data pointer and verify it first */
    shct_data_p = mmi_op11_hs32_get_shct_data_pointer(MMI_OP11_HS32_AP_CNX, MMI_OP11_HS32_SHCT_CNX_BT);

    if(shct_data_p != NULL)
    {
        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_UPDATE;

        shct_data_p->item_uid[0] = (srv_bt_cm_get_power_status() == SRV_BT_CM_POWER_ON?MMI_TRUE : MMI_FALSE); 

        //shct_data_p->item_uid[1] = srv_bt_cm_is_vis() || srv_bt_cm_get_ram_flag(SRV_BT_CM_RAMMASK_IS_TEMP_VIS);
        shct_data_p->item_uid[1] = (srv_bt_cm_get_visibility() == SRV_BT_CM_VISIBILITY_ON ||
            srv_bt_cm_get_visibility() == SRV_BT_CM_VISIBILITY_TEMPORARY_ON);

        if (srv_bt_cm_is_profile_connected(SRV_BT_CM_A2DP_CONNECTION))
        {
            shct_data_p->item_uid[1] = 0;
        }

        dev_p = srv_bt_cm_get_host_dev_info ();        
        mmi_chset_utf8_to_ucs2_string(
            (kal_uint8*) shct_data_p->item_content[0],
            SRV_BT_CM_BD_NAME_UCS2_LEN,
            (kal_uint8*) dev_p->name);        

       
        mmi_op11_hs32_answer_shct_data(MMI_OP11_HS32_AP_CNX, MMI_OP11_HS32_SHCT_CNX_BT, shct_data_p);
    }
}


#endif /* __MMI_BT_SUPPORT__ */


#ifdef __MMI_WLAN_FEATURES__
/*****************************************************************************
 * AP Connections [CNX] WIFI Functions
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_cnx_wifi_update
 * DESCRIPTION
 *  for bt update sidebar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_op11_hs32_cnx_wifi_update(mmi_event_struct* event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_idle_is_active()&&mmi_op11_hs32_is_enable())
    {
        switch (event->evt_id)
        {
            case EVT_ID_SRV_DTCNT_WLAN_ACTIVE:
            case EVT_ID_SRV_DTCNT_WLAN_CONNECTED:
            case EVT_ID_SRV_DTCNT_WLAN_INACTIVE:
            case EVT_ID_SRV_DTCNT_WLAN_SCAN:
            case EVT_ID_SRV_DTCNT_WLAN_CONNECT:
            case EVT_ID_SRV_DTCNT_WLAN_INIT_RES_IND:
            case EVT_ID_SRV_DTCNT_WLAN_DEINIT_RES_IND:
            case EVT_ID_SRV_DTCNT_WLAN_CURR_AP_INFO:
                mmi_wifi_op11_hs32_update_shct_data();
                break;

            default:
                break;
        }
    }

      return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_wifi_op11_hs32_get_shct_data
 * DESCRIPTION
 *  This function is to get WIFI info for shortcut data
 * PARAMETERS
 *  shct_data_p [IN]:   short cut data
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_fill_wifi_data(void *shct_data_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct * data_p = (mmi_op11_hs32_shct_data_struct *)shct_data_p;
    srv_dtcnt_prof_str_info_qry_struct ssid_out;
    S32 Signal;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Store WIFI status in data_p->item_uid[0] */
    /* 1: ON; 0: OFF */
    if (//(srv_dtcnt_wlan_status() == SRV_DTCNT_WLAN_STATUS_ACTIVE) ||
        (srv_dtcnt_wlan_status() == SRV_DTCNT_WLAN_STATUS_CONNECTED))
    {
        data_p->item_uid[0] = 1;

        /* Store WIFI singal strength in data_p->item_uid[1] */
        srv_dtcnt_wlan_get_connected_ap_rssi(&Signal);
        /* Signal > -40dBm will show 100%, <-80dBm will show 0%  */
        if (Signal > -40)
        {
            data_p->item_uid[1] = 100;
        }
        else if (Signal > -60)
        {
            data_p->item_uid[1] = 75;
        }
        else if (Signal > -70)
        {
            data_p->item_uid[1] = 50;
        }
        else if (Signal > -80)
        {
            data_p->item_uid[1] = 25;
        }
        else
        {
            data_p->item_uid[1] = 0;
        }

        /* Store WIFI connected AP SSID strength in data_p->item_content[0] */
        ssid_out.dest = (CHAR*)data_p->item_content[1]; /* temp ASCII buffer */
        ssid_out.dest_len = MMI_OP11_HS32_SHCT_CONTENT_STRLEN_MAX-1;  /* #define MAX_WLAN_SSID_LEN 65 */
        memset(data_p->item_content[0], 0, sizeof(data_p->item_content));
        srv_dtcnt_wlan_get_connected_ap_ssid(&ssid_out);
        mmi_asc_n_to_ucs2((CHAR*)data_p->item_content[0], (CHAR*)ssid_out.dest, ssid_out.dest_len);

    }
    else
    {
        data_p->item_uid[0] = 0;
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_wifi_op11_hs32_get_shct_data
 * DESCRIPTION
 *  This function is to answer WIFI info for shortcut data
 * PARAMETERS
 *  sidebar_id  [IN]:   short cut sidebar info from home screen.
 *  shct_id     [IN]:   short cut id from home screen
 *  shct_data_p [IN]:   short cut data
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_wifi_op11_hs32_get_shct_data(S32 sidebar_id,S32 shct_id, void *shct_data_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct * data_p = (mmi_op11_hs32_shct_data_struct *)shct_data_p;

    mmi_op11_hs32_fill_wifi_data(shct_data_p);

    data_p->result_flag = MMI_OP11_HS32_RESULT_OK;
    mmi_op11_hs32_answer_shct_data(sidebar_id,shct_id,data_p);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_wifi_op11_hs32_update_shct_data
 * DESCRIPTION
 *  This function is to update WIFI info for shortcut data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_wifi_op11_hs32_update_shct_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* All update HS32 shortcut fucntion, please get the data pointer and verify it first */
    shct_data_p = mmi_op11_hs32_get_shct_data_pointer(MMI_OP11_HS32_AP_CNX, MMI_OP11_HS32_SHCT_CNX_WIFI);

    if(shct_data_p != NULL)
    {
        mmi_op11_hs32_fill_wifi_data(shct_data_p);

        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_UPDATE;

        mmi_op11_hs32_answer_shct_data(MMI_OP11_HS32_AP_CNX, MMI_OP11_HS32_SHCT_CNX_WIFI, shct_data_p);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_bt_op11_hs32_entry_power_switch
 * DESCRIPTION
 *  This function is to entry BT power switch
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_entry_wifi_power_switch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    mmi_wlan_entry_wlan_wizard_new();
}


#endif

/*****************************************************************************
 * AP VIP Contacts [VIP] VIP Functions
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_query_sidebar_vip
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  indctr_id         : [IN] indicator id
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_query_sidebar_vip(S32 sidebar_id, S32 indctr_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_query_info_struct sidebar_answer;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (!srv_phb_startup_is_phb_ready())
    {
        sidebar_answer.result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
        mmi_op11_hs32_answer_sidebar(sidebar_id, indctr_id, &sidebar_answer);
    }
    else
    {
        sidebar_answer.result_flag = MMI_OP11_HS32_RESULT_OK;
        mmi_op11_hs32_answer_sidebar(sidebar_id, indctr_id, &sidebar_answer);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_sidebar_answer_vip
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  indctr_id         : [IN] indicator id
 *  sidebar_answer_p  : [IN] sidebar anwser buffer pointer
 *  sidebar_info  : [IN] sidebar info buffer pointer
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_sidebar_answer_vip(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_NOT_READY)
    {
        sidebar_info->sidebar_status = MMI_OP11_HS32_RESULT_NOT_READY;
    }

    if((sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_OK) || (sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE))
    {
        sidebar_info->sidebar_status = MMI_OP11_HS32_RESULT_OK;
        /* vip account sync */
        mmi_op11_hs32_us_vip_sync();
    }


    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
    {
        mmi_op11_hs32_realloc_and_update_shct(sidebar_info);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_indicator_answer
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_sidebar_normal_answer(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_OK) ||(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE))
    {
        /* fill viewitem info to data buffer  */
        MMI_ASSERT(sidebar_info->sidebar_id == sidebar_id);

        sidebar_info->indicator_data[indctr_id] = sidebar_answer_p->indicator_value;

        sidebar_info->sidebar_status = sidebar_answer_p->ap_status;
    }

    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
    {
        updateIndicator(sidebar_id);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_answer_sidebar
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_answer_sidebar(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_struct *sidebar_info=g_mmi_op11_hs32_cntx.sidebar_p;
    S32 i;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (!(mmi_idle_is_active()&&mmi_op11_hs32_is_enable()))
    {
        return;
    }
    MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_ANSWER_SD, sidebar_id, indctr_id, sidebar_answer_p->result_flag, sidebar_answer_p->ap_status);

    #if (defined(__MMI_OP11_HOMESCREEN_0302__) && !defined(__MMI_OP11_HOMESCREEN_US__))
        if ((sidebar_id == MMI_OP11_HS32_AP_ALM) && (indctr_id == 1))
        {
            mmi_op11_hs32_sync_wp_alm(sidebar_id, indctr_id, sidebar_answer_p);
            return;
        }
        if ((sidebar_id == MMI_OP11_HS32_AP_MUS) && (indctr_id == 1))
        {
            updatePlaybackPanel();
            return;
        }
    #endif
                
    for(i=0; i<g_mmi_op11_hs32_cntx.sidebar_count; i++, sidebar_info++)
    {
        if(sidebar_info->sidebar_id == sidebar_id)
        {
            switch (sidebar_id)
            {
                case MMI_OP11_HS32_AP_CON:
                    mmi_op11_hs32_sidebar_answer_con(sidebar_id, indctr_id, sidebar_answer_p, sidebar_info);
                    break;

                case MMI_OP11_HS32_AP_EML:
                    mmi_op11_hs32_sidebar_answer_eml(sidebar_id, indctr_id, sidebar_answer_p, sidebar_info);
                    break;

                case MMI_OP11_HS32_AP_OMR:
                    mmi_op11_hs32_sidebar_answer_omr(sidebar_id, indctr_id, sidebar_answer_p, sidebar_info);
                    break;

                case MMI_OP11_HS32_AP_PRO:
                    mmi_op11_hs32_sidebar_answer_state(sidebar_id, indctr_id, sidebar_answer_p, sidebar_info);
                    break;

                case MMI_OP11_HS32_AP_ALM:
                    MMI_ASSERT(indctr_id == 0);
                    mmi_op11_hs32_sidebar_answer_alm(sidebar_id, indctr_id, sidebar_answer_p, sidebar_info);
                    break;

                case MMI_OP11_HS32_AP_MUS:
                    mmi_op11_hs32_sidebar_answer_state(sidebar_id, indctr_id, sidebar_answer_p, sidebar_info);
                    break;

                case MMI_OP11_HS32_AP_VIP:
                    mmi_op11_hs32_sidebar_answer_vip(sidebar_id, indctr_id, sidebar_answer_p, sidebar_info);
                    break;

                default:
                    mmi_op11_hs32_sidebar_normal_answer(sidebar_id, indctr_id, sidebar_answer_p, sidebar_info);
                break;
            }
            break;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_answer_shct_data
 * DESCRIPTION
 *  answer APs return shct data
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  shct_data_p  : [IN] shortcut data address
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_answer_shct_data(S32 sidebar_id, 
                         S32 shct_id, 
                         mmi_op11_hs32_shct_data_struct *shct_data_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_struct *sidebar_info = g_mmi_op11_hs32_cntx.sidebar_p;
    mmi_op11_hs32_shct_struct *shct_info;
    S32 i,j;
    S32 hightlight_index;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (!(mmi_idle_is_active()&&mmi_op11_hs32_is_enable()))
    {
        return;
    }
    MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_ANSWER_SHCT, sidebar_id, shct_id, shct_data_p->result_flag, shct_data_p->item_count);
    MMI_ASSERT(shct_data_p->item_content[MMI_OP11_HS32_SHCT_ITEM_COUNT_MAX-1][MMI_OP11_HS32_SHCT_CONTENT_STRLEN_MAX] == 0);

#ifdef __MMI_OP11_HOMESCREEN_US__
    if ((sidebar_id == MMI_OP11_HS32_AP_CLL) || (sidebar_id == MMI_OP11_HS32_AP_MES))
    {
        mmi_op11_hs32_answer_us_shct_data(sidebar_id,shct_id,shct_data_p);
        return;
    }
#endif

    if (sidebar_id == MMI_OP11_HS32_AP_MES)
    {
        mmi_op11_hs32_answer_shct_data_mes(sidebar_id,shct_id,shct_data_p);
        return;
    }

    if ((shct_data_p->result_flag == MMI_OP11_HS32_RESULT_OK) || (shct_data_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE))
    {
        /* fill shortcut data buffer  */
        for(i=0; i<g_mmi_op11_hs32_cntx.sidebar_count; i++,sidebar_info++)
        {
            if(sidebar_info->sidebar_id == sidebar_id)
            {
                shct_info = sidebar_info->shortcut_p;
                for(j=0; j<sidebar_info->shortcut_count; j++, shct_info++)
                {
                    if(shct_info->shct_id== shct_id)
                    {
                        /* Trace */
                    #ifndef __MMI_OP11_HOMESCREEN_US__
                        if(shct_data_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
                        {
                            hightlight_index = vadp_v2p_op11_hs_shct_get_def_hlt_shct_index(sidebar_info);
                            setHighlightedShortcut(sidebar_id, hightlight_index);
                        }
                    #endif
                    }
                }
            }
        }
    }
    if(shct_data_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
    {
    /* set first open history */
        updateViewItem(sidebar_id, 0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_is_shct_data_buffer_valid
 * DESCRIPTION
 *  for APs verify data buffer valid
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  shct_data_p  : [IN] shortcut data address
 * RETURNS
 *  MMI_TRUE: shortcut data buffer is valid.
 *  MMI_FALSE: means may leave HomeScreen, or  user already delete this sidebar, so no need to fill data.
 *****************************************************************************/
MMI_BOOL mmi_op11_hs32_is_shct_data_buffer_valid(
                         S32 sidebar_id, 
                         S32 shct_id, 
                         mmi_op11_hs32_shct_data_struct *shct_data_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_struct *sidebar_info = g_mmi_op11_hs32_cntx.sidebar_p;
    mmi_op11_hs32_shct_struct *shct_info;
    S32 i,j;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(mmi_idle_is_active()&&mmi_op11_hs32_is_enable()))
    {
        return MMI_FALSE;
    }

    /* fill shortcut data buffer  */
    for(i=0; i<g_mmi_op11_hs32_cntx.sidebar_count; i++, sidebar_info++)
    {
        if(sidebar_info->sidebar_id == sidebar_id)
        {
            shct_info= sidebar_info->shortcut_p;
            for(j=0; j<sidebar_info->shortcut_count; j++, shct_info++)
            {
                if(shct_info->shct_id == shct_id)
                {
                    if(shct_data_p == shct_info->data_p)
                    {
                        return MMI_TRUE;
                    }
                }
            }
        }
    }

    return MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_get_sidebar_info_pointer
 * DESCRIPTION
 *  Get sidebar info pointer 
 *  (if retun NULL: means may leave HomeScreen, 
 *                        or  user already delete this sidebar, so no need to fill data.)
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 * RETURNS
 *  sidebar info pointer
 *****************************************************************************/
mmi_op11_hs32_sidebar_struct* mmi_op11_hs32_get_sidebar_info_pointer(S32 sidebar_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_struct *sidebar_info = g_mmi_op11_hs32_cntx.sidebar_p;
    S32 i;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (!(mmi_idle_is_active()&&mmi_op11_hs32_is_enable()))
    {
        MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_SIDEBAR_NOT_ON_IDLE);
    }

    if (g_mmi_op11_hs32_cntx.mem.app_mem_pool == NULL)
    {
        MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_NO_MEMORY);
        return NULL;
    }
    
    /* find sidebar info buffer  */
    for(i=0; i<g_mmi_op11_hs32_cntx.sidebar_count; i++, sidebar_info++)
    {
        if(sidebar_info->sidebar_id == sidebar_id)
        {
            return sidebar_info;
        }
    }
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_get_shct_data_pointer
 * DESCRIPTION
 *  for APs get data pointer 
 *  (if retun NULL: means may leave HomeScreen, 
 *                        or  user already delete this sidebar, so no need to fill data.)
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 * RETURNS
 *  shortcut data pointer
 *****************************************************************************/
mmi_op11_hs32_shct_data_struct* mmi_op11_hs32_get_shct_data_pointer(S32 sidebar_id, S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (!(mmi_idle_is_active()&&mmi_op11_hs32_is_enable()))
    {
        return NULL;
    }

    if (sidebar_id == MMI_OP11_HS32_AP_MES)
    {
        switch (shct_id)
        {
            case MMI_OP11_HS32_SHCT_MES_NEW_SMS:
                return g_mmi_op11_hs32_cntx.mes_data_p[shct_id];

            case MMI_OP11_HS32_SHCT_MES_NEW_MMS:
                return g_mmi_op11_hs32_cntx.mes_data_p[shct_id];

            default:
                MMI_ASSERT(shct_id);
        }
    }

    return mmi_op11_hs32_get_shct_data_pointer_internal(sidebar_id, shct_id);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_get_shct_data_pointer_internal
 * DESCRIPTION
 *  for HS internal get data pointer 
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 * RETURNS
 *  shortcut data pointer
 *****************************************************************************/
mmi_op11_hs32_shct_data_struct* mmi_op11_hs32_get_shct_data_pointer_internal(S32 sidebar_id, S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_struct *sidebar_info = g_mmi_op11_hs32_cntx.sidebar_p;
    mmi_op11_hs32_shct_struct *shct_info;
    S32 i,j;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(mmi_idle_is_active()&&mmi_op11_hs32_is_enable()))
    {
        MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_SHCT_NOT_ON_IDLE);
    }

    if (g_mmi_op11_hs32_cntx.mem.app_mem_pool == NULL)
    {
        MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_NO_MEMORY);
        return NULL;
    }
    
    /* find shortcut data buffer  */
    for(i=0; i<g_mmi_op11_hs32_cntx.sidebar_count; i++, sidebar_info++)
    {
        if(sidebar_info->sidebar_id == sidebar_id)
        {
            shct_info= sidebar_info->shortcut_p;
            for(j=0; j<sidebar_info->shortcut_count; j++, shct_info++)
            {
                if(shct_info->shct_id == shct_id)
                {
                    return shct_info->data_p;
                }
            }
        }
    }

    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_fatal_func
 * DESCRIPTION
 * Callback function to release the app ASM allocated by OP11 HS32 
 * And this func should not be called because OP11 HS32 will release app mem when exit screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_app_asm_stop_callback(void)
{
    /* It should not happen */
    MMI_ASSERT(0);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_app_mem_success_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_app_mem_success_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_op11_hs32_cntx.mem.app_mem_pool
        = applib_mem_ap_alloc(APPLIB_MEM_AP_ID_OP11_HS32, MMI_OP11_HS32_APP_MEM_TOTAL_SIZE);
    ASSERT(g_mmi_op11_hs32_cntx.mem.app_mem_pool != NULL);      /* It should provide enough memory */

    mmi_op11_hs32_goback_to_main();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_goback_to_main
 * DESCRIPTION
 *  go back to idle with history
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_goback_to_main(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    GoBackToHistory(IDLE_SCREEN_ID);
//    mmi_idle_display();
    mmi_frm_close_to_idle_group();
    mmi_frm_close_to_root_screen(GRP_ID_IDLE_MAIN);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_is_proprietary_sim
 * DESCRIPTION
 *  go back to idle with history
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_activate_by_ssc(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_popup_property_struct popup_arg;
//    MMI_ID sg_id = mmi_frm_group_get_active_id();
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_op11_hs32_cntx.flag |= MMI_OP11_HS32_ACTIVATE_BY_SSC;
    g_mmi_op11_hs32_cntx.flag |= MMI_OP11_HS32_HISTORY_DISCARDED;

    mmi_popup_property_init(&popup_arg);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    mmi_popup_display((WCHAR*)get_string(STR_GLOBAL_ACTIVATED), MMI_EVENT_SUCCESS, &popup_arg);

//    mmi_display_popup(get_string(STR_GLOBAL_ACTIVATED), MMI_EVENT_SUCCESS);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_is_proprietary_sim
 * DESCRIPTION
 *  go back to idle with history
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_op11_hs32_is_proprietary_sim(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR hplmn[SRV_MAX_PLMN_LEN + 1];
    S32 n_sim, size;
    S32 i;
    MMI_BOOL ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Skip SIM card MCC/MNC check if Homescreen is activated by SSC. */
    if ((g_mmi_op11_hs32_cntx.flag & MMI_OP11_HS32_ACTIVATE_BY_SSC))
    {
        return MMI_TRUE;
    }
    
    /* If the SIM's IMSI is not ready, e.g., no SIM inserted, don't enable
       the Homescreen. */
    ret = srv_sim_ctrl_get_home_plmn(MMI_SIM1, hplmn, SRV_MAX_PLMN_LEN + 1);

    if (!ret)
    {
        return MMI_FALSE;
    }

    /* Check the MCC/MNC is the proprietary one. */
    n_sim = MMI_HS32_GET_SIZE(g_op11_hs32_proprietary_sim);

//    srv_nw_info_get_nw_plmn(MMI_SIM1, PLMNNum, SRV_MAX_PLMN_LEN+1);

    for (i = 0; i < n_sim; i++)
    {
        size = strlen(g_op11_hs32_proprietary_sim[i]);
        
        if (!memcmp(hplmn, g_op11_hs32_proprietary_sim[i], size))
        {
            return MMI_TRUE;
        }
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_is_enable
 * DESCRIPTION
 *  go back to idle with history
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_op11_hs32_is_enable(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /*
     * Homescreen is enable if 
     *  (a) not in no SIM mode or SIM blocked mode or SIM error mode.
     *  (b) proprietary SIM card
     *  (c) the user has chosen to activate the Homescreen
     */
    if (srv_sim_ctrl_is_available(MMI_SIM1) &&
//        (srv_sim_ctrl_get_unavailable_cause(MMI_SIM1) != SRV_SIM_CTRL_UA_CAUSE_BT_ACCESS_PROFILE) &&
        mmi_op11_hs32_is_proprietary_sim() &&
        PhnsetGetHomeScreenStatus())
    {
        return MMI_TRUE;
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_init
 * DESCRIPTION
 *  init app
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_discard_history(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_op11_hs32_cntx.flag |= MMI_OP11_HS32_HISTORY_DISCARDED;
	if (GetScreenCountInHistory() > 1)
	{
		g_mmi_op11_hs32_cntx.flag |= MMI_OP11_HS32_HISTORY_NO_SSE;
	}
}


/*****************************************************************************
 * FUNCTION
 *  mmi_hs_redraw_homescreen
 * DESCRIPTION
 *  This function redraws the Homescreen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_redraw_homescreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Set on the flag such that the history will not be freed. */
    g_mmi_op11_hs32_cntx.flag |= MMI_OP11_HS32_HISTORY_FOR_REDRAW;
//    redraw screen, For small screen background.
    mmi_op11_hs32_entry_homescreen();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_hs_pre_fetch_history
 * DESCRIPTION
 *  This function pre-fetches the history data immediately after we enter the
 *  idle screen to avoid from that the history data is de-initialized.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_pre_fetch_history(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

}



/*****************************************************************************
 * FUNCTION
 *  mmi_hs_pre_fetch_history
 * DESCRIPTION
 *  This function pre-fetches the history data immediately after we enter the
 *  idle screen to avoid from that the history data is de-initialized.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_reset_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_op11_hs32_is_enable())
    {
        return;
    }
    if (mmi_idle_is_active())
    {
        deactivate();
    }
/*
    else
    {
        mmi_op11_hs32_discard_history();
    }
*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_proc_cb_mgr
 * DESCRIPTION
 *  process mmi_cb_mgr_cfg.h EVT_ID_GPIO_BACKLIGHT_DIMMING events.
 * PARAMETERS
 *  para
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_op11_hs32_proc_gpio_dimming(mmi_event_struct* para)
{
    mmi_op11_hs32_reset_screen();
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_init
 * DESCRIPTION
 *  init app
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32     i, j;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&g_mmi_op11_hs32_cntx, 0, sizeof(mmi_op11_hs_context_struct));

    applib_mem_ap_register(
        APPLIB_MEM_AP_ID_OP11_HS32,
        STR_GLOBAL_ERROR,
        IMG_GLOBAL_ERROR,
        mmi_op11_hs32_app_asm_stop_callback);

    g_mmi_op11_hs32_cntx.mem.app_mem_pool = NULL;

    mmi_op11_hs32_setting_init();

    i =0;
    while (g_hs_sdbr_hist_p[i] != 0xFF)
    {
        j=0;
        while(g_hs_hist_cntx.shct_hist[g_hs_sdbr_hist_p[i]][j] != 0xFF)
        {
            j++;
        }
        g_mmi_op11_hs32_cntx.shct_hist_count[g_hs_sdbr_hist_p[i]] = j;
        i++;
    }
    g_mmi_op11_hs32_cntx.sidebar_count = i;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_init
 * DESCRIPTION
 *  init app
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_read_cout(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32     i, j;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    i =0;
    while (g_hs_sdbr_hist_p[i] != 0xFF)
    {
        j=0;
        while(g_hs_hist_cntx.shct_hist[g_hs_sdbr_hist_p[i]][j] != 0xFF)
        {
            j++;
        }
        g_mmi_op11_hs32_cntx.shct_hist_count[g_hs_sdbr_hist_p[i]] = j;
        i++;
    }
    g_mmi_op11_hs32_cntx.sidebar_count = i;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_sidebar_answer_alm
 * DESCRIPTION
 *  for APs return sidebar info
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 *  shct_id         : [IN] short id
 *  sidebar_info_p  : [IN] sidebar info
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_sidebar_answer_alm(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p, mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    U8* alm_list = (U8*)sidebar_answer_p->sync_data;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_NOT_READY)
    {
            sidebar_info->sidebar_status = MMI_OP11_HS32_RESULT_NOT_READY;
    }

    if((sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_OK) || (sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE))
    {
//        g_mmi_op11_hs32_cntx.sidebar_flag[MMI_OP11_HS32_AP_ALM] = SPECIAL_AP_SYNC_DONE;
        sidebar_info->sidebar_status = MMI_OP11_HS32_RESULT_OK;

        MMI_ASSERT(sidebar_info->sidebar_id == sidebar_id);
        sidebar_info->indicator_data[0] = sidebar_answer_p->indicator_value;

        /* account sync */
        if (sidebar_answer_p->indicator_value == 0)
        {
            g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_ALM]= 1;
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_ALM][0] = MMI_OP11_HS32_SHCT_ALM_NO;
        }
        else
        {
            g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_ALM] = sidebar_answer_p->indicator_value;
            for (i=0; i<g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_ALM]; i++)
            {
                g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_ALM][i] = MMI_OP11_HS32_SHCT_ALM_1 + i;
                g_mmi_op11_hs32_cntx.alm_account[i] = alm_list[i];
            }
        }
                /* save account to NVRAM */
                mmi_op11_hs_save_id_history();
    }


    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
    {
        /* update email viewitem  */
        mmi_op11_hs32_realloc_and_update_shct(sidebar_info);
    }

}








/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_adm_free_shct
 * DESCRIPTION
 *  This function exits the Venus home screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_adm_free_shct(mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 j;
    mmi_op11_hs32_shct_struct *shct_info;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if(sidebar_info->shortcut_p != NULL)
    {
        shct_info = sidebar_info->shortcut_p;
        for(j=0; j<sidebar_info->shortcut_count; j++, shct_info++)
        {
            if(shct_info->with_content_flag == 1)
            {
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif                
                MMI_ASSERT(shct_info->data_p != NULL);
                kal_adm_free(g_mmi_op11_hs32_cntx.mem.adm_pool_id, shct_info->data_p);
                shct_info->data_p = NULL;
                shct_info->with_content_flag = 0;
            }
        }
        
        kal_adm_free(g_mmi_op11_hs32_cntx.mem.adm_pool_id, sidebar_info->shortcut_p);
        sidebar_info->shortcut_p = NULL;
    }    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_vhs_exit_homescreen
 * DESCRIPTION
 *  This function exits the Venus home screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_adm_free(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    kal_status ret;
    U32 adm_total_left_size;
    mmi_op11_hs32_sidebar_struct *sidebar_info = g_mmi_op11_hs32_cntx.sidebar_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    adm_total_left_size = kal_adm_get_total_left_size(g_mmi_op11_hs32_cntx.mem.adm_pool_id);

    for(i=0; i<g_mmi_op11_hs32_cntx.sidebar_count; i++,sidebar_info++)
    {
        mmi_op11_hs32_adm_free_shct(sidebar_info);
    }

    kal_adm_free(g_mmi_op11_hs32_cntx.mem.adm_pool_id, g_mmi_op11_hs32_cntx.sidebar_p);
    g_mmi_op11_hs32_cntx.sidebar_p = NULL;

    /* free mes two extra shct data buffer  */
    if (g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_SMS] != NULL)
    {
        kal_adm_free(g_mmi_op11_hs32_cntx.mem.adm_pool_id, g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_SMS]);
        g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_SMS] = NULL;
    }
    if (g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_MMS] != NULL)
    {
        kal_adm_free(g_mmi_op11_hs32_cntx.mem.adm_pool_id, g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_MMS]);
        g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_MMS] = NULL;
    }


    adm_total_left_size = kal_adm_get_total_left_size(g_mmi_op11_hs32_cntx.mem.adm_pool_id);

    ret = kal_adm_delete(g_mmi_op11_hs32_cntx.mem.adm_pool_id);
    ASSERT(ret == KAL_SUCCESS);
    g_mmi_op11_hs32_cntx.mem.adm_pool_id = NULL;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vhs_exit_homescreen
 * DESCRIPTION
 *  This function exits the Venus home screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_exit_homescreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 size;
    S32 hs_time;
    mmi_op11_hs_screen_history_struct *screen_history_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//trace:   exit start
    MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_EXIT);

    if (vadp_p2v_op11_hs_is_active())
    {
        if (!(g_mmi_op11_hs32_cntx.flag & MMI_OP11_HS32_HISTORY_FOR_REDRAW))
        {
            /* Save the history. */
            if (g_mmi_op11_hs32_cntx.history)
            {
                OslMfree(g_mmi_op11_hs32_cntx.history);
            }
            
            /* Obtain the history buffer size. */
            size = vadp_p2v_op11_hs_get_history_size();
            
            g_mmi_op11_hs32_cntx.history = OslMalloc(size);
            MMI_ASSERT(g_mmi_op11_hs32_cntx.history != NULL);
            
            vadp_p2v_op11_hs_get_history(g_mmi_op11_hs32_cntx.history, size);
    
            if (g_mmi_op11_hs32_cntx.history)
            {
                screen_history_p = (mmi_op11_hs_screen_history_struct *)g_mmi_op11_hs32_cntx.history;
                MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_HISTORY_VIEW_MODE, screen_history_p->view_mode);
                MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_HISTORY_VIEW_STATE, screen_history_p->view_state);
                MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_HISTORY_SD_INDX, screen_history_p->sidebar_index);
                MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_HISTORY_SHCT_INDX, screen_history_p->shortcut_index);
            }
        }

        vadp_p2v_op11_hs_deinit();
    }
    /* free adm  */
    mmi_op11_hs32_adm_free();

#if defined(__MMI_OP11_HS32_MEM_MONOPOLY__)
    g_mmi_op11_hs32_cntx.mem.app_mem_pool = NULL;
#elif  defined(__MMI_OP11_HS32_MEM_SHARE_MED__)
    if (g_mmi_op11_hs32_cntx.mem.app_mem_pool != NULL)
    {
//        med_free_ext_mem((void*)&g_mmi_op11_hs32_cntx.mem.app_mem_pool);
        med_free_asm_mem(APP_OP11_HS32, (void*)&g_mmi_op11_hs32_cntx.mem.app_mem_pool);
        
        g_mmi_op11_hs32_cntx.mem.app_mem_pool = NULL;
    }
#else
    if (g_mmi_op11_hs32_cntx.mem.app_mem_pool != NULL)
    {
        applib_mem_ap_free(g_mmi_op11_hs32_cntx.mem.app_mem_pool);
        g_mmi_op11_hs32_cntx.mem.app_mem_pool = NULL;
    }
#endif

    hs_time = GetPhnsetGPIOBlHftime();

    MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_EXIT_END, hs_time);

    if (hs_time < MMI_OP11_HS32_APP_TOV)
    {
        hs_time = MMI_OP11_HS32_APP_TOV;
    }

    if (!(g_mmi_op11_hs32_cntx.flag & MMI_OP11_HS32_HISTORY_FOR_REDRAW))
    {
        StartTimer(IDLE_HS32_REVERT_TIMER, 
                        hs_time, mmi_op11_hs32_revert_timeout);
    }
    g_mmi_op11_hs32_cntx.flag &= ~MMI_OP11_HS32_HISTORY_FOR_REDRAW;

//trace:   exit end
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vhs_entry_homescreen
 * DESCRIPTION
 *  This function shows the Venus home screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_revert_timeout(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    g_mmi_op11_hs32_cntx.flag |= MMI_OP11_HS32_HISTORY_DISCARDED;
    MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_TIMEOUT);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_vhs_entry_homescreen
 * DESCRIPTION
 *  This function shows the Venus home screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_entry_homescreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //mmi_op11_hs_setting_struct *setting;
    extern void gui_effect_cpy_buf_a2b(void); 
	
    S32 i;
    mmi_op11_hs32_sidebar_struct *sidebar_info;
    mmi_op11_hs_screen_history_struct *screen_history_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_ENTRY);
    
#if defined(__MMI_OP11_HS32_MEM_MONOPOLY__)
    g_mmi_op11_hs32_cntx.mem.app_mem_pool = g_mmi_op11_hs32_data_mem;
#elif  defined(__MMI_OP11_HS32_MEM_SHARE_MED__)
    if (g_mmi_op11_hs32_cntx.mem.app_mem_pool == NULL)
    {
//        g_mmi_op11_hs32_cntx.mem.app_mem_pool = med_alloc_ext_mem(MMI_OP11_HS32_APP_MEM_TOTAL_SIZE);
        g_mmi_op11_hs32_cntx.mem.app_mem_pool = med_alloc_asm_mem(APP_OP11_HS32, MMI_OP11_HS32_APP_MEM_TOTAL_SIZE);
    }
#else
    if (g_mmi_op11_hs32_cntx.mem.app_mem_pool == NULL)
    {
        g_mmi_op11_hs32_cntx.mem.app_mem_pool = applib_mem_ap_alloc(APPLIB_MEM_AP_ID_OP11_HS32, MMI_OP11_HS32_APP_MEM_TOTAL_SIZE);
    }
    
    if (g_mmi_op11_hs32_cntx.mem.app_mem_pool == NULL)
    {
        mmi_frm_appmem_prompt_to_release_mem(
            APPLIB_MEM_AP_ID_OP11_HS32,
            IMG_GLOBAL_ERROR,
            MMI_OP11_HS32_APP_MEM_TOTAL_SIZE,
            mmi_op11_hs32_app_mem_success_callback);
        return;
    }
#endif

    MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_ALLOC_MEMORY, g_mmi_op11_hs32_cntx.mem.app_mem_pool);
    
    mmi_op11_hs32_read_cout();
    MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_SIDEBAR_COUNT, g_mmi_op11_hs32_cntx.sidebar_count);
    
    /* Manage the allocated memory by ADM as below. */    

    if (g_mmi_op11_hs32_cntx.mem.adm_pool_id == NULL)
    {
        g_mmi_op11_hs32_cntx.mem.adm_pool_id = kal_adm_create(g_mmi_op11_hs32_cntx.mem.app_mem_pool, MMI_OP11_HS32_APP_MEM_TOTAL_SIZE, NULL, KAL_FALSE);
        MMI_ASSERT(g_mmi_op11_hs32_cntx.mem.adm_pool_id != NULL);
        
        g_mmi_op11_hs32_cntx.sidebar_p = (mmi_op11_hs32_sidebar_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_sidebar_struct)*g_mmi_op11_hs32_cntx.sidebar_count);
        MMI_ASSERT(g_mmi_op11_hs32_cntx.sidebar_p != NULL);
        memset(g_mmi_op11_hs32_cntx.sidebar_p, 0, sizeof(mmi_op11_hs32_sidebar_struct)*g_mmi_op11_hs32_cntx.sidebar_count);
    }

    /* Refresh service indication area */
    mmi_idle_update_service_area();

    /* HS screen related initial */

    if (!(g_mmi_op11_hs32_cntx.flag & MMI_OP11_HS32_HISTORY_FOR_REDRAW))
    {
        StopTimer(IDLE_HS32_REVERT_TIMER);
    }
    
    g_mmi_op11_hs32_cntx.is_sel_screen_changed = 0;
    g_mmi_op11_hs32_cntx.last_set_index = 0xff;
    
    //    ClearAllKeyHandler();
    ClearKeyEvents();

    mmi_op11_hs32_pre_fill_sidebar_info();  /* check history &  fill sidebar_id  */

    if (!(g_mmi_op11_hs32_cntx.flag & MMI_OP11_HS32_HISTORY_FOR_REDRAW))
    {
        mmi_op11_hs32_query_all_sidebar_info();
    }

#if (defined(__MMI_OP11_HOMESCREEN_0302__) && !defined(__MMI_OP11_HOMESCREEN_US__))
    mmi_alm_query_sidebar_info(MMI_OP11_HS32_AP_ALM, 1);
#endif
    
    /* mmi_op11_hs32_answer_sidebar will happend */
    
    sidebar_info = g_mmi_op11_hs32_cntx.sidebar_p;
    for(i=0; i<g_mmi_op11_hs32_cntx.sidebar_count; i++, sidebar_info++)
    {
        mmi_op11_hs32_coordinate_sidebar_info(sidebar_info); /* fill sidebar_info->shortcut_count  */
    }
    
    
    sidebar_info = g_mmi_op11_hs32_cntx.sidebar_p;
    for(i=0; i<g_mmi_op11_hs32_cntx.sidebar_count; i++, sidebar_info++)
    {
        mmi_op11_hs32_alloc_shct_and_pre_fill(sidebar_info);    /* alloc shct by history and fill shct_id  */
    }
//trace:   start     mmi_op11_hs32_query_shct_data_each_sidebar(sidebar_info);
    if (!(g_mmi_op11_hs32_cntx.flag & MMI_OP11_HS32_HISTORY_FOR_REDRAW))
    {
        sidebar_info = g_mmi_op11_hs32_cntx.sidebar_p;
        for(i=0; i<g_mmi_op11_hs32_cntx.sidebar_count; i++, sidebar_info++)
        {
            mmi_op11_hs32_query_shct_data_each_sidebar(sidebar_info);
        }
    }
//trace:   end     mmi_op11_hs32_query_shct_data_each_sidebar(sidebar_info);

    /* mmi_op11_hs32_answer_shct_data will happend */

    mmi_op11_hs32_coordinate_shct_data();    

//trace:   history flag
    MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_HISTORY_FLAG, g_mmi_op11_hs32_cntx.flag);
//trace:   history 
    if (g_mmi_op11_hs32_cntx.history)
    {
        screen_history_p = (mmi_op11_hs_screen_history_struct *)g_mmi_op11_hs32_cntx.history;
        MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_HISTORY_VIEW_MODE, screen_history_p->view_mode);
        MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_HISTORY_VIEW_STATE, screen_history_p->view_state);
        MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_HISTORY_SD_INDX, screen_history_p->sidebar_index);
        MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_HISTORY_SHCT_INDX, screen_history_p->shortcut_index);
    }

    /*  history start */
    if (g_mmi_op11_hs32_cntx.flag & MMI_OP11_HS32_HISTORY_DISCARDED)
    {
        /* discard history */
        g_mmi_op11_hs32_cntx.flag &= ~MMI_OP11_HS32_HISTORY_DISCARDED;

        if (g_mmi_op11_hs32_cntx.history)
        {
//            memset(g_mmi_op11_hs32_cntx.history, 0, sizeof(mmi_op11_hs_screen_history_struct));
            screen_history_p = (mmi_op11_hs_screen_history_struct *)g_mmi_op11_hs32_cntx.history;
            screen_history_p->view_state = 1;  //STATE_IDLE
        }
    }
#if (defined(__MMI_OP11_HOMESCREEN_0302__) && !defined(__MMI_OP11_HOMESCREEN_US__))
    if (g_mmi_op11_hs32_cntx.history)
    {
        screen_history_p->view_mode = (S32)g_mmi_op11_hs32_cntx.view_mode;  // SIDEBAR_VIEW_MODE
    }
#endif
    /*  history end */

    MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_INIT_VENUS);
    
#ifdef __MMI_SCREEN_SWITCH_EFFECT__ 
    // copy buffer A to buffer B before entering Venus HomeScreen, as buffer A is used by VRT
    gui_effect_cpy_buf_a2b();     
#endif

    vadp_p2v_op11_hs_init(g_mmi_op11_hs32_cntx.history);
    
//    SetLeftSoftkeyFunction(mmi_op11_hs_entry_personalise, KEY_EVENT_UP);    
    SetKeyHandler(dummp_func, KEY_ENTER, KEY_EVENT_DOWN);    

    /* Register the exit category function. */
    ExitCategoryFunction = mmi_op11_hs32_exit_homescreen;

    MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_ENRY_END);

}




/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_pre_fill_sidebar_info
 * DESCRIPTION
 *  Pre fill sidebar info.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_pre_fill_sidebar_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //mmi_op11_hs_setting_struct *setting;
    S32 i;
    mmi_op11_hs32_sidebar_struct *sidebar_info = g_mmi_op11_hs32_cntx.sidebar_p;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    for(i=0; i<g_mmi_op11_hs32_cntx.sidebar_count; i++, sidebar_info ++)
    {
        sidebar_info->sidebar_id = g_hs_sdbr_hist_p[i];
        MMI_TRACE(MMI_COMMON_TRC_G3_IDLE, TRC_OP11_HS32_SIDEBAR_ID, sidebar_info->sidebar_id);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_query_all_sidebar_info
 * DESCRIPTION
 *  start query sidebar info.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_query_all_sidebar_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 sidebar_id;
    S32 i;
    mmi_op11_hs32_query_sidebar_func_t query_sidebar_func;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    for(i=0; i<g_mmi_op11_hs32_cntx.sidebar_count; i++)
    {
        sidebar_id = g_hs_sdbr_hist_p[i];
        query_sidebar_func = mmi_op11_hs32_query_sidebar_func_tbl[sidebar_id];
        if(query_sidebar_func != NULL)
        {
            switch (sidebar_id)
            {
                case MMI_OP11_HS32_AP_MES:
                    query_sidebar_func(sidebar_id, 0);
                    break;

                case MMI_OP11_HS32_AP_EML:
                    query_sidebar_func(sidebar_id, MMI_OP11_HS32_EML_NOTIFY_ALL);
                    break;

                case MMI_OP11_HS32_AP_OMR:
                    query_sidebar_func(sidebar_id, MMI_OP11_HS32_OMR_NOTIFY_ALL);
                    break;

                default:
                    query_sidebar_func(sidebar_id, 0);
                    break;
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_coordinate_sidebar_info
 * DESCRIPTION
 *  start query sidebar info.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_coordinate_sidebar_info(mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 count = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(sidebar_info->sidebar_id)
    {

    case MMI_OP11_HS32_AP_CLL:
        if (srv_mode_switch_get_current_mode() == SRV_MODE_FLIGHT_MODE)
        {
            sidebar_info->shortcut_count = 0;        
        }
        else
        {
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        }
        break;
        
    case MMI_OP11_HS32_AP_CON:
        if (sidebar_info->sidebar_status != MMI_OP11_HS32_RESULT_NOT_READY)
        {
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        }
        else
        {
            sidebar_info->shortcut_count = 0;
        }        
        break;
    case MMI_OP11_HS32_AP_MES:
        if (srv_mode_switch_get_current_mode() == SRV_MODE_FLIGHT_MODE)
        {
            sidebar_info->shortcut_count = 0;        
        }
        else
        {
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        }
        break;
        
    case MMI_OP11_HS32_AP_EML:
//        if (g_mmi_op11_hs32_cntx.sidebar_flag[MMI_OP11_HS32_AP_EML] == SPECIAL_AP_SYNC_DONE)
        if (srv_mode_switch_get_current_mode() == SRV_MODE_FLIGHT_MODE)
        {
            sidebar_info->shortcut_count = 0;        
        }
        else if (!mmi_email_is_email_can_forward())
        {
            sidebar_info->shortcut_count = 0;        
        }
        else if (sidebar_info->sidebar_status != MMI_OP11_HS32_RESULT_NOT_READY)
        {
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        }
        else
        {
            sidebar_info->shortcut_count = 0;//MMI_OP11_HS32_SHCT_EML_TYPE_MAX;
        }        
        break;

    case MMI_OP11_HS32_AP_OMR:
        if (srv_mode_switch_get_current_mode() == SRV_MODE_FLIGHT_MODE)
        {
            sidebar_info->shortcut_count = 0;        
        }
        else if (sidebar_info->sidebar_status == MMI_OP11_HS32_STATUS_OMR_OFF)
        {
            sidebar_info->shortcut_count = 1;//MMI_OP11_HS32_SHCT_OMR_OM
        }
        else
        {
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        }        
        break;
        
    case MMI_OP11_HS32_AP_OWD:
        if (srv_mode_switch_get_current_mode() == SRV_MODE_FLIGHT_MODE)
        {
            sidebar_info->shortcut_count = 0;        
        }
        else
        {
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        }        
        break;
        
    case MMI_OP11_HS32_AP_PRO:        /* Profile */
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        break;
        
    case MMI_OP11_HS32_AP_ALM:        /* Alarms */
        if (sidebar_info->sidebar_status != MMI_OP11_HS32_RESULT_NOT_READY)
        {
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        }
        else
        {
            sidebar_info->shortcut_count = 0;
        }        
        break;
        
    case MMI_OP11_HS32_AP_CAL:         /* Calendar */
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        break;
        
    case MMI_OP11_HS32_AP_MUS:        /* Music */
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        break;
        
    case MMI_OP11_HS32_AP_PHO:        /* Photography */
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        break;
        
    case MMI_OP11_HS32_AP_CNX:        /* Connections (Wifi, BT, Flight Mode) */
                count = 1;

        #if defined(__MMI_OP11_HS32_CNX_WIFI__)
            if (srv_mode_switch_get_current_mode() != SRV_MODE_FLIGHT_MODE)
            {
                count ++;
            }
        #endif

#ifdef __MMI_OP11_HS32_CNX_BT__
        if (mmi_bt_is_to_display_bt_menu())
        {
                count ++;
        }
#endif /* __MMI_OP11_HS32_CNX_BT__ */
            sidebar_info->shortcut_count = count;
        break;
        
    case MMI_OP11_HS32_AP_DST:        /* Device Status */
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        break;
        
    case MMI_OP11_HS32_AP_STK: 
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        break;

    case MMI_OP11_HS32_AP_TPH: 
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        break;

    case MMI_OP11_HS32_AP_VIP: 
        if (sidebar_info->sidebar_status != MMI_OP11_HS32_RESULT_NOT_READY)
        {
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        }
        else
        {
            sidebar_info->shortcut_count = 0;
        }        
        break;

    case MMI_OP11_HS32_AP_USCON: 
            sidebar_info->shortcut_count = g_mmi_op11_hs32_cntx.shct_hist_count[sidebar_info->sidebar_id];        
        break;
        
    default:
        sidebar_info->shortcut_count = 0;
        break;
    }

    g_mmi_op11_hs32_cntx.shct_ui_count[sidebar_info->sidebar_id] = sidebar_info->shortcut_count;

    return;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_realloc_and_update_shct
 * DESCRIPTION
 *  shortcut history must already updated
 * PARAMETERS
 *  sidebar_id    : [IN] sidebar id
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_realloc_and_update_shct(mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(sidebar_info);

    mmi_op11_hs32_adm_free_shct(sidebar_info);

    mmi_op11_hs32_coordinate_sidebar_info(sidebar_info);

    mmi_op11_hs32_alloc_shct_and_pre_fill(sidebar_info);
    
    mmi_op11_hs32_query_shct_data_each_sidebar(sidebar_info);

    mmi_op11_hs32_coordinate_shct_data();

    /* update viewitem  */
    deleteAllShortcut(sidebar_info->sidebar_id);
    addShortcuts(sidebar_info);
    updateViewItem(sidebar_info->sidebar_id, 1);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_alloc_shct_and_pre_fill
 * DESCRIPTION
 *  alloc each sidebar's shortcuts buffer by sidebar_info->shortcut_count.
 *  and pre fill shortcut data if needed.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_alloc_shct_and_pre_fill(mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 j;
    U32 adm_total_left_size;
    mmi_op11_hs32_shct_struct *shct_info;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    adm_total_left_size = kal_adm_get_total_left_size(g_mmi_op11_hs32_cntx.mem.adm_pool_id);

    MMI_ASSERT(sidebar_info!= NULL);
        switch(sidebar_info->sidebar_id)
        {
            case MMI_OP11_HS32_AP_CLL:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    for(j=0; j<sidebar_info->shortcut_count; j++,shct_info++)
                    {
                        shct_info->shct_id = g_hs_hist_cntx.shct_hist[sidebar_info->sidebar_id][j];

                        if(mmi_op11_hs32_get_shct_func_tbl[sidebar_info->sidebar_id][shct_info->shct_id] != NULL)
                        {
                            shct_info->with_content_flag = 1;
                            shct_info->data_p= (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                            MMI_ASSERT(shct_info->data_p != NULL);
                            memset(shct_info->data_p, 0, sizeof(mmi_op11_hs32_shct_data_struct));

//                            mmi_op11_hs32_shct_data_pre_fill_eml(shct_info->shct_id, shct_info->data_p);
                        }
                        else
                        {
                            shct_info->with_content_flag = 0;
                        }

                    }
                }
                else
                {
                    /* means sidebar answer not complete */
                }
                break;

            case MMI_OP11_HS32_AP_CON:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    for(j=0; j<sidebar_info->shortcut_count; j++,shct_info++)
                    {
                        shct_info->shct_id =  g_hs_hist_cntx.shct_hist[sidebar_info->sidebar_id][j];

                        if(mmi_op11_hs32_get_shct_func_tbl[sidebar_info->sidebar_id][shct_info->shct_id] != NULL)
                        {
                            shct_info->with_content_flag = 1;
                            shct_info->data_p= (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                            MMI_ASSERT(shct_info->data_p != NULL);
                            memset(shct_info->data_p, 0, sizeof(mmi_op11_hs32_shct_data_struct));
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
                        }
                        else
                        {
                            shct_info->with_content_flag = 0;
                        }

                    }
                }
                else
                {
                    /* means sidebar answer not complete */
                }

                break;

            case MMI_OP11_HS32_AP_MES:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    for(j=0; j<sidebar_info->shortcut_count; j++,shct_info++)
                    {
                        shct_info->shct_id =  g_hs_hist_cntx.shct_hist[sidebar_info->sidebar_id][j];

                        if(mmi_op11_hs32_get_shct_func_tbl[sidebar_info->sidebar_id][shct_info->shct_id] != NULL)
                        {
                            shct_info->with_content_flag = 1;
                            shct_info->data_p= (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                            MMI_ASSERT(shct_info->data_p != NULL);
                            memset(shct_info->data_p, 0, sizeof(mmi_op11_hs32_shct_data_struct));
                        }
                        else
                        {
                            shct_info->with_content_flag = 0;
                        }
                    }
                    /* MES need two extra data buffer for SMS & MMS query data */
                    g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_SMS] = (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                    MMI_ASSERT(g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_SMS] != NULL);
                    memset(g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_SMS], 0, sizeof(mmi_op11_hs32_shct_data_struct));
                    g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_MMS] = (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                    MMI_ASSERT(g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_MMS] != NULL);
                    memset(g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_MMS], 0, sizeof(mmi_op11_hs32_shct_data_struct));

                    mmi_op11_hs32_shct_data_pre_fill_mes(sidebar_info);
                }
                else
                {
                    /* means sidebar answer not complete */
                }

                break;

            case MMI_OP11_HS32_AP_EML:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    for(j=0; j<sidebar_info->shortcut_count; j++,shct_info++)
                    {
                        shct_info->shct_id =  g_hs_hist_cntx.shct_hist[sidebar_info->sidebar_id][j];

                        if(mmi_op11_hs32_get_shct_func_tbl[sidebar_info->sidebar_id][shct_info->shct_id] != NULL)
                        {
                            shct_info->with_content_flag = 1;
                            shct_info->data_p= (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                            MMI_ASSERT(shct_info->data_p != NULL);
                            memset(shct_info->data_p, 0, sizeof(mmi_op11_hs32_shct_data_struct));

                            mmi_op11_hs32_shct_data_pre_fill_eml(shct_info->shct_id, shct_info->data_p);
                        }
                        else
                        {
                            shct_info->with_content_flag= 0;
                        }

                    }
                }
                else
                {
                    /* means email sidebar answer not complete */
                }
                break;

            case MMI_OP11_HS32_AP_OMR:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    if (sidebar_info->sidebar_status == MMI_OP11_HS32_STATUS_OMR_OFF)
                    {
                        shct_info->shct_id = MMI_OP11_HS32_SHCT_OMR_OM;
                        shct_info->with_content_flag= 0;
                        break;
                    }

                    for(j=0; j<sidebar_info->shortcut_count; j++,shct_info++)
                    {
                        shct_info->shct_id =  g_hs_hist_cntx.shct_hist[sidebar_info->sidebar_id][j];
                        shct_info->with_content_flag= 0;

                        if(mmi_op11_hs32_get_shct_func_tbl[sidebar_info->sidebar_id][shct_info->shct_id] != NULL)
                        {
                            shct_info->with_content_flag= 1;
                            shct_info->data_p= (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                            MMI_ASSERT(shct_info->data_p != NULL);
                            memset(shct_info->data_p, 0, sizeof(mmi_op11_hs32_shct_data_struct));

//                            mmi_op11_hs32_shct_data_pre_fill_eml(shct_info->shct_id, shct_info->data_p);
                        }
                        else
                        {
                            shct_info->with_content_flag= 0;
                        }

                    }


                }
                else
                {
                    /* means email sidebar answer not complete */
                }

                break;


            case MMI_OP11_HS32_AP_OWD:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    for(j=0; j<sidebar_info->shortcut_count; j++,shct_info++)
                    {
                        shct_info->shct_id =  g_hs_hist_cntx.shct_hist[sidebar_info->sidebar_id][j];

                        if(mmi_op11_hs32_get_shct_func_tbl[sidebar_info->sidebar_id][shct_info->shct_id] != NULL)
                        {
                            shct_info->with_content_flag= 1;
                            shct_info->data_p= (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                            MMI_ASSERT(shct_info->data_p != NULL);
                            memset(shct_info->data_p, 0, sizeof(mmi_op11_hs32_shct_data_struct));

//                            mmi_op11_hs32_shct_data_pre_fill_eml(shct_info->shct_id, shct_info->data_p);
                        }
                        else
                        {
                            shct_info->with_content_flag= 0;
                        }

                    }
                }
                else
                {
                    /* means email sidebar answer not complete */
                }

                break;


            case MMI_OP11_HS32_AP_PRO:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    MMI_ASSERT(sidebar_info->shortcut_count == 1);
                    shct_info->shct_id = MMI_OP11_HS32_SHCT_PRO;
                    shct_info->with_content_flag= 0;
                }
                else
                {
                    /* means email sidebar answer not complete */
                }

                break;


            case MMI_OP11_HS32_AP_ALM:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    for(j=0; j<sidebar_info->shortcut_count; j++,shct_info++)
                    {
                        shct_info->shct_id =  g_hs_hist_cntx.shct_hist[sidebar_info->sidebar_id][j];

                        if(mmi_op11_hs32_get_shct_func_tbl[sidebar_info->sidebar_id][shct_info->shct_id] != NULL)
                        {
                            shct_info->with_content_flag= 1;
                            shct_info->data_p= (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                            MMI_ASSERT(shct_info->data_p != NULL);
                            memset(shct_info->data_p, 0, sizeof(mmi_op11_hs32_shct_data_struct));

                            mmi_op11_hs32_shct_data_pre_fill_alm(shct_info->shct_id, shct_info->data_p);
                        }
                        else
                        {
                            shct_info->with_content_flag= 0;
                        }

                    }
                }
                else
                {
                    /* means email sidebar answer not complete */
                }

                break;


            case MMI_OP11_HS32_AP_CAL:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    for(j=0; j<sidebar_info->shortcut_count; j++,shct_info++)
                    {
                        shct_info->shct_id =  g_hs_hist_cntx.shct_hist[sidebar_info->sidebar_id][j];

                        if(mmi_op11_hs32_get_shct_func_tbl[sidebar_info->sidebar_id][shct_info->shct_id] != NULL)
                        {
                            shct_info->with_content_flag= 1;
                            shct_info->data_p= (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                            MMI_ASSERT(shct_info->data_p != NULL);
                            memset(shct_info->data_p, 0, sizeof(mmi_op11_hs32_shct_data_struct));

//                            mmi_op11_hs32_shct_data_pre_fill_eml(shct_info->shct_id, shct_info->data_p);
                        }
                        else
                        {
                            shct_info->with_content_flag= 0;
                        }

                    }
                }
                else
                {
                    /* means email sidebar answer not complete */
                }

                break;


            case MMI_OP11_HS32_AP_MUS:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    for(j=0; j<sidebar_info->shortcut_count; j++,shct_info++)
                    {
                        shct_info->shct_id =  g_hs_hist_cntx.shct_hist[sidebar_info->sidebar_id][j];

                        if(mmi_op11_hs32_get_shct_func_tbl[sidebar_info->sidebar_id][shct_info->shct_id] != NULL)
                        {
                            shct_info->with_content_flag= 1;
                            shct_info->data_p= (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                            MMI_ASSERT(shct_info->data_p != NULL);
                            memset(shct_info->data_p, 0, sizeof(mmi_op11_hs32_shct_data_struct));

//                            mmi_op11_hs32_shct_data_pre_fill_eml(shct_info->shct_id, shct_info->data_p);
                        }
                        else
                        {
                            shct_info->with_content_flag= 0;
                        }

                    }
                }
                else
                {
                    /* means email sidebar answer not complete */
                }

                break;


            case MMI_OP11_HS32_AP_PHO:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    for(j=0; j<sidebar_info->shortcut_count; j++,shct_info++)
                    {
                        shct_info->shct_id =  g_hs_hist_cntx.shct_hist[sidebar_info->sidebar_id][j];

                        if(mmi_op11_hs32_get_shct_func_tbl[sidebar_info->sidebar_id][shct_info->shct_id] != NULL)
                        {
                            shct_info->with_content_flag= 1;
                            shct_info->data_p= (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                            MMI_ASSERT(shct_info->data_p != NULL);
                            memset(shct_info->data_p, 0, sizeof(mmi_op11_hs32_shct_data_struct));

//                            mmi_op11_hs32_shct_data_pre_fill_eml(shct_info->shct_id, shct_info->data_p);
                        }
                        else
                        {
                            shct_info->with_content_flag= 0;
                        }

                    }
                }
                else
                {
                    /* means email sidebar answer not complete */
                }

                break;


            case MMI_OP11_HS32_AP_CNX:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    if (sidebar_info->shortcut_count == 1)
                    {
                            shct_info = sidebar_info->shortcut_p;
                            shct_info->shct_id = MMI_OP11_HS32_SHCT_CNX_FM;
                            shct_info->with_content_flag= 0;
                            break;
                    }

                    shct_info = sidebar_info->shortcut_p;
                    for(j=0; j<sidebar_info->shortcut_count; j++,shct_info++)
                    {
                        shct_info->shct_id =  g_hs_hist_cntx.shct_hist[sidebar_info->sidebar_id][j];

                        if(mmi_op11_hs32_get_shct_func_tbl[sidebar_info->sidebar_id][shct_info->shct_id] != NULL)
                        {
                            shct_info->with_content_flag= 1;
                            shct_info->data_p= (mmi_op11_hs32_shct_data_struct*)kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  sizeof(mmi_op11_hs32_shct_data_struct));
                            MMI_ASSERT(shct_info->data_p != NULL);
                            memset(shct_info->data_p, 0, sizeof(mmi_op11_hs32_shct_data_struct));

//                            mmi_op11_hs32_shct_data_pre_fill_eml(shct_info->shct_id, shct_info->data_p);
                        }
                        else
                        {
                            shct_info->with_content_flag= 0;
                        }

                    }
                }
                else
                {
                    /* means cnx sidebar answer not complete */
                }

                break;


            case MMI_OP11_HS32_AP_DST:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    MMI_ASSERT(sidebar_info->shortcut_count == 1);
                    shct_info->shct_id = MMI_OP11_HS32_SHCT_DST;
                    shct_info->with_content_flag= 0;
                    
                }
                else
                {
                    /* means email sidebar answer not complete */
                }

                break;


            case MMI_OP11_HS32_AP_STK:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    MMI_ASSERT(sidebar_info->shortcut_count == 1);
                    shct_info->shct_id = MMI_OP11_HS32_SHCT_STK;
                    shct_info->with_content_flag= 0;
                    
                }
                else
                {
                    /* means email sidebar answer not complete */
                }

                break;


            case MMI_OP11_HS32_AP_TPH:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    MMI_ASSERT(sidebar_info->shortcut_count == 1);
                    shct_info->shct_id = MMI_OP11_HS32_SHCT_TPH;
                    shct_info->with_content_flag= 0;
                    
                }
                else
                {
                    /* means email sidebar answer not complete */
                }

                break;

            case MMI_OP11_HS32_AP_VIP:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    MMI_ASSERT(sidebar_info->shortcut_count == 1);
                    shct_info->shct_id = MMI_OP11_HS32_SHCT_VIP;
                    shct_info->with_content_flag= 0;
                    
                }
                else
                {
                    /* means email sidebar answer not complete */
                }

                break;

            case MMI_OP11_HS32_AP_USCON:

                if (sidebar_info->shortcut_count != 0)
                {
                    sidebar_info->shortcut_p = (mmi_op11_hs32_shct_struct*) kal_adm_alloc(g_mmi_op11_hs32_cntx.mem.adm_pool_id,  (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));
                    MMI_ASSERT(sidebar_info->shortcut_p != NULL);
                    memset(sidebar_info->shortcut_p, 0, (sizeof(mmi_op11_hs32_shct_struct)*sidebar_info->shortcut_count));

                    shct_info = sidebar_info->shortcut_p;
                    MMI_ASSERT(sidebar_info->shortcut_count == 1);
                    shct_info->shct_id = MMI_OP11_HS32_SHCT_USCON;
                    shct_info->with_content_flag= 0;
                    
                }
                else
                {
                    /* means email sidebar answer not complete */
                }

                break;


            default:
                break;

        }

    adm_total_left_size = kal_adm_get_total_left_size(g_mmi_op11_hs32_cntx.mem.adm_pool_id);

    return;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_query_shct_data_each_sidebar
 * DESCRIPTION
 *  Query each sidebar's all shortcut data.(use sidebar_info)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_query_shct_data_each_sidebar(mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 j;
    mmi_op11_hs32_shct_struct *shct_info;
    mmi_op11_hs32_get_shct_func_t query_shct_func;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(sidebar_info->shortcut_p != NULL)
    {
        shct_info = sidebar_info->shortcut_p;
        for(j=0; j<sidebar_info->shortcut_count; j++, shct_info++)
        {
            if(shct_info->with_content_flag == 1)
            {
                query_shct_func = mmi_op11_hs32_get_shct_func_tbl[sidebar_info->sidebar_id][shct_info->shct_id];
                MMI_ASSERT(query_shct_func != NULL);
                query_shct_func(sidebar_info->sidebar_id, shct_info->shct_id, shct_info->data_p);
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_query_shct_data_each_single
 * DESCRIPTION
 *  Query shortcut data(use sidebar_id and shct_id).
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_query_shct_data_each_single(S32 sidebar_id, S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct* shct_data_p;
    mmi_op11_hs32_get_shct_func_t query_shct_func;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    shct_data_p = mmi_op11_hs32_get_shct_data_pointer_internal(sidebar_id, shct_id);

    if (shct_data_p != NULL)
    {
        query_shct_func = mmi_op11_hs32_get_shct_func_tbl[sidebar_id][shct_id];
        if (query_shct_func != NULL)
        {
            query_shct_func(sidebar_id, shct_id, shct_data_p);
        }
    }

}



/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_coordinate_shct_data
 * DESCRIPTION
 *  coordinate  shortcut data.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_coordinate_shct_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    return;

}


/************************************************************/
/*															*/
/*			Special AP utility  functions implement     	        		*/
/*															*/
/************************************************************/



/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_data_pre_fill_eml
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_shct_data_pre_fill_eml(S32 shct_id, mmi_op11_hs32_shct_data_struct *data_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch(shct_id)
    {
        case MMI_OP11_HS32_SHCT_EML_ACCOUNT1_NEWEMAIL:
        case MMI_OP11_HS32_SHCT_EML_ACCOUNT2_NEWEMAIL:
        case MMI_OP11_HS32_SHCT_EML_ACCOUNT3_NEWEMAIL:
        case MMI_OP11_HS32_SHCT_EML_ACCOUNT4_NEWEMAIL:
        case MMI_OP11_HS32_SHCT_EML_ACCOUNT5_NEWEMAIL:
            data_p->query_index = g_mmi_op11_hs32_cntx.eml_account[shct_id-MMI_OP11_HS32_SHCT_EML_ACCOUNT1_NEWEMAIL];
            break;

        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_data_pre_fill_alm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_shct_data_pre_fill_alm(S32 shct_id, mmi_op11_hs32_shct_data_struct *data_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(shct_id != MMI_OP11_HS32_SHCT_ALM_NO);
    data_p->query_index = g_mmi_op11_hs32_cntx.alm_account[shct_id - MMI_OP11_HS32_SHCT_ALM_1];

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_data_pre_fill_mes
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_shct_data_pre_fill_mes(mmi_op11_hs32_sidebar_struct *sidebar_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 j;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (sidebar_info->indicator_data[MMI_OP11_HS32_INDCTR_MES_NEW_SMS] > 0 &&
        sidebar_info->indicator_data[MMI_OP11_HS32_INDCTR_MES_NEW_SMS] <= 2)
    {
        for (j=0; j<sidebar_info->indicator_data[MMI_OP11_HS32_INDCTR_MES_NEW_SMS]; j++)
        {
            g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_SMS]->item_flag[j] = 1;
        }
    }

    if (sidebar_info->indicator_data[MMI_OP11_HS32_INDCTR_MES_NEW_MMS] > 0 &&
        sidebar_info->indicator_data[MMI_OP11_HS32_INDCTR_MES_NEW_MMS] <= 2)
    {
        for (j=0; j<sidebar_info->indicator_data[MMI_OP11_HS32_INDCTR_MES_NEW_MMS]; j++)
        {
            g_mmi_op11_hs32_cntx.mes_data_p[MMI_OP11_HS32_SHCT_MES_NEW_MMS]->item_flag[j] = 1;
        }
    }

}



/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_cll
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_cll(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(shct_id)
    {
        case MMI_OP11_HS32_SHCT_CLL_CALL_LOG:
            shct_data_p = mmi_op11_hs32_get_shct_data_pointer_internal(MMI_OP11_HS32_AP_CLL, shct_id);

            if (shct_data_p->item_count == 0)
             {
                mmi_clog_launch();
             }
             else
             {
                mmi_clog_mclt_launch();
             }

            break;

        default:
            mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_CLL][shct_id]();
            break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_con
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_con(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p;
    U16 store_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(shct_id)
    {
        case MMI_OP11_HS32_SHCT_CON_VIP1:
        case MMI_OP11_HS32_SHCT_CON_VIP2:
        case MMI_OP11_HS32_SHCT_CON_VIP3:
        case MMI_OP11_HS32_SHCT_CON_VIP4:
        case MMI_OP11_HS32_SHCT_CON_VIP5:
            shct_data_p = mmi_op11_hs32_get_shct_data_pointer_internal(MMI_OP11_HS32_AP_CON, shct_id);
            store_index = (U16)shct_data_p->query_index;

            mmi_op11_hs32_create_csk_root_gid();

            cui_phb_view_contact(
                g_mmi_op11_hs32_cntx.csk_sg_id,
                store_index);
            break;

        default:
            mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_CON][shct_id]();
            break;
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_mes
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_mes(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables												  */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p;
    /*----------------------------------------------------------------*/
    /* Code Body													  */
    /*----------------------------------------------------------------*/
#ifdef __MMI_OP11_HOMESCREEN_US__
    if (shct_id == 0)
    {
        /* entry UC or SMS, MMS select screen  */
        mmi_um_entry_write_msg_ext();
        return;
    }
#endif

    switch(shct_id)
    {
        case MMI_OP11_HS32_SHCT_MES_INBOX:
            shct_data_p = mmi_op11_hs32_get_shct_data_pointer_internal(MMI_OP11_HS32_AP_MES, shct_id);
            if (shct_data_p->item_count == 1)
            {
                if (shct_data_p->item_flag[0] == 1)
                {
                    mmi_msg_hs32_menu_view_curr_message((U16)shct_data_p->item_uid[0]);
                }
                else
                {
                    mmi_op11_hs32_create_csk_root_gid();
//                    if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_DUMMY, NULL, NULL, MMI_FRM_FULL_SCRN) == MMI_FALSE)    return;
                    mmi_frm_display_dummy_screen_ex(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_DUMMY);
                    mmi_umms_op_hs32_shct_cb(shct_data_p->item_uid[0]);
                }
            }
            else
            {
                mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_MES][shct_id]();
            }
            break;

        default:
            mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_MES][shct_id]();
            break;

    }

}




/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_eml
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_eml(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_EMAIL__
    switch(shct_id)
    {
        case MMI_OP11_HS32_SHCT_EML_ACCOUNT1_NEWEMAIL:
        case MMI_OP11_HS32_SHCT_EML_ACCOUNT2_NEWEMAIL:
        case MMI_OP11_HS32_SHCT_EML_ACCOUNT3_NEWEMAIL:
        case MMI_OP11_HS32_SHCT_EML_ACCOUNT4_NEWEMAIL:
        case MMI_OP11_HS32_SHCT_EML_ACCOUNT5_NEWEMAIL:
            shct_data_p = mmi_op11_hs32_get_shct_data_pointer_internal(MMI_OP11_HS32_AP_EML, shct_id);
//            if (shct_data_p->item_count == 1)
            /* email account entry func  */
            mmi_email_app_entry_inbox_by_acct((U8)shct_data_p->query_index);
            break;

        default:
            mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_EML][shct_id]();
            break;


    }
#endif
}

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_omr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_omr(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_OMR][shct_id]();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_owd
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_owd(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(shct_id)
    {
        case MMI_OP11_HS32_SHCT_OWD_BK1:
        case MMI_OP11_HS32_SHCT_OWD_BK2:
        case MMI_OP11_HS32_SHCT_OWD_BK3:

#if defined(__MMI_OP11_HS32_OWD__)
            shct_data_p = mmi_op11_hs32_get_shct_data_pointer_internal(MMI_OP11_HS32_AP_OWD, shct_id);
			wap_start_browser(WAP_BROWSER_GOTO_URL,(kal_uint8*)shct_data_p->item_content);
#endif
            break;

        default:
            mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_OWD][shct_id]();
            break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_pro
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_pro(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_PRO][shct_id]();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_alm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_alm(S32 shct_id)
{
#ifdef __MMI_OP11_HS32_ALM_NEW_UE__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_ALM][MMI_OP11_HS32_SHCT_ALM_NO]();

#else   /* __MMI_OP11_HS32_ALM_NEW_UE__ */
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(shct_id)
    {
        case MMI_OP11_HS32_SHCT_ALM_NO:
            mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_ALM][shct_id]();
            break;


        case MMI_OP11_HS32_SHCT_ALM_1:
    #ifdef __MMI_OP11_HOMESCREEN_US__
            mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_ALM][MMI_OP11_HS32_SHCT_ALM_NO]();
    #else
            shct_data_p = mmi_op11_hs32_get_shct_data_pointer_internal(MMI_OP11_HS32_AP_ALM, shct_id);
            mmi_alm_entry_alm_eidt_screen((U8)shct_data_p->query_index);
    #endif
            break;


        default:
            shct_data_p = mmi_op11_hs32_get_shct_data_pointer_internal(MMI_OP11_HS32_AP_ALM, shct_id);
            mmi_alm_entry_alm_eidt_screen((U8)shct_data_p->query_index);
            break;
    }

#endif  /* __MMI_OP11_HS32_ALM_NEW_UE__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_cal
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_cal(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(shct_id)
    {
        case MMI_OP11_HS32_SHCT_CAL_CL:
            shct_data_p = mmi_op11_hs32_get_shct_data_pointer_internal(MMI_OP11_HS32_AP_CAL, shct_id);
            if (shct_data_p->item_count == 0)
            {
                mmi_clndr_op11_hs32_entry_month();
            }
            else
            {
                mmi_clndr_op11_hs32_entry_today();
            }
            break;

        default:
            mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_CAL][shct_id]();
            break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_mus
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_mus(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_MUS][shct_id]();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_pho
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_pho(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_PHO][shct_id]();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_cnx
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_cnx(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_CNX][shct_id]();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_dst
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_dst(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_DST][shct_id]();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_stk
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_stk(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_STK][shct_id]();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_tph
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_tph(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_TPH][shct_id]();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_vip
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_vip(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_phb_check_ready(MMI_TRUE))
    {
        return;
    }
    else
    {
        mmi_op11_hs32_create_csk_root_gid();
        mmi_op11_hs32_enter_us_vip_screen();
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_shct_select_cb_stk
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_shct_select_cb_uscon(S32 shct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_USCON][shct_id]();

}

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_write_sms_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_enter_write_sms_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_sms_write_msg_para_struct sendData;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&sendData, 0, sizeof(mmi_sms_write_msg_para_struct));
    mmi_sms_write_msg_lanch(0, &sendData);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_write_sms_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_enter_video_lib_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    #define OP11_HS32_TEMP_FILEPATH  40
//    #define OP11_HS32_TEMP_FILEPATH  SRV_FMGR_PATH_BUFFER_SIZE
    FMGR_FILTER filter;
    FS_HANDLE file_handle;
    U32 fmgr_handle;
    MMI_ID_TYPE err_strid;
    mmi_event_notify_enum popup_type;
    S32 result = -1;
    CHAR drv[4];
    CHAR buf_filepath[OP11_HS32_TEMP_FILEPATH];

    mmi_popup_property_struct popup_arg;
    MMI_ID sg_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_VIDEO_PLAYER__
    mmi_vdoply_entry_app();
#else

    if (srv_fmgr_drv_has_accessible_removable_drv())
    {
        result =0;
        memset(buf_filepath, 0, OP11_HS32_TEMP_FILEPATH);
        sprintf(drv, "%c:\\", (CHAR) SRV_FMGR_CARD_DRV);
        mmi_asc_to_ucs2((CHAR*)buf_filepath, drv);
        mmi_ucs2cat((CHAR*)buf_filepath, (CHAR*)FMGR_DEFAULT_FOLDER_VIDEO);

        file_handle = FS_Open((WCHAR*)buf_filepath, FS_OPEN_DIR | FS_READ_ONLY);
        if (file_handle < 0)
        {
            result = FS_CreateDir((WCHAR*)buf_filepath);
        }
        else
        {
            FS_Close(file_handle);
        }
    }
    if (result < 0)
    {
        result =0;
        memset(buf_filepath, 0, OP11_HS32_TEMP_FILEPATH);
        sprintf(drv, "%c:\\", (CHAR) SRV_FMGR_PUBLIC_DRV);
        mmi_asc_to_ucs2((CHAR*)buf_filepath, drv);
        mmi_ucs2cat((CHAR*)buf_filepath, (CHAR*)FMGR_DEFAULT_FOLDER_VIDEO);

        file_handle = FS_Open((WCHAR*)buf_filepath, FS_OPEN_DIR | FS_READ_ONLY);
        if (file_handle < 0)
        {
            result = FS_CreateDir((WCHAR*)buf_filepath);
        }
        else
        {
            FS_Close(file_handle);
        }

    }

    mmi_op11_hs32_create_csk_root_gid();
    sg_id = g_mmi_op11_hs32_cntx.csk_sg_id;

    if (result < 0)
    {
        err_strid = srv_fmgr_fs_error_get_string(result);
        popup_type = (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(result);
        mmi_popup_property_init(&popup_arg);
        if (sg_id != GRP_ID_INVALID)
        {
            popup_arg.parent_id = sg_id;
        }
        mmi_popup_display((WCHAR*)get_string(err_strid), popup_type, &popup_arg);
//        mmi_display_popup((UI_string_type)GetString(err_strid), popup_type);
        return;
    }

        {
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifdef __MMI_VIDEO_STREAM__
/* under construction !*/
/* under construction !*/
        #endif /* __MMI_VIDEO_STREAM__ */
/* under construction !*/
        #if defined(__DRM_V02__)
/* under construction !*/
        #endif 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif

                FMGR_FILTER_INIT(&filter);
                FMGR_FILTER_SET_VIDEO(&filter);
            
            #ifdef __MMI_VIDEO_STREAM__
                FMGR_FILTER_SET(&filter, FMGR_TYPE_SDP);
                FMGR_FILTER_SET(&filter, FMGR_TYPE_RAM);
            #endif /* __MMI_VIDEO_STREAM__ */

            #if defined(__DRM_V02__)
                FMGR_FILTER_SET(&filter, FMGR_TYPE_ODF);
            #endif 

            g_mmi_op11_hs32_cntx.fmgr_sg_id = cui_folder_browser_create(sg_id, (WCHAR*)buf_filepath, &filter, 0, 0, 0);
            if(!g_mmi_op11_hs32_cntx.fmgr_sg_id)
            {
                mmi_popup_property_init(&popup_arg);
                popup_arg.parent_id = sg_id;
                mmi_popup_display((WCHAR*)get_string(STR_GLOBAL_ERROR), MMI_EVENT_FAILURE, &popup_arg);
                return;
            }
            cui_folder_browser_run(g_mmi_op11_hs32_cntx.fmgr_sg_id);
        }    


#endif /* __MMI_VIDEO_PLAYER__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_con_vip_goback_idle
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_con_vip_goback_idle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs_screen_history_struct *screen_history_p = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_op11_hs32_cntx.flag &= ~MMI_OP11_HS32_HISTORY_DISCARDED;

#ifndef __MMI_OP11_HOMESCREEN_US__
    if (!g_mmi_op11_hs32_cntx.is_sel_screen_changed)
    {
        mmi_op11_hs32_goback_to_main();
    }
    else
    {
        /* sync con history */
        mmi_op11_hs32_update_shct_history_con();
        mmi_op11_hs_save_id_history();

        /* set highlight item */
        if (g_mmi_op11_hs32_cntx.history)
        {
            screen_history_p = (mmi_op11_hs_screen_history_struct *)g_mmi_op11_hs32_cntx.history;

            if (g_mmi_op11_hs32_cntx.last_set_index != 0xff)
            {
            screen_history_p->shortcut_index = 
                mmi_op11_hs32_get_shct_index(MMI_OP11_HS32_AP_CON, (MMI_OP11_HS32_SHCT_CON_VIP1+g_mmi_op11_hs32_cntx.last_set_index));
            }
            else
            {
                if(mmi_op11_hs32_get_shct_index(MMI_OP11_HS32_AP_CON, MMI_OP11_HS32_SHCT_CON_EDIT_VIP) != -1)
                {
                    screen_history_p->shortcut_index = 
                        mmi_op11_hs32_get_shct_index(MMI_OP11_HS32_AP_CON, MMI_OP11_HS32_SHCT_CON_EDIT_VIP);
                }
                else if (mmi_op11_hs32_get_shct_index(MMI_OP11_HS32_AP_CON, MMI_OP11_HS32_SHCT_CON_SET_VIP) != -1)
                {
                    screen_history_p->shortcut_index = 
                        mmi_op11_hs32_get_shct_index(MMI_OP11_HS32_AP_CON, MMI_OP11_HS32_SHCT_CON_SET_VIP);
                }
                else
                {
                    /* trace history */
                    MMI_ASSERT(0);
                }
            }
        }
        mmi_op11_hs32_goback_to_main();
    }
#else
        mmi_op11_hs32_goback_to_main();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_set_con_vip_screen_group
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_enter_set_con_vip_screen_group(void)
{
    mmi_op11_hs32_create_csk_root_gid();
    mmi_op11_hs32_enter_set_con_vip_screen();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_set_con_vip_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_enter_set_con_vip_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *item_list[MMI_OP11_HS32_AP_CON_VIP_MAX];
    U16     ItemIconList[MMI_OP11_HS32_AP_CON_VIP_MAX] = {0}; 
    U16 i;
    U8 *gui_buffer;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_phb_check_ready(MMI_TRUE))
    {
        return;
    }

//    EntryNewScreen(SCR_ID_OP11_HS_SET_VIP, NULL, mmi_op11_hs32_enter_set_con_vip_screen, NULL);
//    gui_buffer = GetCurrGuiBuffer(SCR_ID_OP11_HS_SET_VIP);

    if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_SET_VIP, NULL, mmi_op11_hs32_enter_set_con_vip_screen, MMI_FRM_FULL_SCRN) == MMI_FALSE)
        return;
    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

    memset(subMenuData, 0, MMI_OP11_HS32_AP_CON_VIP_MAX*MAX_SUB_MENU_SIZE);

    for (i = 0; i < MMI_OP11_HS32_AP_CON_VIP_MAX; i++)
    {
        mmi_ucs2cpy((CHAR*)subMenuData[i], (CHAR*)GetString(STR_ID_OP11_HS32_CON_VIP));
        mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)L" ");
        mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)GetString(STR_GLOBAL_1+i));
        mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)L": ");

        if (srv_phb_vip_contact_is_sync(i))
        {
            if (mmi_ucs2strlen((CHAR*) srv_phb_vip_contact_get_name(i)))
            {
                mmi_ucs2ncpy((CHAR*)&subMenuData[i][14], (CHAR*)srv_phb_vip_contact_get_name(i), (MAX_SUBMENU_CHARACTERS-7));
             }
            else
            {
                mmi_ucs2ncpy((CHAR*)&subMenuData[i][14], (CHAR*)srv_phb_vip_contact_get_number(i), (MAX_SUBMENU_CHARACTERS-7));
             }
        }
        else
        {
            mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)GetString(STR_ID_OP11_HS32_NOT_SET));
        }

        item_list[i] = (U8*)subMenuData[i];
    }


    RegisterHighlightHandler(mmi_op11_hs32_vip_list_highlight_hdlr);

    gdi_layer_lock_frame_buffer();

    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

    wgui_cat1001_op11_show(
        (UI_string_type)get_string(STR_ID_OP11_HS32_CON_SET_VIP),
        (UI_string_type)get_string(STR_ID_OP11_HS32_VIP_TO_S), 
        get_string(STR_ID_OP11_HS32_VIP_SET),
        0,
        NULL,
        0,
        MMI_OP11_HS32_AP_CON_VIP_MAX,
        (U8**)item_list,
        ItemIconList,
        NULL,
        0,
        gui_buffer);

    if (g_mmi_op11_hs32_cntx.is_sel_screen_changed)
    {
        ChangeRightSoftkey(STR_GLOBAL_DONE, 0);
    }
    else
    {
        ChangeRightSoftkey(STR_GLOBAL_CANCEL, 0);
    }

    gdi_layer_unlock_frame_buffer();
    dm_redraw_category_screen();

//    SetLeftSoftkeyFunction(mmi_op11_hs32_enter_vip_select_screen, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_op11_hs32_con_vip_goback_idle, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_edit_con_vip_screen_group
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_enter_edit_con_vip_screen_group(void)
{
    mmi_op11_hs32_create_csk_root_gid();
    mmi_op11_hs32_enter_edit_con_vip_screen();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_edit_con_vip_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_enter_edit_con_vip_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *item_list[MMI_OP11_HS32_AP_CON_VIP_MAX];
    U16     ItemIconList[MMI_OP11_HS32_AP_CON_VIP_MAX] = {0}; 
    U16 i;
    U8 *gui_buffer;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_phb_check_ready(MMI_TRUE))
    {
        return;
    }

//    EntryNewScreen(SCR_ID_OP11_HS_EDIT_VIP, NULL, mmi_op11_hs32_enter_edit_con_vip_screen, NULL);
//    gui_buffer = GetCurrGuiBuffer(SCR_ID_OP11_HS_EDIT_VIP);

    if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_EDIT_VIP, NULL, mmi_op11_hs32_enter_edit_con_vip_screen, MMI_FRM_FULL_SCRN) == MMI_FALSE)
        return;
    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

    memset(subMenuData, 0, MMI_OP11_HS32_AP_CON_VIP_MAX*MAX_SUB_MENU_SIZE);

    for (i = 0; i < MMI_OP11_HS32_AP_CON_VIP_MAX; i++)
    {
        mmi_ucs2cpy((CHAR*)subMenuData[i], (CHAR*)GetString(STR_ID_OP11_HS32_CON_VIP));
        mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)L" ");
        mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)GetString(STR_GLOBAL_1+i));
        mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)L": ");

        if (srv_phb_vip_contact_is_sync(i))
        {
            if (mmi_ucs2strlen((CHAR*) srv_phb_vip_contact_get_name(i)))
            {
                mmi_ucs2ncpy((CHAR*)&subMenuData[i][14], (CHAR*)srv_phb_vip_contact_get_name(i), (MAX_SUBMENU_CHARACTERS-7));
             }
            else
            {
                mmi_ucs2ncpy((CHAR*)&subMenuData[i][14], (CHAR*)srv_phb_vip_contact_get_number(i), (MAX_SUBMENU_CHARACTERS-7));
             }
        }
        else
        {
            mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)GetString(STR_ID_OP11_HS32_NOT_SET));
        }

        item_list[i] = (U8*)subMenuData[i];
    }

    RegisterHighlightHandler(mmi_op11_hs32_vip_list_highlight_hdlr);

    gdi_layer_lock_frame_buffer();

    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

    wgui_cat1001_op11_show(
        (UI_string_type)get_string(STR_ID_OP11_HS32_CON_EDIT_VIP),
        (UI_string_type)get_string(STR_ID_OP11_HS32_VIP_TO_S_OR_R), 
        get_string(STR_ID_OP11_HS32_VIP_SET),
        0,
        NULL,
        0,
        MMI_OP11_HS32_AP_CON_VIP_MAX,
        (U8**)item_list,
        ItemIconList,
        NULL,
        0,
        gui_buffer);

    if (g_mmi_op11_hs32_cntx.is_sel_screen_changed)
    {
        ChangeRightSoftkey(STR_GLOBAL_DONE, 0);
    }
    else
    {
        ChangeRightSoftkey(STR_GLOBAL_CANCEL, 0);
    }

    gdi_layer_unlock_frame_buffer();
    dm_redraw_category_screen();

//    SetLeftSoftkeyFunction(mmi_op11_hs32_enter_vip_select_screen, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_op11_hs32_con_vip_goback_idle, KEY_EVENT_UP);

}



/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_vip_list_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_vip_list_highlight_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_op11_hs32_cntx.vip_index = (U16) index;

    if (srv_phb_vip_contact_is_sync(g_mmi_op11_hs32_cntx.vip_index))
    {
        ChangeLeftSoftkey(STR_ID_OP11_HS32_VIP_REMOVE, 0);
        SetLeftSoftkeyFunction(mmi_op11_hs32_vip_remove_select, KEY_EVENT_UP);
        SetCenterSoftkeyFunction(mmi_op11_hs32_vip_remove_select, KEY_EVENT_UP);
    }
    else
    {
        ChangeLeftSoftkey(STR_ID_OP11_HS32_VIP_SET, 0);
        SetLeftSoftkeyFunction(mmi_op11_hs32_enter_vip_select_screen, KEY_EVENT_UP);
        SetCenterSoftkeyFunction(mmi_op11_hs32_enter_vip_select_screen, KEY_EVENT_UP);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_vip_remove_select
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_vip_remove_select(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_op11_hs32_cntx.is_sel_screen_changed = 1;
    g_mmi_op11_hs32_cntx.last_set_index = 0xFF;
    srv_phb_clear_vip_contact(g_mmi_op11_hs32_cntx.vip_index);

//    EntryNewScreen(SCR_ID_OP11_HS_DUMMY, NULL, NULL, NULL);
    if(mmi_frm_group_get_active_id() == g_mmi_op11_hs32_cntx.csk_sg_id)
    {
//        if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_DUMMY, NULL, NULL, MMI_FRM_FULL_SCRN) == MMI_FALSE)  return;
        mmi_frm_display_dummy_screen_ex(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_DUMMY);
        mmi_frm_scrn_close_active_id();
    }
}




/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_vip_select_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_enter_vip_select_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    g_mmi_op11_hs32_cntx.phb_list_sg_id = cui_phb_list_select_contact_create(g_mmi_op11_hs32_cntx.csk_sg_id);

   if (g_mmi_op11_hs32_cntx.phb_list_sg_id != GRP_ID_INVALID)
   {
        cui_phb_list_select_contact_set_field_filter(g_mmi_op11_hs32_cntx.phb_list_sg_id, SRV_PHB_ENTRY_FIELD_GSM_NUM);
        cui_phb_list_select_contact_run(g_mmi_op11_hs32_cntx.phb_list_sg_id);
   }
   else
   {
        mmi_frm_group_close(GRP_ID_PHB_VIP_CONTACT);
   }

}



#ifdef __MMI_EMAIL__

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_eml_account_goback_idle
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_eml_account_goback_idle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs_screen_history_struct *screen_history_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_op11_hs32_cntx.flag &= ~MMI_OP11_HS32_HISTORY_DISCARDED;

    if (!g_mmi_op11_hs32_cntx.is_sel_screen_changed)
    {
        mmi_op11_hs32_goback_to_main();
    }
    else
    {
        /* sync eml history */
        mmi_op11_hs32_update_shct_history_eml();
        mmi_op11_hs_save_id_history();

        /* set highlight item */
        if (g_mmi_op11_hs32_cntx.history)
        {
            screen_history_p = (mmi_op11_hs_screen_history_struct *)g_mmi_op11_hs32_cntx.history;

            if (g_mmi_op11_hs32_cntx.last_set_index != 0xff)
            {
            screen_history_p->shortcut_index = 
                mmi_op11_hs32_get_shct_index(MMI_OP11_HS32_AP_EML, (MMI_OP11_HS32_SHCT_EML_ACCOUNT1_NEWEMAIL+g_mmi_op11_hs32_cntx.last_set_index));
            }
            else
            {
                if(mmi_op11_hs32_get_shct_index(MMI_OP11_HS32_AP_EML, MMI_OP11_HS32_SHCT_EML_EDIT_ACCOUNT) != -1)
                {
                    screen_history_p->shortcut_index = 
                        mmi_op11_hs32_get_shct_index(MMI_OP11_HS32_AP_EML, MMI_OP11_HS32_SHCT_EML_EDIT_ACCOUNT);
                }
                else if (mmi_op11_hs32_get_shct_index(MMI_OP11_HS32_AP_EML, MMI_OP11_HS32_SHCT_EML_SET_ACCOUNT) != -1)
                {
                    screen_history_p->shortcut_index = 
                        mmi_op11_hs32_get_shct_index(MMI_OP11_HS32_AP_EML, MMI_OP11_HS32_SHCT_EML_SET_ACCOUNT);
                }
                else
                {
                    /* trace history */
                    MMI_ASSERT(0);
                }
            }
        }
        mmi_op11_hs32_goback_to_main();
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_set_eml_account_screen_group
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_enter_set_eml_account_screen_group(void)
{
    mmi_op11_hs32_create_csk_root_gid();
    mmi_op11_hs32_enter_set_eml_account_screen();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_set_con_vip_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_enter_set_eml_account_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *item_list[MMI_OP11_HS32_AP_EML_ACCOUNT_MAX];
    U16     ItemIconList[MMI_OP11_HS32_AP_EML_ACCOUNT_MAX] = {0}; 
    U16 i;
    U8 *gui_buffer;
    mmi_popup_property_struct popup_arg;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_email_is_email_can_forward())
    {
        mmi_popup_property_init(&popup_arg);
        popup_arg.parent_id = g_mmi_op11_hs32_cntx.csk_sg_id;
        mmi_popup_display((WCHAR*)get_string(STR_GLOBAL_NOT_AVAILABLE), MMI_EVENT_FAILURE, &popup_arg);
//        mmi_display_popup(get_string(STR_GLOBAL_NOT_AVAILABLE), MMI_EVENT_FAILURE);
        return;
    }

//    EntryNewScreen(SCR_ID_OP11_HS_SET_ACCOUNT, NULL, mmi_op11_hs32_enter_set_eml_account_screen, NULL);
//    gui_buffer = GetCurrGuiBuffer(SCR_ID_OP11_HS_SET_ACCOUNT);

    if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_SET_ACCOUNT, NULL, mmi_op11_hs32_enter_set_eml_account_screen, MMI_FRM_FULL_SCRN) == MMI_FALSE)
        return;
    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

    memset(subMenuData, 0, MMI_OP11_HS32_AP_CON_VIP_MAX*MAX_SUB_MENU_SIZE);

    for (i = 0; i < MMI_OP11_HS32_AP_EML_ACCOUNT_MAX; i++)
    {
        mmi_ucs2cpy((CHAR*)subMenuData[i], (CHAR*)GetString(STR_GLOBAL_1+i));

        mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)L": ");

        if (g_mmi_op11_hs32_cntx.eml_account[i] != 0)
        {
            mmi_email_get_account_name_by_id(
                (U8)g_mmi_op11_hs32_cntx.eml_account[i], 
                (U16*)&subMenuData[i][6], 
                (MAX_SUBMENU_CHARACTERS-3));

            /* for MAUI_02159421 */
            if (subMenuData[i][6] == 0)
            {
                g_mmi_op11_hs32_cntx.eml_account[i] = 0;
                mmi_email_hs_remove_shct_acct((U8)i);
                g_mmi_op11_hs32_cntx.is_sel_screen_changed = 1;
                g_mmi_op11_hs32_cntx.last_set_index = 0xff;
                mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)GetString(STR_ID_OP11_HS32_NOT_SET));
            }
        }
        else
        {
            mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)GetString(STR_ID_OP11_HS32_NOT_SET));
        }
        item_list[i] = (U8*)subMenuData[i];
    }


    RegisterHighlightHandler(mmi_op11_hs32_eml_account_list_highlight_hdlr);

    gdi_layer_lock_frame_buffer();

    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

    wgui_cat1001_op11_show(
        (UI_string_type)get_string(STR_ID_OP11_HS32_EML_SET_ACCOUNT),
        (UI_string_type)get_string(STR_ID_OP11_HS32_EML_TO_S), 
        get_string(STR_ID_OP11_HS32_VIP_SET),
        0,
        NULL,
        0,
        MMI_OP11_HS32_AP_EML_ACCOUNT_MAX,
        (U8**)item_list,
        ItemIconList,
        NULL,
        0,
        gui_buffer);

    if (g_mmi_op11_hs32_cntx.is_sel_screen_changed)
    {
        ChangeRightSoftkey(STR_GLOBAL_DONE, 0);
    }
    else
    {
        ChangeRightSoftkey(STR_GLOBAL_CANCEL, 0);
    }

    gdi_layer_unlock_frame_buffer();
    dm_redraw_category_screen();

//    SetLeftSoftkeyFunction(mmi_op11_hs32_enter_vip_select_screen, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_op11_hs32_eml_account_goback_idle, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_edit_eml_account_screen_group
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_enter_edit_eml_account_screen_group(void)
{
    mmi_op11_hs32_create_csk_root_gid();
    mmi_op11_hs32_enter_edit_eml_account_screen();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_edit_eml_account_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_enter_edit_eml_account_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *item_list[MMI_OP11_HS32_AP_EML_ACCOUNT_MAX];
    U16     ItemIconList[MMI_OP11_HS32_AP_EML_ACCOUNT_MAX] = {0}; 
    U16 i;
    U8 *gui_buffer;
    mmi_popup_property_struct popup_arg;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_email_is_email_can_forward())
    {
        mmi_popup_property_init(&popup_arg);
        popup_arg.parent_id = g_mmi_op11_hs32_cntx.csk_sg_id;
        mmi_popup_display((WCHAR*)get_string(STR_GLOBAL_NOT_AVAILABLE), MMI_EVENT_FAILURE, &popup_arg);
//        mmi_display_popup(get_string(STR_GLOBAL_NOT_AVAILABLE), MMI_EVENT_FAILURE);
        return;
    }

//    EntryNewScreen(SCR_ID_OP11_HS_EDIT_ACCOUNT, NULL, mmi_op11_hs32_enter_edit_eml_account_screen, NULL);
//    gui_buffer = GetCurrGuiBuffer(SCR_ID_OP11_HS_EDIT_ACCOUNT);

    if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_EDIT_ACCOUNT, NULL, mmi_op11_hs32_enter_edit_eml_account_screen, MMI_FRM_FULL_SCRN) == MMI_FALSE)
        return;
    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

    memset(subMenuData, 0, MMI_OP11_HS32_AP_CON_VIP_MAX*MAX_SUB_MENU_SIZE);

    for (i = 0; i < MMI_OP11_HS32_AP_EML_ACCOUNT_MAX; i++)
    {
        mmi_ucs2cpy((CHAR*)subMenuData[i], (CHAR*)GetString(STR_GLOBAL_1+i));

        mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)L": ");

        if (g_mmi_op11_hs32_cntx.eml_account[i] != 0)
        {
            mmi_email_get_account_name_by_id(
                (U8)g_mmi_op11_hs32_cntx.eml_account[i], 
                (U16*)&subMenuData[i][6], 
                (MAX_SUBMENU_CHARACTERS-3));

            /* for MAUI_02159421 */
            if (subMenuData[i][6] == 0)
            {
                g_mmi_op11_hs32_cntx.eml_account[i] = 0;
                mmi_email_hs_remove_shct_acct((U8)i);
                g_mmi_op11_hs32_cntx.is_sel_screen_changed = 1;
                g_mmi_op11_hs32_cntx.last_set_index = 0xff;
                mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)GetString(STR_ID_OP11_HS32_NOT_SET));
            }
        }
        else
        {
            mmi_ucs2cat((CHAR*)subMenuData[i], (CHAR*)GetString(STR_ID_OP11_HS32_NOT_SET));
        }
        item_list[i] = (U8*)subMenuData[i];
    }

    RegisterHighlightHandler(mmi_op11_hs32_eml_account_list_highlight_hdlr);

    gdi_layer_lock_frame_buffer();

    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

    wgui_cat1001_op11_show(
        (UI_string_type)get_string(STR_ID_OP11_HS32_EML_EDIT_ACCOUNT),
        (UI_string_type)get_string(STR_ID_OP11_HS32_EML_S_OR_R), 
        get_string(STR_ID_OP11_HS32_VIP_SET),
        0,
        NULL,
        0,
        MMI_OP11_HS32_AP_EML_ACCOUNT_MAX,
        (U8**)item_list,
        ItemIconList,
        NULL,
        0,
        gui_buffer);

    if (g_mmi_op11_hs32_cntx.is_sel_screen_changed)
    {
        ChangeRightSoftkey(STR_GLOBAL_DONE, 0);
    }
    else
    {
        ChangeRightSoftkey(STR_GLOBAL_CANCEL, 0);
    }

    gdi_layer_unlock_frame_buffer();
    dm_redraw_category_screen();

//    SetLeftSoftkeyFunction(mmi_op11_hs32_enter_vip_select_screen, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_op11_hs32_eml_account_goback_idle, KEY_EVENT_UP);

}



/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_vip_list_highlight_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_eml_account_list_highlight_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_op11_hs32_cntx.eml_account_index = (U16) index;

    if (g_mmi_op11_hs32_cntx.eml_account[index] != 0)
    {
        ChangeLeftSoftkey(STR_ID_OP11_HS32_VIP_REMOVE, 0);
        SetLeftSoftkeyFunction(mmi_op11_hs32_eml_account_remove_select, KEY_EVENT_UP);
        SetCenterSoftkeyFunction(mmi_op11_hs32_eml_account_remove_select, KEY_EVENT_UP);
    }
    else
    {
        ChangeLeftSoftkey(STR_ID_OP11_HS32_VIP_SET, 0);
        SetLeftSoftkeyFunction(mmi_op11_hs32_enter_eml_account_select_screen, KEY_EVENT_UP);
        SetCenterSoftkeyFunction(mmi_op11_hs32_enter_eml_account_select_screen, KEY_EVENT_UP);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_eml_account_remove_select
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_eml_account_remove_select(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_op11_hs32_cntx.is_sel_screen_changed = 1;
    g_mmi_op11_hs32_cntx.last_set_index = 0xff;

    g_mmi_op11_hs32_cntx.eml_account[g_mmi_op11_hs32_cntx.eml_account_index] = 0;
    mmi_email_hs_remove_shct_acct((U8)g_mmi_op11_hs32_cntx.eml_account_index);

//    EntryNewScreen(SCR_ID_OP11_HS_DUMMY, NULL, NULL, NULL);

    if(mmi_frm_group_get_active_id() == g_mmi_op11_hs32_cntx.csk_sg_id)
    {
//        if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_DUMMY, NULL, NULL, MMI_FRM_FULL_SCRN) == MMI_FALSE)  return;
        mmi_frm_display_dummy_screen_ex(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_DUMMY);
        mmi_frm_scrn_close_active_id();
    }
}




/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_eml_account_select_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_enter_eml_account_select_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_email_hs_pre_set_shct_acct((U8)g_mmi_op11_hs32_cntx.eml_account_index);

}

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_eml_account_select_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_get_eml_account_after_select(S32 account_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_op11_hs32_cntx.is_sel_screen_changed = 1;

    g_mmi_op11_hs32_cntx.last_set_index = (U8)g_mmi_op11_hs32_cntx.eml_account_index;

    g_mmi_op11_hs32_cntx.eml_account[g_mmi_op11_hs32_cntx.eml_account_index] = account_id;

}



#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_eml_account_select_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_answer_us_shct_data(S32 sidebar_id, S32 shct_id, mmi_op11_hs32_shct_data_struct *shct_data_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_struct *sidebar_info;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (sidebar_id)
    {
        case MMI_OP11_HS32_AP_CLL:
            if (shct_id == MMI_OP11_HS32_SHCT_CLL_VOICEMAIL)
            {
                if (shct_data_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
                {
                    if (shct_data_p->item_count > 0)
                    {
                        sidebar_info = mmi_op11_hs32_get_sidebar_info_pointer(sidebar_id);
                        deleteAllShortcut(sidebar_id);
                        /* update viewitem  */
                        addShortcutsUScll(sidebar_info);
                        updateViewItem(sidebar_id, 0);
                    }
                }
            }
            break;

        case MMI_OP11_HS32_AP_MES:
            mmi_op11_hs32_answer_shct_data_mes(sidebar_id,shct_id,shct_data_p);
            if (shct_data_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
            {
                if (shct_data_p->item_count > 0)
                {
                    sidebar_info = mmi_op11_hs32_get_sidebar_info_pointer(sidebar_id);
                    deleteAllShortcut(sidebar_id);
                    /* update viewitem  */
                    addShortcutsUSmes(sidebar_info);
                    updateViewItem(sidebar_id, 0);
                }
            }
            break;

        default:
            MMI_ASSERT(0);
            break;
    }
    

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_entry_dev_screen_group
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_entry_dev_screen_group(void)
{
    mmi_op11_hs32_create_csk_root_gid();
    mmi_op11_hs32_entry_dev_screen();
}


/*****************************************************************************
 * FUNCTION
 *  vadp_v2p_op11_hs_entry_dev_screen
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_entry_dev_screen(void)
{
//    EntryNewScreen(SCR_ID_OP11_HS_DEV_STATUS, mmi_op11_hs32_exit_dev_screen, mmi_op11_hs32_entry_dev_screen, MMI_FULL_SCREEN);

    if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_DEV_STATUS, mmi_op11_hs32_exit_dev_screen, mmi_op11_hs32_entry_dev_screen, MMI_FRM_FULL_SCRN) == MMI_FALSE)
        return;

    vadp_p2v_op11_hs_dev_status_init();
}


/*****************************************************************************
 * FUNCTION
 *  vadp_v2p_op11_hs_exit_dev_screen
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_exit_dev_screen(void)
{
    vadp_p2v_op11_hs_dev_status_deinit();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_hs_get_memory_status
 * DESCRIPTION
 *  This function return the memory status of the specified memory.
 * PARAMETERS
 *  is_device       [IN]        Internal or external memory
 *  n_used          [OUT]       Number of memory used in MB
 *  n_total         [OUT]       Total number of memory in MB
 * RETURNS
 *  On success, return MMI_TRUE; otherwise, return MMI_FALSE.
 *****************************************************************************/
static MMI_BOOL mmi_op11_hs32_get_memory_status(
                MMI_BOOL is_device, 
                U32 *n_used, 
                U32 *n_total)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_DiskInfo info;
    WCHAR path[16];
    U32 size;
    S32 drive, ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_device)
    {
        drive = SRV_FMGR_PUBLIC_DRV;
    }
    else
    {
        drive = SRV_FMGR_CARD_DRV;
    }

    kal_wsprintf(path, "%c:\\", (CHAR)drive);
    
    ret = FS_GetDiskInfo(path, &info, FS_DI_FREE_SPACE | FS_DI_BASIC_INFO);

    if (ret < 0)
    {
        *n_total = 0;
        *n_used  = 0;

        return MMI_FALSE;
    }
    else
    {
        size = info.SectorsPerCluster * info.BytesPerSector;
        *n_total = (info.TotalClusters * size) / (1024);
        *n_used = *n_total - (info.FreeClusters * size) / (1024);

        return MMI_TRUE;
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_get_device_status
 * DESCRIPTION
 *  This function get the device status.
 * PARAMETERS
 *  update_memory   [IN]            Update memory status or not
 *  dev_p             [IN]            Pointer to device status context
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_get_device_status(S32 update_memory, void *dev_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
//    U8 SignalStrengthLevel = srv_nw_info_get_signal_strength_in_percentage(MMI_SIM1);
    S32 idx, n_frame;
    PU8 image;
    vadp_v2p_op11_hs_dev_status_struct *dev = (vadp_v2p_op11_hs_dev_status_struct*)dev_p;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /**
     * Battery status: 
     */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
    image = get_image((MMI_ID_TYPE)wgui_status_icon_bar_get_icon_image_id(STATUS_ICON_BATTERY_STRENGTH));
    n_frame = gui_image_n_frames(image);

    switch (srv_charbat_get_battery_level())
    {
        case BATTERY_LOW_POWEROFF:
        case BATTERY_LOW_TX_PROHIBIT:
        case BATTERY_LOW_WARNING:
        case BATTERY_LEVEL_0:
            idx = 0;
            break;

        case BATTERY_LEVEL_1:
        case BATTERY_LEVEL_2:
        case BATTERY_LEVEL_3:
            idx = 33 * (srv_charbat_get_battery_level() - BATTERY_LEVEL_0);
            break;

        default:
            idx = 33;
            break;
    }

    idx = (idx * n_frame) / 100;
        
    if (idx < 0)
    {
        idx = 0;
    }

    if (idx >= n_frame)
    {
        idx = n_frame - 1;
    }
    
    switch (idx)
    {
        case 0:
            dev->battery = 0;
            break;
        case 1:
            dev->battery = 1;
            break;
        case 2:
            dev->battery = 2;
            break;
        default:
            dev->battery = 3;
            break;
    }
#endif    
    
    /** 
     * Signal status: 
     */
    image = get_image((MMI_ID_TYPE)wgui_status_icon_bar_get_icon_image_id(STATUS_ICON_SIGNAL_STRENGTH));
    n_frame = gui_image_n_frames(image);

    /* 
     * Network info. service cannot report correct signal strength in flight
     * mode. So, in the flight mode, we directly set the idx to 0.
     *
     * TODO: Network info. service should fix this limtation. 
     */
    if (!srv_mode_switch_is_network_service_available())
    {
        idx = 0; /* flight mode */
    }
    else
    {
        idx = (srv_nw_info_get_signal_strength_in_percentage(MMI_SIM1) * n_frame) / 100;
    }

    if (idx < 0)
    {
        idx = 0;
    }

    if (idx >= n_frame)
    {
        idx = n_frame - 1;
    }
   
    switch (idx)
    {
        case 0:
        case 1:
            dev->signal = 0;
            break;
        case 2:
            dev->signal = 1;
            break;
        case 3:
            dev->signal = 2;
            break;
        default:
            dev->signal = 3;
            break;
    }
    
    /* 
     * If no need to update memory status, return directly to reduce file 
     * system accesses.
     */
    if (update_memory == MMI_FALSE)
    {
        return;
    }

#ifdef __USB_IN_NORMAL_MODE__
    if (srv_usb_is_in_mass_storage_mode())       
    {
        dev->ext_mem_current_size = 0;
        dev->ext_mem_total_size = 0;
        dev->int_mem_current_size = 0;
        dev->int_mem_total_size = 0;
        return;
    }
#endif    
    /**
     * External memory status: 
     */
    
    mmi_op11_hs32_get_memory_status(MMI_FALSE, &dev->ext_mem_current_size, &dev->ext_mem_total_size);

    
    /** 
     * Internal memory status: 
     */

    mmi_op11_hs32_get_memory_status(MMI_TRUE, &dev->int_mem_current_size, &dev->int_mem_total_size);


}



/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_option_context_exec
 * DESCRIPTION
 *  void
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8* mmi_op11_hs32_option_context_exec(S32 sidebar_id, S32 op_flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i=0;
    mmi_op11_hs_screen_history_struct *screen_history_p = NULL;
    srv_mode_switch_type_enum mode;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(sidebar_id)
    {
        case MMI_OP11_HS32_AP_CON:
                while (g_hs_hist_cntx.shct_hist[sidebar_id][i] != 0xFF)
                {
                    if (g_hs_hist_cntx.shct_hist[sidebar_id][i] == MMI_OP11_HS32_SHCT_CON_SET_VIP)
                    {
                        if (op_flag == 0)
                        {
                            return (U8*)get_string(STR_ID_OP11_HS32_CON_SET_VIP);
                        }
                        else
                        {
                            mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_CON][MMI_OP11_HS32_SHCT_CON_SET_VIP]();
//                            DeleteScreenIfPresent(SCR_ID_OP11_HS_OPTIONS);
                            mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.lsk_sg_id, SCR_ID_OP11_HS_OPTIONS); 
                            return NULL;
                        }
                    }
                    if (g_hs_hist_cntx.shct_hist[sidebar_id][i] == MMI_OP11_HS32_SHCT_CON_EDIT_VIP)
                    {
                        if (op_flag == 0)
                        {
                            return (U8*)get_string(STR_ID_OP11_HS32_CON_EDIT_VIP);
                        }
                        else
                        {
                            mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_CON][MMI_OP11_HS32_SHCT_CON_EDIT_VIP]();
//                            DeleteScreenIfPresent(SCR_ID_OP11_HS_OPTIONS);
                            mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.lsk_sg_id, SCR_ID_OP11_HS_OPTIONS); 
                            return NULL;
                        }
                    }
                    i++;
                }
                /* trace history */
                MMI_ASSERT(0);
            break;

        case MMI_OP11_HS32_AP_EML:
                while (g_hs_hist_cntx.shct_hist[sidebar_id][i] != 0xFF)
                {
                    if (g_hs_hist_cntx.shct_hist[sidebar_id][i] == MMI_OP11_HS32_SHCT_EML_SET_ACCOUNT)
                    {
                        if (op_flag == 0)
                        {
                            return (U8*)get_string(STR_ID_OP11_HS32_EML_SET_ACCOUNT);
                        }
                        else
                        {
                            mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_EML][MMI_OP11_HS32_SHCT_EML_SET_ACCOUNT]();
//                            DeleteScreenIfPresent(SCR_ID_OP11_HS_OPTIONS);
                            mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.lsk_sg_id, SCR_ID_OP11_HS_OPTIONS); 
                            return NULL;
                        }
                    }
                    if (g_hs_hist_cntx.shct_hist[sidebar_id][i] == MMI_OP11_HS32_SHCT_EML_EDIT_ACCOUNT)
                    {
                        if (op_flag == 0)
                        {
                            return (U8*)get_string(STR_ID_OP11_HS32_EML_EDIT_ACCOUNT);
                        }
                        else
                        {
                            mmi_op11_hs32_shct_sel_func_tbl[MMI_OP11_HS32_AP_EML][MMI_OP11_HS32_SHCT_EML_EDIT_ACCOUNT]();
//                            DeleteScreenIfPresent(SCR_ID_OP11_HS_OPTIONS);
                            mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.lsk_sg_id, SCR_ID_OP11_HS_OPTIONS); 
                            return NULL;
                        }
                    }
                    i++;
                }
                /* trace history */
                MMI_ASSERT(0);
            break;

        case MMI_OP11_HS32_AP_ALM:
                while (g_hs_hist_cntx.shct_hist[sidebar_id][i] != 0xFF)
                {
                    if (g_hs_hist_cntx.shct_hist[sidebar_id][i] == MMI_OP11_HS32_SHCT_ALM_NO)
                    {
                        if (op_flag == -1)
                        {
                            return NULL;
                        }
                        if (op_flag == 0)
                        {
                            return NULL;
                        }
                        else
                        {
                            return NULL;
                        }

                    }
                    i++;
                }

                        if (op_flag == -1)
                        {
                            return g_mmi_op11_hs32_cntx.alm_account;
                        }
                        if (op_flag == 0)
                        {
                            return (U8*)get_string(STR_ID_OP11_HS32_TURN_OFF_ALARM);
                        }
                        else
                        {
                            screen_history_p = (mmi_op11_hs_screen_history_struct *)g_mmi_op11_hs32_cntx.history;
                            mmi_alm_set_alarm_state((U8)g_mmi_op11_hs32_cntx.alm_account[screen_history_p->shortcut_index], 0);
                            if (screen_history_p->shortcut_index != 0)
                                screen_history_p->shortcut_index --;
                            mmi_frm_scrn_close_active_id();
                            return NULL;
                        }
                break;
				
        case MMI_OP11_HS32_AP_CNX:
            screen_history_p = (mmi_op11_hs_screen_history_struct *)g_mmi_op11_hs32_cntx.history;

            if ((srv_mode_switch_get_current_mode() == SRV_MODE_FLIGHT_MODE))
            {
                /* Flight Mode */
                        if (op_flag == 0)
                        {
                            if (srv_mode_switch_get_current_mode() == SRV_MODE_FLIGHT_MODE)
                            {
                                return (U8*)get_string(STR_ID_OP11_HS32_TURN_OFF);
                            }
                            else
                            {
                                return (U8*)get_string(STR_ID_OP11_HS32_TURN_ON);
                            }
                        }
                        else
                        {
                            if (srv_mode_switch_get_current_mode() == SRV_MODE_FLIGHT_MODE)
                            {
//                                g_phnset_cntx.selFlightMode = 0;
                                mode = SRV_MODE_NORMAL_MODE;
                            }
                            else
                            {
//                                g_phnset_cntx.selFlightMode = 1;
                                mode = SRV_MODE_FLIGHT_MODE;
                            }
//                            mmi_phnset_confirm_to_switch_mode();
#ifndef __MTK_TARGET__
                            PopupNoSupport();
                            return NULL;
#else /* __MTK_TARGET__ */
                            srv_mode_switch_switch_network_mode(mode, mmi_op11_hs32_switch_mode_callback, NULL);

                            mmi_op11_hs32_create_flight_mode_gid();
                            mmi_op11_hs32_entry_flight_mode_progress();
#endif /* __MTK_TARGET__ */

                            screen_history_p->shortcut_index = mmi_op11_hs32_get_shct_index(MMI_OP11_HS32_AP_CNX, MMI_OP11_HS32_SHCT_CNX_FM);

//                            DeleteScreenIfPresent(SCR_ID_OP11_HS_OPTIONS);
                            mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.lsk_sg_id, SCR_ID_OP11_HS_OPTIONS); 
                            return NULL;
                        }

            }
            else
            {
                /* not in Flight Mode */
                screen_history_p = (mmi_op11_hs_screen_history_struct *)g_mmi_op11_hs32_cntx.history;
#if defined(__MMI_OP11_HS32_CNX_WIFI__)
                    if (g_hs_hist_cntx.shct_hist[sidebar_id][screen_history_p->shortcut_index] == MMI_OP11_HS32_SHCT_CNX_WIFI)
                    {
                        if (op_flag == 0)
                        {
                            if (//(srv_dtcnt_wlan_status() == SRV_DTCNT_WLAN_STATUS_ACTIVE) ||
                            (srv_dtcnt_wlan_status() == SRV_DTCNT_WLAN_STATUS_CONNECTED))
                            {
                                return (U8*)get_string(STR_ID_OP11_HS32_TURN_OFF);
                            }
                            else
                            {
                                return (U8*)get_string(STR_ID_OP11_HS32_TURN_ON);
                            }
                        }
                        else
                        {
                            mmi_op11_hs32_entry_wifi_power_switch();
//                            DeleteScreenIfPresent(SCR_ID_OP11_HS_OPTIONS);
                            mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.lsk_sg_id, SCR_ID_OP11_HS_OPTIONS); 
                            return NULL;
                        }
                    }
#endif /* __MMI_OP11_HS32_CNX_WIFI__ */

#if defined(__MMI_OP11_HS32_CNX_BT__)
                    if (g_hs_hist_cntx.shct_hist[sidebar_id][screen_history_p->shortcut_index] == MMI_OP11_HS32_SHCT_CNX_BT)
                    {
                        if (op_flag == 0)
                        {
                            if (mmi_bt_is_power_on(MMI_FALSE))
                            {
                                return (U8*)get_string(STR_ID_OP11_HS32_TURN_OFF);
                            }
                            else
                            {
                                return (U8*)get_string(STR_ID_OP11_HS32_TURN_ON);
                            }
                        }
                        else
                        {
                            mmi_bt_entry_power_switch();
//                            DeleteScreenIfPresent(SCR_ID_OP11_HS_OPTIONS);
                            mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.lsk_sg_id, SCR_ID_OP11_HS_OPTIONS); 
                            return NULL;
                        }

                    }
#endif /* __MMI_OP11_HS32_CNX_BT__ */

                    if (g_hs_hist_cntx.shct_hist[sidebar_id][screen_history_p->shortcut_index] == MMI_OP11_HS32_SHCT_CNX_FM)
                    {
                        if (op_flag == 0)
                        {
                            if (srv_mode_switch_get_current_mode() == SRV_MODE_FLIGHT_MODE)
                            {
                                return (U8*)get_string(STR_ID_OP11_HS32_TURN_OFF);
                            }
                            else
                            {
                                return (U8*)get_string(STR_ID_OP11_HS32_TURN_ON);
                            }
                        }
                        else
                        {

                            if (srv_mode_switch_get_current_mode() == SRV_MODE_FLIGHT_MODE)
                            {
                                mode = SRV_MODE_NORMAL_MODE;
                            }
                            else
                            {
                                mode = SRV_MODE_FLIGHT_MODE;
                            }
#ifndef __MTK_TARGET__
                            PopupNoSupport();
                            return NULL;
#else /* __MTK_TARGET__ */
                            srv_mode_switch_switch_network_mode(mode, mmi_op11_hs32_switch_mode_callback, NULL);

                            mmi_op11_hs32_create_flight_mode_gid();
                            mmi_op11_hs32_entry_flight_mode_progress();
#endif
                            mmi_op11_hs32_discard_history();
                            mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.lsk_sg_id, SCR_ID_OP11_HS_OPTIONS); 
                            return NULL;
                        }
                    }
                /* trace history */
                MMI_ASSERT(0);
            }
                break;

        default:
            MMI_ASSERT(0);
            break;
    }

    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_at_delete_vip_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_at_delete_vip_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_group_is_present(GRP_ID_PHB_VIP_CONTACT))
    {
        mmi_frm_group_close(GRP_ID_PHB_VIP_CONTACT);
    }
//    DeleteScreenIfPresent(SCR_ID_OP11_HS_SET_VIP);
//    DeleteScreenIfPresent(SCR_ID_OP11_HS_EDIT_VIP);
//    DeleteScreenIfPresent(SCR_ID_OP11_HS_VIP_OPTION);

    mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_SET_VIP);
    mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_EDIT_VIP);
    mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_VIP_OPTION);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_vip_after_call_cb
 * DESCRIPTION
 *  
 * PARAMETERS
 *  make_call_cb_para       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_vip_after_call_cb(mmi_ucm_after_make_call_cb_struct *make_call_cb_para)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (make_call_cb_para->user_data)
    {
        srv_phb_destory_cm_user_data(make_call_cb_para->user_data);
        make_call_cb_para->user_data = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_vip_launch_call
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_vip_launch_call(U16 vip_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 store_index;
    U32 number_type;
    mmi_ucm_make_call_para_struct make_call_para;
    mmi_phb_vip_contact_struct *vip_entry;
    void *cm_user_data;
    U16 number[SRV_UCM_MAX_NUM_URI_LEN + 1];

    mmi_popup_property_struct popup_arg;
    MMI_ID sg_id = mmi_frm_group_get_active_id();
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!srv_phb_vip_contact_is_sync(vip_index))
    {
        mmi_popup_property_init(&popup_arg);
        if (sg_id != GRP_ID_INVALID)
        {
            popup_arg.parent_id = sg_id;
        }
        mmi_popup_display((WCHAR*)get_string(STR_GLOBAL_ERROR), MMI_EVENT_ERROR, &popup_arg);
//        mmi_display_popup(get_string(STR_GLOBAL_ERROR), MMI_EVENT_ERROR);
        return;
    }
    store_index = srv_phb_vip_contact_get_store_index(vip_index);
    vip_entry = srv_phb_vip_contact_get_entry(vip_index);
    number_type = vip_entry->num_type;

    memset(number, 0, sizeof(number));
    mmi_ucs2ncpy((CHAR*)number, (CHAR*)srv_phb_vip_contact_get_number(vip_index), SRV_UCM_MAX_NUM_URI_LEN);

    mmi_ucm_init_call_para(&make_call_para);

    make_call_para.dial_type = SRV_UCM_VOICE_CALL_TYPE_ALL;
    make_call_para.ucs2_num_uri = number;
    if (store_index != 0xFFFF)
    {
        make_call_para.adv_para.after_make_call_callback = mmi_op11_hs32_vip_after_call_cb;
        cm_user_data = srv_phb_create_cm_user_data(NULL, number_type, store_index);
        make_call_para.adv_para.after_callback_user_data = cm_user_data;
    }
    mmi_ucm_call_launch(0, &make_call_para);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_vip_send_mes
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_vip_send_mes(U16 vip_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR ascii_number[MMI_PHB_NUMBER_LENGTH + 1 + 1];
    mmi_sms_write_msg_para_struct sendData;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(ascii_number, 0, sizeof(ascii_number));
    memset(&sendData, 0, sizeof(mmi_sms_write_msg_para_struct));

    mmi_ucs2_n_to_asc((CHAR*)ascii_number, (CHAR*)srv_phb_vip_contact_get_number(vip_index), MMI_PHB_NUMBER_LENGTH + 1);
    sendData.string = NULL;
    sendData.stringlength = 0;
    sendData.dcs = 0;
    sendData.flag = MMI_SMS_ENTRY_WRITE_REPLY;
    sendData.ascii_addr = (U8*)ascii_number;

    mmi_sms_write_msg_lanch(0, &sendData);

    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_vip_send_mes
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_vip_view_contact(U16 vip_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 store_index;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    store_index = srv_phb_vip_contact_get_store_index(vip_index);

    cui_phb_view_contact(
        g_mmi_op11_hs32_cntx.csk_sg_id,
        store_index);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_us_vip_sync
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_us_vip_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i,j;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(g_mmi_op11_hs32_cntx.us_vip , 0, sizeof(g_mmi_op11_hs32_cntx.us_vip));

    g_mmi_op11_hs32_cntx.us_vip_count = 0;
    for(i=0, j=0; i<MMI_OP11_HS32_AP_CON_VIP_MAX; i++)
    {
        if (srv_phb_vip_contact_is_sync(i)) 
        {
             /* vip exist */
            g_mmi_op11_hs32_cntx.us_vip[j] = i;
            j++;
        }
    }
    g_mmi_op11_hs32_cntx.us_vip_count = j;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_us_vip_sync
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_us_vip_sync(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i,j,count;
    U16 us_vip_temp[MMI_OP11_HS32_AP_CON_VIP_MAX];
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(us_vip_temp, 0xFF, sizeof(us_vip_temp));

    count = 0;
    for(i=0; i<MMI_OP11_HS32_AP_CON_VIP_MAX; i++)
    {
        if (srv_phb_vip_contact_is_sync(i)) 
        {
            count ++;
             /* vip exist */
            for(j=0; j<g_mmi_op11_hs32_cntx.us_vip_count; j++)
            {
                if(g_mmi_op11_hs32_cntx.us_vip[j] == i)
                {
                    /* vip exist in history */
                    break; 
                }
            }

            if (j == g_mmi_op11_hs32_cntx.us_vip_count)
            {
                /* vip not exist in history, add into history last */
                g_mmi_op11_hs32_cntx.us_vip[j] = i;
                g_mmi_op11_hs32_cntx.us_vip_count ++;
            }
        }
        else  /* vip not exist, need revise shct history (label the bad data) */
        {
             /* vip not exist */
            for(j=0; j<g_mmi_op11_hs32_cntx.us_vip_count; j++)
            {
                if(g_mmi_op11_hs32_cntx.us_vip[j] == i)
                {
                    /* vip exist in history, label the bad data  */
                    g_mmi_op11_hs32_cntx.us_vip[j] = 0xFFFE;
                    break;
                }
            }
        }
    }

    for (i=0,j =0; i<g_mmi_op11_hs32_cntx.us_vip_count; i++)
    {
        if (g_mmi_op11_hs32_cntx.us_vip[i] != 0xFFFE)
        {
            us_vip_temp[j] = g_mmi_op11_hs32_cntx.us_vip[i];
            j++;
        }
    }

    g_mmi_op11_hs32_cntx.us_vip_count = j;

    memcpy(g_mmi_op11_hs32_cntx.us_vip, us_vip_temp, MMI_OP11_HS32_AP_CON_VIP_MAX*sizeof(U16));

}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_exit_us_vip_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_exit_us_vip_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    vadp_p2v_op11_hs_vip_contact_deinit();
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_us_vip_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_enter_us_vip_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buffer;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_phb_check_ready(MMI_TRUE))
    {
        return;
    }

//    EntryNewScreen(SCR_ID_OP11_HS_US_VIP, mmi_op11_hs32_exit_us_vip_screen, mmi_op11_hs32_enter_us_vip_screen, NULL);
//    gui_buffer = GetCurrGuiBuffer(SCR_ID_OP11_HS_US_VIP);

    if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_US_VIP, mmi_op11_hs32_exit_us_vip_screen, mmi_op11_hs32_enter_us_vip_screen, MMI_FRM_FULL_SCRN) == MMI_FALSE)
        return;
    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    mmi_op11_hs32_us_vip_sync();
    
    vadp_p2v_op11_hs_vip_contact_init();

    SetLeftSoftkeyFunction(dummp_func, KEY_EVENT_UP);
    SetRightSoftkeyFunction(dummp_func, KEY_EVENT_UP);
    SetKeyHandler(dummp_func, KEY_ENTER, KEY_EVENT_DOWN);    
    SetKeyHandler(dummp_func, KEY_SEND, KEY_EVENT_DOWN);    

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_entry_us_vip_option_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_entry_us_vip_option_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16     ItemStrList[MAX_SUB_MENUS];
    U16     nItems;
    U8 *    gui_buffer;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    EntryNewScreen(SCR_ID_OP11_HS_VIP_OPTION, NULL, mmi_op11_hs32_entry_us_vip_option_screen, NULL);
//    gui_buffer = GetCurrGuiBuffer(SCR_ID_OP11_HS_VIP_OPTION);

    if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_VIP_OPTION, NULL, mmi_op11_hs32_entry_us_vip_option_screen, MMI_FRM_FULL_SCRN) == MMI_FALSE)
        return;
    gui_buffer = mmi_frm_scrn_get_active_gui_buf();

    if (srv_phb_vip_contact_get_store_index(g_mmi_op11_hs32_cntx.vip_index) == 0xFFFF)
    {
        mmi_frm_hide_menu_item(MENU_ID_OP11_HS_VIP_CONTACT); 
    }
    else
    {
        mmi_frm_unhide_menu_item(MENU_ID_OP11_HS_VIP_CONTACT); 
    }

    nItems = GetNumOfChild_Ext(MENU_ID_OP11_HS_VIP_OPTION);
    GetSequenceStringIds_Ext(MENU_ID_OP11_HS_VIP_OPTION, ItemStrList);
    SetParentHandler(MENU_ID_OP11_HS_VIP_OPTION);
   
    RegisterHighlightHandler(ExecuteCurrHiliteHandler);

    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

    ShowCategory1Screen(
        STR_GLOBAL_OPTIONS,
        0,
        STR_GLOBAL_SELECT,
        0,
        STR_GLOBAL_CLOSE,
        0,
        nItems,
        ItemStrList,
        0,
        gui_buffer);     

    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs_hilight_context_item
 * DESCRIPTION
 *  highlight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_hilight_us_vip_send_mes(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    SetLeftSoftkeyFunction(mmi_op11_hs32_us_vip_send_mes, KEY_EVENT_UP);
//    SetKeyHandler(mmi_op11_hs32_us_vip_send_mes, KEY_ENTER, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_op11_hs32_us_vip_send_mes, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs_hilight_context_item
 * DESCRIPTION
 *  highlight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_hilight_us_vip_make_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    SetLeftSoftkeyFunction(mmi_op11_hs32_us_vip_make_call, KEY_EVENT_UP);
//    SetKeyHandler(mmi_op11_hs32_us_vip_make_call, KEY_ENTER, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_op11_hs32_us_vip_make_call, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs_hilight_context_item
 * DESCRIPTION
 *  highlight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_hilight_us_vip_switch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    SetLeftSoftkeyFunction(mmi_op11_hs32_us_vip_switch, KEY_EVENT_UP);
//    SetKeyHandler(mmi_op11_hs32_us_vip_switch, KEY_ENTER, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_op11_hs32_us_vip_switch, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs_hilight_context_item
 * DESCRIPTION
 *  highlight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_hilight_us_vip_remove(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    SetLeftSoftkeyFunction(mmi_op11_hs32_us_vip_remove, KEY_EVENT_UP);
//    SetKeyHandler(mmi_op11_hs32_us_vip_remove, KEY_ENTER, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_op11_hs32_us_vip_remove, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs_hilight_context_item
 * DESCRIPTION
 *  highlight handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_hilight_us_vip_contact(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    SetLeftSoftkeyFunction(mmi_op11_hs32_us_vip_view_contact, KEY_EVENT_UP);
//    SetKeyHandler(mmi_op11_hs32_us_vip_view_contact, KEY_ENTER, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_op11_hs32_us_vip_view_contact, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_us_vip_send_mes
 * DESCRIPTION
 *  execute handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_us_vip_send_mes(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_vip_send_mes(g_mmi_op11_hs32_cntx.vip_index);
//    DeleteScreenIfPresent(SCR_ID_OP11_HS_VIP_OPTION);
    mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_VIP_OPTION);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_us_vip_make_call
 * DESCRIPTION
 *  execute handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_us_vip_make_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    EntryNewScreen(SCR_ID_OP11_HS_DUMMY, NULL, NULL, NULL);
//    if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_DUMMY, NULL, NULL, MMI_FRM_FULL_SCRN) == MMI_FALSE)  return;
    mmi_frm_display_dummy_screen_ex(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_DUMMY);

    mmi_op11_hs32_vip_launch_call(g_mmi_op11_hs32_cntx.vip_index);
//    DeleteScreenIfPresent(SCR_ID_OP11_HS_VIP_OPTION);
    mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_VIP_OPTION);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_us_vip_switch
 * DESCRIPTION
 *  execute handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_us_vip_switch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_op11_hs32_cntx.us_vip_switch = 1;
    mmi_op11_hs32_enter_vip_select_screen();
//    DeleteScreenIfPresent(SCR_ID_OP11_HS_VIP_OPTION);
    mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_VIP_OPTION);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_us_vip_remove
 * DESCRIPTION
 *  execute handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_us_vip_remove(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_phb_clear_vip_contact(g_mmi_op11_hs32_cntx.vip_index);
    mmi_frm_scrn_close_active_id();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_us_vip_view_contact
 * DESCRIPTION
 *  execute handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_us_vip_view_contact(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_phb_vip_contact_get_store_index(g_mmi_op11_hs32_cntx.vip_index) == 0xFFFF)
    {
        return;
    }

    mmi_op11_hs32_vip_view_contact(g_mmi_op11_hs32_cntx.vip_index);
//    DeleteScreenIfPresent(SCR_ID_OP11_HS_VIP_OPTION);
    mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_VIP_OPTION);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_us_vip_view_contact
 * DESCRIPTION
 *  execute handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_us_vip_add_new(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    for(i=0; i<MMI_OP11_HS32_AP_CON_VIP_MAX; i++)
    {
        if (!srv_phb_vip_contact_is_sync(i)) 
        {
             /* vip not exist */
            g_mmi_op11_hs32_cntx.vip_index = i;
            break;
        }
    }
    MMI_ASSERT(i != MMI_OP11_HS32_AP_CON_VIP_MAX);

    g_mmi_op11_hs32_cntx.us_vip_switch = 0;
    mmi_op11_hs32_enter_vip_select_screen();

}


#if (defined(__MMI_OP11_HOMESCREEN_0302__) && !defined(__MMI_OP11_HOMESCREEN_US__))

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_us_vip_view_contact
 * DESCRIPTION
 *  execute handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_sync_wp_alm(S32 sidebar_id, S32 indctr_id, mmi_op11_hs32_sidebar_query_info_struct *sidebar_answer_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    U8* alm_list = (U8*)sidebar_answer_p->sync_data;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if((sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_OK) || (sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE))
    {
        /* account sync */
        if (sidebar_answer_p->indicator_value == 0)
        {
            g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_ALM]= 1;
            g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_ALM][0] = MMI_OP11_HS32_SHCT_ALM_NO;
        }
        else
        {
            g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_ALM] = sidebar_answer_p->indicator_value;
            for (i=0; i<g_mmi_op11_hs32_cntx.shct_hist_count[MMI_OP11_HS32_AP_ALM]; i++)
            {
                g_hs_hist_cntx.shct_hist[MMI_OP11_HS32_AP_ALM][i] = MMI_OP11_HS32_SHCT_ALM_1 + i;
                g_mmi_op11_hs32_cntx.alm_account[i] = alm_list[i];
            }
        }
                /* save account to NVRAM */
                mmi_op11_hs_save_id_history();
    }

    if(sidebar_answer_p->result_flag == MMI_OP11_HS32_RESULT_UPDATE)
    {
        /* update alarm wp data  */
        updateWpPanel(sidebar_id);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_exit_us_vip_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_exit_wp_mgr_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    vadp_p2v_op11_hs_wp_setting_deinit();
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_wp_mgr_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_enter_wp_mgr_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

//    EntryNewScreen(SCR_ID_OP11_HS_WP_MGR, mmi_op11_hs32_exit_wp_mgr_screen, mmi_op11_hs32_enter_wp_mgr_screen, NULL);

    if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.lsk_sg_id, SCR_ID_OP11_HS_WP_MGR, mmi_op11_hs32_exit_wp_mgr_screen, mmi_op11_hs32_enter_wp_mgr_screen, MMI_FRM_FULL_SCRN) == MMI_FALSE)
        return;

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
 
    vadp_p2v_op11_hs_wp_setting_init();

    SetLeftSoftkeyFunction(dummp_func, KEY_EVENT_UP);
    SetRightSoftkeyFunction(dummp_func, KEY_EVENT_UP);
    SetKeyHandler(dummp_func, KEY_ENTER, KEY_EVENT_UP);    
//    SetKeyHandler(dummp_func, KEY_SEND, KEY_EVENT_DOWN);    

}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_exit_wp_select_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_exit_wp_select_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    vadp_p2v_op11_hs_wp_select_deinit();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_enter_wp_select_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_enter_wp_select_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    EntryNewScreen(SCR_ID_OP11_HS_WP_SEL, mmi_op11_hs32_exit_wp_select_screen, mmi_op11_hs32_enter_wp_select_screen, NULL);

    if (mmi_frm_scrn_enter(g_mmi_op11_hs32_cntx.lsk_sg_id, SCR_ID_OP11_HS_WP_SEL, mmi_op11_hs32_exit_wp_select_screen, mmi_op11_hs32_enter_wp_select_screen, MMI_FRM_FULL_SCRN) == MMI_FALSE)
        return;

    vadp_p2v_op11_hs_wp_select_init();

    SetLeftSoftkeyFunction(dummp_func, KEY_EVENT_UP);
    SetRightSoftkeyFunction(dummp_func, KEY_EVENT_UP);
//    SetKeyHandler(dummp_func, KEY_ENTER, KEY_EVENT_DOWN);    
//    SetKeyHandler(dummp_func, KEY_SEND, KEY_EVENT_DOWN);    
}

#endif /* (defined(__MMI_OP11_HOMESCREEN_0302__) && !defined(__MMI_OP11_HOMESCREEN_US__)) */


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_update_idle_text
 * DESCRIPTION
 *  
 * PARAMETERS
 *  network_name
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_update_idle_text(WCHAR *network_name)
{
    vadp_p2v_op11_hs_set_network_name((VfxWChar*)network_name);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_exec_rsk
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_exec_rsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    goto_main_menu();

    if (!mmi_idle_is_active())
    {
        mmi_scr_locker_start_manual_lock(KEY_STAR);
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs_create_csk_root_gid
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_create_csk_root_gid(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((g_mmi_op11_hs32_cntx.csk_sg_id != 0) && mmi_frm_group_is_present(g_mmi_op11_hs32_cntx.csk_sg_id))
    {
        mmi_frm_group_close(g_mmi_op11_hs32_cntx.csk_sg_id);
    }

    g_mmi_op11_hs32_cntx.csk_sg_id =  mmi_frm_group_create (GRP_ID_ROOT, GRP_ID_AUTO_GEN, mmi_op11_hs32_csk_grp_proc, NULL);
    mmi_frm_group_enter(g_mmi_op11_hs32_cntx.csk_sg_id, MMI_FRM_NODE_SMART_CLOSE_FLAG);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_csk_grp_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_op11_hs32_csk_grp_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_phb_select_contact_result_struct *select_contact;
    U8 *ecc_display_ptr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_PHB_SELECT_CONTACT:
            select_contact = (cui_phb_select_contact_result_struct*) evt; 

            if (ecc_custom_verify_emergency_number(
                    (U8*) select_contact->select_data,
                    (U8) mmi_wcslen(select_contact->select_data),
                    ECC_ENCODING_UCS2,
                    ECC_ALL_CALL,
                    NULL,
                    &ecc_display_ptr,
                    NULL))
            {
                    mmi_popup_display((WCHAR*) GetString(STR_EMERGENCY_NUMBER), MMI_EVENT_FAILURE, NULL);
//                    mmi_display_popup((UI_string_type) GetString(STR_EMERGENCY_NUMBER), MMI_EVENT_FAILURE);
                    cui_phb_list_select_contact_close(g_mmi_op11_hs32_cntx.phb_list_sg_id);
            }
            else
            {
                srv_phb_update_vip_contact(
                    g_mmi_op11_hs32_cntx.vip_index,
                    select_contact->store_index,
                    select_contact->name,
                    select_contact->select_data,
                    select_contact->data_type);

                g_mmi_op11_hs32_cntx.is_sel_screen_changed = 1;
                g_mmi_op11_hs32_cntx.last_set_index = (U8)g_mmi_op11_hs32_cntx.vip_index;
#ifdef __MMI_OP11_HOMESCREEN_US__
                if (g_mmi_op11_hs32_cntx.us_vip_switch == 0)
                {
                    g_mmi_op11_hs32_cntx.last_set_index = 0xFE;
                }
#endif
                cui_phb_list_select_contact_close(g_mmi_op11_hs32_cntx.phb_list_sg_id);
            }
            break;

        case EVT_ID_PHB_SELECT_CONTACT_CANCEL:
            cui_phb_list_select_contact_close(g_mmi_op11_hs32_cntx.phb_list_sg_id);
            break;

        case EVT_ID_CUI_FOLDER_BROWSER_ON_QUIT:
            mmi_frm_group_close(g_mmi_op11_hs32_cntx.fmgr_sg_id);
            break;

        default:
            break;
    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs_create_csk_root_gid
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_create_flight_mode_gid(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((g_mmi_op11_hs32_cntx.flightmode_sg_id != 0) && mmi_frm_group_is_present(g_mmi_op11_hs32_cntx.flightmode_sg_id))
    {
        mmi_frm_group_close(g_mmi_op11_hs32_cntx.flightmode_sg_id);
    }

    g_mmi_op11_hs32_cntx.flightmode_sg_id =  mmi_frm_group_create (GRP_ID_ROOT, GRP_ID_AUTO_GEN, mmi_op11_hs32_flight_mode_grp_proc, NULL);
    mmi_frm_group_enter(g_mmi_op11_hs32_cntx.flightmode_sg_id, MMI_FRM_NODE_SMART_CLOSE_FLAG);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_flight_mode_grp_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_op11_hs32_flight_mode_grp_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        default:
            break;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_flight_mode_entry_progress
 * DESCRIPTION
 *  Entry flight mode progressing screen 
 * PARAMETERS
 *  
 * RETURNS
 *  static void
 *****************************************************************************/
static void mmi_op11_hs32_entry_flight_mode_progress()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!mmi_frm_scrn_enter(
        g_mmi_op11_hs32_cntx.flightmode_sg_id,
        SCR_ID_OP11_HS_FLIGHTMODE_PROGRESS,
        NULL,
        (FuncPtr)mmi_op11_hs32_entry_flight_mode_progress,
        MMI_FRM_UNKNOW_SCRN))
    {
        return;
    }

    SetKeyHandler(dummp_func, KEY_END, KEY_EVENT_DOWN);
    SetKeyHandler(dummp_func, KEY_END, KEY_EVENT_UP);
    ShowCategory66Screen(
        STR_MENU_FLIGHT_MODE,
        0,
        0,
        0,
        0,
        0,
        (PU8) GetString(STR_FLIGHT_MODE_PROGRESS),
        mmi_get_event_based_image(MMI_EVENT_PROGRESS),
        NULL);    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_switch_mode_callback
 * DESCRIPTION
 *  switch mode callback function 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_op11_hs32_switch_mode_callback(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (evt->evt_id == EVT_ID_SRV_MODE_SWITCH_FINISH)
	{
        if (((srv_mode_switch_rsp_event_struct*)evt)->result)
        {
            mmi_popup_display_simple((WCHAR*) GetString(STR_GLOBAL_DONE), MMI_EVENT_SUCCESS, GRP_ID_ROOT, NULL);
        }
        else
        {
            mmi_popup_display_simple((WCHAR*)GetString(STR_GLOBAL_ERROR), MMI_EVENT_FAILURE, GRP_ID_ROOT, NULL);
        }
        mmi_frm_group_close(g_mmi_op11_hs32_cntx.flightmode_sg_id);
    //    mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.flightmode_sg_id, SCR_ID_OP11_HS_FLIGHTMODE_PROGRESS);
        g_mmi_op11_hs32_cntx.flightmode_sg_id = 0;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_fmgr_notify_hdlr
 * DESCRIPTION
 *  switch mode callback function 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_op11_hs32_fmgr_notify_hdlr(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(event->evt_id)
    {
        case EVT_ID_SRV_FMGR_NOTIFICATION_DEV_PLUG_IN:
        case EVT_ID_SRV_FMGR_NOTIFICATION_DEV_PLUG_OUT:
            if(mmi_frm_group_is_present(g_mmi_op11_hs32_cntx.csk_sg_id))
            {
//                mmi_frm_group_close(g_mmi_op11_hs32_cntx.csk_sg_id);
//                mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_SET_VIP);  
//                mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_EDIT_VIP);  
                mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_SET_ACCOUNT);  
                mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_EDIT_ACCOUNT);  
            }
            break;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_delete_eml_account_scr
 * DESCRIPTION
 *  switch mode callback function 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_delete_eml_account_scr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(mmi_frm_group_is_present(g_mmi_op11_hs32_cntx.csk_sg_id))
    {
    //                mmi_frm_group_close(g_mmi_op11_hs32_cntx.csk_sg_id);
    //                mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_SET_VIP);  
    //                mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_EDIT_VIP);  
        mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_SET_ACCOUNT);  
        mmi_frm_scrn_close(g_mmi_op11_hs32_cntx.csk_sg_id, SCR_ID_OP11_HS_EDIT_ACCOUNT);  
    }
}

#endif /* __MMI_OP11_HOMESCREEN_0301__ || __MMI_OP11_HOMESCREEN_0302__ */


