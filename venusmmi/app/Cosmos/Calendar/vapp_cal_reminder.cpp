/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2008
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES. ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vapp_cal_group_list.cpp
 *
 * Project:
 * --------
 *  Cosmos
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
 /***************************************************************************** 
 * Include
 *****************************************************************************/
#include "mmi_features.h"

extern "C"
{
    #include "GlobalResDef.h"
    #include "mmi_frm_scenario_gprot.h"
    #include "wgui.h"
    #include "BootupSrvGprot.h"
    #include "gpiosrvgprot.h"
    #include "CharBatSrvGprot.h"
    #include "USBSrvGprot.h"
    #include "notificationgprot.h"
    #include "remindersrvgprot.h"
    #include "todolistsrvgprot.h"
}

#ifdef __MMI_VUI_COSMOS_CP__
#include "mmi_rp_app_cosmos_global_def.h"
#include "mmi_rp_srv_venus_component_menu_popup_def.h"
#include "mmi_rp_srv_venus_component_popup_def.h"
#endif //__MMI_VUI_COSMOS_CP__

#include "mmi_rp_vapp_calendar_def.h"
#include "mmi_rp_srv_reminder_def.h"


#include "vdat_systime.h"
#include "vfx_primitive_frame.h"
#include "vfx_animation.h"
#include "vfx_adp_device.h"
#include "vfx_renderer.h"

#include "vcp_button.h"
#include "vcp_bubble_effect.h"
#include "vcp_status_icon_bar.h"
#include "vcp_form.h" // include for vapp_screen_lock_gprot.h

#include "vapp_screen_lock_gprot.h"
#include "vapp_ncenter_gprot.h"

#include "vapp_wallpaper.h"
#include "vapp_wallpaper_setting_method_gprot.h"
#include "vapp_wallpaper_kit.h"
#include "vapp_platform_context.h"

#include "vapp_cal_prot.h"
#include "vapp_cal_reminder.h"
#include "vapp_cal_edit.h"
#include "vapp_cal_utility.h"

mmi_ret vapp_cal_reminder_notify_proc(mmi_event_struct *evt)
{
    srv_reminder_evt_struct *remdr_evt = NULL;
    
    if (evt->evt_id != EVT_ID_SRV_REMINDER_NOTIFY)
    {
        return MMI_RET_OK;
    }

    remdr_evt = (srv_reminder_evt_struct *)evt;

    MMI_TRACE(
        CALENDAR_TRC_GROUP, 
        VAPP_CAL_REMINDER_PROC,
        remdr_evt->notify,
        remdr_evt->pwr_off,
        remdr_evt->reminder_type,
        remdr_evt->usr_data);

    switch(remdr_evt->notify)
    {
        case SRV_REMINDER_NOTIFY_INIT:
            break;
        case SRV_REMINDER_NOTIFY_EXPIRY:
            VappCalReminderApp::expiriyHandler(remdr_evt);
            break;
        case SRV_REMINDER_NOTIFY_REINIT:
            // reinit the alarm when phone date time is changed 
            VappCalReminderApp::reinitReminder(remdr_evt);
            break;
        case SRV_REMINDER_NOTIFY_DEINIT:
            break;
        default:
            break;
    }
    
    return MMI_RET_OK;
}


mmi_ret vapp_cal_event_reminder_set_proc(mmi_event_struct *evt)
{
    if (evt->evt_id != EVT_ID_SRV_TDL_EVENT_OP)
    {
        return MMI_RET_OK;
    }
    VAPP_CAL_REMINDER_ENUM alarm_type;

    srv_tdl_event_op_struct  *event = (srv_tdl_event_op_struct *)evt;
    srv_tdl_event_struct *pevent;
    VFX_SYS_ALLOC_MEM(pevent, sizeof(srv_tdl_event_struct));
    VFX_ASSERT(pevent);

    srv_tdl_event_get(
                pevent, 
                sizeof(srv_tdl_event_struct), 
                (srv_tdl_event_source_enum)event->source_id, 
                event->event_id);  
    
    alarm_type = (VAPP_CAL_REMINDER_ENUM)pevent->alarm.type;

    switch(event->op_type)
    {       
        case SRV_TDL_OP_UPDATE:     
#ifdef __MMI_SNS_CALENDAR__
            if ((srv_tdl_event_source_enum)event->source_id == SRV_TDL_EVENT_SOURCE_LOCAL)
            {
                srv_reminder_cancel(SRV_REMINDER_TYPE_CAL, event->event_id);
            }
            else
            {

                srv_reminder_cancel(SRV_REMINDER_TYPE_SNS, event->event_id);
            }
#else
            srv_reminder_cancel(SRV_REMINDER_TYPE_CAL, event->event_id);
#endif  /*__MMI_SNS_CALENDAR__*/

        case SRV_TDL_OP_ADD://case:SRV_TDL_OP_UPDATE
            if(alarm_type > VAPP_CAL_REMINDER_NEVER)
            {
                VappCalReminderApp::setReminder(SRV_TDL_VCAL_EVENT, (void*)pevent, event->event_id);
            }
            break;
            
        case SRV_TDL_OP_DELETE:            
             srv_reminder_cancel(SRV_REMINDER_TYPE_CAL, event->event_id);
            break;
        default:
            break;
    }

    VFX_FREE_MEM(pevent);
    return MMI_RET_OK;


}


#if defined(__MMI_TASK_APP__)
mmi_ret vapp_cal_reminder_set_proc(mmi_event_struct *evt)
{
    srv_tdl_op_evt_struct *op_evt = NULL;
    srv_tdl_event_struct *pevent = NULL;
    srv_tdl_task_struct *ptask = NULL;
    void *data;
    VAPP_CAL_REMINDER_ENUM alarm_type;
    
    if (evt->evt_id != EVT_ID_SRV_TDL_OP)
    {
        return MMI_RET_OK;
    }
    
    op_evt = (srv_tdl_op_evt_struct *)evt;

    if (SRV_TDL_VCAL_EVENT == op_evt->vcal_type)
    {
        VFX_SYS_ALLOC_MEM(pevent, sizeof(srv_tdl_event_struct));
        VFX_ASSERT(pevent);

        srv_tdl_get(
                pevent, 
                sizeof(srv_tdl_event_struct), 
                SRV_TDL_VCAL_EVENT, 
                op_evt->store_idx);  
        
        alarm_type = (VAPP_CAL_REMINDER_ENUM)pevent->alarm.type;
        data = (void*)pevent;
    }
    
    else if (SRV_TDL_VCAL_TASK == op_evt->vcal_type)
    {     
        VFX_SYS_ALLOC_MEM(ptask, sizeof(srv_tdl_task_struct));
        VFX_ASSERT(ptask);

        srv_tdl_get(
                ptask, 
                sizeof(srv_tdl_task_struct), 
                SRV_TDL_VCAL_TASK, 
                op_evt->store_idx); 
         
         alarm_type = (VAPP_CAL_REMINDER_ENUM)ptask->alarm.type;
         data = (void*)ptask;
    }
    else
    {
        return MMI_RET_OK;
    }

    MMI_TRACE(
            CALENDAR_TRC_GROUP, 
            VAPP_CAL_SET_REMINDER_TIME, 
            op_evt->op_type, 
            op_evt->vcal_type, 
            alarm_type,
            op_evt->store_idx);

    switch(op_evt->op_type)
    {
        case SRV_TDL_OP_ADD:
            if(alarm_type > VAPP_CAL_REMINDER_NEVER)
            {
                VappCalReminderApp::setReminder(op_evt->vcal_type, data, op_evt->store_idx);
            }
            break;
            
        case SRV_TDL_OP_UPDATE:        
            if (SRV_TDL_VCAL_EVENT == op_evt->vcal_type)
            {
                srv_reminder_cancel(SRV_REMINDER_TYPE_CAL, op_evt->store_idx);
            }           
            else
            {
                srv_reminder_cancel(SRV_REMINDER_TYPE_TASK, op_evt->store_idx);
            }

            if(alarm_type > VAPP_CAL_REMINDER_NEVER)
            {
                VappCalReminderApp::setReminder(op_evt->vcal_type, data, op_evt->store_idx);
            }
            break;
            
        case SRV_TDL_OP_DELETE:   
            if (SRV_TDL_VCAL_EVENT == op_evt->vcal_type)
            {
                srv_reminder_cancel(SRV_REMINDER_TYPE_CAL, op_evt->store_idx);
            }
            
            else
            {
                srv_reminder_cancel(SRV_REMINDER_TYPE_TASK, op_evt->store_idx);
            }
            break;
            
        default:
            break;
    }

    VFX_FREE_MEM(data);
    return MMI_RET_OK;

    
}
#endif /*__MMI_TASK_APP__ */

mmi_ret vapp_cal_reminder_backlight_proc(mmi_event_struct *evt)
{
    // prevent the backlight turn off
    if (evt->evt_id == EVT_ID_GPIO_BACKLIGHT_DIMMING || evt->evt_id == EVT_ID_GPIO_BEFORE_LCD_SLEEP_IN)
    {
        if (!mmi_frm_is_scenario_started(MMI_SCENARIO_ID_IN_CALL))
        {
            return MMI_RET_ERR;
        }        
    }
    
    return MMI_RET_OK;
    
}


#ifndef __LOW_COST_SUPPORT_COMMON__
// close screen guard
void vapp_cal_reminder_screen_lock_close()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    VfxApp *app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = VfxAppLauncher::findApp(
            VAPP_CALENDAR_REMINDER,
            VFX_OBJ_CLASS_INFO(VappCalReminderApp),
            VFX_APP_LAUNACHER_FIND_APP_NORMAL_FLAG|VFX_APP_LAUNACHER_FIND_APP_BG_FLAG);
    if(app)
    {
        //VappCalReminderCardScreen *screen = app->getScreen();
        VappCalReminderCardScreen *screen = VFX_OBJ_DYNAMIC_CAST(app->getScreen(app->getTopScreenId()), VappCalReminderCardScreen);
        if(screen)
        {
            screen->onTimeOut(NULL);
        }
        //VfxAppLauncher::terminate(app->getGroupId());
    }
}
#endif

/***************************************************************************** 
 * Class  VappCalReminderApp
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappCalReminderApp", VappCalReminderApp, VfxApp);
void VappCalReminderApp::onRun(void * args, VfxU32 argSize)
{
    VfxApp::onRun(args, argSize);

    mmi_frm_start_scenario(MMI_SCENARIO_ID_REMINDER_OTHER);
    // avoid sound and vibration are closed by touch screen
    mmi_frm_nmgr_block_sound_vib_stop(MMI_FRM_NMGR_SOUND | MMI_FRM_NMGR_VIB);

    mmi_frm_cb_reg_event(EVT_ID_GPIO_BACKLIGHT_DIMMING, vapp_cal_reminder_backlight_proc, NULL);
    mmi_frm_cb_reg_event(EVT_ID_GPIO_BEFORE_LCD_SLEEP_IN, vapp_cal_reminder_backlight_proc, NULL);

    VappCalRemInfoStruct *info = (VappCalRemInfoStruct *)args;

#ifndef __LOW_COST_SUPPORT_COMMON__ 
    if (!vapp_screen_lock_is_exist())// should replace this api by vapp_screen_lock_is_exist() from 11.08
    {
        // create and display main screen
        VappCalReminderScreen *scr;
        VFX_OBJ_CREATE_EX(scr, VappCalReminderScreen, this, (info));
        scr->show();
    }
    else
    {
        VappCalReminderCardScreen *scr;

        VFX_OBJ_CREATE_EX(scr, VappCalReminderCardScreen, this, (info));

        scr->show();
    }
    #else 
    VappCalReminderScreen *scr;
    VFX_OBJ_CREATE_EX(scr, VappCalReminderScreen, this, (info));
    scr->show();
#endif 
}

void VappCalReminderApp::onDeinit()
{
    mmi_frm_nmgr_unblock_sound_vid_stop(MMI_FRM_NMGR_SOUND | MMI_FRM_NMGR_VIB);
    mmi_frm_end_scenario(MMI_SCENARIO_ID_REMINDER_OTHER);
    mmi_frm_nmgr_control_end(); 

    mmi_frm_cb_dereg_event(EVT_ID_GPIO_BACKLIGHT_DIMMING, vapp_cal_reminder_backlight_proc, NULL);
    mmi_frm_cb_dereg_event(EVT_ID_GPIO_BEFORE_LCD_SLEEP_IN, vapp_cal_reminder_backlight_proc, NULL);

    srv_reminder_notify_finish(MMI_FALSE);  

    VfxApp::onDeinit();
}

	
void VappCalReminderApp::reinitReminder(srv_reminder_evt_struct *remdr_evt)
{

    
    srv_tdl_event_struct *pevent = NULL;
    VFX_SYS_ALLOC_MEM(pevent, sizeof(srv_tdl_event_struct));
    VFX_ASSERT(pevent);

    for (VfxU32 i = 0; i < VAPP_CAL_MAX_COUNT; i++)
    {
        srv_tdl_get(
                pevent, 
                sizeof(srv_tdl_event_struct), 
                SRV_TDL_VCAL_EVENT, 
                i); 

        if (pevent->present && pevent->alarm.type != VAPP_CAL_REMINDER_NEVER)
        {
            if (pevent->repeat.rule == SRV_TDL_RULE_ONCE)
            {             
                if (!VappCalEditPage::checkreminderValidation(
                                                        pevent, 
                                                        SRV_TDL_VCAL_EVENT, 
                                                        (VAPP_CAL_REMINDER_ENUM)pevent->alarm.type))
                {
                    memset(&(pevent->alarm), 0, sizeof(srv_tdl_alarm_struct));
                } 
            }

            pevent->alarm.snooze = 0;
            srv_tdl_event_update(pevent,SRV_TDL_EVENT_SOURCE_LOCAL,i);//(pevent, SRV_TDL_VCAL_EVENT, i);
        }
    }
    VFX_FREE_MEM(pevent);

#ifdef __MMI_TASK_APP__

    {
        srv_tdl_task_struct *ptask = NULL;
        VFX_SYS_ALLOC_MEM(ptask, sizeof(srv_tdl_task_struct));
        VFX_ASSERT(ptask);

        for (VfxU32 i = 0; i < VAPP_TASK_MAX_COUNT; i++)
        {
            srv_tdl_get(
                    ptask, 
                    sizeof(srv_tdl_task_struct), 
                    SRV_TDL_VCAL_TASK, 
                    i); 

            if (ptask->present && ptask->alarm.type != VAPP_CAL_REMINDER_NEVER)
            {
                if (!VappCalEditPage::checkreminderValidation(
                                                    ptask, 
                                                    SRV_TDL_VCAL_TASK, 
                                                    (VAPP_CAL_REMINDER_ENUM)ptask->alarm.type))
                {
                    memset(&(ptask->alarm), 0, sizeof(srv_tdl_alarm_struct));
                }

                ptask->alarm.snooze = 0;
                srv_tdl_update(ptask, SRV_TDL_VCAL_TASK, i);
            }
        }
        VFX_FREE_MEM(ptask);
    }
#endif
}

void VappCalReminderApp::expiriyHandler(srv_reminder_evt_struct *remdr_evt)
{
    srv_tdl_event_source_enum source_Id = SRV_TDL_EVENT_SOURCE_LOCAL;

    if ((remdr_evt->reminder_type == SRV_REMINDER_TYPE_CAL)||(remdr_evt->reminder_type == SRV_REMINDER_TYPE_SNS))
    {
        applib_time_struct currTime;
        applib_dt_get_date_time(&currTime);

        srv_tdl_event_struct *pevent = NULL;
        VFX_SYS_ALLOC_MEM(pevent, sizeof(srv_tdl_event_struct));
        VFX_ASSERT(pevent);

#ifdef __MMI_SNS_CALENDAR__
        if (remdr_evt->reminder_type == SRV_REMINDER_TYPE_SNS)
        {
           srv_tdl_get_sns_reminder_source(remdr_evt->usr_data,&source_Id);
           //source_Id = SRV_TDL_EVENT_SOURCE_FACEBOOK; 
        }       
#endif
        srv_tdl_event_get(
                    pevent, 
                    sizeof(srv_tdl_event_struct), 
                    source_Id, 
                    (U32)remdr_evt->usr_data);  

        if (pevent->start_time.nMonth == 2 && pevent->start_time.nDay == 29)
        {
            if ((pevent->repeat.rule == SRV_TDL_RULE_YEARLY && !applib_dt_is_leap_year(currTime.nYear)) 
                || (pevent->repeat.rule == SRV_TDL_RULE_MONTHLY && !applib_dt_is_leap_year(currTime.nYear)
                && currTime.nMonth == 2))
            {
                VFX_FREE_MEM(pevent);
                return;
            }
        }

        VFX_FREE_MEM(pevent);
    } 

    VappCalRemInfoStruct *reminderInfo;
    VFX_SYS_ALLOC_MEM(reminderInfo, sizeof(VappCalRemInfoStruct));
    VFX_ASSERT(reminderInfo);

    if (remdr_evt->reminder_type == SRV_REMINDER_TYPE_CAL)
    {
        reminderInfo->type = SRV_TDL_VCAL_EVENT;
        reminderInfo->source_Id = SRV_TDL_EVENT_SOURCE_LOCAL;
        reminderInfo->event_Id = remdr_evt->usr_data;
    }  
#ifdef __MMI_TASK_APP__
    else if (remdr_evt->reminder_type == SRV_REMINDER_TYPE_TASK)
    {
        reminderInfo->type = SRV_TDL_VCAL_TASK;
        reminderInfo->event_Id = remdr_evt->usr_data;

    }
#endif
#ifdef __MMI_SNS_CALENDAR__
    else if (remdr_evt->reminder_type == SRV_REMINDER_TYPE_SNS)
    {

        reminderInfo->type = SRV_TDL_VCAL_EVENT;
        reminderInfo->source_Id = source_Id;
        reminderInfo->event_Id = remdr_evt->usr_data;
    }
#endif
    else
    {
        VFX_FREE_MEM(reminderInfo);     
        return;
    }


    mmi_frm_nmgr_notify_by_app(MMI_SCENARIO_ID_REMINDER_OTHER,
                            MMI_EVENT_REMINDER_OTHER,
                            VappCalReminderApp::showReminder,
                            reminderInfo);
}


MMI_BOOL VappCalReminderApp::showReminder(mmi_scenario_id scen_id, void *arg)
{
    VFX_ASSERT(scen_id == MMI_SCENARIO_ID_REMINDER_OTHER);
    VFX_ASSERT(arg != NULL);

    VfxContext *cntx = VFX_OBJ_GET_INSTANCE(VappPlatformContext);

    VfxAppLauncher::launchWithCtx(
        VAPP_CALENDAR_REMINDER,
        VFX_OBJ_CLASS_INFO(VappCalReminderApp),
        GRP_ID_ROOT,
        cntx,
        arg,
        sizeof(VappCalRemInfoStruct));

    VFX_FREE_MEM(arg);

    return MMI_TRUE;
}

void VappCalReminderApp::setReminder(
                            const srv_tdl_vcal_enum vcal_type, 
                            const void *data,
                            const U32 index)
{
    srv_tdl_event_struct *pevent = NULL;
    
    MYTIME incTime, currTime, first_launch;
    MYTIME expiryTime;
    srv_reminder_type reminder_type = SRV_REMINDER_TYPE_TOTAL;
    U16 snooze = 0;
    VAPP_CAL_REPEAT_ENUM repeat = VAPP_CAL_REPEAT_NEVER;
    srv_reminder_repeat_enum new_freq;
    U8 dows = 0;

    if (SRV_TDL_VCAL_EVENT == vcal_type)
    {
        pevent = (srv_tdl_event_struct*)data;
        snooze = pevent->alarm.snooze;
        reminder_type = SRV_REMINDER_TYPE_CAL;
        repeat = (VAPP_CAL_REPEAT_ENUM)pevent->repeat.rule;
        dows = pevent->repeat.dows;

        first_launch = pevent->alarm.first_launch;
    }
#ifdef __MMI_TASK_APP__
    else
    {
    
        srv_tdl_task_struct *ptask = NULL;
        ptask = (srv_tdl_task_struct*)data;
        snooze = ptask->alarm.snooze;
        reminder_type = SRV_REMINDER_TYPE_TASK;
        repeat = (VAPP_CAL_REPEAT_ENUM)ptask->repeat.rule;
        dows = ptask->repeat.dows;

        first_launch = ptask->alarm.first_launch;
    }
#endif

    if (snooze)
    {
        DTGetRTCTime(&currTime);
        currTime.nSec = 0;
        memset(&incTime, 0, sizeof(MYTIME));
        incTime.nMin = VAPP_CAL_REMINDER_INTERVAL;
        IncrementTime(currTime, incTime, &expiryTime);
    }
    else
    {
        new_freq = conv2ReminderRepeatRule(repeat);        
        expiryTime = srv_reminder_calc_time(&first_launch, new_freq, dows);
    }

    if (SRV_TDL_VCAL_EVENT == vcal_type)
    {
#ifdef __MMI_SNS_CALENDAR__
        if (pevent->src_id != SRV_TDL_EVENT_SOURCE_LOCAL)
        {
            reminder_type = SRV_REMINDER_TYPE_SNS;
        }
#endif
        srv_reminder_set(reminder_type, &expiryTime, index);
    }
    
#ifdef __MMI_TASK_APP__
    else
    {
        srv_reminder_set_with_callback(reminder_type, &expiryTime, NULL, VappCalReminderApp::reminderCompare, index);
    }
    #endif
}

#ifdef __MMI_TASK_APP__
S32 VappCalReminderApp::reminderCompare(U32 exist, U32 curr)
{
    // only for task to swap the priority 
    srv_tdl_task_struct *ptask = NULL;
    VFX_SYS_ALLOC_MEM(ptask, sizeof(srv_tdl_task_struct));
    VFX_ASSERT(ptask);

    srv_tdl_get(
            ptask, 
            sizeof(srv_tdl_task_struct), 
            SRV_TDL_VCAL_TASK, 
            exist); 

    VfxU8 existPiority = ptask->priority;

    srv_tdl_get(
            ptask, 
            sizeof(srv_tdl_task_struct), 
            SRV_TDL_VCAL_TASK, 
            curr); 
        
    VfxU8 currPiority = ptask->priority;

    S32 value;
    if (currPiority > existPiority)
    {
        value = 1;
    }
    else
    {
        value = -1;
    }

    VFX_FREE_MEM(ptask);

    return value;
}
#endif   /*__MMI_TASK_APP__*/

srv_reminder_repeat_enum VappCalReminderApp::conv2ReminderRepeatRule(VAPP_CAL_REPEAT_ENUM repeat)
{
    srv_reminder_repeat_enum new_repeat = SRV_REMINDER_REPEAT_ONCE;
    
    switch(repeat)
    {
        case VAPP_CAL_REPEAT_NEVER:
            new_repeat = SRV_REMINDER_REPEAT_ONCE;
            break;
        case VAPP_CAL_REPEAT_DAILY:
            new_repeat = SRV_REMINDER_REPEAT_EVERYDAY;
            break;
        case VAPP_CAL_REPEAT_WEEKDAY:
            new_repeat = SRV_REMINDER_REPEAT_DAYS;
            break;
        case VAPP_CAL_REPEAT_WEEKLY:
            new_repeat = SRV_REMINDER_REPEAT_WEEKLY;
            break;
        case VAPP_CAL_REPEAT_MONTHLY:
            new_repeat = SRV_REMINDER_REPEAT_MONTHLY;
            break;
        case VAPP_CAL_REPEAT_YEARLY:
            new_repeat = SRV_REMINDER_REPEAT_YEARLY;
            break;
        default:
            break;
    }
    return new_repeat;
}


VfxBool VappCalReminderApp::needPwrOff(void)
{
    srv_bootup_mode_enum mode = srv_bootup_get_booting_mode();


    if (mode == SRV_BOOTUP_MODE_NORMAL)
    {
        return VFX_FALSE;
    }

#ifdef __MMI_USB_SUPPORT__
    if (mode == SRV_BOOTUP_MODE_USB && srv_usb_is_connected())
    {
        return VFX_FALSE;
    }
#endif

    if (srv_charbat_is_charger_connect() &&
        ((mode == SRV_BOOTUP_MODE_CHARGE) || 
        (mode == SRV_BOOTUP_MODE_PRECHARGE)))
    {
        return VFX_FALSE;
    }

    return VFX_TRUE;
}


/***************************************************************************** 
 * Class  VappCalReminderScreen
 *****************************************************************************/
void VappCalReminderScreen::onInit(void)
{
    MMI_TRACE(CALENDAR_TRC_GROUP, VAPP_CAL_SHOW_REMINDER_POPUP);

    VfxAppScr::onInit();

    // on unlock screen

    VFX_OBJ_CREATE_EX(m_popup, VappCalReminderPopup, this, (m_type, m_eventId,m_sourceId));


    m_popup->setAutoDestory(VFX_TRUE);
    m_popup->m_signalPopupLeave.connect(this, &VappCalReminderScreen::popupLeave);

    m_statusBar = NULL;
    if (srv_bootup_get_booting_mode() == SRV_BOOTUP_MODE_NORMAL)
    {
        VFX_OBJ_CREATE(m_statusBar, VcpStatusIconBar, this);
        m_statusBar->setAutoAnimate(VFX_TRUE);
        m_statusBar->setSize(getSize().width, MMI_STATUS_BAR_HEIGHT);
        m_statusBar->setPos(0, 0);
    }
}

void VappCalReminderScreen::onEnter(VfxBool isBackward)
{
    VfxAppScr::onEnter(isBackward);

    if (m_statusBar != NULL)
    {
        m_statusBar->setSize(getSize().width, MMI_STATUS_BAR_HEIGHT);
    }

    m_popup->show(VFX_TRUE);
}

void VappCalReminderScreen::onRotate(const VfxScreenRotateParam & param)
{
    VfxAppScr::onRotate(param);

    if (m_statusBar != NULL)
    {
        m_statusBar->setSize(getSize().width, MMI_STATUS_BAR_HEIGHT);
    }
}

void VappCalReminderScreen::popupLeave(VfxObject* sender, VfxId)
{
    exit();
}

void VappCalReminderScreen::onQueryRotateEx(VfxScreenRotateParam &param)
{
    VfxRenderer *render = VFX_OBJ_GET_INSTANCE(VfxRenderer);

    param.rotateTo = render->getPreScreenRotateType();
}



/***************************************************************************** 
 * Class  VappCalReminderPopup
 *****************************************************************************/
VappCalReminderPopup::VappCalReminderPopup()
    : m_type(SRV_TDL_VCAL_EVENT),
        m_lskBtn(NULL),
        m_rskBtn(NULL),
        m_oldAlmType(0),
        m_snoozeValue(0)
{
}
VappCalReminderPopup::VappCalReminderPopup(srv_tdl_vcal_enum type, VfxU32 idx, srv_tdl_event_source_enum sourceId) 
    : m_type(type),
        m_eventId(idx),
        m_sourceId(sourceId),
        m_lskBtn(NULL),
        m_rskBtn(NULL),
        m_oldAlmType(0),
        m_snoozeValue(0)
{
}

void VappCalReminderPopup::onInit()
{
    VfxBasePopup::onInit();

    setAutoAnimate(VFX_TRUE);

    // title background
    VfxFrame *titleBg;
    VFX_OBJ_CREATE(titleBg, VfxFrame, this); 
    //titleBg->setAnchor()
    titleBg->setImgContent(VfxImageSrc(VCP_IMG_POPUP_BACKGROUND));
    titleBg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    titleBg->setPos(0, 0);


    VfxFrame *bodyBg;
    VFX_OBJ_CREATE(bodyBg, VfxFrame, this);
    bodyBg->setImgContent(VfxImageSrc(VCP_IMG_POPUP_MORE_BACKGROUND_BOTTOM));
    bodyBg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    bodyBg->setPos(0, VAPP_CAL_REMINDER_POPUP_TITLE_HEIGHT);	

    VappCalReminderContent *contentFrame;
    VFX_OBJ_CREATE_EX(contentFrame, VappCalReminderContent, bodyBg, (m_type, m_eventId,m_sourceId));
    contentFrame->setAnchor(0.5f, 0.5f);

    VfxU16 height = 2*VAPP_CAL_REMINDER_POPUP_STRNG_GAP + 
                contentFrame->getSize().height + 
                2*VAPP_CAL_REMINDER_POPUP_STRNG_GAP;

    VcpButton *lefBtn;
    VFX_OBJ_CREATE(lefBtn, VcpButton, bodyBg);
    VfxU16 buttonH = lefBtn->getSize().height;
    lefBtn->setId(VAPP_CAL_REMINDER_SNOOZE);
    lefBtn->setText((VfxResId)STR_ID_VAPP_CAL_SNOOZE);
    lefBtn->setTextColor(VfxColorResHelper(CLR_COSMOS_TEXT_MAIN));
    lefBtn->setPos(VAPP_CAL_REMINDER_POPUP_BUTTON_MARGIN, height);
    lefBtn->setSize(
                VAPP_CAL_REMINDER_POPUP_BUTTON_WIDTH, 
                buttonH);
    lefBtn->m_signalClicked.connect(this, &VappCalReminderPopup::onButtonClick);
    m_lskBtn = lefBtn;

    VcpButton *rightBtn;
    VFX_OBJ_CREATE(rightBtn, VcpButton, bodyBg);
    rightBtn->setAnchor(0, 0);
    rightBtn->setId(VAPP_CAL_REMINDER_DISMISS);
    rightBtn->setText((VfxResId)STR_ID_VAPP_CAL_DIMISS);
    rightBtn->setTextColor(VfxColorResHelper(CLR_COSMOS_TEXT_MAIN));
    rightBtn->setPos(
                VAPP_CAL_REMINDER_POPUP_BUTTON_MARGIN + VAPP_CAL_REMINDER_POPUP_BUTTON_MID_MARGIN + VAPP_CAL_REMINDER_POPUP_BUTTON_WIDTH, 
                height);
    rightBtn->setSize(
                VAPP_CAL_REMINDER_POPUP_BUTTON_WIDTH, 
                buttonH);
    rightBtn->m_signalClicked.connect(this, &VappCalReminderPopup::onButtonClick);	
    m_rskBtn = rightBtn;

    contentFrame->setPos(VAPP_CAL_REMINDER_POPUP_WIDTH / 2, height / 2);

    height += buttonH + VAPP_CAL_REMINDER_POPUP_STRNG_GAP;
    height += VAPP_CAL_REMINDER_POPUP_BOTTOM_SHADOW;

    bodyBg->setSize(VAPP_CAL_REMINDER_POPUP_WIDTH, height);

    setSize(VAPP_CAL_REMINDER_POPUP_WIDTH, height + VAPP_CAL_REMINDER_POPUP_TITLE_HEIGHT);	

    titleBg->setSize(VAPP_CAL_REMINDER_POPUP_WIDTH, 
                     height + VAPP_CAL_REMINDER_POPUP_TITLE_HEIGHT);


    // set a timer about 30s
    VfxTimer *timer;
    VFX_OBJ_CREATE(timer, VfxTimer, this);
    timer->setStartDelay(VAPP_CAL_REMINDER_NOTI_TIME);
    timer->m_signalTick.connect(this, &VappCalReminderPopup::onTimeOut);
    timer->start();

    adjustAlmType();

    checkUpdate();
}

void VappCalReminderPopup::onUpdate(void)
{
    if (m_snoozeValue >= VAPP_CAL_REMINDER_SNOOZE_COUNT)
    {
        VfxS32 width = m_lskBtn->getSize().width +
        VAPP_CAL_REMINDER_POPUP_BUTTON_MID_MARGIN +
        m_rskBtn->getSize().width;

        m_rskBtn->setPos(m_lskBtn->getPos());
        m_rskBtn->setSize(width, m_rskBtn->getSize().height);

        m_lskBtn->setHidden(VFX_TRUE);
    }
}

VfxBool VappCalReminderPopup::onKeyInput(VfxKeyEvent &event)
{
    if (event.keyCode == VFX_KEY_CODE_BACK && event.type == VFX_KEY_EVENT_TYPE_DOWN)	
    {
        onButtonClick(NULL, VAPP_CAL_REMINDER_SNOOZE);
        return VFX_TRUE;
    }
    else if (event.keyCode == VFX_KEY_CODE_HOME && 	event.type == VFX_KEY_EVENT_TYPE_DOWN)	
    {
        return VFX_TRUE;
    }
    // don't response on VOL KEY
    else if (event.keyCode == VFX_KEY_CODE_VOL_UP || event.keyCode == VFX_KEY_CODE_VOL_DOWN)
    {
        return VFX_TRUE;
    }
    // below code is from is_mmi_power_off_key_evt()	
    if (event.type == VFX_KEY_EVENT_TYPE_LONG_PRESS)
    {

        if (event.keyCode == VFX_KEY_CODE_END)
        {
            if(!mmi_frm_kbd_is_key_supported(VFX_KEY_CODE_POWER))  
            {
                onButtonClick(NULL, VAPP_CAL_REMINDER_SNOOZE);
            }
        }
        else if (event.keyCode  == VFX_KEY_CODE_POWER)
        {
            onButtonClick(NULL, VAPP_CAL_REMINDER_SNOOZE);
        }

    }
    
    return VfxBasePopup::onKeyInput(event);
}

void VappCalReminderPopup::onButtonClick(VfxObject *sender, VfxId id)
{
    if (id == VAPP_CAL_REMINDER_SNOOZE)
    {
        postponeReminder();
    }
    else
    {
        stopReminder();
    }

    leave(VFX_TRUE);
    m_signalPopupLeave.postEmit(this, id);
}


void VappCalReminderPopup::onTimeOut(VfxTimer *obj)
{
    VfxId btnId = (m_snoozeValue >= VAPP_CAL_REMINDER_SNOOZE_COUNT) ? VAPP_CAL_REMINDER_DISMISS : VAPP_CAL_REMINDER_SNOOZE;

    onButtonClick(NULL, btnId);
}

void VappCalReminderPopup::adjustAlmType()
{
    if (m_type == SRV_TDL_VCAL_EVENT)
    {
        srv_tdl_event_struct *pEvent = NULL;
        VFX_SYS_ALLOC_MEM(pEvent, sizeof(srv_tdl_event_struct));
        VFX_ASSERT(pEvent);
        srv_tdl_event_get(
                pEvent, 
                sizeof(srv_tdl_event_struct), 
                m_sourceId, 
                m_eventId);


        m_oldAlmType = pEvent->alarm.type;
        m_snoozeValue = pEvent->alarm.snooze;

        if (pEvent->present && pEvent->alarm.type != VAPP_CAL_REMINDER_NEVER)
        {
            if (pEvent->repeat.rule == SRV_TDL_RULE_ONCE)
            {             
                if (!VappCalEditPage::checkreminderValidation(
                                                    pEvent, 
                                                    SRV_TDL_VCAL_EVENT, 
                                                    (VAPP_CAL_REMINDER_ENUM)pEvent->alarm.type))
                {
                    pEvent->alarm.type = 0;
                    srv_tdl_event_update(pEvent, m_sourceId, m_eventId);
                }
            }
        }

        VFX_FREE_MEM(pEvent);
    }
    
#ifdef __MMI_TASK_APP__
    else if(m_type == SRV_TDL_VCAL_TASK)
    {
        srv_tdl_task_struct *pTask = NULL;
        VFX_SYS_ALLOC_MEM(pTask, sizeof(srv_tdl_task_struct));
        VFX_ASSERT(pTask);

        srv_tdl_get(
                pTask, 
                sizeof(srv_tdl_task_struct), 
                SRV_TDL_VCAL_TASK, 
                m_eventId); 

        m_oldAlmType = pTask->alarm.type;
        m_snoozeValue = pTask->alarm.snooze;

        if (pTask->present && pTask->alarm.type != VAPP_CAL_REMINDER_NEVER)
        {
            if (pTask->repeat.rule == SRV_TDL_RULE_ONCE)
            {             
                if (!VappCalEditPage::checkreminderValidation(
                                                    pTask, 
                                                    SRV_TDL_VCAL_TASK, 
                                                    (VAPP_CAL_REMINDER_ENUM)pTask->alarm.type))
                {
                    pTask->alarm.type = 0;
                    srv_tdl_update(pTask, SRV_TDL_VCAL_TASK, m_eventId);
                }
            }
        }

        VFX_FREE_MEM(pTask);
    }
#endif
}

void VappCalReminderPopup::postponeReminder()
{
    if (m_type == SRV_TDL_VCAL_EVENT)
    {
        srv_tdl_event_struct *pevent = NULL;
        VFX_SYS_ALLOC_MEM(pevent, sizeof(srv_tdl_event_struct));
        VFX_ASSERT(pevent);

        srv_tdl_event_get(
                pevent, 
                sizeof(srv_tdl_event_struct), 
                m_sourceId, 
                m_eventId);	

        pevent->alarm.snooze++;

        if (pevent->alarm.snooze <= VAPP_CAL_REMINDER_SNOOZE_COUNT)
        {
            if (!VappCalReminderApp::needPwrOff())
            {
                mmi_frm_nmgr_balloon(
                            MMI_SCENARIO_ID_GENERAL,
                            MMI_EVENT_INFO_BALLOON,
                            MMI_NMGR_BALLOON_TYPE_INFO,
                            (WCHAR*)GetString(STR_ID_VAPP_CAL_SNOOZE_4MIN));
            }
            if (pevent->repeat.rule == SRV_TDL_RULE_ONCE)
            {
                pevent->alarm.type = m_oldAlmType;
            }

            srv_tdl_event_update(pevent, m_sourceId, m_eventId);
        }
        else
        {
            stopReminder();
        }

        VFX_FREE_MEM(pevent);
    }
    
#ifdef __MMI_TASK_APP__
    else
    {
        srv_tdl_task_struct *ptask = NULL;
        VFX_ALLOC_MEM(ptask, sizeof(srv_tdl_task_struct), this);
        VFX_ASSERT(ptask);

        srv_tdl_get(
            ptask, 
            sizeof(srv_tdl_task_struct), 
            SRV_TDL_VCAL_TASK,
            m_eventId);   

        ptask->alarm.snooze++;

        if (ptask->alarm.snooze <= VAPP_CAL_REMINDER_SNOOZE_COUNT)
        {
            mmi_frm_nmgr_balloon(
                    MMI_SCENARIO_ID_GENERAL,
                    MMI_EVENT_INFO_BALLOON,
                    MMI_NMGR_BALLOON_TYPE_INFO,
                    (WCHAR*)GetString(STR_ID_VAPP_CAL_SNOOZE_4MIN));
            if (ptask->repeat.rule == SRV_TDL_RULE_ONCE)
            {
                ptask->alarm.type = m_oldAlmType;
            }
            srv_tdl_update(ptask, SRV_TDL_VCAL_TASK, m_eventId);
        }
        else
        {
            stopReminder();
        }

        VFX_FREE_MEM(ptask);
    }
#endif
}



void VappCalReminderPopup::stopReminder()
{
    if (m_type == SRV_TDL_VCAL_EVENT)
    {
        srv_tdl_event_struct *pevent = NULL;
        VFX_ALLOC_MEM(pevent, sizeof(srv_tdl_event_struct), this);
        VFX_ASSERT(pevent);


        srv_tdl_event_get(
                    pevent, 
                    sizeof(srv_tdl_event_struct), 
                    m_sourceId, 
        m_eventId);


        pevent->alarm.snooze = 0;

        srv_tdl_event_update(pevent, m_sourceId, m_eventId);

        VFX_FREE_MEM(pevent);
    }
    
#ifdef __MMI_TASK_APP__
    else
    {
        srv_tdl_task_struct *ptask = NULL;
        VFX_ALLOC_MEM(ptask, sizeof(srv_tdl_task_struct), this);
        VFX_ASSERT(ptask);

        srv_tdl_get(
                ptask, 
                sizeof(srv_tdl_task_struct), 
                SRV_TDL_VCAL_TASK,
                m_eventId);   

        ptask->alarm.snooze = 0;

        srv_tdl_update(ptask, SRV_TDL_VCAL_TASK, m_eventId);

        VFX_FREE_MEM(ptask);
    }
    #endif
}

#ifndef __LOW_COST_SUPPORT_COMMON__
/***************************************************************************** 
 * Class  VappCalReminderCardScreen
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappCalReminderCardScreen", VappCalReminderCardScreen, VfxMainScr);
void VappCalReminderCardScreen::on1stReady()
{
    MMI_TRACE(CALENDAR_TRC_GROUP, VAPP_CAL_SHOW_REMINDER_CARD);

    VfxMainScr::on1stReady();

    // on lock screen
    VappCalReminderCardPage *cardPage;
    VFX_OBJ_CREATE(cardPage, VappCalReminderCardPage, this);
    cardPage->m_signalDrag.connect(this, &VappCalReminderCardScreen::ReminderCardPageLeave);

    VappCalReminderCard *card;
    VFX_OBJ_CREATE(card, VappCalReminderCard, cardPage);
    cardPage->addCard(card);

    pushPage(0, cardPage);

    // set a timer about 30s

    VfxTimer *timer;
    VFX_OBJ_CREATE(timer, VfxTimer, this);
    timer->setStartDelay(VAPP_CAL_REMINDER_NOTI_TIME);
    timer->m_signalTick.connect(this, &VappCalReminderCardScreen::onTimeOut);
    timer->start();
}

void VappCalReminderCardScreen::ReminderCardPageLeave(VfxObject* sender, VfxId id)
{
    exit();

    if (id == VAPP_CAL_REMINDER_SNOOZE)
    {
        postponeReminder();	
    }
    else if (id == VAPP_CAL_REMINDER_DISMISS)
    {
        stopReminder();
    }
}

void VappCalReminderCardScreen::stopReminder()
{
    if (m_type == SRV_TDL_VCAL_EVENT)
    {
        srv_tdl_event_struct *pevent = NULL;
        VFX_ALLOC_MEM(pevent, sizeof(srv_tdl_event_struct), this);
        VFX_ASSERT(pevent);

        VfxU32 eventId;

        srv_tdl_event_get(
                    pevent, 
                    sizeof(srv_tdl_event_struct), 
                    m_sourceId, 
                    m_eventId);
                    eventId = m_eventId;


        pevent->alarm.snooze = 0;

        srv_tdl_event_update(pevent, m_sourceId, eventId);

        VFX_FREE_MEM(pevent);
    }
    
#ifdef __MMI_TASK_APP__
    else
    {
        srv_tdl_task_struct *ptask = NULL;
        VFX_ALLOC_MEM(ptask, sizeof(srv_tdl_task_struct), this);
        VFX_ASSERT(ptask);

        srv_tdl_get(
                ptask, 
                sizeof(srv_tdl_task_struct), 
                SRV_TDL_VCAL_TASK,
                m_eventId);   

        ptask->alarm.snooze = 0;

        srv_tdl_update(ptask, SRV_TDL_VCAL_TASK, m_eventId);

        VFX_FREE_MEM(ptask);
    }
    #endif
}


void VappCalReminderCardScreen::postponeReminder()
{
    if (m_type == SRV_TDL_VCAL_EVENT)
    {
        srv_tdl_event_struct *pevent = NULL;
        VFX_SYS_ALLOC_MEM(pevent, sizeof(srv_tdl_event_struct));
        VFX_ASSERT(pevent);

        srv_tdl_event_get(
                    pevent, 
                    sizeof(srv_tdl_event_struct), 
                    m_sourceId, 
                    m_eventId);

        pevent->alarm.snooze++;

        if (pevent->alarm.snooze <= VAPP_CAL_REMINDER_SNOOZE_COUNT)
        {
            mmi_frm_nmgr_balloon(
                            MMI_SCENARIO_ID_GENERAL,
                            MMI_EVENT_INFO_BALLOON,
                            MMI_NMGR_BALLOON_TYPE_INFO,
                            (WCHAR*)GetString(STR_ID_VAPP_CAL_SNOOZE_4MIN));
            if (pevent->repeat.rule == SRV_TDL_RULE_ONCE)
            {
                pevent->alarm.type = m_oldAlmType;
            }


            srv_tdl_event_update(pevent, m_sourceId, m_eventId);
        }
        else
        {
            stopReminder();
        }

        VFX_FREE_MEM(pevent);
    }
    
#ifdef __MMI_TASK_APP__
    else
    {
        srv_tdl_task_struct *ptask = NULL;
        VFX_ALLOC_MEM(ptask, sizeof(srv_tdl_task_struct), this);
        VFX_ASSERT(ptask);

        srv_tdl_get(
                ptask, 
                sizeof(srv_tdl_task_struct), 
                SRV_TDL_VCAL_TASK,
                m_eventId);   

        ptask->alarm.snooze++;

        if (ptask->alarm.snooze <= VAPP_CAL_REMINDER_SNOOZE_COUNT)
        {
            mmi_frm_nmgr_balloon(
                    MMI_SCENARIO_ID_GENERAL,
                    MMI_EVENT_INFO_BALLOON,
                    MMI_NMGR_BALLOON_TYPE_INFO,
                    (WCHAR*)GetString(STR_ID_VAPP_CAL_SNOOZE_4MIN));
            if (ptask->repeat.rule == SRV_TDL_RULE_ONCE)
            {
                ptask->alarm.type = m_oldAlmType;
            }
            srv_tdl_update(ptask, SRV_TDL_VCAL_TASK, m_eventId);
        }
        else
        {
            stopReminder();
        }

        VFX_FREE_MEM(ptask);
    }
#endif
}

void VappCalReminderCardScreen::onTimeOut(VfxTimer *obj)
{
    if (m_snoozeValue >= VAPP_CAL_REMINDER_SNOOZE_COUNT)
    {
        ReminderCardPageLeave(obj, VAPP_CAL_REMINDER_DISMISS);
    }
    else
    {
        ReminderCardPageLeave(obj, VAPP_CAL_REMINDER_SNOOZE);
    }
}

void VappCalReminderCardScreen::adjustAlmType()
{
    if (m_type == SRV_TDL_VCAL_EVENT)
    {
        srv_tdl_event_struct *pEvent = NULL;
        VFX_SYS_ALLOC_MEM(pEvent, sizeof(srv_tdl_event_struct));
        VFX_ASSERT(pEvent);

        srv_tdl_event_get(
                    pEvent, 
                    sizeof(srv_tdl_event_struct), 
                    m_sourceId, 
                    m_eventId);


        m_oldAlmType = pEvent->alarm.type;
        m_snoozeValue = pEvent->alarm.snooze; 
        if (pEvent->present && pEvent->alarm.type != VAPP_CAL_REMINDER_NEVER)
        {
            if (pEvent->repeat.rule == SRV_TDL_RULE_ONCE)
            {             
                if (!VappCalEditPage::checkreminderValidation(
                                                    pEvent, 
                                                    SRV_TDL_VCAL_EVENT, 
                                                    (VAPP_CAL_REMINDER_ENUM)pEvent->alarm.type))
                {
                    pEvent->alarm.type = 0;
                    srv_tdl_event_update(pEvent, m_sourceId, m_eventId);
                }
            }
        }

        VFX_FREE_MEM(pEvent);
    }
    
#ifdef __MMI_TASK_APP__
    else if(m_type == SRV_TDL_VCAL_TASK)
    {
        srv_tdl_task_struct *pTask = NULL;
        VFX_SYS_ALLOC_MEM(pTask, sizeof(srv_tdl_task_struct));
        VFX_ASSERT(pTask);

        srv_tdl_get(
                pTask, 
                sizeof(srv_tdl_task_struct), 
                SRV_TDL_VCAL_TASK, 
                m_eventId); 

        m_oldAlmType = pTask->alarm.type;
        m_snoozeValue = pTask->alarm.snooze; 
        if (pTask->present && pTask->alarm.type != VAPP_CAL_REMINDER_NEVER)
        {
            if (pTask->repeat.rule == SRV_TDL_RULE_ONCE)
            {             
                if (!VappCalEditPage::checkreminderValidation(
                                                pTask, 
                                                SRV_TDL_VCAL_TASK, 
                                                (VAPP_CAL_REMINDER_ENUM)pTask->alarm.type))
                {
                    pTask->alarm.type = 0;
                    srv_tdl_update(pTask, SRV_TDL_VCAL_TASK, m_eventId);
                }
            }
        }

        VFX_FREE_MEM(pTask);
    }
    #endif
}

void VappCalReminderCardScreen::onDeinit()
{
    VfxMainScr::onDeinit();
}


/***************************************************************************** 
 * Class  VappCalReminderCardPage
 ******************************************************************************/
VFX_IMPLEMENT_CLASS("VappCalReminderCardPage", VappCalReminderCardPage, VfxPage);
VappCalReminderCardPage::VappCalReminderCardPage()
    : m_cardMoveTimeLine(NULL),
        m_bubbleEffectUp(NULL),
        m_bubbleEffectDown(NULL),
        m_wallpaper(NULL),
        m_card(NULL),
        m_isMoveUp(VFX_FALSE),
        m_isCardTaped(VFX_FALSE),
        m_upText(NULL),
        m_downText(NULL),
        m_upArrow(NULL),
        m_downArrow(NULL)
{
}

void VappCalReminderCardPage::onInit()
{
    VfxPage::onInit();

    VcpStatusIconBar *statusBar;
    VFX_OBJ_CREATE(statusBar, VcpStatusIconBar, this);
    VfxS32 h = statusBar->getSize().height;

    pageW = getSize().width;
    pageH = getSize().height - h;

    VFX_OBJ_CLOSE(statusBar);

    m_wallpaper = VappWallpaperKit::createWallpaper(this, VAPP_WALLPAPER_SRC_LOCK);

    // upShadowFrame
    // textDismiss<-upFrame
    VfxImageFrame *upFrame;
    VFX_OBJ_CREATE(upFrame, VfxImageFrame, this);
    upFrame->setResId(IMG_ID_VAPP_CAL_REMINDER_SHADOW_UP);
    upFrame->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    upFrame->setPos(0, 0);
    upFrame->setSize(pageW, VAPP_CAL_REMINDER_PAGE_SHADOW_H);

    VFX_OBJ_CREATE(m_upText, VfxTextFrame, upFrame);
    m_upText->setAnchor(0.5f, 0.5f);
    m_upText->setColor(VFX_COLOR_WHITE);
    m_upText->setString((VfxResId)STR_ID_VAPP_CAL_REMINDER_DISMISS);
    m_upText->setFont(VfxFontDesc(VAPP_CAL_REMINDER_UP_TEXT_FONT, VFX_FONT_DESC_ATTR_NORMAL, VFX_FE1_9));
    m_upText->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER_WITHIN_MARGIN);
    m_upText->setPos(upFrame->getSize().width / 2, VAPP_CAL_REMINDER_PAGE_SHADOW_H - VAPP_CAL_REMINDER_CARD_TEXT_Y_OFFSIZE);
    m_upText->setOpacity(1);

    VFX_OBJ_CREATE(m_upArrow, VfxImageFrame, upFrame);
    m_upArrow->setAnchor(0.5f, 1);
    m_upArrow->setResId(IMG_ID_VAPP_CAL_REMINDER_ARROW_UP);
    m_upArrow->setPos(upFrame->getSize().width / 2, VAPP_CAL_REMINDER_PAGE_SHADOW_H);
    m_upArrow->setOpacity(0);
    //m_upArrow->setSize(getSize().width, VAPP_CAL_REMINDER_PAGE_SHADOW_H);

    // downShadowFrame
    // textSnooze<-downFrame
    VfxImageFrame *downFrame;
    VFX_OBJ_CREATE(downFrame, VfxImageFrame, this);
    downFrame->setAnchor(0, 1);
    downFrame->setResId(IMG_ID_VAPP_CAL_REMINDER_SHADOW_DOWN);
    downFrame->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    downFrame->setSize(pageW, VAPP_CAL_REMINDER_PAGE_SHADOW_H);
    downFrame->setPos(0, pageH);

    VFX_OBJ_CREATE(m_downText, VfxTextFrame, downFrame);
    m_downText->setAnchor(0.5f,0.5f);
    m_downText->setColor(VFX_COLOR_WHITE);
    m_downText->setFont(VfxFontDesc(VAPP_CAL_REMINDER_UP_TEXT_FONT, VFX_FONT_DESC_ATTR_NORMAL, VFX_FE1_9));
    m_downText->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER_WITHIN_MARGIN);
    m_downText->setString((VfxResId)STR_ID_VAPP_CAL_REMINDER_SNOOZE);
    m_downText->setPos(downFrame->getSize().width / 2, VAPP_CAL_REMINDER_CARD_TEXT_Y_OFFSIZE);
    m_downText->setOpacity(1);

    VFX_OBJ_CREATE(m_downArrow, VfxImageFrame, downFrame);
    m_downArrow->setAnchor(0.5f, 0);
    m_downArrow->setResId(IMG_ID_VAPP_CAL_REMINDER_ARROW_DOWN);
    m_downArrow->setPos(downFrame->getSize().width / 2, 0);
    m_downArrow->setOpacity(0);    


    // unlock card flip timeline
    VFX_OBJ_CREATE(m_cardMoveTimeLine, VfxPointTimeline, this);

    // Bubble Effect
    VFX_OBJ_CREATE(m_bubbleEffectUp, VcpBubbleEffect, this);
    m_bubbleEffectUp->setBounds(0, 0, pageW, pageH / 2);

    VFX_OBJ_CREATE(m_bubbleEffectDown, VcpBubbleEffect, this);
    m_bubbleEffectDown->setPos(0, pageH / 2);
    m_bubbleEffectDown->setBounds(0, 0, pageW, pageH / 2);
    m_bubbleEffectDown->setIsInverse(VFX_TRUE);
}

void VappCalReminderCardPage::onEnter(VfxBool isBackward)
{
    VfxPage::onEnter(isBackward);
}

void VappCalReminderCardPage::onBack()
{
    VfxPage::onBack();
}

VfxBool VappCalReminderCardPage::onKeyInput(VfxKeyEvent & event)
{
    if (event.keyCode == VFX_KEY_CODE_BACK &&
        event.type == VFX_KEY_EVENT_TYPE_DOWN)	
    {
        m_signalDrag.postEmit(this, VAPP_CAL_REMINDER_SNOOZE);
    }
    else if (event.keyCode == VFX_KEY_CODE_HOME &&
            event.type == VFX_KEY_EVENT_TYPE_DOWN)	
    {
        return VFX_TRUE;
    }

    //block the POWER KEY
    if (event.keyCode == VFX_KEY_CODE_POWER)
    {
        return VFX_TRUE;
    }
    if (event.keyCode == VFX_KEY_CODE_END)
    {
        if(!mmi_frm_kbd_is_key_supported(VFX_KEY_CODE_POWER))  
        {
             return MMI_TRUE;
            }
        }

    // Except end key, popup block all keys
    if ((event.keyCode == VFX_KEY_CODE_VOL_DOWN) ||
        (event.keyCode == VFX_KEY_CODE_VOL_UP))
    {
        return VFX_TRUE;
    }

    return VfxPage::onKeyInput(event);
}

mmi_ret VappCalReminderCardPage::onProc(mmi_event_struct *event)
{
    if (event->evt_id == EVT_ID_VAPP_NCENTER_DRAG)
    {
        return MMI_RET_ERR;
    }

    return VfxPage::onProc(event);
}

void VappCalReminderCardPage::onDeinit()
{
    if (m_wallpaper)
    {
        VFX_OBJ_CLOSE(m_wallpaper);
    }

    VfxPage::onDeinit();
}



VfxBool VappCalReminderCardPage::onPenInput(VfxPenEvent &event)
{
    // dispatch event directly
    VfxPoint pos;
    pos = event.getRelPos(this);

    switch (event.type)
    {
        case VFX_PEN_EVENT_TYPE_DOWN:
        {
            if (m_card->getCard() == hitTest(pos))
            {
                penDownHandler(pos);
                m_isCardTaped = VFX_TRUE;

                m_card->stopVib();

                vfx_adp_touch_fb_play(VFX_ADP_TOUCH_FB_TYPE_HOLD);

                return VFX_TRUE;
            }
            break;
        }
        case VFX_PEN_EVENT_TYPE_UP:
        case VFX_PEN_EVENT_TYPE_ABORT:
        {
            if (m_isCardTaped)
            {
                penUpHandler(pos);
                m_isCardTaped = VFX_FALSE;   
                return VFX_TRUE;
            }
            break;
        }
        case VFX_PEN_EVENT_TYPE_MOVE:
        {
            if (m_isCardTaped)
            {
                penMoveHandler(event);
                return VFX_TRUE;
            }
            break;
        }
        default:
            break;
    }
    return VfxPage::onPenInput(event);
}

void VappCalReminderCardPage::penDownHandler(VfxPoint &pos)
{
    m_card->setCardStatus(VAPP_CAL_REMINDER_CARD_IS_CLICKED);
    setTextAndArrowOpacity(VAPP_CAL_REMINDER_CARD_IS_CLICKED);
}

void VappCalReminderCardPage::resetCard(void)
{
    m_card->setPos(pageW / 2, pageH / 2);
    m_card->setCardStatus(VAPP_CAL_REMINDER_CARD_NO_MOVE);
    setTextAndArrowOpacity(VAPP_CAL_REMINDER_CARD_NO_MOVE);
    m_bubbleEffectUp->stopFloat(VFX_FALSE);
    m_bubbleEffectDown->stopFloat(VFX_FALSE);
}

void VappCalReminderCardPage::penUpHandler(VfxPoint &pos)
{
    if (pos.y >=  VAPP_CAL_REMINDER_PAGE_SHADOW_H 
        && pos.y <= (getSize().height - VAPP_CAL_REMINDER_PAGE_SHADOW_H))
    {
    // the page height + status bar height = full screen height;
        resetCard();
    }
    else if (pos.y < VAPP_CAL_REMINDER_PAGE_SHADOW_H)
    {
        // card will fly up away
        if (m_card->isMovable(VAPP_CAL_REMINDER_CARD_MOVE_UP))
        {
            m_isMoveUp = VFX_TRUE;
            m_cardMoveTimeLine->setToValue(VfxPoint(getSize().width / 2, -(m_card->getSize().height / 2)));
            m_cardMoveTimeLine->m_signalStopped.connect(this, &VappCalReminderCardPage::onTimeLineStop);
            m_cardMoveTimeLine->start();
        }
        else
        {
            resetCard();
        }
    }
    else
    {
        // card will fly down away
        if (m_card->isMovable(VAPP_CAL_REMINDER_CARD_MOVE_DOWN))
        {
            m_isMoveUp = VFX_FALSE;

            m_cardMoveTimeLine->setToValue(VfxPoint(getSize().width / 2, pageH + m_card->getSize().height / 2));
            m_cardMoveTimeLine->m_signalStopped.connect(this, &VappCalReminderCardPage::onTimeLineStop);
            m_cardMoveTimeLine->start();
        }
        else
        {
            resetCard();
        }
    }

}

void VappCalReminderCardPage::penMoveHandler(VfxPenEvent &event)
{
    VfxPoint pos, prePos, cardPos;
    pos = event.getRelPos(this);
    prePos = event.getRelPrevPos(this);

    cardPos.x = m_card->getPos().x;
    cardPos.y = m_card->getPos().y + (pos.y - prePos.y);

    if ((cardPos.y < getMainScr()->getSize().height / 2) &&
        m_card->isMovable(VAPP_CAL_REMINDER_CARD_MOVE_UP))
    {
        m_isMoveUp = VFX_TRUE;
        m_card->setCardStatus(VAPP_CAL_REMINDER_CARD_MOVE_UP);
        setTextAndArrowOpacity(VAPP_CAL_REMINDER_CARD_MOVE_UP);

        m_bubbleEffectDown->stopFloat(VFX_FALSE);
        m_bubbleEffectUp->shiftFloat(cardPos);
        m_bubbleEffectUp->startFloat(cardPos);
    }
    else if ((cardPos.y > getMainScr()->getSize().height / 2) &&
            m_card->isMovable(VAPP_CAL_REMINDER_CARD_MOVE_DOWN))
    {
        m_isMoveUp = VFX_FALSE;
        m_card->setCardStatus(VAPP_CAL_REMINDER_CARD_MOVE_DOWN);
        setTextAndArrowOpacity(VAPP_CAL_REMINDER_CARD_MOVE_DOWN);

        m_bubbleEffectUp->stopFloat(VFX_FALSE);
        m_bubbleEffectDown->shiftFloat(convertPointTo(cardPos, m_bubbleEffectDown));
        m_bubbleEffectDown->startFloat(convertPointTo(cardPos, m_bubbleEffectDown));		
    }
    else
    {
        m_card->setCardStatus(VAPP_CAL_REMINDER_CARD_NO_MOVE);
        setTextAndArrowOpacity(VAPP_CAL_REMINDER_CARD_NO_MOVE);

        m_bubbleEffectUp->stopFloat(VFX_FALSE);
        m_bubbleEffectDown->stopFloat(VFX_FALSE);
        return;
    }

    m_card->setPos(cardPos);
}

void VappCalReminderCardPage::addCard(VappReminderCard *card)
{
    m_card = card;

    m_cardMoveTimeLine->setTarget(m_card);
    m_cardMoveTimeLine->setDuration(VAPP_CAL_REMINDER_CARD_MOVE_TIME);
    m_cardMoveTimeLine->setTargetPropertyId(VRT_FRAME_PROPERTY_ID_POS);

    if (!m_card->isMovable(VAPP_CAL_REMINDER_CARD_MOVE_UP))
    {
        m_upText->setHidden(VFX_TRUE);
    }

    if (!m_card->isMovable(VAPP_CAL_REMINDER_CARD_MOVE_DOWN))
    {
        m_downText->setHidden(VFX_TRUE);
    }
}


void VappCalReminderCardPage::onTimeLineStop(VfxBaseTimeline *timeline, VfxBool is_stop)
{
    if (!is_stop)
    {
        return;
    }

    if (m_isMoveUp)
    {
        // close lock screen
        vapp_screen_lock_close();

        // dismiss
        m_signalDrag.postEmit(this, VAPP_CAL_REMINDER_DISMISS);
    }
    else
    {
        // go back lock screen

        // snooze
        m_signalDrag.postEmit(this, VAPP_CAL_REMINDER_SNOOZE);
    }

    //VFX_OBJ_CLOSE(m_card);
    //m_cardMoveTimeLine->m_signalStopped.disconnect(this, &VappCalReminderCardPage::onTimeLineStop);	
}

void VappCalReminderCardPage::setTextAndArrowOpacity(VAPP_CAL_REMINDER_CARD_STATUS status)
{
    switch(status)
    {
        case VAPP_CAL_REMINDER_CARD_MOVE_UP:
            m_upText->setOpacity(0.5);
            m_downText->setOpacity(1);

            m_upArrow->setOpacity(0.5);
            m_downArrow->setOpacity(0);
            break;

        case VAPP_CAL_REMINDER_CARD_MOVE_DOWN:
            m_upText->setOpacity(1);
            m_downText->setOpacity(0.5);

            m_upArrow->setOpacity(0);
            m_downArrow->setOpacity(0.5);
            break;

        case VAPP_CAL_REMINDER_CARD_IS_CLICKED:
            m_upText->setOpacity(1);
            m_downText->setOpacity(1);

            m_upArrow->setOpacity(0);
            m_downArrow->setOpacity(0);
            break;

        case VAPP_CAL_REMINDER_CARD_NO_MOVE:
            m_upText->setOpacity(1);
            m_downText->setOpacity(1);

            m_upArrow->setOpacity(0);
            m_downArrow->setOpacity(0);
            break;

        default:
            break;
    }
}


/***************************************************************************** 
 * Class  VappReminderCard
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappReminderCard", VappReminderCard, VfxControl);
void VappReminderCard::onInit()
{
    VfxControl::onInit();


    VappCalReminderCardPage *page = (VappCalReminderCardPage*)getParent();

    setAnchor(0.5f, 0.5f);
    setPos(page->pageW / 2, page->pageH / 2);
    setSize(page->pageW, page->pageH - 2 * VAPP_CAL_REMINDER_PAGE_SHADOW_H);
    setIsZSortChild(VFX_TRUE);

    VFX_OBJ_CREATE(m_cardShadowUp, VfxImageFrame, this);
    m_cardShadowUp->setAnchor(0.5f, 0.5f);
    m_cardShadowUp->setResId(IMG_ID_VAPP_CAL_REMINDER_CARD_SHADOW_UP);
    m_cardShadowUp->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    m_cardShadowUp->setPos(getSize().width / 2, getSize().height / 2 - VAPP_CAL_REMINDER_CARD_SHADOW_UP_OFFSIZE);
    m_cardShadowUp->setSize(getSize().width, VAPP_CAL_REMINDER_CARD_H);
    m_cardShadowUp->setOpacity(0);

    VFX_OBJ_CREATE(m_cardShadowDown, VfxImageFrame, this);
    m_cardShadowDown->setAnchor(0.5f, 0.5f);
    m_cardShadowDown->setResId(IMG_ID_VAPP_CAL_REMINDER_CARD_SHADOW_DOWN);
    m_cardShadowDown->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    m_cardShadowDown->setPos(getSize().width / 2, getSize().height / 2 + VAPP_CAL_REMINDER_CARD_SHADOW_DOWN_OFFSIZE);
    m_cardShadowDown->setSize(getSize().width, VAPP_CAL_REMINDER_CARD_H);
    m_cardShadowDown->setOpacity(0);

    VFX_OBJ_CREATE(m_cardShadowMid, VfxImageFrame, this);
    m_cardShadowMid->setAnchor(0.5f, 0.5f);
    m_cardShadowMid->setResId(IMG_ID_VAPP_CAL_REMINDER_CARD_SHADOW_MID);
    m_cardShadowMid->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    m_cardShadowMid->setPos(getSize().width / 2, getSize().height / 2);
    m_cardShadowMid->setSize(getSize().width, VAPP_CAL_REMINDER_CARD_H + 2 * VAPP_CAL_REMINDER_CARD_SHADOW_DOWN_OFFSIZE);
    m_cardShadowMid->setOpacity(0);

    VFX_OBJ_CREATE(m_cardFrame, VfxImageFrame, this);
    m_cardFrame->setAnchor(0.5f, 0.5f);
    m_cardFrame->setResId(IMG_ID_VAPP_CAL_REMINDER_CARD_BG);
    m_cardFrame->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    m_cardFrame->setPos(getSize().width / 2, getSize().height / 2);
    m_cardFrame->setSize(VAPP_CAL_REMINDER_CARD_W, VAPP_CAL_REMINDER_CARD_H);
    m_cardFrame->bringToFront();	

    VFX_OBJ_CREATE(m_upArrow, VfxImageFrame, m_cardFrame);
    m_upArrow->setAnchor(0.5f, 0);
    m_upArrow->setResId(IMG_ID_VAPP_CAL_REMINDER_CARD_ARROW_UP);
    m_upArrow->setPos(m_cardFrame->getSize().width / 2, 
                VAPP_CAL_REMINDER_CARD_ARROW_UP_OFFSIZE);	
    m_upArrow->setIsUnhittable(VFX_TRUE);


    VFX_OBJ_CREATE(m_downArrow, VfxImageFrame, m_cardFrame);
    m_downArrow->setAnchor(0.5f, 1);
    m_downArrow->setResId(IMG_ID_VAPP_CAL_REMINDER_CARD_ARROW_DOWN);
    m_downArrow->setPos(m_cardFrame->getSize().width / 2, 
                    m_cardFrame->getSize().height - VAPP_CAL_REMINDER_CARD_ARROW_DOWN_OFFSIZE);
    m_downArrow->setIsUnhittable(VFX_TRUE);

    checkUpdate();
}

void VappReminderCard::onUpdate()
{
    // if you want to customize this card, should inherite this class
    // check iamge status
    if (!isMovable(VAPP_CAL_REMINDER_CARD_MOVE_UP))
    {
        m_upArrow->setHidden(VFX_TRUE);
    }
    else
    {
        m_upArrow->setHidden(VFX_FALSE);
    }

    if (!isMovable(VAPP_CAL_REMINDER_CARD_MOVE_DOWN))
    {
        m_downArrow->setHidden(VFX_TRUE);
    }
    else
    {
        m_downArrow->setHidden(VFX_FALSE);
    }
}

VfxBool VappReminderCard::onKeyInput(VfxKeyEvent & event)
{
    // Except end key, popup block all keys
    if ((event.keyCode == VFX_KEY_CODE_VOL_DOWN) ||
        (event.keyCode == VFX_KEY_CODE_VOL_UP))
    {
        return VFX_TRUE;
    }

    return VfxControl::onKeyInput(event);
}

VfxBool VappReminderCard::onContainPoint(const VfxPoint & point)
{
    return m_cardFrame->getBounds().contains(point);
}

void VappReminderCard::setCardStatus(VAPP_CAL_REMINDER_CARD_STATUS status)
{
    switch(status)
    {
        case VAPP_CAL_REMINDER_CARD_MOVE_UP:
            m_cardShadowUp->setOpacity(1);
            m_cardShadowDown->setOpacity(0);
            m_cardShadowMid->setOpacity(0);
            break;

        case VAPP_CAL_REMINDER_CARD_MOVE_DOWN:
            m_cardShadowUp->setOpacity(0);
            m_cardShadowDown->setOpacity(1);
            m_cardShadowMid->setOpacity(0);
            break;

        case VAPP_CAL_REMINDER_CARD_IS_CLICKED:
            m_cardShadowUp->setOpacity(0);
            m_cardShadowDown->setOpacity(0);
            m_cardShadowMid->setOpacity(1);
            break;

        case VAPP_CAL_REMINDER_CARD_NO_MOVE:
            m_cardShadowUp->setOpacity(0);
            m_cardShadowDown->setOpacity(0);
            m_cardShadowMid->setOpacity(0);
            break;	

        default:
            break;
    }
}

VfxFrame* VappReminderCard::getCard()
{
    return m_cardFrame;
}



/***************************************************************************** 
 * Class  VappCalReminderCard
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappCalReminderCard", VappCalReminderCard, VappReminderCard);
void VappCalReminderCard::onInit()
{
    VappReminderCard::onInit();


    srv_tdl_vcal_enum type 
        = ((VappCalReminderCardScreen*)(((VfxPage*)getParent())->getMainScr()))->getType();

  
    VfxU32 event_Id = ((VappCalReminderCardScreen*)(((VfxPage*)getParent())->getMainScr()))->getEventId();
    srv_tdl_event_source_enum source_Id =((VappCalReminderCardScreen*)(((VfxPage*)getParent())->getMainScr()))->getSourceId();
    VFX_OBJ_CREATE_EX(m_content, VappCalReminderContent, this, (type, event_Id, source_Id));


    m_content->setAnchor(0.5f, 0.5f);
    m_content->setPos(getSize().width / 2, getSize().height / 2 - VAPP_CAL_REMINDER_CARD_ARROW_UP_OFFSIZE);		
    m_content->setSubjectColor(VFX_COLOR_BLACK);

    ((VappCalReminderCardScreen*)(((VfxPage*)getParent())->getMainScr()))->adjustAlmType();

}

VfxBool VappCalReminderCard::isMovable(const VfxS32 &operation)
{
    return m_content->isMovable(operation);
}
#endif

/***************************************************************************** 
 * Class  VappCalReminderContent
 *****************************************************************************/
void VappCalReminderContent::onInit()
{
    VfxFrame::onInit();
    setIsUnhittable(VFX_TRUE);

    srv_tdl_event_struct *pevent = NULL;
    
#ifdef __MMI_TASK_APP__
    srv_tdl_task_struct *ptask = NULL;
#endif
    void *data = NULL;

    if (m_type == SRV_TDL_VCAL_EVENT)
    {
        VFX_ALLOC_MEM(pevent, sizeof(srv_tdl_event_struct), this);
        VFX_ASSERT(pevent);
        srv_tdl_event_get(
                pevent, 
                sizeof(srv_tdl_event_struct), 
                m_sourceId,
                m_eventId);

        m_snoozeValue = pevent->alarm.snooze;
        data = (srv_tdl_event_struct *)pevent;
    }
    
#ifdef __MMI_TASK_APP__
    else
    {     
    
        VFX_ALLOC_MEM(ptask, sizeof(srv_tdl_task_struct), this);
        VFX_ASSERT(ptask);

        srv_tdl_get(
                 ptask, 
                 sizeof(srv_tdl_task_struct), 
                 m_type,
                 m_eventId);

        m_snoozeValue = ptask->alarm.snooze;
        data = (srv_tdl_task_struct *)ptask;
    }
#endif

    VfxImageFrame *categoryImg;
    VfxU16 imgId;
    VFX_OBJ_CREATE(categoryImg, VfxImageFrame, this);
    categoryImg->setAnchor(0, 0.5f);

    if (m_type == SRV_TDL_VCAL_EVENT)
    {
        VAPP_CAL_CATEGORY_ENUM categroy = VappCalEditPage::convertCategoryStoM((srv_vcal_category_type_enum)pevent->category);
    
        
        imgId = IMG_ID_VAPP_CAL_PERSONAL + categroy;
        
                  
        categoryImg->setImgContent(VfxImageSrc(imgId));
    }
    
#ifdef __MMI_TASK_APP__
    else
    {
        categoryImg->setImgContent(VfxImageSrc(IMG_ID_VAPP_CAL_TASK_REMINDER));
    }
#endif
    categoryImg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    categoryImg->setSize(
                    VAPP_CAL_REMINDER_POPUP_ICON_W_H, 
                    VAPP_CAL_REMINDER_POPUP_ICON_W_H);
    categoryImg->setIsUnhittable(VFX_TRUE);


   
    VfxFrame *cnxtFrame;
    VFX_OBJ_CREATE(cnxtFrame, VfxFrame, this);
    cnxtFrame->setAnchor(0, 0.5f);
    cnxtFrame->setIsUnhittable(VFX_TRUE);


    VFX_OBJ_CREATE(m_subjText, VfxTextFrame, cnxtFrame);

    if (m_type == SRV_TDL_VCAL_EVENT)
    {
        m_subjText->setString((VfxWChar*) pevent->subject);
    }
    
#ifdef __MMI_TASK_APP__
    else
    {
        m_subjText->setString((VfxWChar*) ptask->subject);
    }
#endif
    m_subjText->setFont(VfxFontDesc(VAPP_CAL_REMINDER_POPUP_SUBJECT_FONT, VFX_FONT_DESC_ATTR_NORMAL));

    m_subjText->setColor(VFX_COLOR_RES(CLR_COSMOS_TEXT_MAIN));
    m_subjText->setLineMode(VfxTextFrame::LINE_MODE_MULTI);
    m_subjText->setMaxLines(2);
    m_subjText->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
    //m_subjText->setAlignMode(VfxTextFrame::ALIGN_MODE_LEFT);
    m_subjText->setPos(0, 0);
    m_subjText->setSize(
                    VAPP_CAL_REMINDER_POPUP_SUBJECT_WIDTH,
                    VAPP_CAL_REMINDER_POPUP_SUBJECT_HEIGHT);
    //m_subjText->setAutoResized(VFX_TRUE);
    m_subjText->setIsUnhittable(VFX_TRUE);


    VfxU16 height = m_subjText->getSize().height + VAPP_CAL_REMINDER_POPUP_STRNG_GAP;

    if ((m_type == SRV_TDL_VCAL_EVENT) && pevent->location[0] != 0)
    {
        VfxTextFrame *locText;
        VFX_OBJ_CREATE(locText, VfxTextFrame, cnxtFrame);
        locText->setString((VfxWChar*) pevent->location);
        locText->setFont(VfxFontDesc(VAPP_CAL_REMINDER_POPUP_LOC_FONT, VFX_FONT_DESC_ATTR_NORMAL));
        locText->setColor(VfxColorResHelper(CLR_COSMOS_TEXT_SUB));
        locText->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
        //locText->setAlignMode(VfxTextFrame::ALIGN_MODE_LEFT);
        locText->setPos(0, height);
        locText->setSize(
                    VAPP_CAL_REMINDER_POPUP_SUBJECT_WIDTH,
                    VAPP_CAL_REMINDER_POPUP_LOC_HEIGHT);
        //locText->setAutoResized(VFX_TRUE);
        locText->setIsUnhittable(VFX_TRUE);

        height += locText->getSize().height + VAPP_CAL_REMINDER_POPUP_STRNG_GAP;
    }

    VfxWString dTStr;

    getReminderDateTimeStr(
                            m_type,
                            (const void*)data,
                            dTStr); 

    VfxTextFrame *dateTimeText;
    VFX_OBJ_CREATE(dateTimeText, VfxTextFrame, cnxtFrame);
    dateTimeText->setString(dTStr);
    dateTimeText->setFont(VfxFontDesc(VAPP_CAL_REMINDER_POPUP_TIME_FONT, VFX_FONT_DESC_ATTR_NORMAL));
    dateTimeText->setColor(VfxColorResHelper(CLR_COSMOS_TEXT_SUB));
    dateTimeText->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
    //dateTimeText->setAlignMode(VfxTextFrame::ALIGN_MODE_LEFT);
    dateTimeText->setPos(0, height);
    dateTimeText->setSize(
                    VAPP_CAL_REMINDER_POPUP_SUBJECT_WIDTH,
                    VAPP_CAL_REMINDER_POPUP_LOC_HEIGHT);

    //dateTimeText->setAutoResized(VFX_TRUE);
    dateTimeText->setIsUnhittable(VFX_TRUE);

    height += dateTimeText->getSize().height;

    VfxU16 width = VAPP_CAL_REMINDER_POPUP_ICON_W_H / 8
                            + VAPP_CAL_REMINDER_POPUP_ICON_W_H
                            + VAPP_CAL_REMINDER_POPUP_ICON_W_H / 8
                            + VAPP_CAL_REMINDER_POPUP_SUBJECT_WIDTH
                            + VAPP_CAL_REMINDER_POPUP_ICON_W_H / 8;

    setSize(width, height);

    categoryImg->setPos(VAPP_CAL_REMINDER_POPUP_ICON_W_H / 8, height / 2);

    cnxtFrame->setSize(VAPP_CAL_REMINDER_POPUP_SUBJECT_WIDTH, height);

    VfxU16 cnxtX = VAPP_CAL_REMINDER_POPUP_ICON_W_H / 8
                    + VAPP_CAL_REMINDER_POPUP_ICON_W_H
                    + VAPP_CAL_REMINDER_POPUP_ICON_W_H / 8;

    cnxtFrame->setPos(cnxtX, height / 2);

    VFX_FREE_MEM(data);
}

void VappCalReminderContent::getReminderDateTimeStr(
                                    srv_tdl_vcal_enum type,
                                    const void* dataPtr,
                                    VfxWString &subBuf)
{

    if (type == SRV_TDL_VCAL_EVENT)
    {
        srv_tdl_event_short_struct* pEvent = (srv_tdl_event_short_struct*)dataPtr;
        getEventReminderDateTimeStr(pEvent,subBuf);

    }
#ifdef __MMI_TASK_APP__
    else if (type == SRV_TDL_VCAL_TASK)
    {
        srv_tdl_task_short_struct* pTask = (srv_tdl_task_short_struct*)dataPtr;
        applib_time_struct *dTime = (applib_time_struct*)&(pTask->due_time);

        VfxDateTime dateTime;
        VfxWString tempBuf;
        VfxU32 flags;
        flags = VFX_DATE_TIME_TIME_HOUR | VFX_DATE_TIME_TIME_MINUTE;

        dateTime.setDate(dTime->nYear, dTime->nMonth, dTime->nDay);
        tempBuf += dateTime.getDateTimeString(VFX_DATE_TIME_DATE_MASK);
        tempBuf += VfxWString(VFX_WSTR(" "));
        dateTime.setTime(dTime->nHour, dTime->nMin, dTime->nSec);
        tempBuf += dateTime.getDateTimeString(flags);
        subBuf = tempBuf;
    }
#endif
    else
    {
        return;
    }
}
void VappCalReminderContent::getEventReminderDateTimeStr(const srv_tdl_event_short_struct* pEvent,VfxWString &subBuf)
{
    VfxDateTime dateTime;
    VfxWString tempBuf;
    VfxU32 flags;
    flags = VFX_DATE_TIME_TIME_HOUR | VFX_DATE_TIME_TIME_MINUTE;

    applib_time_struct *sTime = (applib_time_struct*)&(pEvent->start_time);
    applib_time_struct *eTime = (applib_time_struct*)&(pEvent->end_time);

    /* if the same day */
    VfxBool sameDay;
    if (sTime->nYear == eTime->nYear &&
        sTime->nMonth == eTime->nMonth &&
        sTime->nDay == eTime->nDay)
    {
        sameDay = VFX_TRUE;
    }
    else
    {
        sameDay = VFX_FALSE;
    }

    applib_time_struct *reminderTime = (applib_time_struct*)&(pEvent->alarm.first_launch);
    /* if the current day */
    //if ((VAPP_CAL_REMINDER_ENUM)(pEvent->alarm.type) < VAPP_CAL_REMINDER_1DAY_EARLIER)
    if(sTime->nYear == reminderTime->nYear &&
        sTime->nMonth == reminderTime->nMonth &&
        sTime->nDay == reminderTime->nDay)
    {
            dateTime.setTime(sTime->nHour, sTime->nMin, sTime->nSec);
            tempBuf += dateTime.getDateTimeString(flags);
            tempBuf += VfxWString(VFX_WSTR(" - "));
        if (sameDay)
        {
            // hour:min - hour:min        
            dateTime.setTime(eTime->nHour, eTime->nMin, eTime->nSec);
        }
        else
        {
            // hour:min - year.mon.day hour:min

            dateTime.setDate(eTime->nYear, eTime->nMonth, eTime->nDay);
            tempBuf += dateTime.getDateTimeString(VFX_DATE_TIME_DATE_MASK);
            tempBuf += VfxWString(VFX_WSTR(" "));
            dateTime.setTime(eTime->nHour, eTime->nMin, eTime->nSec);
            
        }
            tempBuf += dateTime.getDateTimeString(flags);

            subBuf = tempBuf;
        }
    else
    {
        applib_time_struct realTime;
        applib_time_struct increment;
        memset(&increment, 0, sizeof(applib_time_struct));

        dateTime.setCurrentTime();

        switch((VAPP_CAL_REMINDER_ENUM)(pEvent->alarm.type))	
        {
            case VAPP_CAL_REMINDER_1DAY_EARLIER:
                increment.nDay = 1;
                break;
            case VAPP_CAL_REMINDER_3DAYS_EARLIER:
                increment.nDay = 3;
                break;
            case VAPP_CAL_REMINDER_1WEEK_EARLIER:
                increment.nDay = 7;
                break;
            default:
                break;
        }
        applib_time_struct applib_time = {0};
        applib_time = dateTime.getDateTime();

        applib_dt_increase_time(
                        (applib_time_struct*)&applib_time,
                        (applib_time_struct*)&increment,
                        (applib_time_struct*)&realTime);

            dateTime.setDate(realTime.nYear, realTime.nMonth, realTime.nDay);
            tempBuf += dateTime.getDateTimeString(VFX_DATE_TIME_DATE_MASK);
            tempBuf += VfxWString(VFX_WSTR(" "));				
            dateTime.setTime(sTime->nHour, sTime->nMin, sTime->nSec);
            tempBuf += dateTime.getDateTimeString(flags);
            tempBuf += VfxWString(VFX_WSTR(" - "));

        if (sameDay)
        {
            // hour:min - hour:min year.mon.day   
            dateTime.setTime(eTime->nHour, eTime->nMin, eTime->nSec);
        }
        else
        {
            // year.mon.day hour:min - year.mon.day hour:min 
            dateTime.setDate(eTime->nYear, eTime->nMonth, eTime->nDay);
            tempBuf += dateTime.getDateTimeString(VFX_DATE_TIME_DATE_MASK);
            tempBuf += VfxWString(VFX_WSTR(" "));
            dateTime.setTime(sTime->nHour, sTime->nMin, sTime->nSec);
            
        }
            tempBuf += dateTime.getDateTimeString(flags);
            subBuf = tempBuf;
        }


}



#ifndef __LOW_COST_SUPPORT_COMMON__
VfxBool VappCalReminderContent::isMovable(const VfxS32 &operation)
{
    if (operation == VAPP_CAL_REMINDER_CARD_MOVE_DOWN &&
        (m_snoozeValue >= VAPP_CAL_REMINDER_SNOOZE_COUNT))
    {
        return VFX_FALSE;
    }

    return VFX_TRUE;
}

void VappCalReminderContent::setSubjectColor(VfxColor color)
{

    m_subjText->setColor(color);
}
#endif
