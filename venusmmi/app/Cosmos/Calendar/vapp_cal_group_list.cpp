/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2008
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES. ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vapp_cal_group_list.cpp
 *
 * Project:
 * --------
 *  Cosmos
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "mmi_features.h"

//#include "vfx_mc_include.h"
//#include "vcp_include.h"

extern "C"
{
    #include "remindersrvgprot.h"
    #include "todolistsrvgprot.h"
    #ifdef __MMI_SNS_CALENDAR__
    #include "SnsSrvGprot.h"
    #endif
}

#include "mmi_rp_srv_venus_component_tool_bar_def.h"
#include "mmi_rp_vapp_calendar_def.h"
#ifdef __MMI_SNS_CALENDAR__
#include "mmi_rp_vapp_sns_def.h"
#endif

#include "vfx_adp_device.h"

#include "vcp_confirm_popup.h"
#include "vcp_menu_popup.h"
#include "vcp_navi_title_bar.h"
#include "vcp_tool_bar.h"

#include "vapp_cal_edit.h"
#include "vapp_cal_group_list.h"
#include "vcui_cal_list_gprot.h"
#include "vapp_cal_list_mgr.h"
#include "vapp_cal_main_view.h"
#include "vapp_cal_prot.h"
#include "vapp_cal_search.h"
#include "vapp_cal_utility.h"
#include "vapp_cal_view_detail.h"
#ifndef __MMI_VCALENDAR__
#pragma arm section code = "DYNAMIC_CODE_CLNDR_ROCODE", rodata = "DYNAMIC_CODE_CLNDR_RODATA"
#endif

#ifdef __MMI_SNS_CALENDAR__
static VfxU32 snstocalendartable[SRV_TDL_EVENT_SOURCE_TOTAL] = {
    0,
    SRV_SNS_PROVIDER_FACEBOOK,
    SRV_SNS_PROVIDER_KAIXIN,
    SRV_SNS_PROVIDER_RENREN,
    SRV_SNS_PROVIDER_TWITTER

    };
#endif



/***************************************************************************** 
 * Class VappCalGroupListPage
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappCalGroupListPage", VappCalGroupListPage, VfxPage);
void VappCalGroupListPage::onInit()
{
    VfxPage::onInit();

    mmi_frm_cb_reg_event(EVT_ID_SRV_TDL_EVENT_OP, updateCalEventGroupListPage, getObjHandle());	
    
#ifdef __MMI_VCALENDAR__
    mmi_frm_cb_reg_event(EVT_ID_SRV_TDL_OP, updateCalGroupListPage, getObjHandle());
#endif

    //m_isBackFromFliter = VFX_FALSE;
    m_jobId[0] = -1; 
    m_jobId[1] = -1; 

    m_totalcount = 0;
    m_eventbuffer[0] = NULL;
    m_eventbuffer[1] = NULL;
    m_stringId =  STR_GLOBAL_LOADING;//STR_ID_VAPP_CAL_NO_EVTS;
    m_listCount[0] = 0;
    m_listCount[1] = 0;
    m_listEventSel[0] = NULL;
    m_listEventSel[1] = NULL;

    m_fliterid = SRV_TDL_EVENT_SOURCE_TOTAL;

    m_multiDel = VFX_FALSE;


    VFX_OBJ_CREATE(m_titleBar, VcpTitleBar, this);
    m_titleBar->setTitleStyle(VCP_TITLE_BAR_STYLE_BASE);
    m_titleBar->setTitle((VfxResId)STR_ID_VAPP_CAL_EVENTS);
    setTopBar(m_titleBar);


    VFX_OBJ_CREATE(m_listMenu, VcpGroupListMenu, this);
    m_listMenu->setContentProvider((IVcpGroupListMenuContentProvider*)this);
    m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT_EX);
    m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_NORMAL, VFX_TRUE);
    m_listMenu->setSize(getSize());
    m_listMenu->setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE,
                            VFX_FRAME_ALIGNER_MODE_SIDE, 
                            VFX_FRAME_ALIGNER_MODE_SIDE, 
                            VFX_FRAME_ALIGNER_MODE_SIDE);

    if (m_entryType != VAPP_CAL_G_LIST_ENTRY_UC)	
    {
        m_listMenu->m_signalItemSelectionStateChanged.connect(this, &VappCalGroupListPage::onSelListMenuClicked);
        m_listMenu->m_signalItemTapped.connect(this, &VappCalGroupListPage::onListMenuClicked);
        m_listMenu->m_signalItemLongTapped.connect(this, &VappCalGroupListPage::onListMenuLongTap);
    }   
#ifdef __MMI_VCALENDAR__
    else
    {
        m_listMenu->m_signalItemTapped.connect(this, &VappCalGroupListPage::onListMenuClicked);
        // hide toolbar
        setBar(VFX_PAGE_BAR_LOCATION_BOTTOM, NULL, VFX_TRUE);
    }
#endif

    m_isMutiDelProcessing = VFX_FALSE;
    //m_isDataChanged = VFX_FALSE;
    m_isNoDeleteDataChanged = VFX_FALSE;

    GetSnsData();

#ifdef __MMI_SNS_CALENDAR__
    m_selIndex =(srv_tdl_event_source_enum) srv_tdl_get_source_count();
#endif

    VFX_ALLOC_MEM(path, VAPP_CAL_MAX_FILE_PATH_SIZE, this);
}

void VappCalGroupListPage::onDeinit()
{
   
    VFX_FREE_MEM(path);

    mmi_frm_cb_dereg_event(EVT_ID_SRV_TDL_EVENT_OP, updateCalEventGroupListPage, getObjHandle());
    
#ifdef __MMI_VCALENDAR__
    mmi_frm_cb_dereg_event(EVT_ID_SRV_TDL_OP, updateCalGroupListPage, getObjHandle());
#endif
    closeJob();
    VfxPage::onDeinit();
}

void VappCalGroupListPage::onBack()
{
    if (m_listMenu->getMenuMode() == VCP_LIST_MENU_MODE_MULTI_SELECTION)	
    {
        m_titleBar->setTitle((VfxResId)STR_ID_VAPP_CAL_EVENTS);

        setBar(VFX_PAGE_BAR_LOCATION_BOTTOM,NULL,VFX_TRUE);
        m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_NORMAL, VFX_TRUE);
        GetSnsData();
    }
    else
    {
        
        VfxPage::onBack();
    }
}


void VappCalGroupListPage::onEnter(VfxBool isBackward)
{
    VfxPage::onEnter(isBackward);

    // if a new item is updated or added
    if (m_isNoDeleteDataChanged)
    {
        m_listMenu->setVisibleMenuRegion(
                                VcpMenuPos(m_selPos.group, m_selPos.pos), 
                                VcpMenuPos(-1, -1), 
                                VFX_FALSE);
    }
    else
    {
        if (!isBackward)
        {
        m_listMenu->setVisibleMenuRegion(
                                VcpMenuPos(VAPP_CAL_G_LIST_INCOMING, -1), 
                                VcpMenuPos(-1, -1), 
                                VFX_FALSE);
        }
    }
}


void VappCalGroupListPage::onEntered()
{
    if(getDataChageState())
    {
        setDataChangeState(VFX_FALSE);
        updateCalGroupListPageInt();  
    }
}

void VappCalGroupListPage::onQueryRotateEx(VfxScreenRotateParam &param)
{
    if (m_entryType == VAPP_CAL_G_LIST_ENTRY_CALENDAR)
    {
        param.rotateTo = VFX_SCR_ROTATE_TYPE_NORMAL;
    }

}


void VappCalGroupListPage::onToolBarClicked(VfxObject *sender, VfxId id)
{
    switch(id)
    {
    case VAPP_CAL_G_LIST_ADD:
    {
        if (srv_tdl_is_full(SRV_TDL_VCAL_EVENT))
        {  
            VcpConfirmPopup *popup;
            VFX_OBJ_CREATE(popup, VcpConfirmPopup, this);
            popup->setInfoType(VCP_POPUP_TYPE_FAILURE);
            popup->setText((VfxResId)STR_ID_VAPP_CAL_MEM_FULL);
            popup->setButtonSet(VCP_CONFIRM_BUTTON_SET_OK);
            popup->setAutoDestory(VFX_TRUE);
            popup->show(VFX_TRUE);        
            break;
        }

        VappCalEditPage *editPage;
        VfxDateTime dateTime;
        dateTime.setCurrentTime();

        applib_time_struct applib_time = {0};
        applib_time = dateTime.getDateTime();
        VFX_OBJ_CREATE_EX(
                    editPage, 
                    VappCalEditPage, 
                    getMainScr(), 
                    (SRV_TDL_VCAL_EVENT, 0, VAPP_CAL_OPERATION_TYPE_ADD, &applib_time));
        getMainScr()->pushPage(0, editPage);
        break;
    }
    #ifdef __MMI_CAL_EXPIRY__
    case VAPP_CAL_G_LIST_EXPIRED:
    {
        VappCalExpiredListPage *page;
        VFX_OBJ_CREATE(page, VappCalExpiredListPage, getMainScr());
        getMainScr()->pushPage(0, page);
        break;
    }
    #endif

#ifndef __LOW_COST_SUPPORT_COMMON__
    case VAPP_CAL_G_LIST_SEARCH:
    {
        VappCalSearchPage *searchPage;
        VFX_OBJ_CREATE_EX(searchPage, VappCalSearchPage, getMainScr(), (SRV_TDL_VCAL_EVENT));
        getMainScr()->pushPage(0, searchPage);
        break;
    }
#endif

    case VAPP_CAL_G_LIST_DELETE:
    {
        m_titleBar->setTitle((VfxResId)STR_ID_VAPP_CAL_DELETE_EVENT_TITLE);
        m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_MULTI_SELECTION, VFX_TRUE);
        GetSnsData();
        break;
    }

    case VAPP_CAL_SEL_LIST_MARK_ALL:
    {
        if (m_markedCount == getTotalCount())
        {
            m_markedCount = 0;
            setSelListState(VCP_LIST_MENU_ITEM_STATE_UNSELECTED);
            m_toolBar->changeItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_MARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
            m_markAllBtn = VFX_TRUE;
        }
        else if (m_markedCount == 0)
        {
            m_markedCount = getTotalCount();
            setSelListState(VCP_LIST_MENU_ITEM_STATE_SELECTED);
            m_toolBar->changeItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_UNMARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_UNSELECT_ALL);
            m_markAllBtn = VFX_FALSE;
        }
        else
        {
            if (m_markAllBtn == VFX_TRUE)
            {
                m_markedCount = getTotalCount();
                setSelListState(VCP_LIST_MENU_ITEM_STATE_SELECTED);
                m_toolBar->changeItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_UNMARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_UNSELECT_ALL);
                m_markAllBtn = VFX_FALSE;
            }
            else
            {
                m_markedCount = 0;
                setSelListState(VCP_LIST_MENU_ITEM_STATE_UNSELECTED);
                m_toolBar->changeItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_MARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
                m_markAllBtn = VFX_TRUE;
            }
        }

        if (m_markedCount == 0)
        {
            m_toolBar->setDisableItem(VAPP_CAL_SEL_LIST_DELETE, VFX_TRUE);
        }
        else
        {
            m_toolBar->setDisableItem(VAPP_CAL_SEL_LIST_DELETE, VFX_FALSE);
        }

        m_listMenu->resetAllItems(VFX_TRUE);

        break;
    }

    case VAPP_CAL_SEL_LIST_DELETE:
    {
        VfxResId resId = (m_markedCount > 1) ? STR_ID_VAPP_CAL_DELETE_EVT : STR_ID_VAPP_CAL_DELETE_ONE_EVT;
        VfxWString str(resId);

        str += VFX_WSTR_RES(STR_ID_VAPP_CAL_LEFT_PARENTHESES);

        VfxWChar tempBuf[3];
        kal_wsprintf(tempBuf, "%d", m_markedCount);
        str += VFX_WSTR_MEM(tempBuf);

        str += VFX_WSTR_RES(STR_ID_VAPP_CAL_RIGHT_PARENTHESES);
        str += VFX_WSTR_RES(STR_ID_VAPP_CAL_QUESTION_MARK);

        VcpConfirmPopup *confirmPopup;

        VFX_OBJ_CREATE(confirmPopup, VcpConfirmPopup, this);
        confirmPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
        confirmPopup->setText(str);

        confirmPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_USER_DEFINE);
        confirmPopup->setCustomButton(
                        (VfxResId)STR_ID_VAPP_CAL_DELETE,
                        (VfxResId)STR_ID_VAPP_CAL_CANCEL,
                        VCP_POPUP_BUTTON_TYPE_WARNING,
                        VCP_POPUP_BUTTON_TYPE_CANCEL);

        confirmPopup->setAutoDestory(VFX_TRUE);    
        confirmPopup->m_signalButtonClicked.connect(this, &VappCalGroupListPage::onSelListDelConfirm);
        confirmPopup->show(VFX_TRUE);

        m_confirmPopupWeakPtr = confirmPopup;

        break;
    }
    case VAPP_CAL_SEL_LIST_CANCEL:	
    {

        setBar(VFX_PAGE_BAR_LOCATION_BOTTOM,NULL,VFX_TRUE);
        m_titleBar->setTitle((VfxResId)STR_ID_VAPP_CAL_EVENTS);

        m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_NORMAL, VFX_TRUE);
        GetSnsData();
        break;
    }
#ifdef __MMI_SNS_CALENDAR__
    case  VAPP_CAL_G_LIST_MORE :
    {
        if (!m_toolBar->isFolded())
        {
            m_toolBar->removeItem(VAPP_CAL_G_LIST_EXPIRED);
            m_toolBar->removeItem(VAPP_CAL_G_LIST_DELETE);
        }
        else
        {
            m_toolBar->addItem(VAPP_CAL_G_LIST_EXPIRED, (VfxResId)STR_ID_VAPP_CAL_EXPIRED, IMG_ID_VAPP_CAL_EXPIRED);
            m_toolBar->addItem(VAPP_CAL_G_LIST_DELETE, (VfxResId)STR_ID_VAPP_CAL_DELETE, VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);
            if ((m_fliterid > SRV_TDL_EVENT_SOURCE_LOCAL)&&(m_fliterid < SRV_TDL_EVENT_SOURCE_TOTAL))
            {
                m_toolBar->setDisableItem(VAPP_CAL_G_LIST_DELETE, VFX_TRUE);
            } 
            m_toolBar->removeItem(VAPP_CAL_G_LIST_MORE);	 
        }
        m_toolBar->switchFoldMode();
        break;
    }
    case VAPP_CAL_G_LIST_FILTER :
    {
        VappCalFliterListPage* m_fiter;

        VFX_OBJ_CREATE_EX(m_fiter,VappCalFliterListPage,getMainScr(),(this,m_selIndex));
        m_fiter->m_signalFilterListItemTap.connect(this,&VappCalGroupListPage::onFilterListPageBack);
        getMainScr()->pushPage(0, m_fiter);
        break;
    }
#endif  /*__MMI_SNS_CALENDAR__*/
    default:
        break;
    }
}

#ifdef __MMI_SNS_CALENDAR__
void VappCalGroupListPage::onFilterListPageBack(VfxU32 index,VfxU32 selIndex)
{
  
    m_fliterid = (srv_tdl_event_source_enum)index;
    m_selIndex = (srv_tdl_event_source_enum)selIndex;
    for (VfxU32 i = VAPP_CAL_G_LIST_INCOMING; i < VAPP_CAL_G_LIST_TOTAL; i++)
    {
        m_listCount[i] = 0;
        if(m_eventbuffer[i])
        {
            VFX_FREE_MEM(m_eventbuffer[i]);
        }
        if(m_listEventSel[i])
        {
            VFX_FREE_MEM(m_listEventSel[i]);
        }

        if(m_jobId[i] > 0)
        {
            srv_tdl_event_search_end(m_jobId[i]);
            mmi_frm_cb_dereg_event(EVT_ID_SRV_TDL_EVENT_SEARCH, VappCalGroupListPage::updateSNSListData, getObjHandle());
            m_jobId[i] = -1;
        }   

    }
    m_listMenu->reset();
    GetSnsData();
}
#endif


void VappCalGroupListPage::setDataChangeState(VfxBool state)
{
    m_multiDel = state;
}

VfxBool VappCalGroupListPage::getDataChageState()
{
    return m_multiDel;
}

void VappCalGroupListPage::onListMenuClicked(VcpGroupListMenu *sender, VcpMenuPos pos)
{
    VFX_ASSERT(pos.group >= VAPP_CAL_G_LIST_INCOMING && pos.group < VAPP_CAL_G_LIST_TOTAL);

    if (m_listMenu->getMenuMode() != VCP_LIST_MENU_MODE_NORMAL)
    {
        return;
    }

    if (m_entryType != VAPP_CAL_G_LIST_ENTRY_UC)	
    {
        VappCalViewDetailPage *viewPage;
        // entry view page

        VFX_OBJ_CREATE_EX(
                    viewPage, 
                    VappCalViewDetailPage,
                    getMainScr(),
                    (SRV_TDL_VCAL_EVENT, m_eventbuffer[pos.group][pos.pos]));


        getMainScr()->pushPage(0, viewPage);
    }
#ifdef __MMI_VCALENDAR__
    else
    {
    // build a vcalendr file and send event to parent

        srv_tdl_event_struct *buffer;
        VFX_ALLOC_MEM(buffer,sizeof(srv_tdl_event_struct),this);
        if ( srv_tdl_event_get(
                    buffer, 
                    sizeof(srv_tdl_event_struct), 
                    m_eventbuffer[pos.group][pos.pos].source_id,
                    m_eventbuffer[pos.group][pos.pos].event_id
                    ) == SRV_TDL_RESULT_OK)

        {

            if (VappCalUtility::buildTempVcalFile(path, (void*)buffer, SRV_TDL_VCAL_EVENT, VAPP_CAL_BUILD_FOLDER_FOR_UC) != NULL)
            {

                VFX_FREE_MEM(buffer);
                // send event with path;
                vcui_cal_list_result_struct evt;
                MMI_FRM_INIT_GROUP_EVENT(&evt, EVT_ID_CUI_CAL_ITEM_SELECTED, getApp()->getGroupId());

                evt.path = path;

                getApp()->sendToCaller((mmi_group_event_struct*)&evt);
            }

        }


        VFX_FREE_MEM(buffer);
       
    }
#endif
}

void VappCalGroupListPage::onListMenuLongTap(VcpGroupListMenu *sender, VcpMenuPos pos)
{
    VFX_ASSERT(pos.group >= VAPP_CAL_G_LIST_INCOMING && pos.group < VAPP_CAL_G_LIST_TOTAL);

    if (m_listMenu->getMenuMode() != VCP_LIST_MENU_MODE_NORMAL)
    {
        return;
    }

    vfx_adp_touch_fb_play(VFX_ADP_TOUCH_FB_TYPE_HOLD);

    m_selPos.group = pos.group;
    m_selPos.pos = pos.pos;

    srv_tdl_event_struct *buffer;
    VFX_ALLOC_MEM(buffer,sizeof(srv_tdl_event_struct),this);
    srv_tdl_event_get(
                buffer, 
                sizeof(srv_tdl_event_struct), 
                m_eventbuffer[m_selPos.group][m_selPos.pos].source_id,
                m_eventbuffer[m_selPos.group][m_selPos.pos].event_id);


    VcpMenuPopup *opList;
    VFX_OBJ_CREATE(opList, VcpMenuPopup, this);
    opList->setTitle((VfxWChar *)buffer->subject);
    opList->addItem(0, (VfxResId)STR_ID_VAPP_CAL_DELETE);

    if (buffer->src_id != SRV_TDL_EVENT_SOURCE_LOCAL)
    {
        opList->removeItem(opList->getItemById(0));
        opList->addItem(1, (VfxResId)STR_ID_VAPP_CAL_CANCEL);
    }

    opList->m_signalMenuCallback.connect(this, &VappCalGroupListPage::onOpListClicked);
    opList->show(VFX_TRUE);

    m_opListWeakPtr = opList;
    VFX_FREE_MEM(buffer);

}

void VappCalGroupListPage::onOpListClicked(VcpMenuPopup* sender, VcpMenuPopupEventEnum evtEnum, VcpMenuPopupItem* item)
{
    if (evtEnum == VCP_MENU_POPUP_EVENT_ITEM_SELECTED && item->getId() == 0)
    {

        srv_tdl_event_struct *buffer;
        VFX_ALLOC_MEM(buffer,sizeof(srv_tdl_event_struct),this);
        srv_tdl_event_get(
                buffer, 
                sizeof(srv_tdl_event_struct), 
                m_eventbuffer[m_selPos.group][m_selPos.pos].source_id,
                m_eventbuffer[m_selPos.group][m_selPos.pos].event_id);

        VcpConfirmPopup *confirmPopup;
        VFX_OBJ_CREATE(confirmPopup, VcpConfirmPopup, this);
        confirmPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
        confirmPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_USER_DEFINE);
        confirmPopup->setCustomButton(
                        (VfxResId)STR_ID_VAPP_CAL_DELETE,
                        (VfxResId)STR_ID_VAPP_CAL_CANCEL,
                        VCP_POPUP_BUTTON_TYPE_WARNING,
                        VCP_POPUP_BUTTON_TYPE_CANCEL);
        if (!buffer->repeat.rule)
        {
            confirmPopup->setText((VfxResId)STR_ID_VAPP_CAL_DELETE_EVENT_ASK);
        }
        else
        {
            confirmPopup->setText((VfxResId)STR_ID_VAPP_CAL_DELETE_ALL_REPEAT_ASK);
        }

        confirmPopup->setAutoDestory(VFX_TRUE);    
        confirmPopup->m_signalButtonClicked.connect(this, &VappCalGroupListPage::onLongPressDelConfirm);
        confirmPopup->show(VFX_TRUE);

        m_confirmPopupWeakPtr = confirmPopup;
        VFX_FREE_MEM(buffer);
    }
    else
    {
        if (m_opListWeakPtr.isValid())
        {
            VcpMenuPopup *temp = m_opListWeakPtr.get();
            VFX_OBJ_CLOSE(temp);
        }
    }

}

void VappCalGroupListPage::onSelListMenuClicked(
                    VcpGroupListMenu * sender, 
                    VcpMenuPos pos,        
                    VcpListMenuItemStateEnum state)
{
    VFX_ASSERT(pos.group >= VAPP_CAL_G_LIST_INCOMING && pos.group < VAPP_CAL_G_LIST_TOTAL);

    if (m_listMenu->getMenuMode() != VCP_LIST_MENU_MODE_MULTI_SELECTION)
    {
        return;
    }

    m_listEventSel[pos.group][pos.pos] = state;


    if (state == VCP_LIST_MENU_ITEM_STATE_SELECTED)
    {
        m_markedCount++;
    }
    else if (state == VCP_LIST_MENU_ITEM_STATE_UNSELECTED)
    {
        m_markedCount--;
    }
    else
    {
        return;
    }

    if (m_markedCount == 0)
    {
        m_toolBar->setDisableItem(VAPP_CAL_SEL_LIST_DELETE, VFX_TRUE);
    }
    else
    {
        m_toolBar->setDisableItem(VAPP_CAL_SEL_LIST_DELETE, VFX_FALSE);
    }

    if (m_markedCount == getTotalCount())
    {
        m_toolBar->changeItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_UNMARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_UNSELECT_ALL);
        m_markAllBtn = VFX_FALSE;
    }
    else if (m_markedCount == 0)
    {
        m_toolBar->changeItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_MARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
        m_markAllBtn = VFX_TRUE;
    }
    else
    {
        m_toolBar->changeItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_MARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
        m_markAllBtn = VFX_TRUE;
    }
}

void VappCalGroupListPage::onLongPressDelConfirm(VfxObject* sender, VfxId id)
{
    if (id == VCP_CONFIRM_POPUP_BUTTON_USER_1)
    {

        if (srv_tdl_event_delete(SRV_TDL_EVENT_SOURCE_LOCAL,m_eventbuffer[m_selPos.group][m_selPos.pos].event_id) == SRV_TDL_RESULT_OK)
        {
            m_isMutiDelProcessing = VFX_FALSE;
        }


    }
}

void VappCalGroupListPage::onSelListDelConfirm(VfxObject* sender, VfxId id)
{        
    if (id == VCP_CONFIRM_POPUP_BUTTON_USER_1)
    {
        m_toolBar->removeItem(VAPP_CAL_SEL_LIST_MARK_ALL);
        m_toolBar->removeItem(VAPP_CAL_SEL_LIST_DELETE);
        m_toolBar->removeItem(VAPP_CAL_SEL_LIST_CANCEL);

        m_toolBar->addItem(VAPP_CAL_G_LIST_ADD, (VfxResId)STR_ID_VAPP_CAL_ADD, VCP_IMG_TOOL_BAR_COMMON_ITEM_ADD);
        
#ifdef __MMI_CAL_EXPIRY__
        m_toolBar->addItem(VAPP_CAL_G_LIST_EXPIRED, (VfxResId)STR_ID_VAPP_CAL_EXPIRED, IMG_ID_VAPP_CAL_EXPIRED);
#endif
#ifndef __LOW_COST_SUPPORT_COMMON__
        m_toolBar->addItem(VAPP_CAL_G_LIST_SEARCH, (VfxResId)STR_GLOBAL_SEARCH, VCP_IMG_TOOL_BAR_COMMON_ITEM_SEARCH);
#endif
        m_toolBar->addItem(VAPP_CAL_G_LIST_DELETE, (VfxResId)STR_ID_VAPP_CAL_DELETE, VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);
        m_titleBar->setTitle(STR_ID_VAPP_CAL_EVENTS);

        m_isMutiDelProcessing = VFX_TRUE;
        setDataChangeState(VFX_TRUE);
        VfxU16 count;
        for (VfxU32 i = VAPP_CAL_G_LIST_INCOMING; i < VAPP_CAL_G_LIST_TOTAL; i++)
        {
            count = m_listCount[i];
            for (VfxU32 j = 0; j < count; j++)
            {
                if (m_listEventSel[i][j] == VCP_LIST_MENU_ITEM_STATE_SELECTED)
                {
                    srv_tdl_event_delete(m_eventbuffer[i][j].source_id,m_eventbuffer[i][j].event_id);
                }
   
            }
        }
        m_isMutiDelProcessing = VFX_FALSE;
        setDataChangeState(VFX_FALSE);
        m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_NORMAL, VFX_TRUE);


        srv_tdl_event_op_struct param;
        MMI_FRM_INIT_EVENT(&param, EVT_ID_SRV_TDL_EVENT_OP);
        param.op_type = SRV_TDL_OP_DELETE;
        //param.event_id = m_eventbuffer[m_selPos.group][m_selPos.pos].event_id;
        //param.source_id = m_eventbuffer[m_selPos.group][m_selPos.pos].source_id;
        param.user_data = getObjHandle();

        //MMI_FRM_CB_EMIT_EVENT((mmi_event_struct*)&param);

        // for mutil delition, we only update once after all items are deleted
        //updateCalGroupListPage((mmi_event_struct*)&param);

        updateCalEventGroupListPage((mmi_event_struct*)&param);

    }
}

void VappCalGroupListPage::setSelListState(VcpListMenuItemStateEnum state)
{
    
    for (VfxU32 i = VAPP_CAL_G_LIST_INCOMING; i < VAPP_CAL_G_LIST_TOTAL; i++)
    {
        for (VfxU32 j = 0; j < m_listCount[i]; j++)
        {

            m_listEventSel[i][j] = state;

        }
    }
}



mmi_ret VappCalGroupListPage::updateSNSListData(mmi_event_struct *param)
{

    VfxObject *obj = handleToObject((VfxObjHandle)param->user_data);
   
    VappCalGroupListPage *page = VFX_OBJ_DYNAMIC_CAST(obj,VappCalGroupListPage);
    if(page == NULL) return MMI_RET_OK;
    
    srv_tdl_event_id_struct *Pbuffer = NULL;
    VfxS32 *PjobId = NULL;

    srv_tdl_search_callback_struct* sEvent = (srv_tdl_search_callback_struct*)param;
    if(!sEvent->success)
    { 
        VappCalUtility::getSnsDataError();	 
    }
  
    if(sEvent->job_id == page->m_jobId[VAPP_CAL_G_LIST_INCOMING])
    {
        page->m_listCount[VAPP_CAL_G_LIST_INCOMING] = sEvent->event_cnt;
        if(sEvent->event_cnt != 0)
        {
            VFX_ALLOC_MEM(page->m_eventbuffer[VAPP_CAL_G_LIST_INCOMING], sEvent->event_cnt * sizeof(srv_tdl_event_id_struct),page);
            Pbuffer = page->m_eventbuffer[VAPP_CAL_G_LIST_INCOMING];

        }
        PjobId = &(page->m_jobId[VAPP_CAL_G_LIST_INCOMING]);
    }
    else if(sEvent->job_id == page->m_jobId[VAPP_CAL_G_LIST_OLD])
    {
        page->m_listCount[VAPP_CAL_G_LIST_OLD] = sEvent->event_cnt;
        if(sEvent->event_cnt != 0)
        {

            VFX_ALLOC_MEM(page->m_eventbuffer[VAPP_CAL_G_LIST_OLD], sEvent->event_cnt * sizeof(srv_tdl_event_id_struct),page);
            Pbuffer = page->m_eventbuffer[VAPP_CAL_G_LIST_OLD];
        }
        PjobId = &(page->m_jobId[VAPP_CAL_G_LIST_OLD]);
    }
    else
    {
        return MMI_RET_OK;
    }
  
    if((sEvent->event_cnt)&&srv_tdl_event_search_get(sEvent->job_id, Pbuffer,sEvent->event_cnt * sizeof(srv_tdl_event_id_struct) , 0) < 0)
    {
        VFX_ASSERT(0);
    }

    srv_tdl_event_search_end(*PjobId);
    *PjobId = TDL_MAX_EVENT_SEARCH_COUNT +1;


    if((page->m_jobId[VAPP_CAL_G_LIST_INCOMING] == TDL_MAX_EVENT_SEARCH_COUNT + 1)&&(page->m_jobId[VAPP_CAL_G_LIST_OLD] == TDL_MAX_EVENT_SEARCH_COUNT +1))
    {
        mmi_frm_cb_dereg_event(EVT_ID_SRV_TDL_EVENT_SEARCH, VappCalGroupListPage::updateSNSListData, page->getObjHandle());

        page->m_stringId = STR_ID_VAPP_CAL_NO_EVTS;
        page->GetlistMenu()->reset();

        page->m_jobId[0] = -1; 
        page->m_jobId[1] = -1; 

        page->setBar(VFX_PAGE_BAR_LOCATION_BOTTOM,NULL,VFX_TRUE);
        
#ifdef __MMI_VCALENDAR__
        if(page->m_entryType == VAPP_CAL_G_LIST_ENTRY_UC)
        {
            return MMI_RET_OK;
        }
#endif

        VFX_OBJ_CREATE(page->m_toolBar, VcpToolBar, page);
        page->m_toolBar->addItem(VAPP_CAL_G_LIST_ADD, (VfxResId)STR_ID_VAPP_CAL_ADD, VCP_IMG_TOOL_BAR_COMMON_ITEM_ADD);	
#ifndef __LOW_COST_SUPPORT_COMMON__
        page->m_toolBar->addItem(VAPP_CAL_G_LIST_SEARCH, (VfxResId)STR_ID_VAPP_CAL_SEARCH, VCP_IMG_TOOL_BAR_COMMON_ITEM_SEARCH);
#endif

#ifdef __MMI_SNS_CALENDAR__
        page->m_toolBar->addItem(VAPP_CAL_G_LIST_FILTER, (VfxResId)STR_ID_VAPP_SNS_FILTER, IMG_ID_VAPP_SNS_TOOL_BAR_FILTER_ICN);
        page->m_toolBar->addItem(VAPP_CAL_G_LIST_MORE, (VfxResId)VCP_STR_TOOL_BAR_MORE, VCP_IMG_TOOL_BAR_COMMON_ITEM_MORE);
#else
#ifdef __MMI_CAL_EXPIRY__
        page->m_toolBar->addItem(VAPP_CAL_G_LIST_EXPIRED, (VfxResId)STR_ID_VAPP_CAL_EXPIRED, IMG_ID_VAPP_CAL_EXPIRED);
#endif
        page->m_toolBar->addItem(VAPP_CAL_G_LIST_DELETE, (VfxResId)STR_ID_VAPP_CAL_DELETE, VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);
#endif  /*__MMI_SNS_CALENDAR__*/

        page->m_toolBar->m_signalButtonTap.connect(page, &VappCalGroupListPage::onToolBarClicked);
        page->setBottomBar(page->m_toolBar);


        for(VfxU32 i = VAPP_CAL_G_LIST_INCOMING; i < VAPP_CAL_G_LIST_TOTAL; ++i)
        {
            if(page->m_listCount[i])
            {
                VFX_ALLOC_MEM(page->m_listEventSel[i],page->m_listCount[i]*sizeof(VcpListMenuItemStateEnum),page);
                memset(page->m_listEventSel[i], 1, page->m_listCount[i]*sizeof(VcpListMenuItemStateEnum));
            }
        }
        if(page->GetlistMenu()->getMenuMode() == VCP_LIST_MENU_MODE_NORMAL)
        {
            page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_ADD, VFX_FALSE);
            if (page->getTotalCount() == 0)
            {
#ifndef __LOW_COST_SUPPORT_COMMON__
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_SEARCH, VFX_TRUE);
#endif
#ifdef __MMI_SNS_CALENDAR__
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_MORE, VFX_TRUE);
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_FILTER, VFX_FALSE);
#else
#ifdef __MMI_CAL_EXPIRY__
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_EXPIRED, VFX_TRUE);
#endif
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_DELETE, VFX_TRUE);
#endif

            }
            else
            {
#ifndef __LOW_COST_SUPPORT_COMMON__
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_SEARCH, VFX_FALSE);
#endif
#ifdef __MMI_SNS_CALENDAR__
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_MORE, VFX_FALSE);
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_FILTER, VFX_FALSE);
#else
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_DELETE, VFX_FALSE);
#ifdef __MMI_CAL_EXPIRY__
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_EXPIRED, VFX_FALSE);
#endif
#endif
            }

        }
        else if(page->GetlistMenu()->getMenuMode() == VCP_LIST_MENU_MODE_MULTI_SELECTION)
        {
            if (page->getTotalCount() == 0)
            {
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_ADD, VFX_FALSE);
#ifndef __LOW_COST_SUPPORT_COMMON__
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_SEARCH, VFX_TRUE);
#endif
#ifdef __MMI_SNS_CALENDAR__
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_MORE, VFX_TRUE);
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_FILTER, VFX_FALSE);
#else
#ifdef __MMI_CAL_EXPIRY__
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_EXPIRED, VFX_TRUE);
#endif
                page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_DELETE, VFX_TRUE);
#endif

            }
            else
            {
                page->m_toolBar->removeAllItems();
                page->m_toolBar->addItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_MARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
                page->m_toolBar->addItem(VAPP_CAL_SEL_LIST_DELETE, (VfxResId)STR_ID_VAPP_CAL_DELETE, VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);
                page->m_toolBar->addItem(VAPP_CAL_SEL_LIST_CANCEL, (VfxResId)STR_ID_VAPP_CAL_CANCEL, VCP_IMG_TOOL_BAR_COMMON_ITEM_CANCEL);
                page->m_toolBar->setDisableItem(VAPP_CAL_SEL_LIST_DELETE, VFX_TRUE);

                page->m_titleBar->setTitle(STR_ID_VAPP_CAL_DELETE_EVENT_TITLE);

                page->m_markAllBtn = VFX_TRUE;
                page->m_markedCount = 0;
            }
        }

        if((page->m_fliterid != SRV_TDL_EVENT_SOURCE_LOCAL)&&(page->m_fliterid != SRV_TDL_EVENT_SOURCE_TOTAL))
        {
            page->m_toolBar->setDisableItem(VAPP_CAL_G_LIST_DELETE, VFX_TRUE);
        }
        page->GetlistMenu()->reset();

    }
  
    return MMI_RET_OK;
 
}


void VappCalGroupListPage::GetSnsData()
{
    closeJob();
    m_stringId = STR_GLOBAL_LOADING;

    srv_tdl_search_filter_struct search_info;

    GetDateTime(&search_info.u.date_time);
    search_info.u.date_time.nSec = 0;
    
#ifdef __MMI_VCALENDAR__
    if(m_entryType == VAPP_CAL_G_LIST_ENTRY_UC)
    {
        srv_tdl_set_source_state(MMI_TRUE, SRV_TDL_EVENT_SOURCE_TOTAL);	
    }
#endif

    for(VfxU32 i = VAPP_CAL_G_LIST_INCOMING; i < VAPP_CAL_G_LIST_TOTAL; ++i)
    {
        if (i)
        {
            search_info.type = SRV_TDL_SEARCH_TYPE_PREVIOUS;
        }
        else
        {
            search_info.type = SRV_TDL_SEARCH_TYPE_INCOMING;
        }
        if(m_listMenu->getMenuMode() == VCP_LIST_MENU_MODE_MULTI_SELECTION)
        {
            m_jobId[i] = srv_tdl_event_search_begin(&search_info, SRV_TDL_EVENT_SORT_START_TIME,SRV_TDL_EVENT_SOURCE_LOCAL);
        }
        else
        {
            m_jobId[i] = srv_tdl_event_search_begin(&search_info, SRV_TDL_EVENT_SORT_START_TIME,m_fliterid);
        }

    }
    if((m_jobId[0] > 0)&&(m_jobId[1] > 0))
    {

        setDataChangeState(VFX_FALSE);
        mmi_frm_cb_reg_event(EVT_ID_SRV_TDL_EVENT_SEARCH, VappCalGroupListPage::updateSNSListData, getObjHandle());
    }
    else
    { 
        m_stringId = STR_ID_VAPP_CAL_NO_EVTS;
    }

}


VcpGroupListMenu * VappCalGroupListPage::GetlistMenu() const
{
    return m_listMenu;
}


VfxU16 VappCalGroupListPage::getTotalCount() const
{
    VfxU16 totalCount = 0;
    for (VfxU32 i = VAPP_CAL_G_LIST_INCOMING; i < VAPP_CAL_G_LIST_TOTAL; i++)
    {
        totalCount = totalCount + m_listCount[i];
    }

    return totalCount;
}



VfxBool VappCalGroupListPage::getItemText(
                                VcpMenuPos pos,                  
                                VcpListMenuFieldEnum fieldType,  
                                VfxWString &text,                
                                VcpListMenuTextColorEnum &color)
{
    VFX_ASSERT(pos.group >= VAPP_CAL_G_LIST_INCOMING && pos.group < VAPP_CAL_G_LIST_TOTAL);

    if(fieldType == VCP_LIST_MENU_FIELD_GROUP_HEADER_TEXT)
    {
        if (pos.group == VAPP_CAL_G_LIST_OLD)
        {
            text = VfxWString((VfxResId)STR_ID_VAPP_CAL_OLD_EVT);
        }
        else
        {
            text = VfxWString((VfxResId)STR_ID_VAPP_CAL_INCOMING_EVT);
        }


        color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;

        return VFX_TRUE;
    }

    srv_tdl_event_struct *buffer;
    VFX_ALLOC_MEM(buffer,sizeof(srv_tdl_event_struct),this);
    srv_tdl_event_get(
    buffer, 
    sizeof(srv_tdl_event_struct),
    m_eventbuffer[pos.group][pos.pos].source_id,
    m_eventbuffer[pos.group][pos.pos].event_id);



    switch(fieldType)
    {
    case VCP_LIST_MENU_FIELD_TEXT:
        text.loadFromMem((VfxWChar*) buffer->subject);
        break;

    case VCP_LIST_MENU_FIELD_SUB_TEXT1:
    case VCP_LIST_MENU_FIELD_SUB_TEXT2:
        VappCalUtility::getListItemDateTimeStr(fieldType, SRV_TDL_VCAL_EVENT, buffer, text);
        break;
    default:
        break;

    }

    color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;
    VFX_FREE_MEM(buffer);


    return VFX_TRUE;
}

VfxBool VappCalGroupListPage::getItemImage(
                                VcpMenuPos pos,                  
                                VcpListMenuFieldEnum fieldType,  
                                VfxImageSrc &image)
{
    VFX_ASSERT(pos.group >= VAPP_CAL_G_LIST_INCOMING && pos.group < VAPP_CAL_G_LIST_TOTAL);

    VappCalDailyList::setItemImagebyIdx(m_eventbuffer[pos.group][pos.pos],fieldType,image,this);

    return VFX_TRUE;
}

VfxU32 VappCalGroupListPage::getCount(VfxU32 group) const
{
    VFX_ASSERT(group < VAPP_CAL_G_LIST_TOTAL);

    return m_listCount[group];
}

VfxU32 VappCalGroupListPage::getGroupCount() const
{
    if (!getTotalCount())
    {
        return 0;
    }
    return VAPP_CAL_G_LIST_TOTAL;
}

VfxBool VappCalGroupListPage::getMenuEmptyText(VfxWString &text,VcpListMenuTextColorEnum &color)
{
   
    text.loadFromRes((VfxResId)m_stringId);

    color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;
    return VFX_TRUE;
}

VcpListMenuItemStateEnum VappCalGroupListPage::getItemState(VcpMenuPos pos) const
{
    VFX_ASSERT(pos.group >= VAPP_CAL_G_LIST_INCOMING && pos.group < VAPP_CAL_G_LIST_TOTAL);
    return m_listEventSel[pos.group][pos.pos];

}

VfxBool VappCalGroupListPage::hasGroupHeader(VfxS32 group) const
{
    if (m_listCount[group] == 0)
    {
        return VFX_FALSE;
    }
    else
    {
        return VFX_TRUE;
    }
}


void VappCalGroupListPage::closeJob()
{
    for (VfxU32 i = VAPP_CAL_G_LIST_INCOMING; i < VAPP_CAL_G_LIST_TOTAL; i++)
    {
        m_listCount[i] = 0;
        if (m_eventbuffer[i])
        {
            VFX_FREE_MEM(m_eventbuffer[i]);
        }
        if (m_listEventSel[i])
        {
            VFX_FREE_MEM(m_listEventSel[i]);
        }

        if (m_jobId[i] > 0)
        {
            srv_tdl_event_search_end(m_jobId[i]);
            mmi_frm_cb_dereg_event(EVT_ID_SRV_TDL_EVENT_SEARCH, VappCalGroupListPage::updateSNSListData, getObjHandle());
            m_jobId[i] = -1;
        }
    }
}


void VappCalGroupListPage::updateCalGroupListPageInt()
{
    GetSnsData();
    m_listMenu->reset();//AllItems(VFX_FALSE);
}


mmi_ret VappCalGroupListPage::updateCalEventGroupListPage(mmi_event_struct *param)
{
    VfxObject *obj = handleToObject((VfxObjHandle)param->user_data);
    
    VappCalGroupListPage *page = VFX_OBJ_DYNAMIC_CAST(obj,VappCalGroupListPage);
    if (page == NULL)
    {
        return MMI_RET_OK;
    }
    srv_tdl_event_op_struct *event = (srv_tdl_event_op_struct *)param;

    page->closeDeletePopup();

    // for deletion, should distinguish single deletion and muti deletion;
    if (event->op_type == SRV_TDL_OP_DELETE && page->m_isMutiDelProcessing == VFX_TRUE )
    {
        return MMI_RET_OK;
    }
    if (!page->isActive())
    {
        page->setDataChangeState(VFX_TRUE);
        return MMI_RET_OK;
    }
    page->updateCalGroupListPageInt();
    return MMI_RET_OK;

}


void VappCalGroupListPage::closeDeletePopup()
{
    if (m_confirmPopupWeakPtr.isValid())
    {
        VcpConfirmPopup *popup = m_confirmPopupWeakPtr.get();
        VFX_OBJ_CLOSE(popup);
    }
    if (m_opListWeakPtr.isValid())
    {
        VcpMenuPopup *menuPopup = m_opListWeakPtr.get();
        VFX_OBJ_CLOSE(menuPopup);
    }

}


#if defined(__MMI_VCALENDAR__)
mmi_ret VappCalGroupListPage::updateCalGroupListPage(mmi_event_struct *param)
{
    VfxObject *obj = handleToObject((VfxObjHandle)param->user_data);
    if (obj == NULL)
    {
        return MMI_RET_OK;
    }
    VappCalGroupListPage *page = VFX_OBJ_DYNAMIC_CAST(obj,VappCalGroupListPage);
    if (page == NULL)
    {
        return MMI_RET_OK;
    }

    srv_tdl_op_evt_struct *event = (srv_tdl_op_evt_struct *)param;
    page->closeDeletePopup();


    // for deletion, should distinguish single deletion and muti deletion;
    if (event->op_type == SRV_TDL_OP_DELETE && page->m_isMutiDelProcessing == VFX_TRUE)
    {
        return MMI_RET_OK;
    }

    if (!page->isActive())
    {
        page->setDataChangeState(VFX_TRUE);
        return MMI_RET_OK;
    }
    page->updateCalGroupListPageInt();

    return MMI_RET_OK;

}
#endif

#ifdef __MMI_CAL_EXPIRY__
/***************************************************************************** 
 * Class VappCalGroupListPage
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappCalExpiredListPage", VappCalExpiredListPage, VfxPage);
void VappCalExpiredListPage::onInit()
{
    VfxPage::onInit();

    mmi_frm_cb_reg_event(EVT_ID_SRV_TDL_EVENT_OP, updateCalExpiredListPage, getObjHandle());
    mmi_frm_cb_reg_event(EVT_ID_SRV_TDL_OP, updateCalExpiredListPage, getObjHandle());

    m_eventbuffer = NULL;
    m_jobId = -1; 
    m_count = 0;
    m_markedCount = 0;
    m_listEventSel = NULL;
    m_markAllBtn = VFX_FALSE;
    GetSnsData(SRV_TDL_EVENT_SOURCE_TOTAL);
    setDataChangeState(VFX_FALSE);


    VFX_OBJ_CREATE(m_titleBar, VcpTitleBar, this);
    m_titleBar->setTitleStyle(VCP_TITLE_BAR_STYLE_BASE);
    m_titleBar->setTitle((VfxResId)STR_ID_VAPP_CAL_SELECT_EXPIRED);
    setTopBar(m_titleBar);


    VFX_OBJ_CREATE(m_listMenu, VcpListMenu, this);
    m_listMenu->setContentProvider((IVcpListMenuContentProvider*)this);
    m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT_EX);
    m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_NORMAL, VFX_TRUE);
    m_listMenu->setPos(0, 0);
    m_listMenu->setSize(getSize());
    m_listMenu->setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE,
                            VFX_FRAME_ALIGNER_MODE_SIDE, 
                            VFX_FRAME_ALIGNER_MODE_SIDE, 
                            VFX_FRAME_ALIGNER_MODE_SIDE);
    m_listMenu->m_signalItemSelectionStateChanged.connect(this, &VappCalExpiredListPage::onSelListMenuClicked);
    m_listMenu->m_signalItemTapped.connect(this, &VappCalExpiredListPage::onListMenuClicked);
    m_listMenu->m_signalItemLongTapped.connect(this, &VappCalExpiredListPage::onListMenuLongTap);

    m_isMutiDelProcessing = VFX_FALSE;
    m_dataChangedType = SRV_TDL_OP_TOTAL;
}

void VappCalExpiredListPage::onDeinit()
{
  
    if (m_jobId>=0)
    {
        mmi_frm_cb_dereg_event(EVT_ID_SRV_TDL_EVENT_SEARCH, VappCalExpiredListPage::updateSNSListData, getObjHandle());
        srv_tdl_event_search_end(m_jobId);
        m_jobId = -1;
    }

    VFX_FREE_MEM(m_eventbuffer);


    VFX_FREE_MEM(m_listEventSel);


    mmi_frm_cb_dereg_event(EVT_ID_SRV_TDL_EVENT_OP, updateCalExpiredListPage, getObjHandle());
    mmi_frm_cb_dereg_event(EVT_ID_SRV_TDL_OP, updateCalExpiredListPage, getObjHandle());

    VfxPage::onDeinit();
}



mmi_ret VappCalExpiredListPage::updateSNSListData(mmi_event_struct *param)
{
    srv_tdl_search_callback_struct* sEvent = (srv_tdl_search_callback_struct*)param;

    VfxObject *obj = handleToObject((VfxObjHandle)param->user_data);
    
    VappCalExpiredListPage *page = VFX_OBJ_DYNAMIC_CAST(obj,VappCalExpiredListPage);

    if (page == NULL) 
    {
        return MMI_RET_OK;
    }

    if (sEvent->job_id != page->m_jobId)
        return MMI_RET_OK;

    if (!sEvent->success)
    { 
        VappCalUtility::getSnsDataError();	 
    }

    if (sEvent->job_id == page->m_jobId)
    {
        page->m_count = sEvent->event_cnt;
        if (page->m_count != 0)
        {
            VFX_ALLOC_MEM(page->m_eventbuffer, sEvent->event_cnt * sizeof(srv_tdl_event_id_struct),page);
            if (srv_tdl_event_search_get(page->m_jobId, page->m_eventbuffer, page->m_count * sizeof(srv_tdl_event_id_struct) , 0) < 0)
            {
                VFX_ASSERT(0);
            }
        }
    }
 

    page->m_stringId = STR_ID_VAPP_CAL_NO_EVTS;
    page->GetlistMenu()->reset();

    srv_tdl_event_search_end(sEvent->job_id);   
    mmi_frm_cb_dereg_event(EVT_ID_SRV_TDL_EVENT_SEARCH, VappCalExpiredListPage::updateSNSListData, page->getObjHandle());
    page->m_jobId = -1;

    if (page->m_count == 0)
    {
        if (page->getBar(VFX_PAGE_BAR_LOCATION_BOTTOM))
        {
            page->setBar(VFX_PAGE_BAR_LOCATION_BOTTOM,NULL,VFX_TRUE);
        }
    }
    else
    {
        if (page->m_listEventSel)
        {
            VFX_FREE_MEM(page->m_listEventSel);
            page->m_listEventSel = NULL;

        }
        VFX_ALLOC_MEM(page->m_listEventSel,page->m_count*sizeof(VcpListMenuItemStateEnum),page);
        memset(page->m_listEventSel, VCP_LIST_MENU_ITEM_STATE_UNSELECTED, page->m_count*sizeof(VcpListMenuItemStateEnum));

        if (!page->getBar(VFX_PAGE_BAR_LOCATION_BOTTOM))
        {
            VFX_OBJ_CREATE(page->m_toolBar, VcpToolBar, page);
            page->m_toolBar->m_signalButtonTap.connect(page, &VappCalExpiredListPage::onToolBarClicked);
            page->setBottomBar(page->m_toolBar);
            page->m_toolBar->addItem(VAPP_CAL_LIST_DELETE, (VfxResId)STR_ID_VAPP_CAL_DELETE, VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);
        }
        //if(page->GetlistMenu()->getMenuMode() != VCP_LIST_MENU_MODE_NORMAL)

        if (page->m_markAllBtn)
        {
            page->m_toolBar->removeItem(VAPP_CAL_LIST_DELETE);
            page->m_toolBar->addItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_MARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
            page->m_toolBar->addItem(VAPP_CAL_SEL_LIST_DELETE, (VfxResId)STR_ID_VAPP_CAL_DELETE, VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);
            page->m_toolBar->addItem(VAPP_CAL_SEL_LIST_CANCEL, (VfxResId)STR_ID_VAPP_CAL_CANCEL, VCP_IMG_TOOL_BAR_COMMON_ITEM_CANCEL);
            page->m_toolBar->setDisableItem(VAPP_CAL_SEL_LIST_DELETE, VFX_TRUE);
            page->m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_MULTI_SELECTION, VFX_TRUE);
        }
        else 
        {
            page->m_toolBar->addItem(VAPP_CAL_LIST_DELETE, (VfxResId)STR_ID_VAPP_CAL_DELETE, VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);
            page->m_toolBar->removeItem(VAPP_CAL_SEL_LIST_MARK_ALL);
            page->m_toolBar->removeItem(VAPP_CAL_SEL_LIST_DELETE);
            page->m_toolBar->removeItem(VAPP_CAL_SEL_LIST_CANCEL);

            page->m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_NORMAL, VFX_TRUE);

        }

    }

    return MMI_RET_OK;
 
}


void VappCalExpiredListPage::GetSnsData(srv_tdl_event_source_enum type)
{
    if (m_count > 0)
    {
        m_jobId = -1; 
        m_count = 0;
        m_markedCount = 0;
    }
    if (m_eventbuffer)
    {
        VFX_FREE_MEM(m_eventbuffer);
    }
    if (m_listEventSel)
    {
        VFX_FREE_MEM(m_listEventSel);

    }
    if (m_jobId > 0)
    {
        srv_tdl_event_search_end(m_jobId);         
        mmi_frm_cb_dereg_event(EVT_ID_SRV_TDL_EVENT_SEARCH, VappCalExpiredListPage::updateSNSListData, getObjHandle());
        m_jobId = -1;
    }

    m_stringId = STR_GLOBAL_LOADING;

    srv_tdl_search_filter_struct search_info;

    GetDateTime(&search_info.u.date_time);
    search_info.u.date_time.nSec = 0;

    //srv_tdl_set_source_state(MMI_TRUE, type);	

    search_info.type = SRV_TDL_SEARCH_TYPE_BEFORE;
    m_jobId = srv_tdl_event_search_begin(&search_info, SRV_TDL_EVENT_SORT_START_TIME,type);
    if (m_jobId > 0)
    {
        mmi_frm_cb_reg_event(EVT_ID_SRV_TDL_EVENT_SEARCH, VappCalExpiredListPage::updateSNSListData, getObjHandle());
    }
    else
    { 
        VFX_ASSERT(0);
    }
    if (getBar(VFX_PAGE_BAR_LOCATION_BOTTOM))
    {
        setBar(VFX_PAGE_BAR_LOCATION_BOTTOM,NULL,VFX_TRUE);
    }
}


VcpListMenu *VappCalExpiredListPage::GetlistMenu() const
{
    return m_listMenu;
}


void VappCalExpiredListPage::onEnter(VfxBool isBackward)
{
    VfxPage::onEnter(isBackward);

    if (m_dataChangedType == SRV_TDL_OP_ADD || m_dataChangedType == SRV_TDL_OP_UPDATE)
    {
        m_listMenu->setVisibleMenuRegion(m_selIdx, -1, VFX_FALSE);
    }

    m_dataChangedType = SRV_TDL_OP_TOTAL;
}


void VappCalExpiredListPage::onEntered()
{
    if (m_isDataChange)
    {
        setDataChangeState(VFX_FALSE);
        GetSnsData(SRV_TDL_EVENT_SOURCE_TOTAL);
        m_listMenu->resetAllItems(VFX_TRUE);
    }
}


void VappCalExpiredListPage::setDataChangeState(VfxBool isChanged)
{
    m_isDataChange = isChanged;
}

void VappCalExpiredListPage::onBack()
{
    if (m_listMenu->getMenuMode() == VCP_LIST_MENU_MODE_MULTI_SELECTION)	
    {
        m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_NORMAL, VFX_TRUE);
        m_titleBar->setTitle((VfxResId)STR_ID_VAPP_CAL_SELECT_EXPIRED);

        GetSnsData(SRV_TDL_EVENT_SOURCE_TOTAL);

        m_markAllBtn = VFX_FALSE;
    }
    else
    {
        VfxPage::onBack();
    }
}


void VappCalExpiredListPage::onToolBarClicked(VfxObject *sender, VfxId id)
{
    switch(id)
    {
        case VAPP_CAL_LIST_DELETE:
        {
            m_markAllBtn = VFX_TRUE;

            GetSnsData(SRV_TDL_EVENT_SOURCE_LOCAL);

            m_listMenu->resetAllItems(VFX_FALSE);
            m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_MULTI_SELECTION, VFX_TRUE);

            break;
        }
        case VAPP_CAL_SEL_LIST_MARK_ALL:
        {

            if (m_markedCount < m_count)
            {
                m_toolBar->changeItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_UNMARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_UNSELECT_ALL);
                for(VfxU32 k = 0; k< m_count; ++k)
                {
                    m_listEventSel[k] = VCP_LIST_MENU_ITEM_STATE_SELECTED;
                }
                //memset(m_listEventSel,0x10,m_count*sizeof(VcpListMenuItemStateEnum));
                m_markedCount = m_count;
            }
            else if (m_markedCount == m_count)
            {
                m_toolBar->changeItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_MARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
                //memset(m_listEventSel,0x01,m_count*sizeof(VcpListMenuItemStateEnum));
                for(VfxU32 k = 0; k< m_count; ++k)
                {
                    m_listEventSel[k] = VCP_LIST_MENU_ITEM_STATE_UNSELECTED;

                }
                m_markedCount = 0;
            }

            if (m_markedCount == 0)
            {
                m_toolBar->setDisableItem(VAPP_CAL_SEL_LIST_DELETE, VFX_TRUE);
            }
            else
            {
                m_toolBar->setDisableItem(VAPP_CAL_SEL_LIST_DELETE, VFX_FALSE);
            }
            m_listMenu->resetAllItems(VFX_TRUE);

            break;
        }
        case VAPP_CAL_SEL_LIST_DELETE:
        {

            VfxResId resId = (m_markedCount > 1) ? STR_ID_VAPP_CAL_DELETE_EVT : STR_ID_VAPP_CAL_DELETE_ONE_EVT;

            VfxWString str(resId);

            str += VFX_WSTR_RES(STR_ID_VAPP_CAL_LEFT_PARENTHESES);

            VfxWChar tempBuf[3];

            kal_wsprintf(tempBuf, "%d", m_markedCount);

            str += VFX_WSTR_MEM(tempBuf);
            str += VFX_WSTR_RES(STR_ID_VAPP_CAL_RIGHT_PARENTHESES);
            str += VFX_WSTR_RES(STR_ID_VAPP_CAL_QUESTION_MARK);

            VcpConfirmPopup *confirmPopup;

            VFX_OBJ_CREATE(confirmPopup, VcpConfirmPopup, this);
            confirmPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
            confirmPopup->setText(str);

            confirmPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_USER_DEFINE);
            confirmPopup->setCustomButton(
                                (VfxResId)STR_ID_VAPP_CAL_DELETE,
                                (VfxResId)STR_ID_VAPP_CAL_CANCEL,
                                VCP_POPUP_BUTTON_TYPE_WARNING,
                                VCP_POPUP_BUTTON_TYPE_CANCEL);

            confirmPopup->setAutoDestory(VFX_TRUE);    
            confirmPopup->m_signalButtonClicked.connect(this, &VappCalExpiredListPage::onSelListDelConfirm);
            confirmPopup->show(VFX_TRUE);

            m_confirmPopupWeakPtr = confirmPopup;

            break;
        }
        case VAPP_CAL_SEL_LIST_CANCEL:

            m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_NORMAL, VFX_TRUE);
            m_titleBar->setTitle((VfxResId)STR_ID_VAPP_CAL_SELECT_EXPIRED);
            GetSnsData(SRV_TDL_EVENT_SOURCE_TOTAL);
            m_markAllBtn = VFX_FALSE;

            break;

        default:
            break;
    }
}

void VappCalExpiredListPage::onListMenuClicked(VcpListMenu *sender, VfxU32 index)
{
    if (m_listMenu->getMenuMode() != VCP_LIST_MENU_MODE_NORMAL)
    {
        return;
    }

    VappCalViewDetailPage *viewPage;

    VFX_OBJ_CREATE_EX(
        viewPage, 
        VappCalViewDetailPage,
        getMainScr(),
        (SRV_TDL_VCAL_EVENT, m_eventbuffer[index]));

    getMainScr()->pushPage(0, viewPage);
}


void VappCalExpiredListPage::onListMenuLongTap(VcpListMenu *sender, VfxId id)
{
    if (m_listMenu->getMenuMode() != VCP_LIST_MENU_MODE_NORMAL)
    {
        return;
    }

    vfx_adp_touch_fb_play(VFX_ADP_TOUCH_FB_TYPE_HOLD);

    m_selIdx = id;

    srv_tdl_event_struct *buffer;
    VFX_ALLOC_MEM(buffer,sizeof(srv_tdl_event_struct),this);
    srv_tdl_event_get(
                buffer, 
                sizeof(srv_tdl_event_struct), 
                m_eventbuffer[id].source_id,
                m_eventbuffer[id].event_id);


    VcpMenuPopup *opList;
    VFX_OBJ_CREATE(opList, VcpMenuPopup, this);
    opList->setTitle((VfxWChar *)buffer->subject);
    opList->addItem(0, (VfxResId)STR_ID_VAPP_CAL_DELETE);
    opList->m_signalMenuCallback.connect(this, &VappCalExpiredListPage::onOpListClicked);
    if (buffer->src_id != SRV_TDL_EVENT_SOURCE_LOCAL)
    {
        opList->removeItem(opList->getItemById(0));
        opList->addItem(1, (VfxResId)STR_ID_VAPP_CAL_CANCEL);
    }
    opList->show(VFX_TRUE);

    VFX_FREE_MEM(buffer);
    m_opListWeakPtr = opList;
}


void VappCalExpiredListPage::onOpListClicked(VcpMenuPopup* sender, VcpMenuPopupEventEnum evtEnum, VcpMenuPopupItem* item)
{
    if (evtEnum == VCP_MENU_POPUP_EVENT_ITEM_SELECTED && item->getId() == 0)
    {

        srv_tdl_event_struct *buffer;
        VFX_ALLOC_MEM(buffer,sizeof(srv_tdl_event_struct),this);
        srv_tdl_event_get(
                    buffer, 
                    sizeof(srv_tdl_event_struct), 
                    m_eventbuffer[m_selIdx].source_id,
                    m_eventbuffer[m_selIdx].event_id);


        VcpConfirmPopup *confirmPopup;
        VFX_OBJ_CREATE(confirmPopup, VcpConfirmPopup, this);
        confirmPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
        confirmPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_USER_DEFINE);
        confirmPopup->setCustomButton(
                            (VfxResId)STR_ID_VAPP_CAL_DELETE,
                            (VfxResId)STR_ID_VAPP_CAL_CANCEL,
                            VCP_POPUP_BUTTON_TYPE_WARNING,
                            VCP_POPUP_BUTTON_TYPE_CANCEL);
        if (!buffer->repeat.rule)
        {
            confirmPopup->setText(VFX_WSTR_RES(STR_ID_VAPP_CAL_DELETE_EVENT_ASK));
        }
        else
        {
            confirmPopup->setText(VFX_WSTR_RES(STR_ID_VAPP_CAL_DELETE_ALL_REPEAT_ASK));
        }

        confirmPopup->setAutoDestory(VFX_TRUE);    
        confirmPopup->m_signalButtonClicked.connect(this, &VappCalExpiredListPage::onLongPressDelConfirm);
        confirmPopup->show(VFX_TRUE);

        m_confirmPopupWeakPtr = confirmPopup;
        VFX_FREE_MEM(buffer);
    }
}

void VappCalExpiredListPage::onSelListMenuClicked(
                    VcpListMenu * sender, 
                    VfxU32 index,        
                    VcpListMenuItemStateEnum state)
{
    m_listEventSel[index] = state;

    if (state == VCP_LIST_MENU_ITEM_STATE_SELECTED)
    {
        m_markedCount++;
    }
    else if (state == VCP_LIST_MENU_ITEM_STATE_UNSELECTED)
    {
        m_markedCount--;
    }
    else
    {
        return;
    }

    if (m_markedCount == 0)
    {
        m_toolBar->setDisableItem(VAPP_CAL_SEL_LIST_DELETE, VFX_TRUE);
    }
    else
    {
        m_toolBar->setDisableItem(VAPP_CAL_SEL_LIST_DELETE, VFX_FALSE);
    }

    if (m_markedCount == m_count)
    {
        m_toolBar->changeItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_UNMARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_UNSELECT_ALL);
        m_markAllBtn = VFX_FALSE;
    }
    else if (m_markedCount == 0)
    {
        m_toolBar->changeItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_MARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
        m_markAllBtn = VFX_TRUE;
    }
    else
    {
        m_toolBar->changeItem(VAPP_CAL_SEL_LIST_MARK_ALL, (VfxResId)STR_ID_VAPP_CAL_MARK_ALL, VCP_IMG_TOOL_BAR_COMMON_ITEM_SELECT_ALL);
        m_markAllBtn = VFX_TRUE;
    }
   
}


void VappCalExpiredListPage::onLongPressDelConfirm(VfxObject* sender, VfxId id)
{
    if (id == VCP_CONFIRM_POPUP_BUTTON_USER_1)
    {

        srv_tdl_event_delete(m_eventbuffer[m_selIdx].source_id,
        m_eventbuffer[m_selIdx].event_id);

    }
}


void VappCalExpiredListPage::onSelListDelConfirm(VfxObject* sender, VfxId id)
{    
    if (id == VCP_CONFIRM_POPUP_BUTTON_USER_1)
    {
        /*m_toolBar->removeItem(VAPP_CAL_SEL_LIST_MARK_ALL);
        m_toolBar->removeItem(VAPP_CAL_SEL_LIST_DELETE);
        m_toolBar->removeItem(VAPP_CAL_SEL_LIST_CANCEL);
        m_toolBar->addItem(VAPP_CAL_LIST_DELETE, VFX_WSTR_RES(STR_ID_VAPP_CAL_DELETE), VCP_IMG_TOOL_BAR_COMMON_ITEM_DELETE);*/
        m_titleBar->setTitle((VfxResId)STR_ID_VAPP_CAL_SELECT_EXPIRED);

        m_isMutiDelProcessing = VFX_TRUE;

        for (VfxU32 j = 0; j < m_count; ++j)
        {
            if (m_listEventSel[j] == VCP_LIST_MENU_ITEM_STATE_SELECTED)
            {
                srv_tdl_event_delete(m_eventbuffer[j].source_id,m_eventbuffer[j].event_id);
            }

        }

        m_isMutiDelProcessing = VFX_FALSE;
        m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_NORMAL, VFX_TRUE);


        srv_tdl_event_op_struct param;
        MMI_FRM_INIT_EVENT(&param, EVT_ID_SRV_TDL_EVENT_OP);
        param.op_type = SRV_TDL_OP_DELETE;
        param.event_id = 0XFFFF;
        param.source_id = SRV_TDL_EVENT_SOURCE_LOCAL;
        param.user_data = getObjHandle();

        m_markAllBtn = VFX_FALSE;

        updateCalExpiredListPage((mmi_event_struct*)&param);
    }
}

VfxBool VappCalExpiredListPage::getItemText(
                                    VfxU32 index,                   
                                    VcpListMenuFieldEnum fieldType,  
                                    VfxWString &text,               
                                    VcpListMenuTextColorEnum &color)
{

    srv_tdl_event_struct *buffer;
    VFX_ALLOC_MEM(buffer,sizeof(srv_tdl_event_struct),this);
    srv_tdl_event_get(
                buffer, 
                sizeof(srv_tdl_event_struct),
                m_eventbuffer[index].source_id,
                m_eventbuffer[index].event_id);




    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        text.loadFromMem((VfxWChar*) buffer->subject);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1 ||
        fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT2)
    {
        VappCalUtility::getListItemDateTimeStr(
                                        fieldType, 
                                        SRV_TDL_VCAL_EVENT, 
                                        buffer,
                                        text);

    }

    color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;
    VFX_FREE_MEM(buffer);

    return VFX_TRUE;
}

VfxU32 VappCalExpiredListPage::getCount() const
{
  
    return m_count;

}

VfxBool VappCalExpiredListPage::getItemImage(
                                            VfxU32 index,                    
                                            VcpListMenuFieldEnum fieldType,  
                                            VfxImageSrc &image)
{
    VappCalDailyList::setItemImagebyIdx(
                                m_eventbuffer[index],
                                fieldType,
                                image,
                                this);


    return VFX_TRUE;
}

VcpListMenuItemStateEnum VappCalExpiredListPage::getItemState(VfxU32 index) const
{
    return m_listEventSel[index];
}


VfxBool VappCalExpiredListPage::getMenuEmptyText(
                                            VfxWString &text,               
                                            VcpListMenuTextColorEnum &color)
{
   
    text.loadFromRes((VfxResId)m_stringId);

    color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;
    return VFX_TRUE;
}


void VappCalExpiredListPage::updateCalExpiredListPageInt()
{
    if (!m_isMutiDelProcessing)
    {
        GetSnsData(SRV_TDL_EVENT_SOURCE_TOTAL);
        m_listMenu->resetAllItems(VFX_TRUE);
    }
}


void VappCalExpiredListPage::closeDeletePopup()
{
    if (m_confirmPopupWeakPtr.isValid())
    {
        VcpConfirmPopup *popup = m_confirmPopupWeakPtr.get();
        VFX_OBJ_CLOSE(popup);
    }
    if (m_opListWeakPtr.isValid())
    {
        VcpMenuPopup *menuPopup = m_opListWeakPtr.get();
        VFX_OBJ_CLOSE(menuPopup);
    }
}


mmi_ret VappCalExpiredListPage::updateCalExpiredListPage(mmi_event_struct *param)
{
    VfxObject *obj = handleToObject((VfxObjHandle)param->user_data);
    if (obj == NULL)
    {
        return MMI_RET_OK;
    }
    VappCalExpiredListPage *page = VFX_OBJ_DYNAMIC_CAST(obj,VappCalExpiredListPage);
    if (page == NULL)
    {
        return MMI_RET_OK;
    }
    page->closeDeletePopup();

    if (!page->isActive())
    {
        page->setDataChangeState(VFX_TRUE);
        return MMI_RET_OK;
    }
    page->updateCalExpiredListPageInt();
    return MMI_RET_OK;
}
#endif


#ifdef __MMI_SNS_CALENDAR__
void VappCalFliterListPage::onInit()
{
    VfxPage::onInit();

    VcpTitleBar *titleBar;
    VFX_OBJ_CREATE(titleBar, VcpTitleBar, this);
    titleBar->setTitleStyle(VCP_TITLE_BAR_STYLE_BASE);
    titleBar->setTitle((VfxResId)STR_ID_VAPP_SNS_FILTER);
    setTopBar(titleBar);

    VFX_OBJ_CREATE(m_listMenu, VcpListMenu, this);
    m_listMenu->setContentProvider((IVcpListMenuContentProvider*)this);
    m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT);

    m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_HEAD_SINGLE_CHECK_MARK, VFX_FALSE);
    m_listMenu->setPos(0, 0);
    m_listMenu->setSize(getSize());
    m_listMenu->setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE,
                            VFX_FRAME_ALIGNER_MODE_SIDE, 
                            VFX_FRAME_ALIGNER_MODE_SIDE, 
                            VFX_FRAME_ALIGNER_MODE_SIDE);
    m_listMenu->m_signalItemTapped.connect(this, &VappCalFliterListPage::onListMenuClicked);
}


void VappCalFliterListPage::onDeinit()
{
    VfxPage::onDeinit();
}


VcpListMenuItemStateEnum VappCalFliterListPage::getItemState(VfxU32 index) const
{
    if (index == m_selIndex)  
    {
        return VCP_LIST_MENU_ITEM_STATE_SELECTED;
    }
    else
    {
        return VCP_LIST_MENU_ITEM_STATE_UNSELECTED;
    }

}



VfxBool VappCalFliterListPage::getItemText(
                                    VfxU32 index,                   
                                    VcpListMenuFieldEnum fieldType,  
                                    VfxWString &text,               
                                    VcpListMenuTextColorEnum &color)
{
    if (index == 0)
        text.loadFromRes(STR_ID_VAPP_CAL_LOCAL);
    else
    {
        VfxU32 j = 1;
        for (VfxU16 i = 1; i < SRV_TDL_EVENT_SOURCE_TOTAL; ++i)
        {
            if (srv_tdl_get_source_state((srv_tdl_event_source_enum)i))
            {
                if (j == index)
                {
                    VfxWChar *temp = srv_sns_get_provider_name(snstocalendartable[i]);
                    text.loadFromMem(temp);
                    color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;
                    return VFX_TRUE;
                }
                ++j;
            }

        }
        if (j == index)
        {
            text.loadFromRes(STR_ID_VAPP_CAL_ALL);
        }
    }

    color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;
    return VFX_TRUE;
}


/*
#define SRV_SNS_PROVIDER_ALL      0xFFFFFFFF
#define SRV_SNS_PROVIDER_FACEBOOK 0xfaceb00c
#define SRV_SNS_PROVIDER_TWITTER  0x54776974
#define SRV_SNS_PROVIDER_RENREN     26598088
#define SRV_SNS_PROVIDER_WEIBO    0x00000000
#define SRV_SNS_PROVIDER_KAIXIN   0x00000000

*/


VfxU32 VappCalFliterListPage::getCount() const
{
    return srv_tdl_get_source_count() + 1;
}


VfxBool VappCalFliterListPage::getItemImage(
                                    VfxU32 index,                    
                                    VcpListMenuFieldEnum fieldType,  
                                    VfxImageSrc &image)
{
    if (index == 0)
    {
        image.setResId(IMG_ID_VAPP_CAL_LOCAL);
    }
    else
    {
        VfxU32 j = 1;
        for (VfxU16 i = 1; i < SRV_TDL_EVENT_SOURCE_TOTAL; ++i)
        {
            if (srv_tdl_get_source_state((srv_tdl_event_source_enum)i))
            {
                if (j == index)
                {
                    VfxWChar *path = srv_sns_get_provider_icon( srv_sns_provider_from_tdl_source((srv_tdl_event_source_enum)i),SRV_SNS_LOGO_SMALL);
                    if (path)
                    {
                        image.setPath(VFX_WSTR_MEM(path));
                        return VFX_TRUE;
                    }
                }
                ++j;
            }

        }
        if (j == index)
        {
            image.setResId(IMG_ID_VAPP_CAL_ALL);
        }
    }	    
    return VFX_TRUE;
}


VfxBool VappCalFliterListPage::getMenuEmptyText(
                                            VfxWString &text,               
                                            VcpListMenuTextColorEnum &color)
{
    text.loadFromRes((VfxResId)STR_ID_VAPP_CAL_NO_EVTS);
    color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;
    return VFX_TRUE;
}


void VappCalFliterListPage::onListMenuClicked(VcpListMenu *sender, VfxU32 index)
{
    m_selIndex = (srv_tdl_event_source_enum)index;

    if (index == srv_tdl_get_source_count())
    {
        m_signalFilterListItemTap.emit(SRV_TDL_EVENT_SOURCE_TOTAL,m_selIndex);
        getMainScr()->popPage();
        return;
    }

    VfxU32 j = 0;
    for (VfxU32 i = 0; i <= SRV_TDL_EVENT_SOURCE_TOTAL; ++i)
    {    
        if (srv_tdl_has_source((srv_tdl_event_source_enum)i))
        {
            if (j == index)
            {
                m_signalFilterListItemTap.emit(i,m_selIndex);
                getMainScr()->popPage();
                return;
            }
            ++j;
        }

    }
    if (j == SRV_TDL_EVENT_SOURCE_TOTAL + 1)
    {

        m_signalFilterListItemTap.emit(j-1,m_selIndex);
        getMainScr()->popPage();

    }
   
}

#endif
#ifndef __MMI_VCALENDAR__
#pragma arm section code, rodata
#endif
