/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vapp_launcher_mm.cpp
 *
 * Project:
 * --------
 *  Cosmos Launcher 2.0 - Launcher MM
 *
 * Description:
 * ------------
 *  Launcher MM
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/


#include "MMI_features.h"

#ifdef __MMI_VUI_LAUNCHER_MM__


/*****************************************************************************
 * Include
 *****************************************************************************/

#include "vfx_font_desc.h"
#include "vfx_system.h"

#include "vcp_page_menu_transition.h"
#include "vcp_status_icon_bar.h"
#include "vcp_global_popup.h"    // for global pop on uninstall app
#include "vcp_indicator_popup.h" // for VcpIndicatorPopup

#ifndef __MMI_VUI_PLATFORM_CONTEXT_SLIM__
#include "vapp_platform_context.h"
#endif

#include "vapp_launcher_mm.h"
#include "vapp_launcher_mm_builder.h"
#include "vapp_launcher_mm_default_order.h"
#include "vapp_launcher_mm_gprot.h"
#include "vapp_launcher_mm_page_menu.h"
#include "mmi_rp_vapp_launcher_mm_def.h"
#if defined(__MMI_VUI_MAIN_MENU_SWITCH_EFFECT__)
#include "mmi_rp_vapp_launcher_mm_barrel_setting_def.h"
#endif // __MMI_VUI_MAIN_MENU_SWITCH_EFFECT__

#include "vapp_launcher_app.h"      // For VappLauncherApp
#include "vapp_launcher_def.h"
#include "vapp_launcher_gprot.h"
#include "vapp_launcher_native_factory.h"

#include "vapp_ncenter.h"

#include "vapp_wallpaper.h"
#include "vapp_wallpaper_kit.h"
#include "vapp_wallpaper_setting_method_gprot.h"

#include "mmi_rp_vapp_setting_def.h"    // for EVT_ID_VAPP_LANGUAGE_CHANGED
#ifdef __MMI_THEMES_APPLICATION__
#include "mmi_rp_vapp_theme_def.h"      // for EVT_ID_VAPP_THEME_CHANGED
#endif
#if defined(__MMI_FE_VECTOR_FONT_ON_FILE_SYSTEM__)
#include "mmi_rp_vapp_fontmgr_def.h"  // for EVT_ID_VAPP_FONT_CHANGED
#endif

extern "C"
{
#include "nvram_common_defs.h"
#include "Wgui.h"   // for MMI_STATUS_BAR_HEIGHT
#include "AppMgrSrvGprot.h"
#include "SensorSrvGport.h"
#include "MREAppMgrSrvGprot.h"      // for query if there is MRE app running
#include "JavaAppFactorySrvGprot.h" // for query if there is Java app running

}

#if defined(__COSMOS_3D_V10__) && defined(__MMI_SCREEN_SWITCH_EFFECT_VENUS__)
#include "vcp_sse.h"
#endif

#ifdef __MTK_TARGET__
//#define __MAUI_SOFTWARE_LA__
#endif // __MTK_TARGET__

#ifdef __MAUI_SOFTWARE_LA__
extern "C"
{
#include "SST_sla.h"
}
#endif 


/*****************************************************************************
 * Define
 *****************************************************************************/

//#define VAPP_LAUNCHER_MM_DEBUG_ORDER_DATA


/*****************************************************************************
 * Static Constant
 *****************************************************************************/

static const VfxS32 VAPP_LAUNCHER_MM_SAVED_APP_ORDER_DATA_COUNT = NVRAM_EF_VAPP_LAUNCHER_MM_APP_ORDER_DATA_COUNT_PER_RECORD * NVRAM_EF_VAPP_LAUNCHER_MM_APP_ORDER_DATA_RECORD_TOTAL;
static const VfxS32 VAPP_LAUNCHER_MM_SAVED_APP_FOLDER_DATA_COUNT = NVRAM_EF_VAPP_LAUNCHER_MM_APP_FOLDER_DATA_COUNT_PER_RECORD * NVRAM_EF_VAPP_LAUNCHER_MM_APP_FOLDER_DATA_RECORD_TOTAL;

#if defined(__MMI_MAINLCD_480X800__)
static const VfxS32 VAPP_LAUNCHER_MM_SCREEN_WIDTH = 480;
static const VfxS32 VAPP_LAUNCHER_MM_SCREEN_HEIGHT = 800;
static const VfxS32 VAPP_LAUNCHER_MM_BOTTOM_BAR_HEIGHT = 144;

static const VfxS32 VAPP_LAUNCHER_MM_CELL_ROW_COUNT = 4;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_COLUMN_COUNT = 4;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_START_X = 0;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_START_Y = 80;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_OFFSET_X = 120;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_OFFSET_Y = 144;
static const VfxS32 VAPP_LAUNCHER_MM_PAGE_MARGIN = 27;
static const VfxS32 VAPP_LAUNCHER_MM_BOTTOM_BAR_VISIBLE_SHIFT_Y = 0;

// Folder
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_ROW_COUNT = 2;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_COLUMN_COUNT = 2;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_START_X = 16;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_START_Y = 12;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_OFFSET_X = 41;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_OFFSET_Y = 41;
static const VfxFloat VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_SCALE = 0.4f;

#elif defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__)

#if defined(__MMI_MAINLCD_240X320__)
static const VfxS32 VAPP_LAUNCHER_MM_SCREEN_WIDTH = 240;
static const VfxS32 VAPP_LAUNCHER_MM_SCREEN_HEIGHT = 320;
static const VfxS32 VAPP_LAUNCHER_MM_BOTTOM_BAR_HEIGHT = 70;

static const VfxS32 VAPP_LAUNCHER_MM_CELL_ROW_COUNT = 3;
#else
static const VfxS32 VAPP_LAUNCHER_MM_SCREEN_WIDTH = 240;
static const VfxS32 VAPP_LAUNCHER_MM_SCREEN_HEIGHT = 400;
static const VfxS32 VAPP_LAUNCHER_MM_BOTTOM_BAR_HEIGHT = 72;

static const VfxS32 VAPP_LAUNCHER_MM_CELL_ROW_COUNT = 4;
#endif

static const VfxS32 VAPP_LAUNCHER_MM_CELL_COLUMN_COUNT = 4;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_START_X = 0;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_START_Y = 40;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_OFFSET_X = 60;

#if defined(__MMI_MAINLCD_240X320__)
static const VfxS32 VAPP_LAUNCHER_MM_CELL_OFFSET_Y = 70;
#else
static const VfxS32 VAPP_LAUNCHER_MM_CELL_OFFSET_Y = 72;
#endif

static const VfxS32 VAPP_LAUNCHER_MM_PAGE_MARGIN = 15;
static const VfxS32 VAPP_LAUNCHER_MM_BOTTOM_BAR_VISIBLE_SHIFT_Y = 0;

// Folder
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_ROW_COUNT = 2;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_COLUMN_COUNT = 2;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_START_X = 10;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_START_Y = 9;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_OFFSET_X = 19;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_OFFSET_Y = 19;
static const VfxFloat VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_SCALE = 0.35f;

#else // default HVGA 320X480
static const VfxS32 VAPP_LAUNCHER_MM_SCREEN_WIDTH = 320;
static const VfxS32 VAPP_LAUNCHER_MM_SCREEN_HEIGHT = 480;
static const VfxS32 VAPP_LAUNCHER_MM_BOTTOM_BAR_HEIGHT = 88;

static const VfxS32 VAPP_LAUNCHER_MM_CELL_ROW_COUNT = 4;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_COLUMN_COUNT = 4;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_START_X = 0;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_START_Y = 40;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_OFFSET_X = 80;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_OFFSET_Y = 88;
static const VfxS32 VAPP_LAUNCHER_MM_PAGE_MARGIN = 20;
static const VfxS32 VAPP_LAUNCHER_MM_BOTTOM_BAR_VISIBLE_SHIFT_Y = 0;

// Folder
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_ROW_COUNT = 2;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_COLUMN_COUNT = 2;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_START_X = 15;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_START_Y = 11;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_OFFSET_X = 23;
static const VfxS32 VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_OFFSET_Y = 23;
static const VfxFloat VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_SCALE = 0.35f;

#endif

static const VfxS32 VAPP_LAUNCHER_MM_BOTTOM_BAR_Y = VAPP_LAUNCHER_MM_SCREEN_HEIGHT - VAPP_LAUNCHER_MM_BOTTOM_BAR_HEIGHT;

static const VfxS32 VAPP_LAUNCHER_MM_CELL_COUNT_IN_PAGE = VAPP_LAUNCHER_MM_CELL_ROW_COUNT * VAPP_LAUNCHER_MM_CELL_COLUMN_COUNT;

#ifdef VAPP_LAUNCHER_MM_MOTION_DOUBLE_TAP_TO_CHANGE_SWITCH_EFFECT
static const VfxS32 VAPP_LAUNCHER_MM_MOTION_DOUBLE_TAP_ANIMTIME = 400;
#endif

static const VfxS32 VAPP_LAUNCHER_MM_SCREENSHOT_COUNT = 1;

// Delayed time, in msec., to load the wallpaper. Because loading the
// wallpaper takes time, if the handset will hang for a while when it
// just enters the home screen, please tune this parameter.
static const VfxS32 VAPP_LAUNCHER_MM_WALLPAPER_BOOTUP_DELAY_TIME = 4000;
static const VfxS32 VAPP_LAUNCHER_MM_WALLPAPER_NORMAL_DELAY_TIME = 450;
static const VfxS32 VAPP_LAUNCHER_MM_WALLPAPER_SWIPE_DELAY_TIME = 500;

// Cache data variables
static const VfxS32 VAPP_LAUNCHER_MM_APP_DATA_CACHE_COUNT = VAPP_LAUNCHER_MM_SAVED_APP_ORDER_DATA_COUNT;
static const VfxS16 VAPP_LAUNCHER_MM_APP_STRING_SHADOW_DEGREE       = 270;
static const VfxS16 VAPP_LAUNCHER_MM_APP_STRING_SHADOW_DISTANT      = 2;
static const VfxS16 VAPP_LAUNCHER_MM_APP_STRING_SHADOW_RANGE        = 1;
static const VfxS16 VAPP_LAUNCHER_MM_APP_STRING_SHADOW_TRANSPARENCY = 80;

/*****************************************************************************
 * Global Variable
 *****************************************************************************/
static VappLauncherMmCell *g_vapp_launcher_mm_uninstalled_cell = NULL;
static VfxBool m_gIsUninstallBtnClicked = VFX_FALSE;

/*****************************************************************************
 * Local Variable
 *****************************************************************************/

// Order data variables
#ifdef VAPP_LAUNCHER_MM_DEBUG_ORDER_DATA
static VappLauncherMmAppOrderDataStruct s_vappLauncherMmAllOrderData[VAPP_LAUNCHER_MM_SAVED_APP_ORDER_DATA_COUNT];
static VappLauncherMmAppFolderDataStruct s_vappLauncherMmAllFolderData[VAPP_LAUNCHER_MM_SAVED_APP_FOLDER_DATA_COUNT];
#else
static VappLauncherMmAppOrderDataStruct *s_vappLauncherMmAllOrderData = NULL;
static VappLauncherMmAppFolderDataStruct *s_vappLauncherMmAllFolderData = NULL;
#endif
static VfxBool s_vappLauncherMmIsFirstLoad = VFX_TRUE;
static VfxS32 s_vappLauncherMmOrderCount = 0;
static VfxBool s_vappLauncherMmNeedSync = VFX_TRUE;
static VfxS32 s_vappLauncherMmSyncVersion = 0;
static VfxBool s_vappLauncherMmIsDataDirty = VFX_FALSE;

// Cache data variables
static VfxFontEffect *s_vappLauncherMmAppStringFontEffect = NULL;
static VfxS16 *s_vappLauncherMmAppDataCacheStringWidth = NULL;

static VappLauncherMm *s_vappLauncherMm = NULL;


/***************************************************************************** 
 * Static Declaration
 *****************************************************************************/

// Order data utilities
static void vappLauncherMmCheckLoadOrderData();
// allOrderData [OUT] : the order list to be compact
// pIsNeedResetOrder [OUT] : if is empty data in nvram
// return : data count after loading
static VfxS32 vappLauncherMmLoadData(VappLauncherMmAppOrderDataStruct *allOrderData, VfxBool *pIsNeedResetOrder);
static void vappLauncherMmLoadFolderData(VappLauncherMmAppFolderDataStruct *allFolderData, VfxBool isNeedResetOrder);
static void vappLauncherMmSaveData();
static void vappLauncherMmSaveFolderData();
static VfxS32 vappLauncherMmCalculateOrderCount(VappLauncherMmAppOrderDataStruct *orderList);
// allOrderData [IN, OUT] : the order data to be compared with app manager data
static VfxS32 vappLauncherMmSyncAppMgr(VappLauncherMmAppOrderDataStruct *allOrderData, VfxS32 initOrderCount, VfxBool isNeedResetOrder, VfxBool *pIsDataDirty);
static void vappLauncherMmSortAppListByDisplayName(mmi_app_package_name_struct *appList, VfxS32 appCount);
static VfxU32 vappLauncherMmGetAppTypeOrder(mmi_app_package_name_struct appName);
// remove the "delete" app in order list
// orderList [IN, OUT] : the order list to be compact
// maxDataCount [IN] : max data count in the order list
// return : data count after compact
static VfxS32 vappLauncherMmCompactData(VappLauncherMmAppOrderDataStruct *orderList, VfxS32 maxDataCount, VfxBool isNeedResetOrder);
static void vappLauncherMmCompactGroupData(VappLauncherMmAppOrderDataStruct *barOrderList, VfxS32 maxDataCount);
static mmi_ret vappLauncherMmEventHandler(mmi_event_struct *event);
static VfxBool vappLauncherMmGetIsDataDirty();
static VfxS32 vappLauncherMmGetSycnVersion();
static void vappLauncherMmSetNeedSycn();

// Data cache utilities
static void vappLauncherMmUpdateAppDataCache(VappLauncherMmAppOrderDataStruct *allOrderData, VfxS32 orderCount);
static void vappLauncherMmGetAppInfo(mmi_app_package_name_struct &appName, VfxS32 cacheIndex);
static VfxS32 vappLauncherMmFindAppDataIndex(mmi_app_package_name_struct &appName);


/***************************************************************************** 
 * Local Function
 *****************************************************************************/

void vappLauncherMmCheckLoadOrderData()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM0", SA_start);
#endif

    VfxBool isNeedResetOrder = VFX_FALSE;

    if (s_vappLauncherMmIsFirstLoad)
    {
    #ifndef __MMI_VUI_PLATFORM_CONTEXT_SLIM__
        //
        //If platform size slim, data buffer come from asm, not cache it when release launcher.
        //
        s_vappLauncherMmIsFirstLoad = VFX_FALSE;
    #endif    
        s_vappLauncherMmOrderCount = vappLauncherMmLoadData(s_vappLauncherMmAllOrderData, &isNeedResetOrder);
        vappLauncherMmLoadFolderData(s_vappLauncherMmAllFolderData, isNeedResetOrder);
    }

    VfxBool dirtyWhenSync = VFX_FALSE;
    if (s_vappLauncherMmNeedSync)
    {
        s_vappLauncherMmNeedSync = VFX_FALSE;
        VappLauncherMmAppOrderDataStruct *orderList = s_vappLauncherMmAllOrderData + VAPP_LAUNCHER_MM_MAX_BOTTOM_BAR_APP_DATA;
        s_vappLauncherMmOrderCount = vappLauncherMmCalculateOrderCount(orderList);
        s_vappLauncherMmOrderCount = vappLauncherMmSyncAppMgr(s_vappLauncherMmAllOrderData, s_vappLauncherMmOrderCount, isNeedResetOrder, &dirtyWhenSync);
        vappLauncherMmUpdateAppDataCache(s_vappLauncherMmAllOrderData, s_vappLauncherMmOrderCount + VAPP_LAUNCHER_MM_MAX_BOTTOM_BAR_APP_DATA);
    }
    s_vappLauncherMmIsDataDirty = s_vappLauncherMmIsDataDirty || isNeedResetOrder || dirtyWhenSync;
    
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM0", SA_stop);
#endif
}

VfxS32 vappLauncherMmLoadData(VappLauncherMmAppOrderDataStruct *allOrderData, VfxBool *pIsNeedResetOrder)
{
    VappLauncherMmAppOrderDataStruct *orderList = allOrderData + VAPP_LAUNCHER_MM_MAX_BOTTOM_BAR_APP_DATA;
    VappLauncherMmAppOrderDataStruct *barOrderList = allOrderData;

    U8 * readBufferPointer = (U8*)allOrderData;
    for (VfxS32 i = 0; i < NVRAM_EF_VAPP_LAUNCHER_MM_APP_ORDER_DATA_RECORD_TOTAL; ++i)
    {
        S16 error;

        ReadRecord(
            NVRAM_EF_VAPP_LAUNCHER_MM_APP_ORDER_DATA_LID,
            1+i,
            readBufferPointer + NVRAM_EF_VAPP_LAUNCHER_MM_APP_ORDER_DATA_RECORD_SIZE * i,
            NVRAM_EF_VAPP_LAUNCHER_MM_APP_ORDER_DATA_RECORD_SIZE,
            &error);

        MMI_ASSERT(error == NVRAM_READ_SUCCESS);
    }

    VfxS32 orderCount = 0;
    VfxBool isNeedResetOrder = VFX_FALSE;
    if (orderList[0].appId == 0 && orderList[1].appId == 0)
    {
        isNeedResetOrder = VFX_TRUE;
    }
    else
    {
        orderCount = vappLauncherMmCalculateOrderCount(orderList);
    }

    if (isNeedResetOrder)
    {
        U32 count = srv_appmgr_get_app_package_num(SRV_APPMGR_ALL_APP_PACKAGE_FLAG_TYPE);
        mmi_app_package_name_struct *array = NULL;
        VFX_SYS_ALLOC_MEM(array, sizeof(mmi_app_package_name_struct) * count);
        memset(array, 0, sizeof(mmi_app_package_name_struct) * count);
        mmi_ret result = srv_appmgr_get_app_package_list(SRV_APPMGR_ALL_APP_PACKAGE_FLAG_TYPE, array, count);
        VFX_ASSERT(result != MMI_RET_ERR);

        VfxS32 i;
        for (i = 0;
             i < VAPP_LAUNCHER_MM_BAR_CELL_COUNT && i < vappLauncherMmDefaultOrderCount;
             ++i)
        {
            barOrderList[i].index = i;
            barOrderList[i].subindex = VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX;
            
            VfxBool found = VFX_FALSE;
            for (VfxS32 j = 0; j < count; ++j)
            {
                if (strncmp(vappLauncherMmDefaultOrder[i], array[j], MMI_APP_NAME_MAX_LEN) == 0)
                {
                    found = VFX_TRUE;
                    break;
                }
            }
            if (found)
            {
                mmi_app_package_name_struct appPackageName;
                strncpy(appPackageName, vappLauncherMmDefaultOrder[i], MMI_APP_NAME_MAX_LEN - 1);
                barOrderList[i].appId = srv_appmgr_get_id_by_app_package_name(appPackageName);
            }
            else
            {
                barOrderList[i].appId = VAPP_LAUNCHER_MM_APP_ORDER_DATA_DISABLED;
            }
        }

        // set remaining bar data as empty
        for (; i < VAPP_LAUNCHER_MM_MAX_BOTTOM_BAR_APP_DATA; ++i)
        {
            vappLauncherMmClearOrderData(&barOrderList[i]);
        }
        
        orderCount = 0;
        VfxS32 countInPage = 0;
        for (VfxS32 i = VAPP_LAUNCHER_MM_BAR_CELL_COUNT; i < vappLauncherMmDefaultOrderCount; ++i)
        {
            if (countInPage == VAPP_LAUNCHER_MM_CELL_COUNT_IN_PAGE)
            {
                vappLauncherMmClearOrderData(&orderList[orderCount]);
                
                ++orderCount;
                countInPage = 0;
            }

            // append
            orderList[orderCount].index = i - VAPP_LAUNCHER_MM_BAR_CELL_COUNT;
            orderList[orderCount].subindex = VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX;
            
            VfxBool found = VFX_FALSE;
            for (VfxS32 j = 0; j < count; ++j)
            {
                if (strncmp(vappLauncherMmDefaultOrder[i], array[j], MMI_APP_NAME_MAX_LEN) == 0)
                {
                    found = VFX_TRUE;
                    break;
                }
            }
            if (found)
            {
                mmi_app_package_name_struct appPackageName;
                strncpy(appPackageName, vappLauncherMmDefaultOrder[i], MMI_APP_NAME_MAX_LEN - 1);
                orderList[orderCount].appId = srv_appmgr_get_id_by_app_package_name(appPackageName);
            }
            else
            {
                orderList[orderCount].appId = VAPP_LAUNCHER_MM_APP_ORDER_DATA_DISABLED;
            }
            
            ++orderCount;
            ++countInPage;
        }
        
        // set remaining data as empty
        for (VfxS32 i = orderCount; i < VAPP_LAUNCHER_MM_MAX_PAGE_APP_DATA; ++i)
        {
            vappLauncherMmClearOrderData(&orderList[i]);
        }
        
        VFX_SYS_FREE_MEM(array);
    }

    *pIsNeedResetOrder = isNeedResetOrder;

    return orderCount;
}

void vappLauncherMmLoadFolderData(VappLauncherMmAppFolderDataStruct *allFolderData, VfxBool isNeedResetOrder)
{
    U8 *readBufferPointer = (U8 *)allFolderData;
    for (VfxS32 i = 0; i < NVRAM_EF_VAPP_LAUNCHER_MM_APP_FOLDER_DATA_RECORD_TOTAL; ++i)
    {
        S16 error;
        ReadRecord(NVRAM_EF_VAPP_LAUNCHER_MM_APP_FOLDER_DATA_LID,
                   i + 1,
                   readBufferPointer + NVRAM_EF_VAPP_LAUNCHER_MM_APP_FOLDER_DATA_RECORD_SIZE * i,
                   NVRAM_EF_VAPP_LAUNCHER_MM_APP_FOLDER_DATA_RECORD_SIZE,
                   &error);

        MMI_ASSERT(error == NVRAM_READ_SUCCESS);
    }

    if (isNeedResetOrder)
    {
        for (VfxS32 i = 0; i < VAPP_LAUNCHER_MM_MAX_PAGE_FOLDER_DATA; ++i)
        {
            allFolderData[i].index = VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX;
        }
    }
}

void vappLauncherMmSaveData()
{
    U8 * writeBufferPointer = (U8*)s_vappLauncherMmAllOrderData;
    for (VfxS32 i = 0; i < NVRAM_EF_VAPP_LAUNCHER_MM_APP_ORDER_DATA_RECORD_TOTAL; ++i)
    {
        S16 error;

        WriteRecord(
            NVRAM_EF_VAPP_LAUNCHER_MM_APP_ORDER_DATA_LID,
            1+i,
            writeBufferPointer + NVRAM_EF_VAPP_LAUNCHER_MM_APP_ORDER_DATA_RECORD_SIZE * i,
            NVRAM_EF_VAPP_LAUNCHER_MM_APP_ORDER_DATA_RECORD_SIZE,
            &error);

        MMI_ASSERT(error == NVRAM_WRITE_SUCCESS);
    }
    s_vappLauncherMmIsDataDirty = VFX_FALSE;
}

void vappLauncherMmSaveFolderData()
{
    U8 *writeBufferPointer = (U8 *)s_vappLauncherMmAllFolderData;
    for (VfxS32 i = 0; i < NVRAM_EF_VAPP_LAUNCHER_MM_APP_FOLDER_DATA_RECORD_TOTAL; ++i)
    {
        S16 error;
        WriteRecord(NVRAM_EF_VAPP_LAUNCHER_MM_APP_FOLDER_DATA_LID,
                    i + 1,
                    writeBufferPointer + NVRAM_EF_VAPP_LAUNCHER_MM_APP_FOLDER_DATA_RECORD_SIZE * i,
                    NVRAM_EF_VAPP_LAUNCHER_MM_APP_FOLDER_DATA_RECORD_SIZE,
                    &error);

        MMI_ASSERT(error == NVRAM_WRITE_SUCCESS);
    }
}

VfxS32 vappLauncherMmCalculateOrderCount(VappLauncherMmAppOrderDataStruct *orderList)
{
    VfxS32 orderCount = VAPP_LAUNCHER_MM_MAX_PAGE_APP_DATA;
    for (VfxS32 i = 0; i < VAPP_LAUNCHER_MM_MAX_PAGE_APP_DATA - 1; ++i)
    {
        if (orderList[i].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY)
        {
            if (orderList[i + 1].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY)
            {
                orderCount = i;
                break;
            }
        }
    }
    return orderCount;
}

VfxS32 vappLauncherMmSyncAppMgr(VappLauncherMmAppOrderDataStruct *allOrderData, VfxS32 initOrderCount, VfxBool isNeedResetOrder, VfxBool *pIsDataDirty)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM4", SA_start);
#endif

    U32 count = srv_appmgr_get_app_package_num(SRV_APPMGR_ALL_APP_PACKAGE_IN_MAIN_MENU_FLAG_TYPE);
    U32 preCount = srv_appmgr_get_app_package_num(SRV_APPMGR_PRE_INSTALLED_APP_PACKAGE_FLAG_TYPE);

    U32 totalCount = count + preCount;
    mmi_app_package_name_struct * array = NULL;
    VFX_SYS_ALLOC_MEM(array, sizeof(mmi_app_package_name_struct) * totalCount);
    memset(array, 0, sizeof(mmi_app_package_name_struct) * totalCount);
    mmi_ret result;

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM4", SA_stop);
#endif

    result = srv_appmgr_get_app_package_list(SRV_APPMGR_ALL_APP_PACKAGE_IN_MAIN_MENU_FLAG_TYPE, array, count);
    VFX_ASSERT(result != MMI_RET_ERR);
    
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM4", SA_start);
#endif

    result = srv_appmgr_get_app_package_list(SRV_APPMGR_PRE_INSTALLED_APP_PACKAGE_FLAG_TYPE, array + count, preCount);
    VFX_ASSERT(result != MMI_RET_ERR);

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM4", SA_stop);
#endif

    if (isNeedResetOrder)
    {
        vappLauncherMmSortAppListByDisplayName(array, totalCount);
    }
    
    // check if every thing in the current order list are in the app list
    VfxS32 countInPage = 0;
    VfxBool isDataDirty = VFX_FALSE;
    for (VfxS32 i = 0; i < VAPP_LAUNCHER_MM_MAX_BOTTOM_BAR_APP_DATA + initOrderCount; ++i)
    {
        VfxBool found = VFX_FALSE;
        if (allOrderData[i].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY)
        {
            countInPage = 0;
            continue;
        }

        for (VfxU32 j = 0; j < totalCount; ++j)
        {
            if (strncmp(array[j], "ADDED", MMI_APP_NAME_MAX_LEN) != 0 &&
                allOrderData[i].appId == srv_appmgr_get_id_by_app_package_name(array[j]))
            {
                strncpy(array[j], "ADDED", MMI_APP_NAME_MAX_LEN - 1);
                found = VFX_TRUE;
                break;
            }
        }

        if (!found)
        {
        #if defined(__MMI_VUI_MAIN_MENU_SWITCH_EFFECT__)
            mmi_app_package_name_struct appPackageName;
            memset(appPackageName, 0, sizeof(mmi_app_package_name_struct));
            srv_appmgr_get_app_package_name_by_id(allOrderData[i].appId, appPackageName);
            if (strncmp(appPackageName, "native.mtk.launcher_mm_barrel_setting", MMI_APP_NAME_MAX_LEN) == 0)
            {
                countInPage = (allOrderData[i].index % VAPP_LAUNCHER_MM_CELL_COUNT_IN_PAGE) + 1;
                continue;
            }
        #endif // __MMI_VUI_MAIN_MENU_SWITCH_EFFECT__
            if (allOrderData[i].appId != VAPP_LAUNCHER_MM_APP_ORDER_DATA_DELETED)
            {
                allOrderData[i].appId = VAPP_LAUNCHER_MM_APP_ORDER_DATA_DELETED;
                
                isDataDirty = VFX_TRUE;
            }
        }
        else
        {
            countInPage = (allOrderData[i].index % VAPP_LAUNCHER_MM_CELL_COUNT_IN_PAGE) + 1;
        }
    }

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM4", SA_start);
#endif

    // append apps not in the order list
    VappLauncherMmAppOrderDataStruct *orderList = allOrderData + VAPP_LAUNCHER_MM_MAX_BOTTOM_BAR_APP_DATA;
    VfxS32 newOrderCount = initOrderCount;
    for (VfxU32 i = 0; i < totalCount; ++i)
    {
        if (newOrderCount >= VAPP_LAUNCHER_MM_MAX_PAGE_APP_DATA ||
            orderList[newOrderCount - 1].index >= VAPP_LAUNCHER_MM_MAX_PAGE_CELL_COUNT - 1)
        {
            break;
        }
        
        if (strncmp(array[i], "ADDED", MMI_APP_NAME_MAX_LEN) == 0)
        {
            continue;
        }

    #if !defined(__MMI_GOOGLE_SEARCH_COSMOS__) && !defined(__MMI_BAIDU_SEARCH_COSMOS__)
        // Do not appear "Winguo App" in fruit launcher if google search app is disabled
        if (strncmp(array[i], "native.guobi.winguo", MMI_APP_NAME_MAX_LEN) == 0 ||
            strncmp(array[i], "native.guobi.winguo_net", MMI_APP_NAME_MAX_LEN) == 0)
        {
            continue;
        }
    #endif
        
        if (countInPage >= VAPP_LAUNCHER_MM_CELL_COUNT_IN_PAGE)
        {
            vappLauncherMmClearOrderData(&orderList[newOrderCount]);
            ++newOrderCount;
            countInPage = 0;
        }

        // append
        if (orderList[newOrderCount - 1].index == VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX)
        {
            orderList[newOrderCount].index = orderList[newOrderCount - 2].index + 1;
        }
        else
        {
            orderList[newOrderCount].index = orderList[newOrderCount - 1].index + 1;
        }
        orderList[newOrderCount].subindex = VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX;
        orderList[newOrderCount].appId = srv_appmgr_get_id_by_app_package_name(array[i]);
        
        isDataDirty = VFX_TRUE;
        ++newOrderCount;
        ++countInPage;
    }

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM4", SA_stop);
#endif

    VFX_SYS_FREE_MEM(array);

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM4", SA_start);
#endif

    newOrderCount = vappLauncherMmCompactData(orderList, VAPP_LAUNCHER_MM_MAX_PAGE_APP_DATA, isNeedResetOrder);
    vappLauncherMmCompactGroupData(allOrderData, VAPP_LAUNCHER_MM_MAX_BOTTOM_BAR_APP_DATA);
    
    *pIsDataDirty = isDataDirty;
    
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM4", SA_stop);
#endif

    return newOrderCount;
}

void vappLauncherMmSortAppListByDisplayName(mmi_app_package_name_struct * appList, VfxS32 appCount)
{
    // construct the display name mapping
    mmi_ret result;
    WCHAR **names;
    VFX_SYS_ALLOC_MEM(names, sizeof(WCHAR*) * appCount + sizeof(WCHAR) * MMI_APP_NAME_MAX_LEN * appCount);
    memset(names, 0, sizeof(WCHAR) * MMI_APP_NAME_MAX_LEN * appCount);
    names[0] = (WCHAR*)(names + appCount );
    for (VfxS32 iPos = 0; iPos < appCount; ++iPos)
    {
        names[iPos] = names[0] + iPos * MMI_APP_NAME_MAX_LEN;
        result = srv_appmgr_get_app_package_name(appList[iPos], names[iPos]);
        VFX_ASSERT(result != MMI_RET_ERR);
    }

    // selection sort
    for (VfxS32 iPos = 0; iPos < appCount; ++iPos)
    {
        VfxS32 iMin = iPos;
        VfxU32 iMinTypeOrder = vappLauncherMmGetAppTypeOrder(appList[iPos]);
        for (VfxS32 i = iPos + 1; i < appCount; ++i)
        {
            // first compare app type, then compare app display name
            VfxU32 typeOrder = vappLauncherMmGetAppTypeOrder(appList[i]);
            if (typeOrder < iMinTypeOrder)
            {
                iMin = i;
                iMinTypeOrder = typeOrder;
            }
            else if (typeOrder == iMinTypeOrder)
            {
                if (wcsncmp((const wchar_t*)names[iMin], (const wchar_t*)names[i], MMI_APP_NAME_MAX_LEN) > 0)
                {
                    iMin = i;
                }
            }
        }
        // swap(iPos, iMin)
        mmi_app_package_name_struct packageTemp;
        strncpy(packageTemp, appList[iMin], MMI_APP_NAME_MAX_LEN - 1);
        strncpy(appList[iMin], appList[iPos], MMI_APP_NAME_MAX_LEN - 1);
        strncpy(appList[iPos], packageTemp, MMI_APP_NAME_MAX_LEN - 1);

        WCHAR* nameTemp;
        nameTemp = names[iMin];
        names[iMin] = names[iPos];
        names[iPos] = nameTemp;
    }

    VFX_SYS_FREE_MEM(names);
}

VfxU32 vappLauncherMmGetAppTypeOrder(mmi_app_package_name_struct appName)
{
    srv_appmgr_app_package_type_enum type = srv_appmgr_get_app_package_type(appName);
    if (type == SRV_APPMGR_NATIVE_APP_PACKAGE_TYPE)
    {
        return 0;
    }
    else if (type == SRV_APPMGR_MRE_APP_PACKAGE_TYPE)
    {
        return 1;
    }
    else if (type == SRV_APPMGR_JAVA_APP_PACKAGE_TYPE)
    {
        return 2;
    }
    return 100;
}

VfxS32 vappLauncherMmCompactData(VappLauncherMmAppOrderDataStruct *orderList, VfxS32 maxDataCount, VfxBool isNeedResetOrder)
{
    VfxS32 orderCount = 0;
    VfxS32 i1 = 0;
    VfxS32 i2 = 0;
    VfxS32 countInPage = 0;
    VfxS32 fromIndex = 0;
    VfxS32 toIndex = 0;
    VfxS32 toSubindex = 0;
    
    while (i1 < maxDataCount)
    {
        if (orderList[i1].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_DELETED)
        {
            i1 += 1;
            continue;
        }

        if (i1 != i2)
        {
            // special handling for deleting the icon which is the only one icon in a page
            if (i2 >= 1 &&
                orderList[i2 - 1].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY &&
                orderList[i2].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_DELETED &&
                orderList[i1].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY)
            {
                i1 += 1;
                continue;
            }
            
            // Do not reserve space when first time bootup
            if (isNeedResetOrder &&
                orderList[i1].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY &&
                orderList[i1 + 1].appId != VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY)
            {
                i1 += 1;
                continue;
            }
            if (isNeedResetOrder && countInPage == VAPP_LAUNCHER_MM_CELL_COUNT_IN_PAGE)
            {
                vappLauncherMmClearOrderData(&orderList[i2]);
                i2 += 1;
                countInPage = 0;
                continue;
            }

            // Compact app
            if (orderList[i1].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY)
            {
                orderList[i2].index = orderList[i1].index;
                orderList[i2].subindex = orderList[i1].subindex;
            }
            else
            {
                if (orderList[i1].index == fromIndex)
                {
                    // Cell in same folder
                    toSubindex += 1;
                }
                else
                {
                    // Cell in different index/folder
                    fromIndex = orderList[i1].index;

                    // Check if change page
                    if (orderList[i2 - 1].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY)
                    {
                        toIndex = (toIndex + VAPP_LAUNCHER_MM_CELL_COUNT_IN_PAGE) /
                                  VAPP_LAUNCHER_MM_CELL_COUNT_IN_PAGE *
                                  VAPP_LAUNCHER_MM_CELL_COUNT_IN_PAGE;
                    }
                    else
                    {
                        toIndex += 1;
                    }

                    // Check if in folder
                    if (orderList[i1].subindex == VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX)
                    {
                        toSubindex = orderList[i1].subindex;
                    }
                    else
                    {
                        toSubindex = 0;
                        
                        // Compact folder
                        if (fromIndex != toIndex)
                        {
                            for (VfxS32 i = 0; i < VAPP_LAUNCHER_MM_MAX_PAGE_FOLDER_DATA; ++i)
                            {
                                if (s_vappLauncherMmAllFolderData[i].index == fromIndex + VAPP_LAUNCHER_MM_BAR_CELL_COUNT)
                                {
                                    s_vappLauncherMmAllFolderData[i].index = toIndex + VAPP_LAUNCHER_MM_BAR_CELL_COUNT;
                                }
                            }
                        }
                    }
                }
                orderList[i2].index = toIndex;
                orderList[i2].subindex = toSubindex;
            }
            orderList[i2].appId = orderList[i1].appId;
            vappLauncherMmClearOrderData(&orderList[i1]);
        }
        else
        {
            if (orderList[i1].appId != VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY)
            {
                fromIndex = toIndex = orderList[i1].index;
                toSubindex = orderList[i1].subindex;
            }
        }

        // successive empty string means end of data
        if (orderList[i2].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY)
        {
            if (i2 >= 1 && orderList[i2 - 1].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY)
            {
                i1 += 1;
                i2 += 1;
                orderCount = i2;
                break;
            }
        }
        countInPage = (orderList[i2].index % VAPP_LAUNCHER_MM_CELL_COUNT_IN_PAGE) + 1;
        i1 += 1;
        i2 += 1;
        orderCount = i2;
    }
    orderCount -= 2;

    // set the remaining to empty string
    if (i1 != i2)
    {
        while (i2 < maxDataCount)
        {
            vappLauncherMmClearOrderData(&orderList[i2]);
            i2 += 1;
        }
    }

    // clear folder name if necessary
    for (VfxS32 i = 0; i < VAPP_LAUNCHER_MM_MAX_PAGE_FOLDER_DATA; ++i)
    {
        if (s_vappLauncherMmAllFolderData[i].index != VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX &&
            s_vappLauncherMmAllFolderData[i].index >= VAPP_LAUNCHER_MM_BAR_CELL_COUNT)
        {
            VfxBool isFolder = VFX_FALSE;
            for (VfxS32 j = 0; j < orderCount; ++j)
            {
                if (orderList[j].index + VAPP_LAUNCHER_MM_BAR_CELL_COUNT == s_vappLauncherMmAllFolderData[i].index)
                {
                    if (orderList[j].subindex != VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX &&
                        orderList[j].appId != VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY &&
                        orderList[j].appId != VAPP_LAUNCHER_MM_APP_ORDER_DATA_DELETED)
                    {
                        isFolder = VFX_TRUE;
                    }
                    
                    break;
                }
            }

            if (!isFolder)
            {
                s_vappLauncherMmAllFolderData[i].index = VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX;
                memset(s_vappLauncherMmAllFolderData[i].name,
                       0,
                       sizeof(s_vappLauncherMmAllFolderData[i].name));
            }
        }
    }
    
    return orderCount;
}

void vappLauncherMmCompactGroupData(VappLauncherMmAppOrderDataStruct *barOrderList, VfxS32 maxDataCount)
{
    // For shortcut bar
    VfxS32 i1 = 0;
    VfxS32 i2 = 0;
    VfxS32 fromIndex = 0;
    VfxS32 toIndex = 0;
    VfxS32 toSubindex = 0;
    
    while (i1 < maxDataCount)
    {
        if (barOrderList[i1].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY ||
            barOrderList[i1].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_DELETED)
        {
            i1 += 1;
            continue;
        }

        if (i1 != i2)
        {
            // Compact app
            if (barOrderList[i1].index == fromIndex)
            {
                // Cell in same folder
                toSubindex += 1;
            }
            else
            {
                // Cell in different index/folder
                fromIndex = barOrderList[i1].index;

                toIndex += 1;

                // Check if in folder
                if (barOrderList[i1].subindex == VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX)
                {
                    toSubindex = barOrderList[i1].subindex;
                }
                else
                {
                    toSubindex = 0;
                    
                    // Compact folder
                    if (fromIndex != toIndex)
                    {
                        for (VfxS32 i = 0; i < VAPP_LAUNCHER_MM_MAX_PAGE_FOLDER_DATA; ++i)
                        {
                            if (s_vappLauncherMmAllFolderData[i].index == fromIndex)
                            {
                                s_vappLauncherMmAllFolderData[i].index = toIndex;
                            }
                        }
                    }
                }
            }
            barOrderList[i2].index = toIndex;
            barOrderList[i2].subindex = toSubindex;
            barOrderList[i2].appId = barOrderList[i1].appId;
            vappLauncherMmClearOrderData(&barOrderList[i1]);
        }
        else
        {
            fromIndex = toIndex = barOrderList[i1].index;
            toSubindex = barOrderList[i1].subindex;
        }

        i1 += 1;
        i2 += 1;
    }

    if (i1 != i2)
    {
        while (i2 < maxDataCount)
        {
            vappLauncherMmClearOrderData(&barOrderList[i2]);
            i2 += 1;
        }
    }

    // clear folder name if necessary
    for (VfxS32 i = 0; i < VAPP_LAUNCHER_MM_MAX_PAGE_FOLDER_DATA; ++i)
    {
        if (s_vappLauncherMmAllFolderData[i].index != VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX &&
            s_vappLauncherMmAllFolderData[i].index < VAPP_LAUNCHER_MM_BAR_CELL_COUNT)
        {
            VfxBool isFolder = VFX_FALSE;
            for (VfxS32 j = 0; j < maxDataCount; ++j)
            {
                if (barOrderList[j].index == s_vappLauncherMmAllFolderData[i].index)
                {
                    if (barOrderList[j].subindex != VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX &&
                        barOrderList[j].appId != VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY &&
                        barOrderList[j].appId != VAPP_LAUNCHER_MM_APP_ORDER_DATA_DELETED)
                    {
                        isFolder = VFX_TRUE;
                    }
                    
                    break;
                }
            }
            
            if (!isFolder)
            {
                s_vappLauncherMmAllFolderData[i].index = VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX;
                memset(s_vappLauncherMmAllFolderData[i].name,
                       0,
                       sizeof(s_vappLauncherMmAllFolderData[i].name));
            }
        }
    }
}

mmi_ret vappLauncherMmEventHandler(mmi_event_struct *event)
{
    switch (event->evt_id)
    {
        case EVT_ID_SRV_APPMGR_INSTALL_PACKAGE:
        case EVT_ID_SRV_APPMGR_UPDATE_INSTALLED_PACKAGE:
        case EVT_ID_SRV_APPMGR_UNINSTALL_PACKAGE:
        case EVT_ID_VAPP_LANGUAGE_CHANGED:
#ifdef __MMI_THEMES_APPLICATION__
        case EVT_ID_VAPP_THEME_CHANGED:
#endif
#if defined(__MMI_FE_VECTOR_FONT_ON_FILE_SYSTEM__)
		case EVT_ID_VAPP_FONT_CHANGED:
#endif
            vappLauncherMmSetNeedSycn();
            s_vappLauncherMmIsDataDirty = VFX_TRUE;
            break;
            
        default:
            break;
    }
    return MMI_RET_OK;
}

VfxBool vappLauncherMmGetIsDataDirty()
{
    return s_vappLauncherMmIsDataDirty;
}

VfxS32 vappLauncherMmGetSycnVersion()
{
    return s_vappLauncherMmSyncVersion;
}

void vappLauncherMmSetNeedSycn()
{
    s_vappLauncherMmNeedSync = VFX_TRUE;
    s_vappLauncherMmSyncVersion += 1;
}

static void vappLauncherMmUpdateAppDataCache(VappLauncherMmAppOrderDataStruct *allOrderData, VfxS32 orderCount)
{
    vappLauncherMmClearStringWidth();
    
    for (VfxS32 i = 0; i < orderCount; ++i)
    {
        if (allOrderData[i].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY)
        {
            continue;
        }

        if (allOrderData[i].appId == VAPP_LAUNCHER_MM_APP_ORDER_DATA_DELETED)
        {
            continue;
        }

        mmi_app_package_name_struct appName;
        srv_appmgr_get_app_package_name_by_id(allOrderData[i].appId, appName);
        vappLauncherMmGetAppInfo(appName, i);
    }
}

void vappLauncherMmGetAppInfo(mmi_app_package_name_struct & appName, VfxS32 cacheIndex)
{
    srv_app_info_struct info;
    mmi_ret result = srv_appmgr_get_app_package_info(appName, &info);
    VFX_ASSERT(result != MMI_RET_ERR);
    
    VfxFontDesc fontDesc;
    fontDesc.size = VFX_FONT_DESC_VF_SIZE(VAPP_LAUNCHER_MM_CELL_TITLE_FONT_SIZE);
    fontDesc.attr = VFX_FONT_DESC_ATTR_BOLD;
    fontDesc.effect = vappLauncherMmGetStringFontEffectId();
    s_vappLauncherMmAppDataCacheStringWidth[cacheIndex] = fontDesc.measureStr(info.string).width;
}

VfxS32 vappLauncherMmFindAppDataIndex(mmi_app_package_name_struct &appName)
{
    VfxS32 i;
    for (i = 0; i < VAPP_LAUNCHER_MM_APP_DATA_CACHE_COUNT; ++i)
    {
        if (s_vappLauncherMmAllOrderData[i].appId != VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY)
        {
            mmi_app_package_name_struct appPackageName;
            srv_appmgr_get_app_package_name_by_id(s_vappLauncherMmAllOrderData[i].appId, appPackageName);
            if (strncmp(appPackageName, appName, MMI_APP_NAME_MAX_LEN) == 0)
            {
                return i;
            }
        }
    }

    return -1;
}


/***************************************************************************** 
 * Global Function
 *****************************************************************************/

VfxU8 vappLauncherMmGetStringFontEffectId()
{
    return s_vappLauncherMmAppStringFontEffect->getEffectId();
}

VfxS32 vappLauncherMmGetStringWidth(mmi_app_package_name_struct &appName)
{
    VfxS32 i = vappLauncherMmFindAppDataIndex(appName);
    if (i == -1)
    {
        return -1;
    }

    return s_vappLauncherMmAppDataCacheStringWidth[i];
}

void vappLauncherMmSetStringWidth(mmi_app_package_name_struct &appName, VfxS16 stringWidth)
{
    VfxS32 i = vappLauncherMmFindAppDataIndex(appName);
    if (i == -1)
    {
        return;
    }

    s_vappLauncherMmAppDataCacheStringWidth[i] = stringWidth;
}

void vappLauncherMmClearStringWidth()
{
    for (VfxS32 i = 0; i < VAPP_LAUNCHER_MM_APP_DATA_CACHE_COUNT; ++i)
    {
        s_vappLauncherMmAppDataCacheStringWidth[i] = -1;
    }
}

VappLauncherMm *vappLauncherMmGetInstance()
{
    return s_vappLauncherMm;
}

void vappLauncherMmUninstallApp(VappLauncherMmCell *cell)
{
    VappLauncherMm *content = vappLauncherMmGetInstance();
    content->onDelBtnClicked(cell);
}

void vappLauncherMmClearOrderData(VappLauncherMmAppOrderDataStruct *orderData)
{
    orderData->index = VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX;
    orderData->subindex = VAPP_LAUNCHER_MM_APP_ORDER_DATA_INVALID_INDEX;
    orderData->appId = VAPP_LAUNCHER_MM_APP_ORDER_DATA_EMPTY;
}

/***************************************************************************** 
 * Class VappLauncherMm
 *****************************************************************************/

VAPP_LAUNCHER_SYS_PUBLISH_NATIVE(
    VappLauncherMm,
    VAPP_LAUNCHER_TYPE_MM,
    VappLauncherMMPublisher);

VAPP_LAUNCHER_IMPLEMENT_CLASS(VappLauncherMm, VappLauncher);

VfxS32 VappLauncherMm::s_currentPage = 0;

VappLauncherMm::VappLauncherMm():
    m_bottomBarBgFrame(NULL),
    m_menu(NULL),
    m_builder(NULL),
    m_wallpaper(NULL),
    m_wallpaperMask(NULL),
    m_timerResumeWallpaper(NULL),
#ifdef VAPP_LAUNCHER_MM_MOTION_DOUBLE_TAP_TO_CHANGE_SWITCH_EFFECT
    m_doubleTapSensorHandle(SRV_SENSOR_MOTION_INVALID_PARAM),
    m_doubleTapSwitchDirection(0),
    m_doubleTapTimer(NULL),
#endif
    m_dataSyncVersion(-1),
    m_isDataDirty(VFX_FALSE),
    m_isOrganizeMode(VFX_FALSE),
    m_isFolderMode(VFX_FALSE),
    m_isEnter(VFX_FALSE),
    m_deletingPopup(NULL),
    m_isPopupAutoDestory(VFX_FALSE),
#if defined(VAPP_LAUNCHER_MM_SUSPEND_LWP_DURING_SWIPE)
    m_isSuspendWallpaperForSwipe(VFX_FALSE),
    m_isSuspendWallpaperForPenDown(VFX_FALSE),
#endif /* defined(VAPP_LAUNCHER_MM_SUSPEND_LWP_DURING_SWIPE) */
    m_isWallpaperSuspendForPageExit(VFX_FALSE),
    m_isWallpaperSuspendForNcenter(VFX_FALSE),
    m_isWallpaperSuspendForEditMode(VFX_FALSE),
    m_isWallpaperSuspendForFolderMode(VFX_FALSE)
{
}

void VappLauncherMm::setIsUninstallingMode(VfxBool isUninstalling)
{
    m_menu->setIsUninstallingMode(isUninstalling);
}

#if defined(__MMI_VUI_MAIN_MENU_SWITCH_EFFECT__)
void VappLauncherMm::setTransitionEffect(VcpPageMenuTransitionType transitionType)
{
    m_menu->setTransitionEffect(transitionType);
}
#endif // __MMI_VUI_MAIN_MENU_SWITCH_EFFECT__

#ifdef VAPP_LAUNCHER_MM_MOTION_DOUBLE_TAP_TO_CHANGE_SWITCH_EFFECT
void VappLauncherMm::startListenMotionSensor()
{
    if (m_doubleTapSensorHandle == SRV_SENSOR_MOTION_INVALID_PARAM && m_isEnter)
    {
        m_doubleTapSensorHandle = srv_sensor_start_listen(SRV_SENSOR_MOTION_DOUBLE_TAP, NULL, &VappLauncherMm::sensorHandler, this);
    }
}

void VappLauncherMm::stopListenMotionSensor()
{
    if (m_doubleTapSensorHandle != SRV_SENSOR_MOTION_INVALID_PARAM && m_isEnter)
    {
        srv_sensor_stop_listen(m_doubleTapSensorHandle);
        m_doubleTapSensorHandle = SRV_SENSOR_MOTION_INVALID_PARAM;
    }
}
#endif

VappLauncherId VappLauncherMm::getId() const
{
    return VappLauncherId(VAPP_LAUNCHER_SRC_NATIVE, VAPP_LAUNCHER_TYPE_MM);
}

VfxS32 VappLauncherMm::getName(VfxWChar *string, VfxS32 size) const
{
    VFX_ASSERT(string && size > 0);
    
    const VfxWChar *str = vfxSysResGetStr(STR_ID_VAPP_LAUNCHER_MM);
    
    mmi_wcsncpy((WCHAR *)string, (const WCHAR *)str, size - 1);
    
    return vfx_sys_wcslen(string);
}

VfxFrame *VappLauncherMm::createIcon(VfxObject *parentObj)
{
    return NULL;
}

VfxS32 VappLauncherMm::getScreenshotNum() const
{
    return VAPP_LAUNCHER_MM_SCREENSHOT_COUNT;
}

VfxFrame **VappLauncherMm::createScreenshot(VfxObject *parentObj) const
{
    VfxS32 screenshotNum = getScreenshotNum();
    VfxFrame **screenshot;
    
    VFX_ALLOC_MEM(screenshot, screenshotNum, parentObj);
    for (VfxS32 i = 0; i < screenshotNum; ++i)
    {
        VFX_OBJ_CREATE(screenshot[i], VfxImageFrame, parentObj);
        ((VfxImageFrame *)(screenshot[i]))->setResId(IMG_ID_VAPP_LAUNCHER_MM_SCREENSHOT + i);
    }
    
    return screenshot;
}

void VappLauncherMm::onCreateView()
{
    VappLauncher::onCreateView();

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MOI", SA_start);
#endif

    VappLauncherScreen *launcherScreen = static_cast<VappLauncherScreen *>(VfxMainScr::findMainScr(this));
    VFX_ASSERT(launcherScreen);
    launcherScreen->m_signalScreenOnEntered.connect(this, &VappLauncherMm::onScreenEntered);
    launcherScreen->setBgColor(VFX_COLOR_TRANSPARENT);
    
#ifndef VAPP_LAUNCHER_MM_DEBUG_ORDER_DATA
    #ifdef __MMI_VUI_PLATFORM_CONTEXT_SLIM__
    //Maybe need to increase heap size of fruit launcher for debug order data
    if (s_vappLauncherMmIsFirstLoad)
    {
        VFX_ALLOC_MEM(s_vappLauncherMmAllOrderData,
                      sizeof(VappLauncherMmAppOrderDataStruct) * VAPP_LAUNCHER_MM_SAVED_APP_ORDER_DATA_COUNT,
                      this);
        VFX_ALLOC_MEM(s_vappLauncherMmAllFolderData,
                      sizeof(VappLauncherMmAppFolderDataStruct) * VAPP_LAUNCHER_MM_SAVED_APP_FOLDER_DATA_COUNT,
                      this);
    }
    #else
    if (s_vappLauncherMmIsFirstLoad)
    {
        VfxContext *cntx = VFX_OBJ_GET_INSTANCE(VappPlatformContext);
        VFX_ALLOC_MEM(s_vappLauncherMmAllOrderData,
                      sizeof(VappLauncherMmAppOrderDataStruct) * VAPP_LAUNCHER_MM_SAVED_APP_ORDER_DATA_COUNT,
                      cntx);
        VFX_ALLOC_MEM(s_vappLauncherMmAllFolderData,
                      sizeof(VappLauncherMmAppFolderDataStruct) * VAPP_LAUNCHER_MM_SAVED_APP_FOLDER_DATA_COUNT,
                      cntx);
    }
    #endif//__MMI_VUI_WITHOUT_VAPP_PLATFORM_CONTEXT__
#endif
    VFX_ALLOC_MEM(s_vappLauncherMmAppDataCacheStringWidth,
                  sizeof(VfxS16) * VAPP_LAUNCHER_MM_APP_DATA_CACHE_COUNT,
                  this);
    VFX_ALLOC_NEW(s_vappLauncherMmAppStringFontEffect, VfxFontEffect, this);
    s_vappLauncherMmAppStringFontEffect->setType(VFX_FONT_EFFECT_SHADOW);
    s_vappLauncherMmAppStringFontEffect->setShadow(VFX_COLOR_BLACK,
                                                   VAPP_LAUNCHER_MM_APP_STRING_SHADOW_DEGREE,
                                                   VAPP_LAUNCHER_MM_APP_STRING_SHADOW_DISTANT,
                                                   VAPP_LAUNCHER_MM_APP_STRING_SHADOW_RANGE,
                                                   VAPP_LAUNCHER_MM_APP_STRING_SHADOW_TRANSPARENCY
    );
    
    s_vappLauncherMmOrderCount = 0;
    s_vappLauncherMmNeedSync = VFX_TRUE;
    s_vappLauncherMmSyncVersion = 0;
    s_vappLauncherMmIsDataDirty = VFX_FALSE;
    
    vappLauncherMmCheckLoadOrderData();
    m_isDataDirty |= vappLauncherMmGetIsDataDirty();
    m_dataSyncVersion = vappLauncherMmGetSycnVersion();

    setSize(VAPP_LAUNCHER_MM_SCREEN_WIDTH, VAPP_LAUNCHER_MM_SCREEN_HEIGHT);
    
    if (!isRestoreStatus())
    {
        s_currentPage = 0;
    }
    
    initUI();

    mmi_frm_cb_reg_event(EVT_ID_SRV_APPMGR_INSTALL_PACKAGE, vappLauncherMmEventHandler, NULL);
    mmi_frm_cb_reg_event(EVT_ID_SRV_APPMGR_UPDATE_INSTALLED_PACKAGE, vappLauncherMmEventHandler, NULL);
    mmi_frm_cb_reg_event(EVT_ID_SRV_APPMGR_UNINSTALL_PACKAGE, vappLauncherMmEventHandler, NULL);
    mmi_frm_cb_reg_event(EVT_ID_VAPP_LANGUAGE_CHANGED, vappLauncherMmEventHandler, NULL);
#ifdef __MMI_THEMES_APPLICATION__
    mmi_frm_cb_reg_event(EVT_ID_VAPP_THEME_CHANGED, vappLauncherMmEventHandler, NULL);
#endif
#if defined(__MMI_FE_VECTOR_FONT_ON_FILE_SYSTEM__)
    mmi_frm_cb_reg_event(EVT_ID_VAPP_FONT_CHANGED, vappLauncherMmEventHandler, NULL);
#endif

    mmi_frm_cb_reg_event(EVT_ID_SRV_APPMGR_INSTALL_PACKAGE,  &VappLauncherMm::eventHandler, this);
    mmi_frm_cb_reg_event(EVT_ID_SRV_APPMGR_UPDATE_INSTALLED_PACKAGE,  &VappLauncherMm::eventHandler, this);
    mmi_frm_cb_reg_event(EVT_ID_SRV_APPMGR_UNINSTALL_PACKAGE,  &VappLauncherMm::eventHandler, this);
    
    s_vappLauncherMm = this;
    
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MOI", SA_stop);
#endif
}

void VappLauncherMm::onReleaseView()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MOD", SA_start);
#endif

    VappLauncherScreen *launcherScreen = static_cast<VappLauncherScreen *>(VfxMainScr::findMainScr(this));
    VFX_ASSERT(launcherScreen);
    launcherScreen->m_signalScreenOnEntered.disconnect(this, &VappLauncherMm::onScreenEntered);
    
    deinitUI();

    VFX_FREE_MEM(s_vappLauncherMmAppDataCacheStringWidth);
    VFX_DELETE(s_vappLauncherMmAppStringFontEffect);

#ifdef __MMI_VUI_PLATFORM_CONTEXT_SLIM__
    //
    //The memory allocated from asm, need free before release launcher.
    //
    VFX_FREE_MEM(s_vappLauncherMmAllOrderData);
    VFX_FREE_MEM(s_vappLauncherMmAllFolderData);
#endif
   
    mmi_frm_cb_dereg_event(EVT_ID_SRV_APPMGR_INSTALL_PACKAGE, vappLauncherMmEventHandler, NULL);
    mmi_frm_cb_dereg_event(EVT_ID_SRV_APPMGR_UPDATE_INSTALLED_PACKAGE, vappLauncherMmEventHandler, NULL);
    mmi_frm_cb_dereg_event(EVT_ID_SRV_APPMGR_UNINSTALL_PACKAGE, vappLauncherMmEventHandler, NULL);
    mmi_frm_cb_dereg_event(EVT_ID_VAPP_LANGUAGE_CHANGED, vappLauncherMmEventHandler, NULL);
#ifdef __MMI_THEMES_APPLICATION__
    mmi_frm_cb_dereg_event(EVT_ID_VAPP_THEME_CHANGED, vappLauncherMmEventHandler, NULL);
#endif
#if defined(__MMI_FE_VECTOR_FONT_ON_FILE_SYSTEM__)
    mmi_frm_cb_dereg_event(EVT_ID_VAPP_FONT_CHANGED, vappLauncherMmEventHandler, NULL);
#endif

    mmi_frm_cb_dereg_event(EVT_ID_SRV_APPMGR_INSTALL_PACKAGE, &VappLauncherMm::eventHandler, this);
    mmi_frm_cb_dereg_event(EVT_ID_SRV_APPMGR_UPDATE_INSTALLED_PACKAGE, &VappLauncherMm::eventHandler, this);
    mmi_frm_cb_dereg_event(EVT_ID_SRV_APPMGR_UNINSTALL_PACKAGE, &VappLauncherMm::eventHandler, this);
    
    s_vappLauncherMm = NULL;
    
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MOD", SA_stop);
#endif

    VappLauncher::onReleaseView();
}

void VappLauncherMm::onEnter()
{
    VappLauncher::onEnter();

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM0", SA_start);
#endif

    m_isEnter = VFX_TRUE;

    // Restore the wallpaper. Note that video wallpaper cannot be changed when the
    // setting sends a 'wallpaper-changed' signal.
    //
    // SEE ALSO: onWallpaperChanged
    if (!m_wallpaper)
    {
        createWallpaperExt(VAPP_LAUNCHER_MM_WALLPAPER_NORMAL_DELAY_TIME);
    }
    else
    {
        m_wallpaper->restoreView();
    }
    
    // For performance, resume the wallpaper after the page transition animation
    // completes. To avoid from the complication, we only resume wallpaper when
    // it had suspended because the page exited.
    if (m_wallpaper && m_isWallpaperSuspendForPageExit)
    {
        delayResumeWallpaper(VAPP_LAUNCHER_MM_WALLPAPER_NORMAL_DELAY_TIME);
        m_isWallpaperSuspendForPageExit = VFX_FALSE;
    }

    // reload menu
    if (m_dataSyncVersion != vappLauncherMmGetSycnVersion())
    {
        reloadMainmenu();
    }

    m_menu->refreshMenu();
    m_menu->setCurrentPageIndex(s_currentPage, VFX_FALSE);
    
#ifdef VAPP_LAUNCHER_MM_MOTION_DOUBLE_TAP_TO_CHANGE_SWITCH_EFFECT
    startListenMotionSensor();
#endif
    
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM0", SA_stop);
#endif
}

void VappLauncherMm::onExit()
{
    if (m_isOrganizeMode)
    {
        // Do not leave edit mode if it's in the uninstalling status.
        if (g_vapp_launcher_mm_uninstalled_cell != NULL && m_gIsUninstallBtnClicked)
        {
            m_menu->compactPages(VFX_FALSE);
        }
        else
        {
            // The rest of behaviour must leave edit mode (e.g. enter screen lock)
            m_menu->leaveOrganizationMode(VFX_TRUE);
        }
        //m_menu->leaveOrganizationMode();
        m_isDataDirty = VFX_TRUE;
    }

    if (m_isDataDirty)
    {
        saveAllData();
    }
        
#ifdef VAPP_LAUNCHER_MM_MOTION_DOUBLE_TAP_TO_CHANGE_SWITCH_EFFECT
    stopListenMotionSensor();
#endif
    
    // For performance, suspend the wallpaper before the page transition
    // animation starts.
    if (m_wallpaper && !m_isWallpaperSuspendForPageExit)
    {
        m_wallpaper->suspend();
        m_isWallpaperSuspendForPageExit = VFX_TRUE;
    }
    
    m_isEnter = VFX_FALSE;
    
    VappLauncher::onExit();
}

void VappLauncherMm::onSerializeView(VfxArchive *ar)
{
    VappLauncher::onSerializeView(ar);

    m_wallpaper->serializeView();
}

VfxResId VappLauncherMm::onGetStatusBarBg()
{
    return IMG_ID_VAPP_LAUNCHER_MM_STATUS_BAR_BG;
}

VfxBool VappLauncherMm::onGetStatusBarTranslucent()
{
    return VFX_TRUE;
}

VfxBool VappLauncherMm::onKeyInput(VfxKeyEvent &event)
{
    if (event.type == VFX_KEY_EVENT_TYPE_DOWN)
    {
        switch (event.keyCode)
        {
        case VFX_KEY_CODE_BACK:
        case VFX_KEY_CODE_HOME:
            if (m_isOrganizeMode)
            {
                m_menu->leaveOrganizationMode();
                saveAllData();
                return VFX_TRUE;
            }
            else if (m_menu->getFolderState() == VCP_PAGE_MENU_FIRST_FOLDER_MODE ||
                     m_menu->getFolderState() == VCP_PAGE_MENU_FOLDER_MODE)
            {
                m_menu->leaveFolderMode();
                return VFX_TRUE;
            }
            
            break;
        default:
            break;
        };
    }
    return VfxControl::onKeyInput(event);
}

VfxBool VappLauncherMm::onPreviewPenInput(VfxPenEvent &event)
{
    if (m_wallpaper)
    {
        if (event.pos.y > VAPP_LAUNCHER_MM_CELL_START_Y &&
            event.pos.y < VAPP_LAUNCHER_MM_BOTTOM_BAR_Y &&
            !m_menu->isHitCell(event))
        {
            m_wallpaper->doPenInput(event);
        }
        
    #if defined(VAPP_LAUNCHER_MM_SUSPEND_LWP_DURING_SWIPE)
        switch (event.type)
        {
            case VFX_PEN_EVENT_TYPE_DOWN:
                suspendWallpaperForPenDown();
                break;
        
            case VFX_PEN_EVENT_TYPE_MOVE:
                suspendWallpaperForSwipe();
                break;
            
            case VFX_PEN_EVENT_TYPE_UP:
            case VFX_PEN_EVENT_TYPE_ABORT:
                resumeWallpaperForPenDown();
                resumeWallpaperForSwipe();
                break;
        
            default:
                break;
        }
    }
    #endif

    return VfxControl::onPreviewPenInput(event);
}

void VappLauncherMm::reloadMainmenu()
{
    if (m_isOrganizeMode)
    {
        saveAllData();
    }
    
    vappLauncherMmCheckLoadOrderData();
    m_isDataDirty |= vappLauncherMmGetIsDataDirty();
    m_dataSyncVersion = vappLauncherMmGetSycnVersion();

    if (m_builder != NULL)
    {
        mmi_app_package_name_struct appName;
        if (g_vapp_launcher_mm_uninstalled_cell)
        {
            g_vapp_launcher_mm_uninstalled_cell->getCellAppName(appName);
        }
        
        m_menu->clearAllMenuItems();
        
        if (g_vapp_launcher_mm_uninstalled_cell)
        {
            m_builder->loadMenu(m_menu, &appName, &g_vapp_launcher_mm_uninstalled_cell);
        }
        else
        {
            m_builder->loadMenu(m_menu, NULL, NULL);
        }

        m_menu->reloadFolderEditor();
        
        if (m_isOrganizeMode)
        {
            m_menu->enterOrganizationMode();
        }
    }
}

void VappLauncherMm::initUI()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MIU", SA_start);
#endif
    
    // Create tool bar background
    VFX_OBJ_CREATE(m_bottomBarBgFrame, VfxFrame, this);
    m_bottomBarBgFrame->setPos(0, VAPP_LAUNCHER_MM_BOTTOM_BAR_Y);
    m_bottomBarBgFrame->setSize(VAPP_LAUNCHER_MM_SCREEN_WIDTH, VAPP_LAUNCHER_MM_BOTTOM_BAR_HEIGHT);
    m_bottomBarBgFrame->setImgContent(VfxImageSrc(IMG_ID_VAPP_LAUNCHER_MM_TOOLBAR_BG) );
    m_bottomBarBgFrame->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);

    // Create VappLauncherMmPageMenu
    initMenu();

    // Create wallpaper
    if(isFirstInit())
    {
        createWallpaper(VAPP_LAUNCHER_MM_WALLPAPER_BOOTUP_DELAY_TIME);
    }
    else
    {
        createWallpaper(VAPP_LAUNCHER_MM_WALLPAPER_NORMAL_DELAY_TIME);
    }

    // Connect wallpaper changed signal.
    VappWallpaperSettingInterface *setting;
    setting = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingInterface);
    setting->m_signalWallpaperIsUpdated.connect(this, &VappLauncherMm::onWallpaperChanged);

    // For performance, we will suspend the wallpaper when the notification
    // center is active.
    VappNCenter *ncenter = VFX_OBJ_GET_INSTANCE(VappNCenter);
    ncenter->m_signalEvent.connect(this, &VappLauncherMm::onNotificationCenterChanged);

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MIU", SA_stop);
#endif
}

void VappLauncherMm::deinitUI()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MDU", SA_start);
#endif

    // Disconnect wallpaper changed signal.
    VappWallpaperSettingInterface *setting;
    setting = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingInterface);
    setting->m_signalWallpaperIsUpdated.disconnect(this, &VappLauncherMm::onWallpaperChanged);
    
    // Disconnect the notification center changed signal.
    VappNCenter *ncenter = VFX_OBJ_GET_INSTANCE(VappNCenter);
    ncenter->m_signalEvent.disconnect(this, &VappLauncherMm::onNotificationCenterChanged);
    
    releaseWallpaper();
    
    VFX_OBJ_CLOSE(m_builder);
    VFX_OBJ_CLOSE(m_menu);
    VFX_OBJ_CLOSE(m_bottomBarBgFrame);

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MDU", SA_stop);
#endif
}

void VappLauncherMm::initMenu()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM1", SA_start);
#endif

    VFX_OBJ_CREATE(m_menu, VappLauncherMmPageMenu, this);
    VcpPageMenuLayout layout;
    layout.rowCount = VAPP_LAUNCHER_MM_CELL_ROW_COUNT;
    layout.columnCount = VAPP_LAUNCHER_MM_CELL_COLUMN_COUNT;
    layout.cellStartX = VAPP_LAUNCHER_MM_CELL_START_X;
    layout.cellStartY = VAPP_LAUNCHER_MM_CELL_START_Y;
    layout.cellOffsetX = VAPP_LAUNCHER_MM_CELL_OFFSET_X;
    layout.cellOffsetY = VAPP_LAUNCHER_MM_CELL_OFFSET_Y;
    layout.rowCountInFolderIcon = VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_ROW_COUNT;
    layout.columnCountInFolderIcon = VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_COLUMN_COUNT;
    layout.cellInFolderIconStartX = VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_START_X;
    layout.cellInFolderIconStartY = VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_START_Y;
    layout.cellInFolderIconOffsetX = VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_OFFSET_X;
    layout.cellInFolderIconOffsetY = VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_OFFSET_Y;
    layout.cellInFolderIconScale = VAPP_LAUNCHER_MM_CELL_IN_FOLDER_ICON_SCALE;
    layout.pageMargin = VAPP_LAUNCHER_MM_PAGE_MARGIN;
    layout.bottomBarOffsetY = VAPP_LAUNCHER_MM_BOTTOM_BAR_Y;
    layout.bottomBarVisibleShiftY = VAPP_LAUNCHER_MM_BOTTOM_BAR_VISIBLE_SHIFT_Y;
    m_menu->setPos(VfxPoint(0, 0));
    m_menu->setSize(VAPP_LAUNCHER_MM_SCREEN_WIDTH, VAPP_LAUNCHER_MM_SCREEN_HEIGHT);
    m_menu->setMenuLayout(layout);
    m_menu->setCellIconSize(VfxSize(VAPP_LAUNCHER_MM_CELL_OFFSET_X, VAPP_LAUNCHER_MM_CELL_OFFSET_Y) );
    m_menu->m_appClicked.connect(this, &VappLauncherMm::onAppClicked);
    m_menu->m_organizationChanged.connect(this, &VappLauncherMm::onOrganizeChanged);
    m_menu->m_folderModeChanged.connect(this, &VappLauncherMm::onFolderModeChanged);
    m_menu->m_pageChanged.connect(this, &VappLauncherMm::onPageChanged);
    m_menu->m_pageMoved.connect(this, &VappLauncherMm::onPageMoved);

#if defined(__MMI_VUI_MAIN_MENU_SWITCH_EFFECT__)
    // Read barrel setting from nvram
    VfxS16 sError = 0;
    VfxU8 setting = 0;
    ReadValue(NVRAM_VAPP_LAUNCHER_MM_BARREL_SETTING, (void*)&setting, DS_BYTE, & sError);
    m_menu->setTransitionEffect((VcpPageMenuTransitionType)setting);
#endif // __MMI_VUI_MAIN_MENU_SWITCH_EFFECT__
    
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM1", SA_stop);
    SLA_CustomLogging("MM1", SA_start);
#endif

    VappLauncherMmAppOrderDataStruct *orderList = s_vappLauncherMmAllOrderData + VAPP_LAUNCHER_MM_MAX_BOTTOM_BAR_APP_DATA;
    VappLauncherMmAppOrderDataStruct *barOrderList = s_vappLauncherMmAllOrderData;

    VFX_OBJ_CREATE(m_builder, VappLauncherMmBuilder, this);
    m_builder->setFolderData(s_vappLauncherMmAllFolderData, VAPP_LAUNCHER_MM_MAX_PAGE_FOLDER_DATA);
    m_builder->setAppOrderData(orderList, VAPP_LAUNCHER_MM_MAX_PAGE_APP_DATA);
    m_builder->setAppGroupData(barOrderList, VAPP_LAUNCHER_MM_MAX_BOTTOM_BAR_APP_DATA);
    m_builder->loadMenu(m_menu, NULL, NULL);

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("MM1", SA_stop);
#endif
}

void VappLauncherMm::createWallpaper(VfxMsec delayTime)
{
    // create wallpaper bounds mask
    VFX_OBJ_CREATE(m_wallpaperMask, VfxFrame, this);
    m_wallpaperMask->setIsUnhittable(VFX_TRUE);
    m_wallpaperMask->m_signalBoundsChanged.connect(this, &VappLauncherMm::onWallpaperMaskBoundsChanged);
        
    //
    // Create the wallpaper.
    m_wallpaper = VappWallpaperKit::createWallpaper(this, VAPP_WALLPAPER_SRC_HOMESCREEN, m_menu->getPageCount());

    // For performance, suspend it first. Resume the wallpaper according to the
    // 'delayTime'.
    //
    //   = 0: resume it immediately
    //   > 0: resume it after the specified msec.
    //   < 0: do not resume it now.
    m_wallpaper->suspend();

    if (delayTime >= 0)
    {
        delayResumeWallpaper(delayTime);
    }
}

void VappLauncherMm::createWallpaperExt(VfxMsec delayTime)
{
    createWallpaper(delayTime);

    // For performance, if the notification center is present, suspend it.
    if (m_isWallpaperSuspendForNcenter)
    {
        m_wallpaper->suspend();
    }
}

void VappLauncherMm::releaseWallpaper()
{
    // Release objects.
    VFX_OBJ_CLOSE(m_wallpaperMask);
    VFX_OBJ_CLOSE(m_wallpaper);
    VFX_OBJ_CLOSE(m_timerResumeWallpaper);

    // Reset other variables.
    m_isWallpaperSuspendForPageExit = VFX_FALSE;
}

void VappLauncherMm::onWallpaperMaskBoundsChanged(VfxFrame *frame, const VfxRect &oldBounds)
{
    m_wallpaper->setTotalPage(m_menu->getPageCount());
    m_wallpaper->setDesktopBoundsChanged(m_menu->getPageCount(),
                                         frame,
                                         oldBounds);
}

void VappLauncherMm::onWallpaperChanged()
{
    releaseWallpaper();

    // Because video wallpaper cannot be created in the background, we can only
    // re-create the wallpaper when this page is active.
    if (isEntered())
    {
        createWallpaperExt(VAPP_LAUNCHER_MM_WALLPAPER_NORMAL_DELAY_TIME);
    }
}

void VappLauncherMm::onNotificationCenterChanged(VappNCenterEventEnum event)
{
    switch (event)
    {
        case VAPP_NCENTER_EVENT_ENTER:
            // For performance, suspend the wallpaper if the notification center
            // is active.
            if (!m_isWallpaperSuspendForNcenter)
            {
                if (m_wallpaper)
                {
                    m_wallpaper->suspend();
                }

                m_isWallpaperSuspendForNcenter = VFX_TRUE;
            }

            // Suspend icon shaking
            m_menu->setIsEnterNCenter(VFX_TRUE);
            
        #ifdef VAPP_LAUNCHER_MM_MOTION_DOUBLE_TAP_TO_CHANGE_SWITCH_EFFECT
            stopListenMotionSensor();
        #endif
        
            break;

        case VAPP_NCENTER_EVENT_EXITED:
            // For performance, resume the wallpaper after the notification
            // center is inactive. To avoid from the complication, we only
            // resume wallpaper when it had suspended because the notification
            // center entered.
            if (m_isWallpaperSuspendForNcenter)
            {
                if (m_wallpaper)
                {
                    delayResumeWallpaper(VAPP_LAUNCHER_MM_WALLPAPER_NORMAL_DELAY_TIME);
                }

                m_isWallpaperSuspendForNcenter = VFX_FALSE;
            }
            
            // Resume icon shaking
            m_menu->setIsEnterNCenter(VFX_FALSE);
            
        #ifdef VAPP_LAUNCHER_MM_MOTION_DOUBLE_TAP_TO_CHANGE_SWITCH_EFFECT
            startListenMotionSensor();
        #endif
        
            break;

        default:
            break;
    }
}

void VappLauncherMm::delayResumeWallpaper(VfxMsec delayTime)
{
    // If wallpaper is not present, this function does nothing.
    if (!m_wallpaper)
    {
        return;
    }

    // Lazy creation the timer when it is needed.
    if (!m_timerResumeWallpaper)
    {
        VFX_OBJ_CREATE(m_timerResumeWallpaper, VfxTimer, this);
    }

    // If timer is already ongoing, fire it immediately.
    if (m_timerResumeWallpaper->getIsEnabled())
    {
        m_wallpaper->resume();
        m_timerResumeWallpaper->stop();
    }

    // Prepare for the next run. If delayTime is 0, resume it right now.
    if (delayTime == 0)
    {
        m_wallpaper->resume();
    }
    else if (delayTime > 0)
    {
        m_timerResumeWallpaper->setStartDelay(delayTime);
        m_timerResumeWallpaper->m_signalTick.connect(this, &VappLauncherMm::onResumeWallpaper);
        m_timerResumeWallpaper->start();
    }
}

void VappLauncherMm::onResumeWallpaper(VfxTimer *timer)
{
    if (m_wallpaper)
    {
        m_wallpaper->resume();
    }
}

#if defined(VAPP_LAUNCHER_MM_SUSPEND_LWP_DURING_SWIPE)
void VappLauncherMm::suspendWallpaperForSwipe()
{
    if (!m_isSuspendWallpaperForSwipe && m_wallpaper->isAllowSuspendOnSwipe())
    {
        m_isSuspendWallpaperForSwipe = VFX_TRUE;
        m_wallpaper->suspend();
    }
}

void VappLauncherMm::resumeWallpaperForSwipe()
{
    if (m_isSuspendWallpaperForSwipe)
    {
        m_isSuspendWallpaperForSwipe = VFX_FALSE;
        delayResumeWallpaper(VAPP_LAUNCHER_MM_WALLPAPER_SWIPE_DELAY_TIME);
    }
}

void VappLauncherMm::suspendWallpaperForPenDown()
{
    if (!m_isSuspendWallpaperForPenDown &&
        m_wallpaper->isAllowSuspendOnPenDown())
    {
        m_isSuspendWallpaperForPenDown = VFX_TRUE;
        m_wallpaper->suspend();
    }
}

void VappLauncherMm::resumeWallpaperForPenDown()
{
    if (m_isSuspendWallpaperForPenDown)
    {
        m_isSuspendWallpaperForPenDown = VFX_FALSE;
        delayResumeWallpaper(VAPP_LAUNCHER_MM_WALLPAPER_SWIPE_DELAY_TIME);
    }
}
#endif /* defined(VAPP_LAUNCHER_MM_SUSPEND_LWP_DURING_SWIPE) */

void VappLauncherMm::onScreenEntered(VfxBool isBackward)
{
    m_menu->preLoadAndCacheNeighborPageCell();
}

void VappLauncherMm::onAppClicked(VcpPageMenuCell * cell)
{
    VappLauncherMmCell * mmCell = static_cast<VappLauncherMmCell*>(cell);
    mmi_app_package_name_struct appName;
    mmCell->getCellAppName(appName);

    MMI_ID id = srv_appmgr_launch(appName);

    // Remove pressed down effect if still in main menu
    if (s_vappLauncherMm && m_isEnter && m_menu)
    {
        m_menu->checkUpdate();
    }
    
#if defined(__COSMOS_3D_V10__) && defined(__MMI_SCREEN_SWITCH_EFFECT_VENUS__)
    vcpSseSetupScenarioByApp(appName);
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT_VENUS__) */
}

void VappLauncherMm::onOrganizeChanged(VfxBool organizeMode)
{
    m_isOrganizeMode = organizeMode;
    
    if (organizeMode && !m_isWallpaperSuspendForEditMode)
    {
        m_isWallpaperSuspendForEditMode = VFX_TRUE;
        m_wallpaper->suspend();
    }
    else if (!organizeMode && m_isWallpaperSuspendForEditMode)
    {
        m_isWallpaperSuspendForEditMode = VFX_FALSE;
        delayResumeWallpaper(VAPP_LAUNCHER_MM_WALLPAPER_NORMAL_DELAY_TIME);
    }
}

void VappLauncherMm::onFolderModeChanged(VfxBool isFolderMode)
{
    m_isFolderMode = isFolderMode;
    
    if (isFolderMode && !m_isWallpaperSuspendForFolderMode)
    {
        m_isWallpaperSuspendForFolderMode = VFX_TRUE;
        m_wallpaper->suspend();
    }
    else if (!isFolderMode && m_isWallpaperSuspendForFolderMode)
    {
        m_isWallpaperSuspendForFolderMode = VFX_FALSE;
        delayResumeWallpaper(VAPP_LAUNCHER_MM_WALLPAPER_NORMAL_DELAY_TIME);
    }
}

void VappLauncherMm::onPageChanged(VfxS32 pageIndex)
{
    s_currentPage = pageIndex;
}

void VappLauncherMm::onDelBtnClicked(VappLauncherMmCell *cell)
{
    m_gIsUninstallBtnClicked = VFX_TRUE;

    // Freeze icon shaking
    setIsUninstallingMode(VFX_TRUE);
    
    g_vapp_launcher_mm_uninstalled_cell = cell;
    mmi_app_package_name_struct appName;
    cell->getCellAppName(appName);

    if ((srv_appmgr_get_app_package_type(appName) == SRV_APPMGR_MRE_APP_PACKAGE_TYPE &&
        srv_mre_appmgr_is_bg_running(appName)) ||
        (srv_appmgr_get_app_package_type(appName) == SRV_APPMGR_JAVA_APP_PACKAGE_TYPE
#if defined(__J2ME__)
         && srv_java_appfactory_is_app_running(appName)
#endif
        ))
    {
        // Deleting App is running
        VcpConfirmPopup* popup;
        VFX_OBJ_CREATE(popup, VcpConfirmPopup, this);
        popup->m_signalButtonClicked.connect(this, &VappLauncherMm::onBgRunningPopupClicked);
        popup->setButtonSet(VCP_CONFIRM_BUTTON_SET_OK);
        popup->setInfoType(VCP_POPUP_TYPE_FAILURE);
        popup->setText((STR_ID_VAPP_LAUNCHER_MM_EXIT_RUNNING_APP));
        popup->setButtonSet(VCP_CONFIRM_BUTTON_SET_OK);
        popup->setAutoDestory(VFX_TRUE);
        popup->show(VFX_TRUE);        
        
    }
    else
    {

        // Deleting App is not running,append the app name into pop-up for deleteing
        WCHAR temp[MMI_APP_NAME_MAX_LEN];
        srv_appmgr_get_app_package_name(appName, temp);
        VfxWString strAppName;
        strAppName.loadFromMem(temp);
        VfxWString strAsk = VFX_WSTR_RES(STR_ID_VAPP_LAUNCHER_MM_UNINSTALL);
        strAsk += strAppName;
        strAsk += VFX_WSTR("?");

        VcpConfirmPopup* popup;
        VFX_OBJ_CREATE(popup, VcpConfirmPopup, this);
        popup->m_signalButtonClicked.connect(this, &VappLauncherMm::onPopupButtonClicked);
        popup->setButtonSet(VCP_CONFIRM_BUTTON_SET_OK);
        popup->setInfoType(VCP_POPUP_TYPE_WARNING);
        popup->setText(strAsk);
        popup->setButtonSet(VCP_CONFIRM_BUTTON_SET_USER_DEFINE);
        popup->setCustomButton(
            VFX_WSTR_RES(STR_ID_VAPP_LAUNCHER_MM_UNINSTALL),
            VFX_WSTR_RES(STR_GLOBAL_CANCEL),
            VCP_POPUP_BUTTON_TYPE_WARNING,
            VCP_POPUP_BUTTON_TYPE_CANCEL);
        popup->setAutoDestory(VFX_TRUE);
        popup->show(VFX_TRUE);
    }
}

void VappLauncherMm::onBgRunningPopupClicked(VfxObject* obj,VfxId id)
{
    // recover icon shaking
    setIsUninstallingMode(VFX_FALSE);
}

void VappLauncherMm::onPopupButtonClicked(VfxObject* obj,VfxId id)
{

	switch (id)
    {
        case VCP_CONFIRM_POPUP_BUTTON_USER_1:

            mmi_app_package_name_struct appName;
            g_vapp_launcher_mm_uninstalled_cell->getCellAppName(appName);

            // MAUI_03228575, When user confirmed(clicked) to uninstall the app
            // MRE will delete image icon of the app, but VRT did not notify this and keep rendering.
            // So that, the image will turns messy.
            // Solution: suspend VRT until commit.
            // Note: This issue is not happended by 12.24&28MP and the solution is provided by feifei.chen
            VFX_OBJ_GET_INSTANCE(VfxRenderer)->suspendUntilCommit();
            g_vapp_launcher_mm_uninstalled_cell->resetCellImage();
            
            // error handling if uninstall failed.
            if (srv_appmgr_uninstall_app(appName,&VappLauncherMm::onUninstallAppCallback, NULL) == MMI_RET_ERR)
            {
                // show balloon of uninstall failed.
                VcpInfoBalloon *balloon = VFX_OBJ_GET_INSTANCE(VcpInfoBalloon);
                balloon->addItem(VCP_INFO_BALLOON_TYPE_INFO,VFX_WSTR_RES(STR_ID_VAPP_LAUNCHER_MM_DELETE_FAILED));
                g_vapp_launcher_mm_uninstalled_cell = NULL;

                return;
            }

            if (g_vapp_launcher_mm_uninstalled_cell != NULL)
            {
                VFX_OBJ_CREATE(m_deletingPopup, VcpIndicatorPopup, this);
                m_deletingPopup->setInfoType (VCP_INDICATOR_POPUP_STYLE_ACTIVITY);
                m_deletingPopup->setText((STR_ID_VAPP_LAUNCHER_MM_UNINSTALLING));
                m_deletingPopup->show(VFX_TRUE);
            }
            break;

        case VCP_CONFIRM_POPUP_BUTTON_USER_2:
            g_vapp_launcher_mm_uninstalled_cell = NULL;
            break;
    }
    m_gIsUninstallBtnClicked = VFX_FALSE;

    // recover icon shaking    
    setIsUninstallingMode(VFX_FALSE);
}

void VappLauncherMm::closeDeletingPopup()
{
    if (!m_deletingPopup)
    {
        //MRE app would call uninstall callback before popup create. Need to add flag for it.
        m_isPopupAutoDestory = VFX_TRUE;
        return;
    }
	
    VFX_OBJ_CLOSE(m_deletingPopup);
	
    reloadMainmenu();
}

void VappLauncherMm::onUninstallAppCallback(srv_appmgr_cb_event_enum result, void *user_data)
{
    s_vappLauncherMm->closeDeletingPopup();

    switch (result)
    {
        case SRV_APPMGR_CB_EVENT_DONE:

            return;
        case SRV_APPMGR_CB_EVENT_ERROR:
        case SRV_APPMGR_CB_EVENT_CANCEL:
        default:
            break;
    }
    
    g_vapp_launcher_mm_uninstalled_cell = NULL;
}

void VappLauncherMm::onPageMoved(VfxS32 translateX, VfxS32 translateDuration)
{
    if (m_wallpaperMask)
    {
        // Update wallpaper mask bounds
        VfxAutoAnimate::begin();
        
        VfxAutoAnimate::setTimingFunc(VFX_TIMING_FUNC_ID_EASE_OUT);
        VfxAutoAnimate::setDuration(translateDuration);
        
        VfxRect bounds = getBounds();
        bounds.origin.x = -translateX;
        m_wallpaperMask->setBounds(bounds);
        
        VfxAutoAnimate::commit();
    }
}

void VappLauncherMm::saveAllData()
{
    m_builder->saveMenu(m_menu);
    vappLauncherMmSaveFolderData();
    vappLauncherMmSaveData();
    m_isDataDirty = VFX_FALSE;
}

mmi_ret VappLauncherMm::eventHandler(mmi_event_struct *event)
{
    VappLauncherMm *mainmenuContent = (VappLauncherMm *)event->user_data;

    switch (event->evt_id)
    {
        case EVT_ID_SRV_APPMGR_INSTALL_PACKAGE:
        case EVT_ID_SRV_APPMGR_UPDATE_INSTALLED_PACKAGE:
            if (vapp_launcher_is_active())
            {
                mainmenuContent->reloadMainmenu();
            }
            break;
        case EVT_ID_SRV_APPMGR_UNINSTALL_PACKAGE:
            if (vapp_launcher_is_active())
            {
                g_vapp_launcher_mm_uninstalled_cell->scaleDeletingIcon();
                g_vapp_launcher_mm_uninstalled_cell->m_signalDeleteIconScaled.connect(mainmenuContent, &VappLauncherMm::onDeleteIconScaled);
            }
            g_vapp_launcher_mm_uninstalled_cell = NULL;
            break;
            
        default:
            break;
    }
    return MMI_RET_OK;
}

void VappLauncherMm::onDeleteIconScaled(VfxBool isScaled)
{
    if (isScaled)
    {
        if (m_deletingPopup && !m_isPopupAutoDestory)
            return;
		
        if (m_deletingPopup && m_isPopupAutoDestory)
            VFX_OBJ_CLOSE(m_deletingPopup);

        m_isPopupAutoDestory = VFX_FALSE;
		
        reloadMainmenu();
    }
}

#ifdef VAPP_LAUNCHER_MM_MOTION_DOUBLE_TAP_TO_CHANGE_SWITCH_EFFECT
void VappLauncherMm::onDoubleTapTimerTick(VfxTimer *source)
{
    VFX_OBJ_CLOSE(source);
    
    if (m_doubleTapSwitchDirection == 1)
    {
        m_menu->setCurrentPageIndex(m_menu->getCurrentPageIndex() - 1, VFX_TRUE);
    }
    else if (m_doubleTapSwitchDirection == -1)
    {
        m_menu->setCurrentPageIndex(m_menu->getCurrentPageIndex() + 1, VFX_TRUE);
    }
}

void VappLauncherMm::sensorHandler(srv_sensor_type_enum sensor_type, void *sensor_data, void *user_data)
{
    VappLauncherMm *mainmenu = (VappLauncherMm *)user_data;
    
    if (mainmenu->m_isOrganizeMode || mainmenu->m_isFolderMode)
    {
        return;
    }

    if (sensor_type == SRV_SENSOR_MOTION_DOUBLE_TAP)
    {
        VcpPageMenuTransitionType transitionType = (VcpPageMenuTransitionType)(mainmenu->m_menu->getTransitionEffect() + 1);
        if (transitionType == VCP_PAGE_MENU_TRANSITION_TYPE_MAX)
        {
            transitionType = VCP_PAGE_MENU_TRANSITION_TYPE_NORMAL;
        }
        mainmenu->m_menu->setTransitionEffect(transitionType);
        
        // Write to NVRAM
        VfxS16 sError = 0;
        WriteValue(NVRAM_VAPP_LAUNCHER_MM_BARREL_SETTING, (void *)&transitionType, DS_BYTE, &sError);
        
        // Play animation
        if (mainmenu->m_menu->getCurrentPageIndex() < mainmenu->m_menu->getPageCount() - 1)
        {
            mainmenu->m_doubleTapSwitchDirection = 1;
            mainmenu->m_menu->setCurrentPageIndex(mainmenu->m_menu->getCurrentPageIndex() + 1, VFX_TRUE);
        }
        else
        {
            mainmenu->m_doubleTapSwitchDirection = -1;
            mainmenu->m_menu->setCurrentPageIndex(mainmenu->m_menu->getCurrentPageIndex() - 1, VFX_TRUE);
        }
        
        VFX_OBJ_CREATE(mainmenu->m_doubleTapTimer, VfxTimer, mainmenu);
        mainmenu->m_doubleTapTimer->m_signalTick.connect(mainmenu, &VappLauncherMm::onDoubleTapTimerTick);
        mainmenu->m_doubleTapTimer->setStartDelay(VAPP_LAUNCHER_MM_MOTION_DOUBLE_TAP_ANIMTIME);
        mainmenu->m_doubleTapTimer->start();
    }
}
#endif


#endif // __MMI_VUI_LAUNCHER_MM__

