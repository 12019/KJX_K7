/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *  vapp_ucm_app.cpp
 *
 * Project:
 * -------- 
 *  COSMOS
 *
 * Description:
 * ------------
 *  UCM call screen files
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "MMI_features.h"
#include "vrt_datatype.h"
#include "mmi_rp_vapp_ucm_def.h"
#include "mmi_rp_core_ucm_def.h"
#include "mmi_rp_vapp_callset_def.h" // IMG_ID_CALLSET_VT_DEFAULT_IMAGE
#include "vcp_include.h"
#include "..\xml\vfx_xml_loader.h"
#include "vcp_global_popup.h"
#include "mmi_rp_app_cosmos_global_def.h"
#include "vapp_ucm_def.h"
#include "vapp_ucm_prot.h"
#include "mmi_rp_vapp_vol_dialog_def.h"
#include "vapp_vol_dialog_gprot.h"
#include "vapp_dialer_gprot.h"
#ifdef __MMI_NOTE_APP__
#include "vapp_notes_app.h"
#endif
#include "Vapp_fmgr_table.h" // SHOOTING_DOWNLOAD_FOLDER_NAME
#include "vapp_ncenter_gprot.h"
#include "vapp_screen_lock_gprot.h"
#include "vapp_platform_context.h" 
#include "vapp_phb_gprot.h"
#include "vapp_sat_gprot.h"
#include "vapp_ncenter.h"
#include "vapp_usb_gprot.h"
#include "vapp_dialer_cui.h"
#include "vsrv_notification.h"
#ifdef __MMI_UCM_SLIM__
#include "mmi_rp_vapp_screen_lock_rhythm_def.h"
#endif // __MMI_UCM_SLIM__

#if defined(__MTK_TARGET__) && defined(__MTK_INTERNAL__)
/* under construction !*/
#endif // __MTK_TARGET__

extern "C"
{
    #include "GlobalConstants.h"
    #include "GlobalResDef.h"
    #include "GpioSrvGprot.h" // EVT_ID_GPIO_BEFORE_LCD_SLEEP_IN
    #include "DialerCuiGprot.h"
    #include "PhbSrvGprot.h"
    #include "UcmSrvGprot.h"
    #include "UcmGprot.h"
    #include "UcmProt.h"
    #include "UcmCoreProt.h"
    #include "ScrLockerGprot.h"
    #include "SoundRecSrvGProt.h"
    #include "SmsSrvGProt.h"
#ifndef __MMI_UCM_SLIM__
    #include "BtcmSrvGprot.h"
    #include "BtAudioSrvGprot.h"
#endif // __MMI_UCM_SLIM__
    #include "NotificationGprot.h"
#ifdef __MMI_VIDEO_TELEPHONY__
    #include "FileMgrSrvGProt.h"
#endif // __MMI_VIDEO_TELEPHONY__
    #include "SimCtrlSrvGprot.h"
#ifdef __MMI_USB_SUPPORT__
    #include "UsbSrvGProt.h"
#endif // __MMI_USB_SUPPORT__
    #include "custom_mmi_folders_config.h"
    #include "ShutdownSrvGprot.h"
    #include "wgui_categories_util.h"
    #include "CustDataRes.h"
    #include "ProfilesSrvGprot.h" // tone
    #include "BootupSrvGprot.h"
    #include "SmsSrvGProt.h"
#ifdef __MAUI_SOFTWARE_LA__
    #include "SST_sla.h"
#endif // __MAUI_SOFTWARE_LA__
}


//static VfxU32       g_vappUcmMemPool[300 * 1024 / sizeof(VfxU32)];
static mmi_id       vapp_ucm_app_id = 0;
VappUcmCallScreen   *vapp_ucm_scr = NULL;
VfxBool             vapp_ucm_is_recording = VFX_FALSE;
VfxBool             vapp_ucm_launch_screen_lock = VFX_FALSE;
VfxBool             vapp_ucm_touch_fb_enable = VFX_TRUE;
#define UC_MAX_SMS_CONTENT 670
VappUcmSmsStateEnum vapp_ucm_sms_state = VAPP_UCM_SMS_NONE;
#ifdef __MMI_EM_PROFILING_VT_LOOKBACK__
/* under construction !*/
#endif // __MMI_EM_PROFILING_VT_LOOKBACK__
#ifdef __PXS_APP_ENABLE__
VfxBool             vapp_ucm_pxs_on = VFX_FALSE;
VfxBool             vapp_ucm_pxs_obj_close = VFX_FALSE;
#endif /* __PXS_APP_ENABLE__ */

#ifdef __IP_NUMBER__
mmi_ucm_ip_dial_struct g_ucm_ip_num;
#endif /* __IP_NUMBER__ */

static VfxDateTime getCallStartTime(S32 group_index)
{
    VfxDateTime start_time;
    srv_ucm_group_info_struct group_info;
    srv_ucm_index_info_struct call_index;
    srv_ucm_call_info_struct call_info;
    VfxU8 call_count;
    call_count = (VfxU8)srv_ucm_query_group_data(group_index, &group_info);
    if (0 < call_count)
    {
        call_index.group_index = group_index;
        call_index.call_index = 0;
        if (srv_ucm_query_call_data(call_index, &call_info))
        {
            start_time.setDateTime((applib_time_struct*)&(call_info.start_time));
        }
        if (1 < call_count)
        {
            VfxDateTime other_time;
            for (VfxU32 i = 1; i < call_count; ++i)
            {
                call_index.call_index = i;
                if (srv_ucm_query_call_data(call_index, &call_info))
                {
                    other_time.setDateTime((applib_time_struct*)&(call_info.start_time));
                    if (start_time.compareWith(other_time) == VfxDateTime::GREATER)
                    {
                        start_time = other_time;
                    }
                }
            }
        }
    }
    
    return start_time;
}

mmi_id vapp_ucm_get_app_id()
{
    return vapp_ucm_app_id;
}

void vapp_ucm_launch(void)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("UCM", SA_start);
#endif // __MAUI_SOFTWARE_LA__

    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_VAPP_UCM_APP_STATE, 0);

    if (vapp_ucm_scr)
    {
        vapp_ucm_terminate();
        vapp_ucm_scr = NULL;
    }

    if (vapp_screen_lock_is_exist())
    {
        vapp_screen_lock_close();
        vapp_ucm_launch_screen_lock = VFX_TRUE;
    }
#ifdef __MMI_UCM_SLIM__
    vapp_ucm_app_id = VfxAppLauncher::launch(
        VAPP_UCM,
        VFX_OBJ_CLASS_INFO(VappUcmApp),
        GRP_ID_ROOT);
#else
    VfxContext *cntx = VFX_OBJ_GET_INSTANCE(VappPlatformContext);
    vapp_ucm_app_id = VfxAppLauncher::launchWithCtx(
        VAPP_UCM,
        VFX_OBJ_CLASS_INFO(VappUcmApp),
        GRP_ID_ROOT,
        cntx);
#endif // __MMI_UCM_SLIM__
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("UCM", SA_stop);
#endif // __MAUI_SOFTWARE_LA__

}

#ifdef __MMI_EM_PROFILING_VT_LOOKBACK__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif // __MMI_EM_PROFILING_VT_LOOKBACK__

void vapp_ucm_terminate(void)
{
    if (vapp_ucm_scr)
    {
    	VfxAppLauncher::terminate(vapp_ucm_app_id);
        vapp_ucm_scr = NULL;
    }
}

void vapp_ucm_refresh_screen(VappUcmCallCellRefreshTypeEnum refresh_type, void* data)
{
    if (vapp_ucm_scr)
    {
        VappUcmMainPage *page = vapp_ucm_scr->getMainPage();
        if (page)
        {
            if (page->isOnPostAction())
            {
                page->CloseRedialConfirm();
                vapp_ucm_scr->refreshMainScreen();
            }
            else
            {
                VappNCenter *NCenter = VFX_OBJ_GET_INSTANCE(VappNCenter);
                if (NCenter && vapp_ucm_scr->getApp()->isActive())
                {
                    NCenter->leave();
                }
                page->refreshCallCells(refresh_type, data);
            }

            if (!srv_shutdown_is_running()
                && srv_ucm_query_call_count(
                  (srv_ucm_call_state_enum)(SRV_UCM_OUTGOING_STATE | SRV_UCM_INCOMING_STATE), 
                  SRV_UCM_CALL_TYPE_ALL, NULL))
            {
                mmi_frm_set_active_group(vapp_ucm_get_app_id());
            }
        }
        else
        {
            vapp_ucm_launch();
        }
    }
    else
    {
        vapp_ucm_launch();
    }
}

void vapp_ucm_check_redial_fail()
{
    /* check if it is the scenario that redial fail before outgoing call screen displays
     * in this case, shall not refresh ucm screen. 
     * Maybe vapp_ucm_scr doesn't exist but vapp_ucm_alive is still true.
     * [Gemini+]When there are more than 1 SIM card, MO video call fails, 
     * redial voice call, only Dialer CUI exists */
    if (vapp_ucm_scr)
    {
        VappUcmMainPage *page = vapp_ucm_scr->getMainPage();
        if (page)
        {
            if (page->isOnPostAction())
            {
                page->CloseRedialConfirm();
                if (MMI_FALSE == srv_ucm_is_any_call())
                {
                    page->back();
                }
            }
        }
    }
}

void vapp_ucmapp_set_active_call_info(srv_ucm_index_info_struct *index_info)
{
    g_ucm_p->call_misc.hilite_tab = index_info->group_index;
    g_ucm_p->call_misc.hilite_index = index_info->call_index;
    mmi_ucm_set_hilight_index(g_ucm_p->call_misc.hilite_tab, g_ucm_p->call_misc.hilite_index);
}

#ifdef __PXS_APP_ENABLE__
VfxBool vapp_ucm_allow_PXS()
{
    if (!srv_ucm_query_call_count(
          (srv_ucm_call_state_enum)(SRV_UCM_OUTGOING_STATE | SRV_UCM_CALL_STATE_CONNECTED), 
            SRV_UCM_VOICE_CALL_TYPE_ALL, NULL)
    #ifdef __MMI_VIDEO_TELEPHONY__
        || srv_ucm_query_call_count(
            (srv_ucm_call_state_enum)(SRV_UCM_OUTGOING_STATE | SRV_UCM_CALL_STATE_CONNECTED), 
            SRV_UCM_VIDEO_CALL_TYPE, NULL)
    #endif // __MMI_VIDEO_TELEPHONY__
        || srv_earphone_is_plug_in()
    #if (defined(__MMI_BT_SUPPORT__) && !defined(__MMI_UCM_SLIM__))
        || srv_btaud_get_status(BTAUD_CHNL_MONO) == BTAUD_SWITCH_ON
    #endif // __MMI_BT_SUPPORT__
        || srv_speech_is_hand_free())
    {
        return VFX_FALSE;
    }
    else
    {
        return VFX_TRUE;
    }
}
#endif // __PXS_APP_ENABLE__

mmi_ret vapp_ucm_proc(mmi_event_struct *evt)
{
    switch (evt->evt_id)
    {
        case EVT_ID_MDI_AUDIO_MODE_SWITCHED:
        {
            mmi_evt_mdi_audio_mode_switch_struct *mdi_evt = (mmi_evt_mdi_audio_mode_switch_struct*) evt;
            if (vapp_ucm_scr && vapp_ucm_scr->getMainPage()
                && vapp_ucm_scr->getMainPage()->getActivateCallCell())
            {
                if (AUD_MODE_LOUDSPK == mdi_evt->new_mode)
                {                            
                    wgui_status_icon_bar_show_icon(STATUS_ICON_SPEAKER_CALL);
                    vapp_ucm_scr->getMainPage()->getActivateCallCell()->setActBtnSwitchOn(VAPP_UCM_ACT_AREA_BTN_SPEAKER, VFX_TRUE); 
                }
                else
                {
                    wgui_status_icon_bar_hide_icon(STATUS_ICON_SPEAKER_CALL);
                    vapp_ucm_scr->getMainPage()->getActivateCallCell()->setActBtnSwitchOn(VAPP_UCM_ACT_AREA_BTN_SPEAKER, VFX_FALSE);
                }
            }
            break;
        }
        case EVT_ID_VOL_DIALOG_CHECK_VOL_TYPE:
        {
            vapp_vol_dialog_evt_struct *vol_evt = (vapp_vol_dialog_evt_struct*) evt;
            if (VAPP_VOL_DIALOG_IS_SPEECH == vol_evt->type)
            {
                if (srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL) == 0 &&
                    srv_ucm_query_call_count((srv_ucm_call_state_enum)(SRV_UCM_OUTGOING_STATE | SRV_UCM_CALL_STATE_CONNECTED), 
                        SRV_UCM_CALL_TYPE_NO_DATA_CSD, NULL) != 0)
                {
                    return !MMI_RET_OK;
                }
            }
            else if (VAPP_VOL_DIALOG_IS_NOT_SHOWN == vol_evt->type)
            {
                if (srv_ucm_is_incoming_call())
                {
                    return !MMI_RET_OK;
                }
            }
            return MMI_RET_OK;
        }
        case EVT_ID_VAPP_SCREEN_LOCK_PRE_LOCK_EVT_ROUTING:
        {
            if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL)
                || (vapp_ucm_scr && vapp_ucm_scr->getMainPage() && vapp_ucm_scr->getMainPage()->isOnPostAction())
                || VAPP_UCM_SMS_NONE != vapp_ucm_sms_state)
            {
                return MMI_RET_ERR;
            }
            break;
        }
        case EVT_ID_VAPP_NCENTER_DRAG:
        {
            if (srv_ucm_query_call_count((srv_ucm_call_state_enum)(SRV_UCM_INCOMING_STATE | SRV_UCM_OUTGOING_STATE), SRV_UCM_CALL_TYPE_ALL, NULL)
                || srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_VIDEO_CALL_TYPE, NULL)
                || VAPP_UCM_SMS_NONE != vapp_ucm_sms_state)
            {
                return MMI_RET_ERR;
            }
            break;
        }
        case EVT_ID_SRV_FMGR_NOTIFICATION_DEV_PLUG_OUT:
        case EVT_ID_SRV_FMGR_NOTIFICATION_DEV_PLUG_IN:
    #ifdef __MMI_USB_SUPPORT__
        case EVT_ID_USB_ENTER_MS_MODE:
        case EVT_ID_USB_EXIT_MS_MODE:
    #endif // __MMI_USB_SUPPORT__
        {
            if (vapp_ucm_scr && vapp_ucm_scr->getMainPage()
                && vapp_ucm_scr->getMainPage()->getActivateCallCell())
            {
                srv_ucm_ind_evt_struct evt;
                MMI_FRM_INIT_EVENT(&evt, EVT_ID_SRV_UCM_INDICATION);
                evt.ind_type = SRV_UCM_REFRESH_IND;
                evt.ptr = NULL;
                vapp_ucm_refresh_screen(VAPP_UCM_REFRESH_TYPE_IND, (void *)&evt);
            }
            break;
        }
    
    #ifdef __MMI_VIDEO_TELEPHONY__
        case EVT_ID_GPIO_BEFORE_LCD_SLEEP_IN:
        {
            if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_VIDEO_CALL_TYPE, NULL))
            {
                return MMI_RET_ERR;
            }
            break;
        }
    #endif // __MMI_VIDEO_TELEPHONY__
    #ifdef __PXS_APP_ENABLE__
        case EVT_ID_SENSOR_PXS_DETECT_OBJ_CLOSE:
        {
            if (vapp_ucm_allow_PXS())
            {
                srv_backlight_turn_off_ext();
                vapp_ucm_pxs_obj_close = VFX_TRUE;
            }
            break;
        }
        case EVT_ID_SENSOR_PXS_DETECT_OBJ_AWAY:
        {
            if (vapp_ucm_allow_PXS())
            {
                srv_backlight_turn_on(SRV_BACKLIGHT_SHORT_TIME);
                vapp_ucm_pxs_obj_close = VFX_FALSE;
            }
            break;
        }
    #endif // __PXS_APP_ENABLE__

        case EVT_ID_ASM_CANCELED:
        {
            //VFX_ASSERT(0); // New MT call comes while prepare memory to enter UC will cause ASM_CANCELED
            break;
        }
        
        case EVT_ID_ASM_POST_PREPARED:
        {
            if (vapp_ucm_scr)
            {
			#if (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__))
                VappUcmCallScreen *scr = VFX_OBJ_DYNAMIC_CAST((VfxObject*)evt->user_data, VappUcmCallScreen);
                if (scr && vapp_ucm_scr)
                {
                    vapp_ucm_scr->realEnterUC();
                }
			#endif /* (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__)) */
            #ifdef __MMI_VIDEO_TELEPHONY__
                VappUcmVideoCallCell *c = VFX_OBJ_DYNAMIC_CAST((VfxObject*)evt->user_data, VappUcmVideoCallCell);
                if (c)
                    c->onPrepareDone(VT_READY_ASM);
            #endif // __MMI_VIDEO_TELEPHONY__
            }
            break;
        }
    #ifdef __PXS_APP_ENABLE__
        case EVT_ID_GPIO_EARPHONE_PLUG_IN:
        {
            if (vapp_ucm_pxs_obj_close && MMI_FALSE == srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD))
            {
                srv_backlight_turn_on(SRV_BACKLIGHT_SHORT_TIME);
            }
            break;
        }
    #endif // __PXS_APP_ENABLE__
        case EVT_ID_SRV_UCM_STATUS_CHANGE:
        {
            // only handle special case for make outgoing call from SAT while there is an active call
            if (vapp_ucm_scr && vapp_ucm_scr->getMainPage())
            {
                VfxS32 total_call_count = srv_ucm_query_group_count(SRV_UCM_CALL_STATE_ALL, (srv_ucm_call_type_enum)(SRV_UCM_VOICE_CALL_TYPE_ALL | SRV_UCM_VIDEO_CALL_TYPE | SRV_UCM_CALL_TYPE_DATA_CSD_ALL), MMI_TRUE, NULL);
                if (total_call_count> 1 &&  vapp_ucm_scr->getMainPage()->getTotalCallCounts() == total_call_count)
                {
                    for (VfxU32 i = 0; i < total_call_count; ++i)
                    {
                        VappUcmCallCell *callCell = vapp_ucm_scr->getMainPage()->getCallCell(i);
                        if (callCell)
                        {
                            srv_ucm_index_info_struct call_index = callCell->getCallIndex();
                            srv_ucm_call_info_struct call_info;
                            if (srv_ucm_query_call_data(call_index, &call_info))
                            {
                                if (SRV_UCM_HOLD_STATE == call_info.call_state && call_info.call_state != callCell->getCallState())
                                {
                                    callCell->setCallState(call_info.call_state);
                                }
                            }
                        }
                    }
                }
            }
            break;
        }
    }
    return MMI_RET_OK;
}

void vapp_ucm_display_info(WCHAR* string)
{
    mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT,
                         MMI_EVENT_INFO_BALLOON,
                         MMI_NMGR_BALLOON_TYPE_FAILURE,
                         string);
}

void vapp_ucm_stop_recording()
{
    if (vapp_ucm_is_recording)
    {
        mdi_audio_stop_record();
        vapp_ucm_is_recording = VFX_FALSE;
    }
}

#ifndef __MMI_UCM_SLIM__
void vapp_ucm_bt_notify(U32 event, U32 arg, void *userData)
{
    if (!vapp_ucm_scr || !vapp_ucm_scr->getMainPage() || !vapp_ucm_scr->getMainPage()->getActivateCallCell())
    {
        return;
    }
    switch (event)
    {
        case BTAUD_EV_SWITCH_IND:
        {
            // arg != 0 : switched to headset, else switched to phone
            vapp_ucm_scr->getMainPage()->getActivateCallCell()->stopBTSwitch(arg ? VFX_TRUE : VFX_FALSE);
            if (!arg)
            {
                vapp_ucm_scr->getMainPage()->getActivateCallCell()->setActBtnSwitchOn(VAPP_UCM_ACT_AREA_BTN_SPEAKER, MMI_FALSE == srv_speech_is_hand_free() ? VFX_FALSE : VFX_TRUE);
            }
        }
        break;
        case BTAUD_EV_ATTACH_IND:
        {
        #ifdef __PXS_APP_ENABLE__
            if (vapp_ucm_pxs_obj_close && MMI_FALSE == srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD))
            {
                srv_backlight_turn_on(SRV_BACKLIGHT_SHORT_TIME);
            }
        #endif
            vapp_ucm_scr->getMainPage()->getActivateCallCell()->setActBtnDisable(VAPP_UCM_ACT_AREA_BTN_SPEAKER, VFX_TRUE);
            vapp_ucm_scr->getMainPage()->getActivateCallCell()->setActBtnDisable(VAPP_UCM_ACT_AREA_BTN_BLUETOOTH, MMI_FALSE == srv_btaud_switchable(BTAUD_CHNL_MONO) ? VFX_TRUE : VFX_FALSE);
        }
        break;
        case BTAUD_EV_DETACH_IND:
        {
            vapp_ucm_scr->getMainPage()->getActivateCallCell()->stopBTSwitch(VFX_FALSE);
            vapp_ucm_scr->getMainPage()->getActivateCallCell()->setActBtnSwitchOn(VAPP_UCM_ACT_AREA_BTN_SPEAKER, MMI_FALSE == srv_speech_is_hand_free() ? VFX_FALSE : VFX_TRUE);
            vapp_ucm_scr->getMainPage()->getActivateCallCell()->setActBtnDisable(VAPP_UCM_ACT_AREA_BTN_BLUETOOTH, VFX_TRUE);
        }
        break;
        case BTAUD_EV_SWITCH_FAIL: 
        {
            vapp_ucm_scr->getMainPage()->getActivateCallCell()->stopBTSwitch(VFX_FALSE);
        }
        break;
    }
}
#endif // __MMI_UCM_SLIM__

void vapp_ucm_show_info_ballon(VfxU16 *str)
{
    VcpInfoBalloon *ballon = VFX_OBJ_GET_INSTANCE(VcpInfoBalloon);
    ballon->addItem(VCP_INFO_BALLOON_TYPE_INFO, VFX_WSTR_MEM(str));
}

void vapp_ucm_enter_confirm()
{
    if (vapp_ucm_scr && vapp_ucm_scr->getMainPage())
    {
        vapp_ucm_scr->getMainPage()->showCofirmPopup(g_ucm_p->cnf_scr.content);
    }
}

void vapp_ucm_mdi_callback(mdi_result result, void *user_data)
{
    if (VFX_FALSE == vapp_ucm_is_recording)
    {
        return;
    }

    MMI_TRACE(TRACE_GROUP_5, TRC_VAPP_UCM_RECORD, VFX_FALSE, result);
    VfxResId strId = MDI_AUDIO_DISC_FULL == result ? STR_GLOBAL_MEMORY_FULL : STR_ID_VAPP_UCM_RECORDING_STOP;
    mmi_frm_nmgr_balloon(
			MMI_SCENARIO_ID_DEFAULT,
			MMI_EVENT_INFO_BALLOON,
			MMI_NMGR_BALLOON_TYPE_INFO,
			(WCHAR *)VFX_WSTR_RES(strId).getBuf());
    
    if (!vapp_ucm_scr)
    {
        // background call
        vapp_ucm_stop_recording();
        return;
    }

    VappUcmMainPage *mainPage = vapp_ucm_scr->getMainPage();
    if (mainPage)
    {
        VappUcmCallCell *activeCallCell = mainPage->getActivateCallCell();
        if (activeCallCell)
        {
            activeCallCell->stopRecord();
        }
    }
}
void vapp_ucm_cancel_confirm()
{
    if (vapp_ucm_scr)
    {
        VappUcmMainPage *page = vapp_ucm_scr->getMainPage();
        if (page)
        {
            page->closeConfirmPopup();
        }
    }
}

void vapp_ucm_headset_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* release processing calls */
    if (srv_ucm_is_pending_action())
    {
        // do nothing
    }
    // incoming call exists, headset key is to answer it
    else if (srv_ucm_is_incoming_call())
    {
        MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_MMI_UCM_APP_HEADSET_KEY_ANSWER);

    #ifdef __MMI_VIDEO_TELEPHONY__
        if (srv_ucm_query_group_count(SRV_UCM_INCOMING_STATE, SRV_UCM_VIDEO_CALL_TYPE, MMI_FALSE, NULL) && 
            vapp_ucm_scr)
        {
            VappUcmMainPage *page = vapp_ucm_scr->getMainPage();
            if (page)
            {
                page->onHeadsetKey();
            }
        }
        else
    #endif // __MMI_VIDEO_TELEPHONY__
        {
            vapp_ucm_incoming_call_sendkey();
        }
    }
    // outgoing call exists, headset key is to abort it
    else if (srv_ucm_is_outgoing_call())
    {
        MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_MMI_UCM_APP_HEADSET_KEY_ABORT_OUTGOING_CALL); 
        vapp_ucm_outgoing_call_endkey();
    }
    // in call, headset key is to release current highlight tab call
    else if (srv_ucm_is_any_call())
    {
        MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_MMI_UCM_APP_HEADSET_KEY_RESET_HIGHLIGHT_CALL); 
        vapp_ucm_in_call_endkey();
    }
}

typedef enum _VappUcmAllowToAcceptResultEnum
{
    VAPP_UCM_ALLOW_TO_ACCEPT_RET_OK,
    VAPP_UCM_ALLOW_TO_ACCEPT_RET_REPLACE_EXISTING,
    VAPP_UCM_ALLOW_TO_ACCEPT_RET_END_EXISTING,
    VAPP_UCM_ALLOW_TO_ACCEPT_RET_FAIL
}VappUcmAllowToAcceptResultEnum;

VappUcmAllowToAcceptResultEnum vapp_ucm_allow_to_accept(void)
{
    VappUcmMainPage *mainPage = vapp_ucm_scr->getMainPage();
    if (mainPage->getTotalCallCounts() == 1)
    {
        return VAPP_UCM_ALLOW_TO_ACCEPT_RET_OK;
    }
    else if (mainPage->getTotalCallCounts() == 2)
    {
        // replace all: voice call cannot coexist with viceo / csd / data
        if (srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_VOICE_CALL_TYPE_ALL, NULL)
            && srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, 
                (srv_ucm_call_type_enum)(SRV_UCM_VIDEO_CALL_TYPE | SRV_UCM_CALL_TYPE_DATA_CSD_ALL), NULL))
        {
            return VAPP_UCM_ALLOW_TO_ACCEPT_RET_REPLACE_EXISTING;
        }
        // replace all: video / data / csd call cannot coexist with any call
        else if (srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, 
                   (srv_ucm_call_type_enum)(SRV_UCM_VIDEO_CALL_TYPE | SRV_UCM_CALL_TYPE_DATA_CSD_ALL), NULL))
        {
            return VAPP_UCM_ALLOW_TO_ACCEPT_RET_REPLACE_EXISTING;
        }
        else
        {
            return VAPP_UCM_ALLOW_TO_ACCEPT_RET_OK;
        }
    }
    else if (mainPage->getTotalCallCounts() == 3)
    {
        // replace all: video / data / csd call cannot coexist with any call
        if (srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, 
              (srv_ucm_call_type_enum)(SRV_UCM_VIDEO_CALL_TYPE | SRV_UCM_CALL_TYPE_DATA_CSD_ALL), NULL))
        {
            return VAPP_UCM_ALLOW_TO_ACCEPT_RET_REPLACE_EXISTING;
        }
        else
        {
            return VAPP_UCM_ALLOW_TO_ACCEPT_RET_END_EXISTING;
        }
    }

    return VAPP_UCM_ALLOW_TO_ACCEPT_RET_FAIL;
}

#ifdef MOTION_SENSOR_SUPPORT
void vapp_ucm_motion_sensor_callback(srv_sensor_type_enum sensor_type, void *sensor_data, void *user_data)
{
    if (SRV_SENSOR_MOTION_TURNOVER == sensor_type)
    {
        // flip to mute
        srv_sensor_motion_turnover_struct *motion_turnover = (srv_sensor_motion_turnover_struct *)sensor_data;        
        if (SRV_SENSOR_MOTION_TURNOVER_DOWN == motion_turnover->direction
            && srv_callset_flip_to_mute_call_get_mode()
            && srv_ucm_is_incoming_call())
        {
            mmi_ucm_suppress_incoming_tone();
            // should disable 'Silent' button
            if (vapp_ucm_scr && vapp_ucm_scr->getMainPage()
                && vapp_ucm_scr->getMainPage()->getActivateCallCell()
                && SRV_UCM_INCOMING_STATE == vapp_ucm_scr->getMainPage()->getActivateCallCell()->getCallState())
            {
                vapp_ucm_scr->getMainPage()->getActivateCallCell()->m_actionArea->m_actionButtonGroup->setBtnDisable(0, VFX_TRUE);
            }
        }
    }
#ifdef __MOTION_SENSOR_ADVANCED_GESTURE__
    else if (SRV_SENSOR_MOTION_DOUBLE_TAP == sensor_type)
    {
        // double tap to start record
        if (srv_callset_tap_tap_to_record_in_call_get_mode()
            && srv_ucm_query_call_count(SRV_UCM_CALL_STATE_CONNECTED, SRV_UCM_CALL_TYPE_NO_CSD, NULL) > 0
            && VFX_FALSE == vapp_ucm_is_recording && vapp_ucm_scr && !vapp_ucm_scr->isPopupPresent() 
            && vapp_ucm_scr->getMainPage() && vapp_ucm_scr->getMainPage()->getActivateCallCell())
        {
        #ifdef __MMI_USB_SUPPORT__
            if(srv_usb_is_in_mass_storage_mode())
            {
                vapp_usb_unavailable_popup(0);
            }
            else
        #endif // __MMI_USB_SUPPORT__
            {
                srv_prof_play_req_struct play_req;
                srv_prof_play_req_struct_init(&play_req, SRV_PROF_TONE_CALL_REMINDER);
                play_req.audio_id = TONE_WARNING2;
                play_req.play_style = SRV_PROF_RING_TYPE_ONCE;
                play_req.audio_type = SRV_PROF_AUDIO_DTMF;
                play_req.aud_path = MDI_DEVICE_SPEAKER2;
                srv_prof_play_tone_with_full_struct(&play_req);

                if (MMI_FALSE == srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD))
                {
                    srv_backlight_turn_on(SRV_BACKLIGHT_SHORT_TIME);
                }
                vapp_ucm_scr->getMainPage()->getActivateCallCell()->startRecord();
            }
        }
    }
#endif // __MOTION_SENSOR_ADVANCED_GESTURE__
    else
    {
        MMI_ASSERT(0);
    }
}
#endif // MOTION_SENSOR_SUPPORT

VFX_IMPLEMENT_CLASS("VappUcmApp", VappUcmApp, VfxApp);

void VappUcmApp::onRun(void *args, VfxU32 argSize)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CAR", SA_start);
#endif

    VfxApp::onRun(args, argSize);
    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_VAPP_UCM_APP_STATE, 1);

    VFX_OBJ_CREATE(vapp_ucm_scr, VappUcmCallScreen, this);
    vapp_ucm_scr->show();

    mmi_frm_cb_reg_event(EVT_ID_VAPP_SCREEN_LOCK_PRE_LOCK_EVT_ROUTING, vapp_ucm_proc, NULL);
    mmi_frm_cb_reg_event(EVT_ID_VAPP_NCENTER_DRAG, vapp_ucm_proc, NULL);
#ifdef __MMI_VIDEO_TELEPHONY__
    mmi_frm_cb_reg_event(EVT_ID_GPIO_BEFORE_LCD_SLEEP_IN, vapp_ucm_proc, NULL);
#endif // __MMI_VIDEO_TELEPHONY__
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CAR", SA_stop);
#endif
}

mmi_ret VappUcmApp::onProc(mmi_event_struct *evt)
{
    switch(evt->evt_id)
    {
        case EVT_ID_CUI_DIALER_CLOSE_REQ:
        case EVT_ID_CUI_DIALER_CLOSED_IND:
        {
            //vcui_dialer_close(vapp_dialer_cui_id);
            return MMI_RET_OK;
        }
    }
    return VfxApp::onProc(evt);
}

void VappUcmApp::onGroupActive()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CAA", SA_start);
#endif

    VfxApp::onGroupActive();

    mmi_event_struct evt;
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_VAPP_UCM_BG_RUN_END);
    MMI_FRM_CB_EMIT_EVENT(&evt);

#ifdef MOTION_SENSOR_SUPPORT
    m_muteSensor = -1;    
    m_muteSensor = srv_sensor_start_listen(SRV_SENSOR_MOTION_TURNOVER, NULL, vapp_ucm_motion_sensor_callback, NULL);
    srv_sensor_motion_enable_mode(m_muteSensor, SRV_SENSOR_MOTION_ALWAYS_ON_MODE);
#ifdef __MOTION_SENSOR_ADVANCED_GESTURE__
    m_recordSensor = -1;
    m_recordSensor = srv_sensor_start_listen(SRV_SENSOR_MOTION_DOUBLE_TAP, NULL, vapp_ucm_motion_sensor_callback, NULL);
    srv_sensor_motion_enable_mode(m_recordSensor, SRV_SENSOR_MOTION_ALWAYS_ON_MODE);
#endif // __MOTION_SENSOR_ADVANCED_GESTURE__
#endif // MOTION_SENSOR_SUPPORT
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CAA", SA_stop);
#endif
}

void VappUcmApp::onGroupInactive()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CAI", SA_start);
#endif
    if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_NO_CSD, NULL) > 0)
    {
        mmi_event_struct evt;
        MMI_FRM_INIT_EVENT(&evt, EVT_ID_VAPP_UCM_BG_RUN_START);
        MMI_FRM_CB_EMIT_EVENT(&evt);
    }

#ifdef MOTION_SENSOR_SUPPORT
    srv_sensor_stop_listen(m_muteSensor);
    m_muteSensor = -1;
#ifdef __MOTION_SENSOR_ADVANCED_GESTURE__
    srv_sensor_stop_listen(m_recordSensor);
    m_recordSensor = -1;
#endif // __MOTION_SENSOR_ADVANCED_GESTURE__
#endif // MOTION_SENSOR_SUPPORT

#if (defined(__LOW_COST_SUPPORT_COMMON__) && !defined(__MMI_VIDEO_TELEPHONY__))
    if (srv_ucm_is_any_call() && mmi_frm_is_in_backward_scenario())
    {
        serialize(NULL, VFX_FALSE, NULL, NULL, 0, vapp_ucm_proc);
    }
#endif // SLIM PROJECT WITHOUT VIDEO CALL
    VfxApp::onGroupInactive();

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CAI", SA_stop);
#endif
}

#if (defined(__LOW_COST_SUPPORT_COMMON__) && !defined(__MMI_VIDEO_TELEPHONY__))
void VappUcmApp::onRestore(VfxArchive &archive)
{
    if (srv_ucm_is_any_call())
    {
        vapp_ucm_launch();
    }
    else
    {
        exit();
    }
}
#endif // SLIM PROJECT WITHOUT VIDEO CALL

void VappUcmApp::onDeinit()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CAD", SA_start);
#endif
    MMI_ID groupId, scrnId;
    mmi_frm_get_active_scrn_id(&groupId, &scrnId);
    if(groupId !=0 && groupId != vapp_ucm_app_id)
    {
        vapp_ucm_launch_screen_lock = VFX_FALSE;
    }

    if (mmi_frm_is_scenario_started(MMI_SCENARIO_ID_HIGH_SCRN))
    {
        mmi_frm_end_scenario(MMI_SCENARIO_ID_HIGH_SCRN);
    }
#ifdef __MMI_VIDEO_TELEPHONY__
    mmi_frm_cb_dereg_event(EVT_ID_GPIO_BEFORE_LCD_SLEEP_IN, vapp_ucm_proc, NULL);
#endif // __MMI_VIDEO_TELEPHONY__

    if (vapp_ucm_launch_screen_lock)
    {
        if(!srv_sim_ctrl_any_verifying_sim())
        {
            vapp_screen_lock_post_launch();
        }
        vapp_ucm_launch_screen_lock = VFX_FALSE;
    }
    VFX_OBJ_CLOSE(vapp_ucm_scr);
    vapp_ucm_app_id = 0;
    vapp_ucm_sms_state = VAPP_UCM_SMS_NONE;
    if (mmi_frm_is_scenario_started(MMI_SCENARIO_ID_UCM_EDIT_MSG))
    {
        mmi_frm_end_scenario(MMI_SCENARIO_ID_UCM_EDIT_MSG);
    }
    VfxApp::onDeinit();
    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_VAPP_UCM_APP_STATE, 11);
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CAD", SA_stop);
#endif
}

VfxAppCloseAnswerEnum VappUcmApp::onProcessClose(VfxAppCloseOption options)
{
    VfxBool isScreenLocked = VFX_FALSE;
    if (!vapp_ucm_scr)
    {
        return VFX_APP_CLOSE_ANSWER_YES;
    }
    VappUcmMainPage *main_page = vapp_ucm_scr->getMainPage();
    if (main_page)
    {
        isScreenLocked = main_page->isScreenLocked();
    }
    if (!srv_bootup_is_completed() 
        || srv_ucm_is_outgoing_call()
        || srv_ucm_is_incoming_call()
    #ifdef __MMI_VIDEO_TELEPHONY__
        || (srv_ucm_query_call_count((srv_ucm_call_state_enum)SRV_UCM_CALL_STATE_ALL, SRV_UCM_VIDEO_CALL_TYPE, NULL))>0
    #endif // __MMI_VIDEO_TELEPHONY__
        || isScreenLocked)
    {
        return VFX_APP_CLOSE_ANSWER_NO;
    }    
    return VFX_APP_CLOSE_ANSWER_YES;
}

VFX_IMPLEMENT_CLASS("VappUcmCallScreen", VappUcmCallScreen, VfxMainScr);

void VappUcmCallScreen::onInit()
{
    VfxMainScr::onInit();
#if (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__))
    m_ucData = NULL;
    m_uc = GRP_ID_INVALID;
#endif /* (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__)) */
}

void VappUcmCallScreen::on1stReady()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CS1", SA_start);
#endif
    VfxMainScr::on1stReady();
    setBgColor(VFX_COLOR_BLACK);

    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_VAPP_UCM_APP_STATE, 2);

    VFX_OBJ_CREATE(m_mainPage, VappUcmMainPage, this);
    pushPage(0, m_mainPage.get());

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CS1", SA_stop);
#endif
}
void VappUcmCallScreen::refreshMainScreen()
{
    setAutoClose(VFX_FALSE);
    popPage();
    VFX_OBJ_CREATE(m_mainPage, VappUcmMainPage, this);
    pushPage(0, m_mainPage.get());
    setAutoClose(VFX_TRUE);
}

#ifdef __CTM_SUPPORT__
void VappUcmCallScreen::pushCtmPage()
{
    VFX_OBJ_CREATE(m_ctmPage, VappCallSetPageCtm, this);
    pushPage(VFX_ID_NULL, m_ctmPage.get());
}
#endif // __CTM_SUPPORT__

#ifdef __MMI_UCM_REJECT_BY_SMS__
void VappUcmCallScreen::pushSMSTemplatePage()
{
    VFX_OBJ_CREATE(m_smsTemplatePage, VappUcmSmsTemplatePage, this);
    srv_ucm_call_info_struct call_info;
    srv_ucm_index_info_struct index = m_mainPage->getActivateCallCell()->getCallIndex();
    srv_ucm_query_call_data(index, &call_info);
    m_smsTemplatePage->updateCallerInfo(&call_info);

    pushPage(0, m_smsTemplatePage.get());
    vapp_ucm_sms_state = VAPP_UCM_SMS_SELECT_MSG;
    if (!mmi_frm_is_scenario_started(MMI_SCENARIO_ID_UCM_EDIT_MSG))
    {
        mmi_frm_start_scenario(MMI_SCENARIO_ID_UCM_EDIT_MSG);
    }
}
#endif // __MMI_UCM_REJECT_BY_SMS__

#if (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__))
// TBD: ask UC to provide next two APIs to copy/destroy VappUcEntryStruct
void VappUcmCallScreen::copyUCData(VappUcEntryStruct *data)
{
    if (data)
    {
        VFX_ALLOC_MEM(m_ucData, sizeof(VappUcEntryStruct), this);
        memset(m_ucData, 0, sizeof(VappUcEntryStruct));
        m_ucData->addr_num = data->addr_num;
        m_ucData->media_num = data->media_num;

        if (data->addr)
        {
            srv_uc_addr_struct *currAddr = data->addr;
            srv_uc_addr_struct *cpyAddr = NULL, *tempPtr = NULL;
            U8 firstNode = 1;
            while (currAddr)
            {
                U16 len = mmi_ucs2strlen((CHAR*)currAddr->addr);
                VFX_ALLOC_MEM(cpyAddr, sizeof(srv_uc_addr_struct), this);
                memset(cpyAddr, 0, sizeof(srv_uc_addr_struct));
                if (firstNode)
                {
                    m_ucData->addr = cpyAddr;
                    tempPtr = cpyAddr;
                }

                VFX_ALLOC_MEM(cpyAddr->addr, ((len + 1) * ENCODING_LENGTH), this);
                MMI_ASSERT(cpyAddr->addr);
                memset(cpyAddr->addr, 0, ((len + 1) * ENCODING_LENGTH));
                memcpy(cpyAddr->addr, currAddr->addr, (len * ENCODING_LENGTH));

                cpyAddr->type = currAddr->type;
                cpyAddr->group = currAddr->group;
                currAddr = currAddr->next;
                if (firstNode)
                {
                    firstNode = 0;
                }
                else
                {
                    tempPtr->next = cpyAddr;
                    cpyAddr->previous = tempPtr;
                    tempPtr = tempPtr->next;
                }
            }
        }

        m_ucData->msg_type = data->msg_type;

        if (data->file_path)
        {
            U32 file_path_len = mmi_ucs2strlen((CHAR*) data->file_path);

            VFX_ALLOC_MEM(m_ucData->file_path, (file_path_len + 1) * ENCODING_LENGTH, this);
            ASSERT(m_ucData->file_path);
            memset(m_ucData->file_path, 0, (file_path_len + 1) * ENCODING_LENGTH);
            mmi_ucs2ncpy((CHAR*) m_ucData->file_path, (CHAR*) data->file_path, file_path_len);
            m_ucData->auto_delete_file = data->auto_delete_file;
        }

        if (data->text_num)
        {
            U32 buffer_size = 0;
            U8 *buffer = NULL;
            U32 buffer_len = 0;

            // Discard the exceeding part
            if (data->text_num > SRV_UC_MAX_CHAR_NUM_IN_ONE_SLIDE)
            {
                data->text_num = SRV_UC_MAX_CHAR_NUM_IN_ONE_SLIDE;
            }
            if (data->msg_type == SRV_UC_MSG_TYPE_SMS_ONLY && data->text_num > UC_MAX_SMS_CONTENT)
            {
                data->text_num = UC_MAX_SMS_CONTENT;
            }

            buffer_size = (data->text_num + 1) * ENCODING_LENGTH;
            VFX_ALLOC_MEM(buffer, buffer_size, this);
            MMI_ASSERT(buffer_size <= SRV_UC_UTF8_TEXT_BUFFER_SIZE);
            memset(buffer, 0, buffer_size);
            srv_sms_remove_escape_char(
                (CHAR*) buffer,
                (CHAR*) data->text_buffer,
                (U16) data->text_num);
            buffer_len = mmi_ucs2strlen((CHAR*) buffer);

            if (buffer_len <= (SRV_UC_TEXT_BUFFER_SIZE / ENCODING_LENGTH) - 1)
            {
                VFX_ALLOC_MEM(m_ucData->text_buffer, (buffer_len + 1) * ENCODING_LENGTH, this);
                memset(m_ucData->text_buffer, 0, (buffer_len + 1) * ENCODING_LENGTH);
                mmi_ucs2ncpy((CHAR*) m_ucData->text_buffer, (CHAR*) buffer, buffer_len);
            }
            else
            {
                VFX_ALLOC_MEM(m_ucData->text_buffer, SRV_UC_TEXT_BUFFER_SIZE, this);
                memset(m_ucData->text_buffer, 0, SRV_UC_TEXT_BUFFER_SIZE);
                mmi_ucs2ncpy((CHAR*) m_ucData->text_buffer, (CHAR*) buffer, (SRV_UC_TEXT_BUFFER_SIZE / ENCODING_LENGTH) - 1);
            }

            VFX_FREE_MEM(buffer);

        }
        m_ucData->text_num = data->text_num;

        if (data->subject)
        {
            U32 len = mmi_ucs2strlen((CHAR*) data->subject);

            VFX_ALLOC_MEM(m_ucData->subject, ((len + 1) * ENCODING_LENGTH), this);
            MMI_ASSERT(m_ucData->subject);
            memset(m_ucData->subject, 0, ((len + 1) * ENCODING_LENGTH));
            mmi_ucs2ncpy((CHAR*) m_ucData->subject, (CHAR*) data->subject, len);
        }

        m_ucData->info_type = data->info_type;
        m_ucData->info = data->info;
        m_ucData->callback = data->callback;
        m_ucData->callback_para = data->callback_para;
        m_ucData->sim_id = data->sim_id;
        m_ucData->get_address_callback = data->get_address_callback;
        m_ucData->get_media_callback = data->get_media_callback;
        m_ucData->app_id = data->app_id;
        m_ucData->mode = data->mode;
        m_ucData->msg_id = data->msg_id;
        m_ucData->edit_mode = data->edit_mode;
        m_ucData->curr_storage = data->curr_storage;
        m_ucData->type = data->type;
        m_ucData->operation = data->operation;
		m_ucData->launch_mode = data->launch_mode;
    }
}

void VappUcmCallScreen::deinitUCData()
{
    if (m_ucData)
    {
        if (m_ucData->addr)
        {
            srv_uc_addr_struct *currAddr = m_ucData->addr;
            srv_uc_addr_struct *tempPtr = currAddr->next;
            while (tempPtr)
            {
                VFX_FREE_MEM(currAddr->addr);
                VFX_FREE_MEM(currAddr);
                currAddr = tempPtr;
                tempPtr = tempPtr->next;
            }
            VFX_FREE_MEM(currAddr->addr);
            VFX_FREE_MEM(currAddr);
        }
        if (m_ucData->file_path)
        {
            VFX_FREE_MEM(m_ucData->file_path);
        }
        if (m_ucData->text_buffer)
        {
            VFX_FREE_MEM(m_ucData->text_buffer);
        }
        if (m_ucData->subject)
        {
            VFX_FREE_MEM(m_ucData->subject);
        }

        VFX_FREE_MEM(m_ucData);
    }
}

void VappUcmCallScreen::enterUC(VappUcEntryStruct *data)
{
    deinitUCData();
    copyUCData(data);
    if (!mmi_frm_is_scenario_started(MMI_SCENARIO_ID_UCM_EDIT_MSG))
    {
        mmi_frm_start_scenario(MMI_SCENARIO_ID_UCM_EDIT_MSG);
    }
    // prepare memory for CUI
    // UC CUI will use ASM, so to hide call in OOM
    mmi_frm_asm_property_struct property;
    mmi_frm_asm_property_init(&property);
    property.f_prepare_w_reserve = 1;
    property.f_hide_in_oom = 1;
    mmi_frm_asm_set_property(getApp()->getGroupId(), &property);
    mmi_frm_asm_prepare(
        getApp()->getGroupId(), 
        mmi_res_get_app_base_mem_size(getApp()->getGroupId()) + mmi_res_get_app_fg_mem_size(getApp()->getGroupId()), 
        vapp_ucm_proc, this, MMI_FRM_ASM_F_FORCE_PREPARE);    
}

void VappUcmCallScreen::realEnterUC()
{
    MMI_ASSERT(NULL != m_ucData);
    m_uc = vcui_unifiedcomposer_create(getApp()->getGroupId(), m_ucData);
    if (m_uc != GRP_ID_INVALID)
    {
        vfxSetCuiCallerScr(m_uc, this);
        vapp_ucm_scr->setAutoClose(VFX_FALSE);
        vcui_unifiedcomposer_run(m_uc);
        vapp_ucm_sms_state = VAPP_UCM_SMS_SENDING;
    }
    deinitUCData();
    /// Should delay closing mainpage to prevent blank flashing
    ///   if select 'send msg' on 'confirm redial' popup
    ///   As prepare memory to enter UC is asynchronization
    if (MMI_FALSE == srv_ucm_is_any_call() && m_mainPage.isValid())
    {
        m_mainPage->back();
    }
}
#endif /* (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__)) */
#ifdef __MMI_UCM_VT_MSG__
void VappUcmCallScreen::pushMsgFolderPage()
{
    VFX_OBJ_CREATE_EX(m_msgFolderPage, VappMsgFolderPage, this, 
        (SRV_UM_MSG_SMS, 
         SRV_UM_MSG_BOX_INBOX, 
         SRV_UM_SIM_ALL, 
         VAPP_MSG_FOLDER_TYPE_LITE));
    pushPage(VFX_ID_NULL, m_msgFolderPage.get());
}

VfxBool VappUcmCallScreen::msgFolderPageExists()
{
    if (m_msgFolderPage.isValid())
    {
        return VFX_TRUE;
    }
    else
    {
        return VFX_FALSE;
    }
}
#endif // __MMI_UCM_VT_MSG__

void VappUcmCallScreen::closePagesAboveMainPage()
{
    if (m_mainPage.isValid())
    {
        // Just to clear popups not explicitly created by UCM
        // Popups created and maintained by UCM should not be destroyed here
        clearPopupStack();
        VfxId mainPageId = m_mainPage->getId();
        VfxId nextPageId = getNextPageId(mainPageId);
        while (VFX_ID_NULL != nextPageId)
        {
            closePage(nextPageId);
            nextPageId = getNextPageId(mainPageId);
        }
        MMI_ID group_id[10]; // 10 should be enough for all first level nodes.
        S32 size = 10;

        if (MMI_RET_OK == mmi_frm_group_query_children_list(getApp()->getGroupId(), group_id, &size))
        {
            for (VfxU32 i = 1; i < size; i++)
            {
                
                mmi_frm_group_close(group_id[i]);

            }    
        }
    }
    else
    {
        vapp_ucm_terminate();
    }
}

VappUcmMainPage* VappUcmCallScreen::getMainPage(void)
{
    if (m_mainPage.isValid())
    {
        return m_mainPage.get();
    }
    else
    {
        return NULL;
    }
}

void VappUcmCallScreen::onDeinit()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CSD", SA_start);
#endif
    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_VAPP_UCM_APP_STATE, 12);
#if (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__))
    deinitUCData();
#endif
    VfxMainScr::onDeinit();
    vapp_ucm_scr = NULL;
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CSD", SA_stop);
#endif
}

mmi_ret VappUcmCallScreen::onProc(mmi_event_struct* evt)
{
    switch (evt->evt_id)
    {
        //case EVT_ID_CUI_DIALER_CLOSED_IND:
        //    break;
        case EVT_ID_CUI_DIALER_CLOSE_REQ:        
        {
            vcui_dialer_close(((mmi_group_event_struct*)evt)->sender_id);
            return MMI_RET_OK;
        }
        case EVT_ID_VAPP_NCENTER_DRAG:
        {
            if (m_mainPage.isValid() && m_mainPage->isScreenLocked())
            {
                // other cases will be handled in vapp_ucm_proc as Ucm may be inactive group
                return MMI_RET_ERR;
            }
            break;
        }
        
#if (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__))
        case EVT_ID_CUI_UC_SMS_SENT:
        {
        #ifdef __MMI_UCM_REJECT_BY_SMS__
            // close template page whenever sms is sent
            if (m_smsTemplatePage.isValid())
            {
                m_smsTemplatePage->back();
            }
        #endif // __MMI_UCM_REJECT_BY_SMS__

            if (VAPP_UCM_SMS_SENDING == vapp_ucm_sms_state)
            {
                if (srv_ucm_is_incoming_call())
                {
                    // incoming call may have been released by the remote side, don't need to end call again
                    vapp_ucm_incoming_call_endkey();
                }
                vapp_ucm_sms_state = VAPP_UCM_SMS_NONE;
            }
            break;
        }
        case EVT_ID_CUI_UC_MSGCOMPOSER_CLOSE:
        {
            if (GRP_ID_INVALID != m_uc)
            {
            #ifdef __MMI_UCM_REJECT_BY_SMS__
                if (m_smsTemplatePage.isValid())
                {
                    vapp_ucm_sms_state = VAPP_UCM_SMS_SELECT_MSG;
                }
                else
            #endif // __MMI_UCM_REJECT_BY_SMS__
                {
                    vapp_ucm_sms_state = VAPP_UCM_SMS_NONE;
                    if (mmi_frm_is_scenario_started(MMI_SCENARIO_ID_UCM_EDIT_MSG))
                    {
                        mmi_frm_end_scenario(MMI_SCENARIO_ID_UCM_EDIT_MSG);
                    }
                }
                if (m_mainPage.isValid()
                #ifdef __MMI_UCM_REJECT_BY_SMS__
                    || m_smsTemplatePage.isValid()
                #endif // __MMI_UCM_REJECT_BY_SMS__
                    )
                {
                    setAutoClose(VFX_TRUE);
                }
                else
                {
                    back();
                }

                // just close it
                vcui_unifiedcomposer_close(m_uc);
                m_uc = GRP_ID_INVALID;

            }
            break;
        }
#endif /* (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__)) */
    }

    return VfxMainScr::onProc(evt);
}

VFX_IMPLEMENT_CLASS("VappUcmMainPage", VappUcmMainPage, VfxPage);
void VappUcmMainPage::onInit()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMP", SA_start);
#endif
    VfxPage::onInit();

    VappNCenter *NCenter = VFX_OBJ_GET_INSTANCE(VappNCenter);
    if (NCenter)
    {
        NCenter->m_signalEvent.connect(this, &VappUcmMainPage::onNCenterStatus);
    }

    setStatusBar(VFX_TRUE);
    setIsZSortChild(VFX_TRUE);
    for (VfxU32 idx = 0; idx < 3; ++idx)
    {
        m_callCells[idx].call_type = VAPP_UCM_CALL_TYPE_NONE;
    #ifdef __MMI_VIDEO_TELEPHONY__
        m_callCells[idx].ptrCallCell.videoCallCell = NULL;
    #endif // __MMI_VIDEO_TELEPHONY__
    }
    m_disableBacknHomeKey = VFX_FALSE;
    m_bgImg = NULL;
    initWallpaper();

    m_dialPad = NULL;
    m_redialTimer = NULL;
    m_cnfPopup = NULL;
    m_scrnLock = NULL;
#ifndef __PXS_APP_ENABLE__
    m_isScrnLocked = vapp_ucm_launch_screen_lock;
#else
    m_isScrnLocked = VFX_FALSE;
#endif // __PXS_APP_ENABLE__
	m_redialType= VAPP_UCM_REDIAL_NONE;
    m_floatTimeLine = NULL;
    m_effect1 = NULL;
    m_effect1Count = 0;
    m_effect2 = NULL;
    m_effect2Count = 0;
    m_redialCmdPopup = NULL;
    m_penDown = VFX_FALSE;

#ifdef __MMI_EM_PROFILING_VT_LOOKBACK__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif // __MMI_EM_PROFILING_VT_LOOKBACK__
        createCallCells();

    if(m_isScrnLocked)
    {
        createScrnLockFrame();
        m_activeCallCell->hideActionArea(VFX_TRUE);
    }

    VFX_OBJ_CREATE(m_scrnLockTimer, VfxTimer, this);
    m_scrnLockTimer->setStartDelay(5000);
    m_scrnLockTimer->setDuration(5000);
    m_scrnLockTimer->m_signalTick.connect(this, &VappUcmMainPage::onScrnLockTimerExpiry);

    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_VAPP_UCM_APP_STATE, 3);
    preCacheChildren();
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMP", SA_stop);
#endif
}

void VappUcmMainPage::onDeinit()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMD", SA_start);
#endif
    if(m_redialType == VAPP_UCM_REDIAL_AUTO)
    {
        if (!srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_VOICE_CALL_TYPE_ALL, NULL))
        {
            // confirm popup event is post emit, which may not be handled yet
            vapp_ucm_auto_redial_abort();
        }
    }

    VappNCenter *NCenter = VFX_OBJ_GET_INSTANCE(VappNCenter);
    if (NCenter)
    {
        NCenter->m_signalEvent.disconnect(this, &VappUcmMainPage::onNCenterStatus);
    }

    if (g_ucm_p->call_end_tone_id == TONE_BUSY_CALL_GSM)
    {
        srv_prof_stop_tone(SRV_PROF_TONE_GSM_BUSY);     
    }
    else if (g_ucm_p->call_end_tone_id > 0) 
    {
        srv_prof_stop_tone((srv_prof_tone_enum)g_ucm_p->call_end_tone_id);
    }
    g_ucm_p->call_end_tone_id = 0;

#ifdef __MMI_EM_PROFILING_VT_LOOKBACK__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif // __MMI_EM_PROFILING_VT_LOOKBACK__

    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_VAPP_UCM_APP_STATE, 13);
    VfxPage::onDeinit();
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMD", SA_stop);
#endif
}

void VappUcmMainPage::onEnter(VfxBool isBackward)
{
    VfxPage::onEnter(isBackward);
    initWallpaper();
}

void VappUcmMainPage::onEntered()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMN", SA_start);
#endif

    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_VAPP_UCM_APP_STATE, 4);
    setScrnLockTimer(VFX_TRUE);
#ifdef __MMI_VIDEO_TELEPHONY__
    for (VfxU32 i = 0; i < 3; ++i)
    {
        if(m_callCells[i].call_type == VAPP_UCM_CALL_TYPE_VIDEO)
        {
            VfxBool active = VFX_TRUE;
            m_callCells[i].ptrCallCell.videoCallCell->onPrepareDone(VT_READY_PLAY_VIDEO);
            m_callCells[i].ptrCallCell.videoCallCell->onRefreshCell(VAPP_UCM_REFRESH_TYPE_ACTIVE_SCREEN, (void*) &active);
        }
    }
#endif // __MMI_VIDEO_TELEPHONY__
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMN", SA_stop);
#endif
}
void VappUcmMainPage::onExit(VfxBool isBackward)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMX", SA_start);
#endif
    setScrnLockTimer(VFX_FALSE);
#ifdef __MMI_VIDEO_TELEPHONY__
    for (VfxU32 i = 0; i < 3; ++i)
    {
        if(m_callCells[i].call_type == VAPP_UCM_CALL_TYPE_VIDEO)
        {
            VfxBool active = VFX_FALSE;
            m_callCells[i].ptrCallCell.videoCallCell->waitReadyPlay();
            m_callCells[i].ptrCallCell.videoCallCell->onRefreshCell(VAPP_UCM_REFRESH_TYPE_ACTIVE_SCREEN, (void*) &active);
        }
    }
#endif // __MMI_VIDEO_TELEPHONY__
    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_VAPP_UCM_APP_STATE, 14);
    VfxPage::onExit(isBackward);
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMX", SA_stop);
#endif
}
void VappUcmMainPage::onExited()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMO", SA_start);
#endif
    setScrnLockTimer(VFX_FALSE);
    VfxPage::onExited();
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMO", SA_stop);
#endif
}

void VappUcmMainPage::onExited2()
{
    VFX_OBJ_CLOSE(m_bgImg);
    VfxPage::onExited2();
}

void VappUcmMainPage::initWallpaper()
{
    if (!m_bgImg)
    {
        m_bgImg = VappWallpaperKit::createWallpaper(this, VAPP_WALLPAPER_SRC_LOCK);
    }
}

void VappUcmMainPage::setActiveCallCell(VappUcmCallCell *call_cell)
{
    m_activeCallCell = call_cell;
    srv_ucm_index_info_struct call_index = m_activeCallCell->getCallIndex();
    vapp_ucmapp_set_active_call_info(&call_index);
}

VappUcmCallCell* VappUcmMainPage::getActivateCallCell(void)
{
    return m_activeCallCell;
}

VappUcmCallCell* VappUcmMainPage::getCallCell(VfxU8 index)
{
    MMI_ASSERT(index < m_totalCallCells);
    if (index < m_totalCallCells)
    {
        return m_callCells[index].ptrCallCell.voiceCallCell;
    }
    return NULL;
}

void VappUcmMainPage::onShowDialPad(VfxBool show)
{
    if (show)
    {
        VFX_ASSERT(!m_dialPad);
        VFX_OBJ_CREATE(m_dialPad, VappUcmDialPad, this);
        m_dialPad->m_signalScrnLockTimer.connect(this, &VappUcmMainPage::onControlScrnLocKTimer);
    }
    else
    {
        VFX_ASSERT(m_dialPad);
        VFX_OBJ_CLOSE(m_dialPad);
        VFX_ASSERT(m_activeCallCell);
        // for UI Performance_BEGIN
        if (SRV_UCM_HOLD_STATE == m_activeCallCell->getCallState() 
            || SRV_UCM_ACTIVE_STATE == m_activeCallCell->getCallState()) 
        {
            m_activeCallCell->onCallTimerTicked(NULL);
        }
        // for UI Performance_END
    }
    setScrnLockTimer(!show);
}

void VappUcmMainPage::onSwapEffectFinish1(VfxFrame *call_cell, VfxBool is_complete)
{
    if (!m_effect1) return;
    if (m_effect1Count)
    {
        m_effect1Count = 0;
        VFX_OBJ_CLOSE(m_effect1);
        return;
    }
    else
    {
        m_effect1Count++;
    }

    VappUcmCallCell *target_cell = (VappUcmCallCell*)call_cell;
    VfxBool maxConf = m_activeCallCell->getCallCount() >= SRV_UCM_MAX_CALL_IN_GROUP;
    for (VfxU32 idx = 0; idx < m_totalCallCells; ++idx)
    {
        if ((VappUcmCallCell*)m_callCells[idx].ptrCallCell.voiceCallCell == target_cell)
        {
            m_effect1->restore();
            m_callCells[idx].ptrCallCell.voiceCallCell->setCellType((VappUcmCallCellTypeEnum)(VAPP_UCM_CALL_CELL_TYPE_TOTAL - m_totalCallCells));
            if (!m_floatTimeLine)
            {
                // don't update cells during release animation
                if (VAPP_UCM_CALL_TYPE_VOICE == m_callCells[idx].call_type
                    || VAPP_UCM_CALL_TYPE_DATA == m_callCells[idx].call_type
                    || VAPP_UCM_CALL_TYPE_CSD == m_callCells[idx].call_type)
                {
                    m_callCells[idx].ptrCallCell.voiceCallCell->updateCallCell();
                }
            #ifdef __MMI_VIDEO_TELEPHONY__
                else
                {
                    m_callCells[idx].ptrCallCell.videoCallCell->updateScreen();
                }
            #endif
            }
            setActiveCallCell(m_callCells[idx].ptrCallCell.voiceCallCell);
            m_effect1->applyEffect((VfxFrame*) m_callCells[idx].ptrCallCell.voiceCallCell,
                                VCP_EFFECT_FLIP,
                                150,
                                VCP_EFFECT_DIRECTION_FROM_UP,
                                VFX_FALSE,
                                NULL,
                                0);
            setScrnLockTimer(VFX_TRUE);
        }
    }
    if (maxConf)
    {
        m_activeCallCell->setActBtnDisable(VAPP_UCM_ACT_AREA_BTN_CONFERENCE, VFX_TRUE);
    }
}

void VappUcmMainPage::onSwapEffectFinish2(VfxFrame *call_cell, VfxBool is_complete)
{
    if (!m_effect2) return;
    if (m_effect2Count)
    {
        m_effect2Count = 0;
        VFX_OBJ_CLOSE(m_effect2);
        return;
    }
    else
    {
        m_effect2Count++;
    }

    VappUcmCallCell *target_cell = (VappUcmCallCell*)call_cell;

    for (VfxU32 idx = 0; idx < m_totalCallCells; ++idx)
    {
        if ((VappUcmCallCell*)m_callCells[idx].ptrCallCell.voiceCallCell == target_cell)
        {
            m_effect2->restore();
            m_callCells[idx].ptrCallCell.voiceCallCell->setCellType(m_cellType);
            if (!m_floatTimeLine)
            {
                // don't update cells during release animation
                if (VAPP_UCM_CALL_TYPE_VOICE == m_callCells[idx].call_type
                    || VAPP_UCM_CALL_TYPE_CSD == m_callCells[idx].call_type
                    || VAPP_UCM_CALL_TYPE_DATA == m_callCells[idx].call_type)
                {
                    m_callCells[idx].ptrCallCell.voiceCallCell->updateCallCell();
                }
            #ifdef __MMI_VIDEO_TELEPHONY__
                else
                {
                    m_callCells[idx].ptrCallCell.videoCallCell->updateScreen();
                }
            #endif // __MMI_VIDEO_TELEPHONY__
            }
            m_effect2->applyEffect((VfxFrame*) m_callCells[idx].ptrCallCell.voiceCallCell,
                                VCP_EFFECT_FLIP,
                                150,
                                VCP_EFFECT_DIRECTION_FROM_UP,
                                VFX_FALSE,
                                NULL,
                                0);
            setScrnLockTimer(VFX_TRUE);
        }
    }
}

void VappUcmMainPage::swapCallCells(VappUcmCallCell *target_cell)
{
    VfxU32 idx;

    if (m_isScrnLocked || m_floatTimeLine || m_effect1 || m_effect2)
    {
        return;
    }

#ifdef __MMI_VIDEO_TELEPHONY__
    for (idx = 0; idx < m_totalCallCells; ++idx)
    {
        if(m_callCells[idx].call_type == VAPP_UCM_CALL_TYPE_VIDEO
            && !m_callCells[idx].ptrCallCell.videoCallCell->isReady())
        {
            return;
        }
    }
#endif // __MMI_VIDEO_TELEPHONY__

    m_cellType = target_cell->getCellType();
    VFX_OBJ_CLOSE(m_dialPad);

    for (idx = 0; idx < m_totalCallCells; ++idx)
    {
        if (VAPP_UCM_CALL_TYPE_VOICE == m_callCells[idx].call_type
            || VAPP_UCM_CALL_TYPE_CSD == m_callCells[idx].call_type
            || VAPP_UCM_CALL_TYPE_DATA == m_callCells[idx].call_type)
        {
            if (target_cell == m_callCells[idx].ptrCallCell.voiceCallCell)
            {
                VFX_OBJ_CREATE(m_effect1, VcpFrameEffect, this);
                m_effect1->m_signalFinished.connect(this, &VappUcmMainPage::onSwapEffectFinish1);
                m_effect1->applyEffect((VfxFrame*) m_callCells[idx].ptrCallCell.voiceCallCell,
                                    VCP_EFFECT_FLIP,
                                    150,
                                    VCP_EFFECT_DIRECTION_FROM_UP,
                                    VFX_TRUE,
                                    NULL,
                                    0);
            }
            if (m_activeCallCell == m_callCells[idx].ptrCallCell.voiceCallCell)
            {
                VFX_OBJ_CREATE(m_effect2, VcpFrameEffect, this);
                m_effect2->m_signalFinished.connect(this, &VappUcmMainPage::onSwapEffectFinish2);
                m_effect2->applyEffect((VfxFrame*) m_callCells[idx].ptrCallCell.voiceCallCell,
                                    VCP_EFFECT_FLIP,
                                    150,
                                    VCP_EFFECT_DIRECTION_FROM_UP,
                                    VFX_TRUE,
                                    NULL,
                                    0);            
            }
        }
    #ifdef __MMI_VIDEO_TELEPHONY__
        else
        {
            if (target_cell == m_callCells[idx].ptrCallCell.videoCallCell)
            {
                VFX_OBJ_CREATE(m_effect1, VcpFrameEffect, this);
                m_effect1->m_signalFinished.connect(this, &VappUcmMainPage::onSwapEffectFinish1);
                m_effect1->applyEffect((VfxFrame*) m_callCells[idx].ptrCallCell.videoCallCell,
                                    VCP_EFFECT_FLIP,
                                    150,
                                    VCP_EFFECT_DIRECTION_FROM_UP,
                                    VFX_TRUE,
                                    NULL,
                                    0);
            }
            if (m_activeCallCell == m_callCells[idx].ptrCallCell.videoCallCell)
            {
                VFX_OBJ_CREATE(m_effect2, VcpFrameEffect, this);
                m_effect2->m_signalFinished.connect(this, &VappUcmMainPage::onSwapEffectFinish2);
                m_effect2->applyEffect((VfxFrame*) m_callCells[idx].ptrCallCell.videoCallCell,
                                    VCP_EFFECT_FLIP,
                                    150,
                                    VCP_EFFECT_DIRECTION_FROM_UP,
                                    VFX_TRUE,
                                    NULL,
                                    0);
            }
        }
    #endif // __MMI_VIDEO_TELEPHONY__
    }
}

void VappUcmMainPage::createCallCells()
{
    // Query call table
    srv_ucm_index_info_struct index_list[SRV_UCM_MAX_CALL]; 
    S32 group_index_list[SRV_UCM_MAX_GROUP];
    m_totalCallCells = (VfxU8)srv_ucm_query_group_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, MMI_FALSE, group_index_list);
    m_activeCallCell = NULL;

    VFX_ASSERT(m_totalCallCells <4);
    VfxU8 reduced_cell_number = 0;

    // MO_2Steps-BEGIN
    if (0 == m_totalCallCells)
    {
        group_index_list[0] = 0;
        m_totalCallCells = srv_ucm_query_group_data(group_index_list[0], NULL);
    }
    //MO_2Steps-END
    
    for (VfxU32 idx = 0; idx < m_totalCallCells; ++idx)
    {
        VfxS32  call_index_list[SRV_UCM_MAX_CALL_IN_GROUP];
        srv_ucm_group_info_struct group_info;

        srv_ucm_query_group_data(group_index_list[idx], &group_info);
        index_list[idx].group_index = group_index_list[idx];
        mmi_ucm_get_call_index_list_by_group_index(group_index_list[idx], call_index_list);
        //MO_2Steps-BEGIN
        if (SRV_UCM_INVALID_ID == group_info.group_id)
        {
            call_index_list[0] = 0;
        }
        //MO_2Steps-END
        index_list[idx].call_index = call_index_list[0];

        if (group_info.call_type & (SRV_UCM_VOICE_CALL_TYPE_ALL | SRV_UCM_CALL_TYPE_DATA_CSD_ALL))
        {
            if (group_info.call_type & SRV_UCM_DATA_CALL_TYPE_ALL)
            {
                m_callCells[idx].call_type = VAPP_UCM_CALL_TYPE_DATA;
            }
            else if (group_info.call_type & SRV_UCM_CSD_CALL_TYPE_ALL)
            {
                m_callCells[idx].call_type = VAPP_UCM_CALL_TYPE_CSD;
            }
            else
            {
                m_callCells[idx].call_type = VAPP_UCM_CALL_TYPE_VOICE;
            }

            if (m_totalCallCells == 1)
            {
                m_callCells[idx].ptrCallCell.voiceCallCell = createVoiceCallCell(
                                                                index_list[idx].group_index,
                                                                index_list[idx].call_index,
                                                                VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1);
                m_activeCallCell = m_callCells[idx].ptrCallCell.voiceCallCell;
                vapp_ucmapp_set_active_call_info(&index_list[idx]);
                if (SRV_UCM_CALL_STATE_CONNECTED & group_info.call_state)
                {
                    m_activeCallCell->startCallTimer();
                }
            }
            else if (SRV_UCM_OUTGOING_STATE == group_info.call_state
                     || SRV_UCM_INCOMING_STATE == group_info.call_state)
            {
                m_callCells[idx].ptrCallCell.voiceCallCell = createVoiceCallCell(
                                                                index_list[idx].group_index,
                                                                index_list[idx].call_index,
                                                                (VappUcmCallCellTypeEnum)(VAPP_UCM_CALL_CELL_TYPE_TOTAL - m_totalCallCells));

                m_activeCallCell = m_callCells[idx].ptrCallCell.voiceCallCell;
                vapp_ucmapp_set_active_call_info(&index_list[idx]);
            }
            else if (SRV_UCM_CALL_STATE_CONNECTED & group_info.call_state)
            {
                if (reduced_cell_number + 1 == m_totalCallCells)
                {
                    // All calls are active/hold call
                    m_callCells[idx].ptrCallCell.voiceCallCell = createVoiceCallCell(
                                                                    index_list[idx].group_index,
                                                                    index_list[idx].call_index,
                                                                    (VappUcmCallCellTypeEnum)(VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1-reduced_cell_number));

                    m_activeCallCell = m_callCells[idx].ptrCallCell.voiceCallCell;
                    vapp_ucmapp_set_active_call_info(&index_list[idx]);
                }
                else
                {
                    m_callCells[idx].ptrCallCell.voiceCallCell = createVoiceCallCell(
                                                                    index_list[idx].group_index,
                                                                    index_list[idx].call_index,
                                                                    (VappUcmCallCellTypeEnum)(VAPP_UCM_CALL_CELL_TYPE_REDUCED1 + reduced_cell_number));
                    reduced_cell_number ++;
                }
                m_callCells[idx].ptrCallCell.voiceCallCell->startCallTimer();
            }
            m_callCells[idx].ptrCallCell.voiceCallCell->m_signalSwapCell.connect(this, &VappUcmMainPage::swapCallCells);
            m_callCells[idx].ptrCallCell.voiceCallCell->m_signalShowDialPad.connect(this, &VappUcmMainPage::onShowDialPad);
            m_callCells[idx].ptrCallCell.voiceCallCell->m_signalScrnLockTimer.connect(this, &VappUcmMainPage::onControlScrnLocKTimer);
            m_callCells[idx].ptrCallCell.voiceCallCell->m_signalDisableBacknHomeKey.connect(this, &VappUcmMainPage::disableBacknHomeKey);
        }
    #ifdef __MMI_VIDEO_TELEPHONY__
        else if (group_info.call_type & SRV_UCM_VIDEO_CALL_TYPE)
        {
            m_callCells[idx].call_type = VAPP_UCM_CALL_TYPE_VIDEO;
            if (1 == m_totalCallCells)
            {
                if (m_callCells[idx].ptrCallCell.videoCallCell == NULL)
                {
                    m_callCells[idx].ptrCallCell.videoCallCell= createVideoCallCell(
                                                                    index_list[idx].group_index,
                                                                    index_list[idx].call_index,
                                                                    VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1);
                }
                else
                {
                    refreshVideoCallCell(
                        index_list[idx].group_index,
                        index_list[idx].call_index,
                        VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1,
                        m_callCells[idx].ptrCallCell.videoCallCell,
                        m_callCells[idx].refresh_type,
                        m_callCells[idx].data);
                }
                m_activeCallCell = m_callCells[idx].ptrCallCell.voiceCallCell;
                vapp_ucmapp_set_active_call_info(&index_list[idx]);
            }
            else if (SRV_UCM_OUTGOING_STATE == group_info.call_state
                     || SRV_UCM_INCOMING_STATE == group_info.call_state)
            {
                if (m_callCells[idx].ptrCallCell.videoCallCell == NULL)
                {
                    m_callCells[idx].ptrCallCell.videoCallCell = createVideoCallCell(
                                                                    index_list[idx].group_index,
                                                                    index_list[idx].call_index,
                                                                    (VappUcmCallCellTypeEnum)(VAPP_UCM_CALL_CELL_TYPE_TOTAL - m_totalCallCells));
                }
                else
                {
                    refreshVideoCallCell(
                        index_list[idx].group_index,
                        index_list[idx].call_index,
                        (VappUcmCallCellTypeEnum)(VAPP_UCM_CALL_CELL_TYPE_TOTAL - m_totalCallCells),
                        m_callCells[idx].ptrCallCell.videoCallCell,
                        m_callCells[idx].refresh_type,
                        m_callCells[idx].data);
                }

                m_activeCallCell = m_callCells[idx].ptrCallCell.videoCallCell;
                vapp_ucmapp_set_active_call_info(&index_list[idx]);
            }
            else if (SRV_UCM_CALL_STATE_CONNECTED & group_info.call_state)
            {
                if (reduced_cell_number + 1 == m_totalCallCells)
                {
                    // All calls are active/hold call
                    if (m_callCells[idx].ptrCallCell.videoCallCell == NULL)
                    {
                        m_callCells[idx].ptrCallCell.videoCallCell = createVideoCallCell(
                                                                        index_list[idx].group_index,
                                                                        index_list[idx].call_index,
                                                                        (VappUcmCallCellTypeEnum)(VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1-reduced_cell_number));
                    }
                    else
                    {
                        refreshVideoCallCell(
                            index_list[idx].group_index,
                            index_list[idx].call_index,
                            (VappUcmCallCellTypeEnum)(VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1-reduced_cell_number),
                            m_callCells[idx].ptrCallCell.videoCallCell,
                            m_callCells[idx].refresh_type,
                            m_callCells[idx].data);
                    }

                    m_activeCallCell = m_callCells[idx].ptrCallCell.videoCallCell;
                    vapp_ucmapp_set_active_call_info(&index_list[idx]);
                }
                else
                {
                    if (m_callCells[idx].ptrCallCell.videoCallCell == NULL)
                    {
                        m_callCells[idx].ptrCallCell.videoCallCell = createVideoCallCell(
                                                                        index_list[idx].group_index,
                                                                        index_list[idx].call_index,
                                                                        (VappUcmCallCellTypeEnum)(VAPP_UCM_CALL_CELL_TYPE_REDUCED1 + reduced_cell_number));
                    }
                    else
                    {
                        refreshVideoCallCell(
                            index_list[idx].group_index,
                            index_list[idx].call_index,
                            (VappUcmCallCellTypeEnum)(VAPP_UCM_CALL_CELL_TYPE_REDUCED1 + reduced_cell_number),
                            m_callCells[idx].ptrCallCell.videoCallCell,
                            m_callCells[idx].refresh_type,
                            m_callCells[idx].data);
                    }
                    reduced_cell_number ++;
                }
            }
            m_callCells[idx].ptrCallCell.videoCallCell->m_signalSwapCell.connect(this, &VappUcmMainPage::swapCallCells);
            m_callCells[idx].ptrCallCell.videoCallCell->m_signalShowDialPad.connect(this, &VappUcmMainPage::onShowDialPad);
            m_callCells[idx].ptrCallCell.videoCallCell->m_signalScrnLockTimer.connect(this, &VappUcmMainPage::onControlScrnLocKTimer);
            m_callCells[idx].ptrCallCell.videoCallCell->m_signalDisableBacknHomeKey.connect(this, &VappUcmMainPage::disableBacknHomeKey);
        }
    #endif // __MMI_VIDEO_TELEPHONY__
    }
}

void VappUcmMainPage::updateAutoRedialString(VfxTimer *timer)
{
    if (m_cnfPopup)
    {
        m_autoRedialTime --;

        VfxWChar redialPrompt[SRV_UCM_MAX_AUTO_REDIAL_MSG_LEN];
        mmi_wsprintf(redialPrompt, SRV_UCM_MAX_AUTO_REDIAL_MSG_LEN, STR_ID_VAPP_UCM_REDIAL_PROMPT, m_autoRedialTime);
//        VfxWString  redialPromptStr = VFX_WSTR_MEM(redialPrompt);
            
	    if (1 == m_autoRedialTime)
	    {
	        timer->stop();
	    }
	    m_cnfPopup->setText(redialPrompt);
	  }
}

void VappUcmMainPage::showCofirmPopup(const VfxWChar* str)
{
    VFX_OBJ_CREATE(m_cnfPopup, VcpConfirmPopup, this);
    m_cnfPopup->setText(str);
    m_cnfPopup->setInfoType(VCP_POPUP_TYPE_QUESTION);
    m_cnfPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_YES_NO);
    m_cnfPopup->m_signalButtonClicked.connect(this, &VappUcmMainPage::onHandleConfirm);
    m_cnfPopup->show(VFX_TRUE);

    onScrnLock(VFX_FALSE);
    setScrnLockTimer(VFX_FALSE);
}

void VappUcmMainPage::closeConfirmPopup()
{
    VFX_OBJ_CLOSE(m_cnfPopup);
}

void VappUcmMainPage::onHandleConfirm(VfxObject *obj, VfxId id)
{
    setScrnLockTimer(VFX_TRUE);

    if (!m_cnfPopup)
    {
        // cancel confirm by ucm service, don't send ABORT to ucm service
        return;
    }

    m_cnfPopup = NULL;

    srv_ucm_query_cnf_struct query_cnf_result;
    if (VCP_CONFIRM_POPUP_BUTTON_YES == id)
    {
        query_cnf_result.result_info = SRV_UCM_QUERY_CNF_YES;
    }
    else if (VCP_CONFIRM_POPUP_BUTTON_NO == id)
    {
        query_cnf_result.result_info = SRV_UCM_QUERY_CNF_NO;
    }
    else if (VCP_POPUP_BUTTON_NO_PRESSED == id)
    {
        query_cnf_result.result_info = SRV_UCM_QUERY_CNF_ABORT;
    }
    else
    {
        query_cnf_result.result_info = SRV_UCM_QUERY_CNF_TOTAL;
    }
    g_ucm_p->cnf_scr.conf_ind_cb(SRV_UCM_QUERY_CNF, &query_cnf_result);
    if (g_ucm_p->cnf_scr.content)
    {
        OslMfree(g_ucm_p->cnf_scr.content);
        g_ucm_p->cnf_scr.content = NULL;
    }
}

void VappUcmMainPage::onNCenterStatus(VappNCenterEventEnum evt)
{
    switch (evt)
    {
        case VAPP_NCENTER_EVENT_ENTER:
            setScrnLockTimer(VFX_FALSE);
            break;
        case VAPP_NCENTER_EVENT_ENTERED:
            break;
        case VAPP_NCENTER_EVENT_EXIT:
            break;
        case VAPP_NCENTER_EVENT_EXITED:
            if (!vapp_screen_lock_is_exist() && getApp()->isGroupTopActive())
            {
                setScrnLockTimer(VFX_TRUE);
            }
            break;
    }
}

void VappUcmMainPage::afterReleaseAnimation(VfxBaseTimeline *time_line, VfxBool reason)
{
    if (TONE_BUSY_CALL_GSM == g_ucm_p->call_end_tone_id)
    {
        srv_prof_stop_tone(SRV_PROF_TONE_GSM_BUSY);     
    }
    else if (g_ucm_p->call_end_tone_id > 0) 
    {
        srv_prof_stop_tone((srv_prof_tone_enum)g_ucm_p->call_end_tone_id);
    }
    g_ucm_p->call_end_tone_id = 0;

    VfxS32 total_call_count = srv_ucm_query_group_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, MMI_FALSE, NULL);
    if (0 == total_call_count)
    {
        if (VAPP_UCM_REDIAL_AUTO == m_redialType)
        {           
            VfxWChar redialPrompt[SRV_UCM_MAX_AUTO_REDIAL_MSG_LEN];
            mmi_wsprintf(redialPrompt, SRV_UCM_MAX_AUTO_REDIAL_MSG_LEN, STR_ID_VAPP_UCM_REDIAL_PROMPT, m_autoRedialTime);
            VfxWString  redialPromptStr = VFX_WSTR_MEM(redialPrompt);

            VFX_OBJ_CREATE(m_cnfPopup, VcpConfirmPopup, this);
            m_cnfPopup->setText(redialPromptStr);
            m_cnfPopup->setInfoType(VCP_POPUP_TYPE_INFO);
            m_cnfPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_CANCEL);
            m_cnfPopup->m_signalButtonClicked.connect(this, &VappUcmMainPage::onCancelAutoRedial);
            m_cnfPopup->show(VFX_TRUE);

            onScrnLock(VFX_FALSE);
            setScrnLockTimer(VFX_FALSE);

            if (!m_redialTimer)
            {
                VFX_OBJ_CREATE(m_redialTimer, VfxTimer, this);
            }
            m_redialTimer->setDuration(1000);
            m_redialTimer->start();
            m_redialTimer->m_signalTick.connect(this, &VappUcmMainPage::updateAutoRedialString);
        }
        else if (VAPP_UCM_REDIAL_CONFIRM == m_redialType)
        {
            ShowRedialConfirm(STR_ID_VAPP_UCM_NO_ANSWER_REDIAL, m_callCells[0].call_type);
        }
        else if (SRV_UCM_END_ALL_AND_DIAL_ACT == srv_ucm_query_curr_action())
        {
            // disconnecting because of compound action, does not exit main page
        }
        else if (VAPP_UCM_SMS_NONE != vapp_ucm_sms_state)
        {
            back();
        }
        else
        {
            VfxWChar w_number[SRV_UCM_MAX_NUM_URI_LEN + 1];
            memset(w_number, 0, SRV_UCM_MAX_NUM_URI_LEN + 1);
            mmi_asc_to_ucs2((CHAR*)w_number, (CHAR*)m_numUri);
            vapp_phb_unsaved_number_to_phb(w_number);
            back();
        }
        return;
    }

    VFX_OBJ_CLOSE(m_floatTimeLine);
    setOpacity(1.0f);

    // if these is video call survive during the operation, the video call can't be destroyed
    for(VfxU32 ori_idx = 0; ori_idx < m_totalCallCells; ori_idx ++)
    {
        if (VAPP_UCM_CALL_TYPE_VOICE == m_callCells[ori_idx].call_type
            || VAPP_UCM_CALL_TYPE_CSD == m_callCells[ori_idx].call_type
            || VAPP_UCM_CALL_TYPE_DATA == m_callCells[ori_idx].call_type)
        {   // terminate all voice call cells
            VFX_OBJ_CLOSE(m_callCells[ori_idx].ptrCallCell.voiceCallCell);
            m_callCells[ori_idx].call_type = VAPP_UCM_CALL_TYPE_NONE;
        }
    #ifdef __MMI_VIDEO_TELEPHONY__
        else if (VAPP_UCM_CALL_TYPE_VIDEO == m_callCells[ori_idx].call_type)
        { 
            VfxS16 group_id = m_callCells[ori_idx].ptrCallCell.videoCallCell->getCallGroupId();
            VfxS32 group_idx = 0;
            if (srv_ucm_query_group_index_by_group_id(group_id, SRV_UCM_VIDEO_CALL_TYPE, &group_idx))
            {
                // cell type change
                if (group_idx != ori_idx)
                {
                    // change group index
                    m_callCells[group_idx].call_type = VAPP_UCM_CALL_TYPE_VIDEO;
                    m_callCells[group_idx].ptrCallCell.videoCallCell = m_callCells[ori_idx].ptrCallCell.videoCallCell;
                    m_callCells[ori_idx].call_type = VAPP_UCM_CALL_TYPE_NONE;
                    m_callCells[ori_idx].ptrCallCell.videoCallCell = NULL;
                }
            }
            else
            {
                VFX_OBJ_CLOSE(m_callCells[ori_idx].ptrCallCell.videoCallCell);
                m_callCells[ori_idx].call_type = VAPP_UCM_CALL_TYPE_NONE;
                
                // unreserve asm
                mmi_frm_asm_property_struct property;
                mmi_frm_asm_property_init(&property);
                property.f_prepare_w_reserve = 0;
                mmi_frm_asm_set_property(vapp_ucm_scr->getApp()->getGroupId(), &property);
            }
        }
    #endif // __MMI_VIDEO_TELEPHONY__
    }
    VFX_OBJ_CLOSE(m_dialPad);
    createCallCells();
}

void VappUcmMainPage::onCancelAutoRedial(VfxObject *obj, VfxId id)
{
    setScrnLockTimer(VFX_TRUE);
    m_cnfPopup = NULL;
    m_redialType= VAPP_UCM_REDIAL_NONE;
    if (0 == srv_ucm_query_group_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, MMI_FALSE, NULL))
    {
        back();
    }
    vapp_ucm_auto_redial_abort();
}

void VappUcmMainPage::onConfirmRedial(VfxObject *obj, VfxId id)
{
    setScrnLockTimer(VFX_TRUE);
    m_redialCmdPopup = NULL;

    if (VCP_POPUP_BUTTON_NO_PRESSED == id) return;

    m_redialType = VAPP_UCM_REDIAL_NONE;
    switch(id)
    {
        case VAPP_UCM_POST_ACT_CANCEL:
        {
            if (srv_ucm_query_group_count(SRV_UCM_CALL_STATE_ALL, (srv_ucm_call_type_enum)(SRV_UCM_VOICE_CALL_TYPE_ALL | SRV_UCM_VIDEO_CALL_TYPE), MMI_FALSE, NULL) == 0)
            {
                back();
            }
        }
        break;
    #ifdef __MMI_VIDEO_TELEPHONY__
    #if (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__))
        case VAPP_UCM_POST_ACT_SEND_SMS:
        {
            VappUcEntryStruct data;
            memset(&data, 0x00, sizeof(VappUcEntryStruct));
            data.info_type = (srv_uc_info_type_enum)SRV_UC_INFO_TYPE_SMS;
            data.operation = (vappUcMsgOperationEnum)UC_OPERATION_WRITE_NEW_MSG;
            data.type = (srv_uc_state_enum)SRV_UC_STATE_WRITE_NEW_MSG;
            data.msg_type = SRV_UC_MSG_TYPE_SMS_ONLY;

            srv_uc_addr_struct addr;
            memset(&addr, 0x00, sizeof(srv_uc_addr_struct));
            data.addr_num = 1;
            U8 ucs2_addr[(SRV_SMS_MAX_ADDR_LEN + 1) * ENCODING_LENGTH];
            U16 addr_len;
            addr_len = mmi_asc_n_to_ucs2((CHAR*)ucs2_addr, (CHAR*)m_numUri, SRV_SMS_MAX_ADDR_LEN);
            ucs2_addr[addr_len] = '\0';
            ucs2_addr[addr_len + 1] = '\0';
            addr.addr = (kal_uint8*) ucs2_addr;
            addr.type = SRV_UC_ADDRESS_TYPE_PHONE_NUMBER;
            addr.group = SRV_UC_ADDRESS_GROUP_TYPE_TO;
            data.addr = &addr;
            data.sim_id = SRV_UC_SIM_ID_GSM_SIM1;

            vapp_ucm_scr->enterUC(&data);
        }
    #endif // __MMI_VIDEO_TELEPHONY__
        break;
#endif /* (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__)) */

        case VAPP_UCM_POST_ACT_REDIAL:
    #ifdef __MMI_VIDEO_TELEPHONY__
        case VAPP_UCM_POST_ACT_REDIAL_VOICE:
    #endif // __MMI_VIDEO_TELEPHONY__
        {
            mmi_ucm_make_call_para_struct make_call_para;
            U16 num_uri[SRV_UCM_MAX_NUM_URI_LEN+1];
            memset(num_uri, 0, sizeof(num_uri));
            memset(&make_call_para, 0, sizeof(mmi_ucm_make_call_para_struct));
            mmi_asc_n_to_ucs2((CHAR*)num_uri, (CHAR*)g_ucm_p->mo_info.dial_num.num_uri, strlen((char*)g_ucm_p->mo_info.dial_num.num_uri));
            make_call_para.ucs2_num_uri = num_uri;
            make_call_para.adv_para.module_id = g_ucm_p->mo_info.module_id;
            make_call_para.adv_para.is_ip_dial = g_ucm_p->mo_info.is_ip_dial;
            make_call_para.adv_para.phb_data = g_ucm_p->mo_info.phb_data;
            make_call_para.adv_para.after_make_call_callback = vapp_ucm_hdlr_make_call_cb;
            if (VAPP_UCM_POST_ACT_REDIAL == id)
            {
                make_call_para.dial_type = g_ucm_p->mo_info.dial_type;
                mmi_ucm_call_launch(0, &make_call_para);
            }
            else if (srv_sim_ctrl_get_num_of_inserted() > 1)
            {
                mmi_id cuiId;
                cuiId = vcui_dialer_create(getApp()->getGroupId());
                vcui_dialer_set_dial_string(cuiId, VFX_WSTR_MEM(num_uri));
                vfxSetCuiCallerScr(cuiId, getMainScr());
                vcui_dialer_run(cuiId);
                back();
            }
            else
            {
                make_call_para.dial_type = SRV_UCM_VOICE_CALL_TYPE;
                mmi_ucm_call_launch(0, &make_call_para);
            }
        }
        break;
    }
}

void VappUcmMainPage::ShowRedialConfirm(VfxResId resId, VappUcmCallTypeEnum call_type)
{
    if (VAPP_UCM_CALL_TYPE_VOICE == call_type)
    {
        VFX_OBJ_CREATE(m_redialCmdPopup, VcpMoreCommandPopup, this);
        m_redialCmdPopup->addItem(VAPP_UCM_POST_ACT_REDIAL, STR_ID_VAPP_UCM_REDIAL, VCP_POPUP_BUTTON_TYPE_NORMAL);
        m_redialCmdPopup->addItem(VAPP_UCM_POST_ACT_CANCEL, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_CANCEL);
        m_redialCmdPopup->m_signalButtonClicked.connect(this, &VappUcmMainPage::onConfirmRedial);
        m_redialCmdPopup->show(VFX_TRUE);
    }
#ifdef __MMI_VIDEO_TELEPHONY__
    else if (VAPP_UCM_CALL_TYPE_VIDEO == call_type)
    {
        VFX_OBJ_CREATE(m_redialCmdPopup, VcpMoreCommandPopup, this);
        m_redialCmdPopup->addItem(VAPP_UCM_POST_ACT_REDIAL, STR_ID_VAPP_UCM_REDIAL_VIDEO_CALL, VCP_POPUP_BUTTON_TYPE_NORMAL);
        m_redialCmdPopup->addItem(VAPP_UCM_POST_ACT_REDIAL_VOICE, STR_ID_VAPP_UCM_REDIAL_VOICE_CALL, VCP_POPUP_BUTTON_TYPE_NORMAL);
        m_redialCmdPopup->addItem(VAPP_UCM_POST_ACT_SEND_SMS, STR_ID_VAPP_UCM_SEND_MSG, VCP_POPUP_BUTTON_TYPE_NORMAL);
        m_redialCmdPopup->addItem(VAPP_UCM_POST_ACT_CANCEL, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_CANCEL);
        m_redialCmdPopup->m_signalButtonClicked.connect(this, &VappUcmMainPage::onConfirmRedial);
        m_redialCmdPopup->show(VFX_TRUE);
    }
#endif // __MMI_VIDEO_TELEPHONY__
    else
    {
        return;
    }

    onScrnLock(VFX_FALSE);
    setScrnLockTimer(VFX_FALSE);
}

void VappUcmMainPage::CloseRedialConfirm()
{
    m_redialType = VAPP_UCM_REDIAL_NONE;
    VFX_OBJ_CLOSE(m_redialCmdPopup);
    VFX_OBJ_CLOSE(m_cnfPopup);
}

void VappUcmMainPage::refreshCallCells(VappUcmCallCellRefreshTypeEnum refresh_type, void* data)
{
    VfxS32 total_call_count = srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL);
    if (0 == total_call_count)
    {
        setScrnLockTimer(VFX_FALSE);
    }
    else
    {
        if (m_isScrnLocked)
        {
            m_activeCallCell->hideActionArea(VFX_TRUE);
        }
        else
        {
            setScrnLockTimer(VFX_TRUE);
        }
    }
    total_call_count = srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL);
    if (1 == total_call_count)
    {
        setScrnLockTimer(VFX_FALSE);

    }

    if (m_isScrnLocked)
    {
        VFX_ASSERT(m_scrnLock);
    #ifndef __MMI_UCM_SLIM__
		VfxBool hideCad = (1 != total_call_count);
        m_scrnLock->hideCard(VAPP_UCM_SCRN_UNLOCK_ACCEPT_CALL, hideCad);
        m_scrnLock->hideCard(VAPP_UCM_SCRN_UNLOCK_REJECT_CALL, hideCad);
    #endif // __MMI_UCM_SLIM__        
    }

    total_call_count = srv_ucm_query_call_count(SRV_UCM_OUTGOING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL);
    if (1 == total_call_count)
    {
        setScrnLockTimer(VFX_TRUE);
    }
    total_call_count = srv_ucm_query_group_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, MMI_FALSE, NULL);
    srv_ucm_ind_evt_struct *ind = (srv_ucm_ind_evt_struct*)data;
    if (VAPP_UCM_REFRESH_TYPE_IND == refresh_type && SRV_UCM_AUTO_REDIAL_IND == ind->ind_type)
    {
        srv_ucm_auto_redial_ind_struct *auto_redial_ind = (srv_ucm_auto_redial_ind_struct*)(ind->ptr);
		m_redialType = VAPP_UCM_REDIAL_AUTO;
        m_autoRedialTime = auto_redial_ind->time;
        if (0 == total_call_count)
        {
            return;
        }
    }

    if (VAPP_UCM_REFRESH_TYPE_IND == refresh_type && SRV_UCM_RELEASE_IND == ind->ind_type)
    {
        srv_ucm_release_ind_struct *release_ind = (srv_ucm_release_ind_struct*) ind->ptr;
        if (MMI_FALSE != release_ind->post_action.action)
        {
            m_redialType = VAPP_UCM_REDIAL_CONFIRM;
            g_ucm_p->mo_info.dial_type = release_ind->uid_info.call_type;
        }
        if (0 == total_call_count)
        {
            memcpy(m_numUri, release_ind->remote_info.num_uri, SRV_UCM_MAX_NUM_URI_LEN + 1);
        }
    }

    if (m_totalCallCells != total_call_count)
    {
        VFX_OBJ_CLOSE(m_effect1);
        VFX_OBJ_CLOSE(m_effect2);
        m_effect1Count = 0;
        m_effect2Count = 0;
    }

    if (m_floatTimeLine)
    {
        // during call end animation, don't refresh call cells
        return;
    }

    if (m_totalCallCells == total_call_count)
    {
        VfxBool maxConf = VFX_FALSE;
        for(VfxU32 idx = 0; idx < m_totalCallCells; ++idx)
        {
            if (VAPP_UCM_CALL_TYPE_VOICE == m_callCells[idx].call_type
                || VAPP_UCM_CALL_TYPE_DATA == m_callCells[idx].call_type
                || VAPP_UCM_CALL_TYPE_CSD == m_callCells[idx].call_type)
            {
                m_callCells[idx].ptrCallCell.voiceCallCell->onRefreshCell(refresh_type, data);
                maxConf |= (m_callCells[idx].ptrCallCell.voiceCallCell->getCallCount() >= SRV_UCM_MAX_CALL_IN_GROUP);
            }
        #ifdef __MMI_VIDEO_TELEPHONY__
            else if (VAPP_UCM_CALL_TYPE_VIDEO == m_callCells[idx].call_type)
            {
                m_callCells[idx].ptrCallCell.videoCallCell->onRefreshCell(refresh_type, data);
            }
        #endif // __MMI_VIDEO_TELEPHONY__
        }
        if (m_totalCallCells > 1 && maxConf)
        {
            // if there are 2 or 3 calls and the active call is not conference call
            m_activeCallCell->setActBtnDisable(VAPP_UCM_ACT_AREA_BTN_CONFERENCE, VFX_TRUE);
        }
        if (VAPP_UCM_REFRESH_TYPE_ACT == refresh_type)
        {
            srv_ucm_act_notify_evt_struct *act_notify = (srv_ucm_act_notify_evt_struct *)data;
            if (SRV_UCM_SWAP_ACT == act_notify->comp_act_op
                && SRV_UCM_RETRIEVE_ACT == act_notify->act_op
                && SRV_UCM_ACT_TYPE_COMPOUND_SECOND == act_notify->act_type
                && SRV_UCM_ACT_NOTIFY_TYPE_END == act_notify->notify_type)
            {
                // After Swapping, if the normal cell is not active state, we should swap reduced/normal cell
                if (SRV_UCM_HOLD_STATE == m_activeCallCell->getCallState())
                {
                    VfxU8 cellIdx = 0;
                    if (m_activeCallCell == m_callCells[0].ptrCallCell.voiceCallCell)
                    {
                        cellIdx = 1;
                    }
                    swapCallCells(m_callCells[cellIdx].ptrCallCell.voiceCallCell);
                }
            }
        }
		if (VAPP_UCM_REFRESH_TYPE_IND == refresh_type && SRV_UCM_CONNECT_IND == ind->ind_type)
		{
			if (1 == srv_ucm_query_call_count(SRV_UCM_ACTIVE_STATE, SRV_UCM_CSD_CALL_TYPE_ALL, NULL))
			{
				back();
				return;
			}
		}
    }
    else if (m_totalCallCells < total_call_count)
    {
        // new call
        VFX_OBJ_CLOSE(m_dialPad);
        vapp_ucm_scr->closePagesAboveMainPage();

        // if these is video call survive during the operation, the video call can't be destroyed
        for (VfxU32 ori_idx = 0; ori_idx < m_totalCallCells; ++ori_idx)
        {
            if (VAPP_UCM_CALL_TYPE_VOICE == m_callCells[ori_idx].call_type
                || VAPP_UCM_CALL_TYPE_DATA == m_callCells[ori_idx].call_type
                || VAPP_UCM_CALL_TYPE_CSD == m_callCells[ori_idx].call_type)
            {   // terminate all voice call cells
                VFX_OBJ_CLOSE(m_callCells[ori_idx].ptrCallCell.voiceCallCell);
                m_callCells[ori_idx].call_type = VAPP_UCM_CALL_TYPE_NONE;
            }
        #ifdef __MMI_VIDEO_TELEPHONY__
            else if (VAPP_UCM_CALL_TYPE_VIDEO == m_callCells[ori_idx].call_type)
            { 
                VfxS16 group_id = m_callCells[ori_idx].ptrCallCell.videoCallCell->getCallGroupId();
                VfxS32 group_idx = 0;
                if (srv_ucm_query_group_index_by_group_id(group_id, SRV_UCM_VIDEO_CALL_TYPE, &group_idx))
                {   // video still exist after some changes
                    //video_call_still_exist = VFX_TRUE;
                    m_callCells[group_idx].call_type = VAPP_UCM_CALL_TYPE_VIDEO;
                    m_callCells[group_idx].ptrCallCell.videoCallCell = m_callCells[ori_idx].ptrCallCell.videoCallCell;
                    m_callCells[group_idx].refresh_type = refresh_type;
                    m_callCells[group_idx].data = data;
					if (group_idx != ori_idx)
					{
						m_callCells[ori_idx].call_type = VAPP_UCM_CALL_TYPE_NONE;
						m_callCells[ori_idx].ptrCallCell.videoCallCell = NULL;
					}
                }
                else
                {   // the video call is terminated
                    VFX_OBJ_CLOSE(m_callCells[ori_idx].ptrCallCell.videoCallCell);
                    m_callCells[ori_idx].call_type = VAPP_UCM_CALL_TYPE_NONE;

                    // unreserve asm
                    mmi_frm_asm_property_struct property;
                    mmi_frm_asm_property_init(&property);
                    property.f_prepare_w_reserve = 0;
                    mmi_frm_asm_set_property(vapp_ucm_scr->getApp()->getGroupId(), &property);
                }
            }
        #endif // __MMI_VIDEO_TELEPHONY__
        }
        createCallCells();
    }
    else
    {
        // cell count reduces
        VFX_OBJ_CLOSE(m_dialPad);
        if (VAPP_UCM_REFRESH_TYPE_IND == refresh_type && data
            && SRV_UCM_RELEASE_IND == ((srv_ucm_ind_evt_struct*)data)->ind_type
            && ((srv_ucm_ind_evt_struct*)data)->ptr)
        {
            // for call end exit function, to stop tone
            g_ucm_p->call_end_tone_id = 
                ((srv_ucm_release_ind_struct*)((srv_ucm_ind_evt_struct*)data)->ptr)->call_end_tone_id;
            if (TONE_BUSY_CALL_GSM == g_ucm_p->call_end_tone_id)
            {
                srv_prof_play_tone_with_id(
                    SRV_PROF_TONE_GSM_BUSY, 
                    TONE_BUSY_CALL_GSM,
                    SRV_PROF_RING_TYPE_REPEAT,
                    NULL);
            }
            else if (0 != g_ucm_p->call_end_tone_id)
            {
                srv_prof_play_tone((srv_prof_tone_enum)g_ucm_p->call_end_tone_id, NULL);      
            }

            if (vapp_ucm_launch_screen_lock && 0 == total_call_count)
            {
                mmi_frm_start_scenario(MMI_SCENARIO_ID_HIGH_SCRN);
            }
        }

        VFX_OBJ_CREATE(m_floatTimeLine, VfxFloatTimeline, this);
        m_floatTimeLine->setTarget(this);
        m_floatTimeLine->setTargetPropertyId(VRT_FRAME_PROPERTY_ID_OPACITY);
        m_floatTimeLine->setStartTime(0);
        m_floatTimeLine->setFromValue(1.0f);
        m_floatTimeLine->setToValue(1.0f);
        m_floatTimeLine->setDuration(200);
        m_floatTimeLine->setTimingFunc(VFX_TIMING_FUNC_ID_EASE_OUT);
        m_floatTimeLine->m_signalStopped.connect(this, &VappUcmMainPage::afterReleaseAnimation);
        m_floatTimeLine->start();

        if (m_activeCallCell && m_activeCallCell->m_actionArea)
        {
            m_activeCallCell->m_actionArea->disableAllBtns(VAPP_UCM_DISABLE_ACT_BTN_ALL);
        }

        for (VfxU32 ori_idx = 0; ori_idx < m_totalCallCells; ++ori_idx)
        {
            VfxS16 group_id;
            VfxS32 group_idx;    

            if (VAPP_UCM_CALL_TYPE_VOICE == m_callCells[ori_idx].call_type
                || VAPP_UCM_CALL_TYPE_DATA == m_callCells[ori_idx].call_type
                || VAPP_UCM_CALL_TYPE_CSD == m_callCells[ori_idx].call_type)
            {
                if (VAPP_UCM_REFRESH_TYPE_ACT == refresh_type)
                {
                    srv_ucm_act_notify_evt_struct *act_notify = (srv_ucm_act_notify_evt_struct *) data;
                    if (SRV_UCM_ACT_TYPE_SINGLE == act_notify->act_type && SRV_UCM_CONFERENCE_ACT == act_notify->act_op)
                    {
                        break;
                    }
                }

                group_id = m_callCells[ori_idx].ptrCallCell.voiceCallCell->getCallGroupId();
                group_idx = 0;
                if (!srv_ucm_query_group_index_by_group_id(group_id, m_callCells[ori_idx].ptrCallCell.voiceCallCell->getCallType(), &group_idx))
                {
                #ifdef __IP_NUMBER__
					if (group_id == g_ucm_ip_num.group_id)
					{
						memset(&g_ucm_ip_num, 0, sizeof(mmi_ucm_ip_dial_struct));
					}
				#endif /*__IP_NUMBER__*/ 
					m_callCells[ori_idx].ptrCallCell.voiceCallCell->onCallRelease();
                }
            }
        #ifdef __MMI_VIDEO_TELEPHONY__
            else if (VAPP_UCM_CALL_TYPE_VIDEO == m_callCells[ori_idx].call_type)
            { 
                group_id = m_callCells[ori_idx].ptrCallCell.videoCallCell->getCallGroupId();
                group_idx = 0;
                if (!srv_ucm_query_group_index_by_group_id(group_id, SRV_UCM_VIDEO_CALL_TYPE, &group_idx))
                {
                    m_callCells[ori_idx].ptrCallCell.videoCallCell->onCallRelease();
                }
            }
        #endif // __MMI_VIDEO_TELEPHONY__
        }
    }
}

VappUcmVoiceCallCell* VappUcmMainPage::createVoiceCallCell(VfxS32 group_id, VfxS32 call_id, VappUcmCallCellTypeEnum cell_type)
{
    // Create call cell(s)
    VappUcmVoiceCallCell *voiceCallCell;
    VFX_OBJ_CREATE(voiceCallCell, VappUcmVoiceCallCell, this);
    srv_ucm_group_info_struct group_info;
    VfxS32 num_calls = srv_ucm_query_group_data(group_id, &group_info);
    // Set call-id of each call cell
    voiceCallCell->setCallId(group_id, call_id);
    // Set lock status if the call cell is in normal state
    voiceCallCell->setLocked(m_isScrnLocked);
    // Set cell type of each call cell
    voiceCallCell->setCellType(cell_type);
    voiceCallCell->setCallNumber((VfxU8)num_calls);
    voiceCallCell->setGroupInfo(&group_info);
    // Launch updateScreen for each call cell
    voiceCallCell->updateScreen();

    return voiceCallCell;
}

VfxMainScr* VappUcmMainPage::getUcmMainScr(void)
{
    return getMainScr();
}

#ifdef __MMI_VIDEO_TELEPHONY__
VappUcmVideoCallCell* VappUcmMainPage::createVideoCallCell(VfxS32 group_id, VfxS32 call_id, VappUcmCallCellTypeEnum cell_type)
{
    VappUcmVideoCallCell *videoCallCell;
    VFX_OBJ_CREATE(videoCallCell, VappUcmVideoCallCell, this);
    srv_ucm_group_info_struct group_info;
    VfxS32 num_calls = srv_ucm_query_group_data(group_id, &group_info);
    // Set call-id of each call cell
    videoCallCell->setCallId(group_id, call_id);
    // Set lock status if the call cell is in normal state
    videoCallCell->setLocked(m_isScrnLocked);
    // Set cell type of each call cell
    videoCallCell->setCellType(cell_type);
    videoCallCell->setGroupInfo(&group_info);
    // Launch updateScreen for each call cell
    videoCallCell->updateScreen();

    return videoCallCell;
}

void VappUcmMainPage::refreshVideoCallCell(VfxS32 group_id, VfxS32 call_id, VappUcmCallCellTypeEnum cell_type, VappUcmVideoCallCell *videoCallCell, VappUcmCallCellRefreshTypeEnum refresh_type, void* data)
{
    if (videoCallCell->getCellType() != cell_type)
    {
        // cell type change
        srv_ucm_group_info_struct group_info;
        srv_ucm_query_group_data(group_id, &group_info);
        
        videoCallCell->setCallId(group_id, call_id);
        videoCallCell->setLocked(m_isScrnLocked);
        videoCallCell->setCellType(cell_type);
        videoCallCell->setGroupInfo(&group_info);
        videoCallCell->updateScreen();
    }
    else
    {
        videoCallCell->onRefreshCell(refresh_type, data);
    }

}

void VappUcmMainPage::onHeadsetKey()
{
    for(VfxU32 idx = 0; idx < 3; ++idx)
    {
        if (VAPP_UCM_CALL_TYPE_VIDEO == m_callCells[idx].call_type)
        {
            if (SRV_UCM_INCOMING_STATE == m_callCells[idx].ptrCallCell.videoCallCell->getCallState())
            {
                m_callCells[idx].ptrCallCell.videoCallCell->onCallAccept();
                break;
            }
        }
    }
    // all other scenarios are handling in vapp_ucm_headset_key since headset key is still need to be handled even if ucm app is not alive
}

#ifdef __MMI_EM_PROFILING_VT_LOOKBACK__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif // __MMI_EM_PROFILING_VT_LOOKBACK__

#endif // __MMI_VIDEO_TELEPHONY__


void VappUcmMainPage::createScrnLockFrame()
{
#ifndef __MMI_UCM_SLIM__
    VFX_OBJ_CREATE(m_scrnLock, VappUcmScrnLockFrame, this);
    m_scrnLock->setSize(getSize());
    m_scrnLock->setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE, VFX_FRAME_ALIGNER_MODE_SIDE, 
            VFX_FRAME_ALIGNER_MODE_SIDE, VFX_FRAME_ALIGNER_MODE_SIDE);
    m_scrnLock->setPosZ(-1000.0f);
    m_scrnLock->layoutCards();

    m_scrnLock->m_signalScrnUnlock.connect(this, &VappUcmMainPage::onScrnUnlock);
    m_scrnLock->m_signalUnlocked.connect(this, &VappUcmMainPage::onUnlockFinished);
#else
    VFX_OBJ_CREATE(m_scrnLock, VappUcmScrnLockPanel, this);
    m_scrnLock->setAnchor(0.0f, 1.0f);
    m_scrnLock->setPos(0, 296);
    m_scrnLock->setPosZ(-1000.0f);
    m_scrnLock->m_signalScrnUnlock.connect(this, &VappUcmMainPage::onUnlockFinished);
#endif // __MMI_UCM_SLIM__
}

void VappUcmMainPage::setScrnLockTimer(VfxBool state)
{
    // general criteria to control scrn lock timer

    if (state)
    {
        if(m_activeCallCell && (VFX_FALSE == m_activeCallCell->isMorePopupShowing())
            && getId() == vapp_ucm_scr->getTopPageId() && (!m_dialPad || m_dialPad->getHidden())
            && !srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL)
        #ifdef __MMI_VIDEO_TELEPHONY__
            && !srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_VIDEO_CALL_TYPE, NULL)
        #endif // __MMI_VIDEO_TELEPHONY__
            )
        {
            m_scrnLockTimer->start();
        }
    }
    else
    {
        m_scrnLockTimer->stop();
    }

}

void VappUcmMainPage::onScrnLock(VfxBool locked)
{
#ifdef __MMI_EM_PROFILING_VT_LOOKBACK__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif // __MMI_EM_PROFILING_VT_LOOKBACK__

#ifdef __PXS_APP_ENABLE__
    return;
#else // __PXS_APP_ENABLE__
    if (!m_activeCallCell)
    {
        return;
    }

    if (locked)
    {
        if (!m_isScrnLocked)
        {
            m_isScrnLocked = VFX_TRUE;
            createScrnLockFrame();
            m_activeCallCell->hideActionArea(VFX_TRUE);
            if (m_dialPad)
            {
                m_dialPad->setHidden(VFX_TRUE);
            }
        }
        for (VfxU32 idx = 0; idx < m_totalCallCells; ++idx)
        {
            m_callCells[idx].ptrCallCell.voiceCallCell->setLocked(VFX_TRUE);
        }
    }
    else
    {
        if (m_isScrnLocked)
        {
            m_isScrnLocked = VFX_FALSE;
            VFX_OBJ_CLOSE(m_scrnLock);
            m_activeCallCell->hideActionArea(VFX_FALSE);
            setScrnLockTimer(VFX_TRUE);
            if (m_dialPad)
            {
                m_dialPad->setHidden(VFX_FALSE);
            }
        }
        else
        {
            setScrnLockTimer(VFX_FALSE);
        }
        for (VfxU32 idx = 0; idx < m_totalCallCells; ++idx)
        {
            m_callCells[idx].ptrCallCell.voiceCallCell->setLocked(VFX_FALSE);
        }
    }
#endif // __PXS_APP_ENABLE__
}

void VappUcmMainPage::onScrnUnlock(VappUcmCallCellScrnUnlockTypeEnum unlock_type)
{
#ifdef __PXS_APP_ENABLE__
    return;
#else // __PXS_APP_ENABLE__
#ifndef __MMI_UCM_SLIM__
    if (VAPP_UCM_SCRN_UNLOCK_ACCEPT_CALL == unlock_type)
    {
        if (srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL) == 1)
        {
            //vapp_ucm_incoming_call_sendkey();
            VappUcmVoiceCallCell *call_cell = (VappUcmVoiceCallCell*)m_activeCallCell;
            call_cell->onActionAreaClicked(VAPP_UCM_ACT_AREA_BTN_ACCEPT_CALL, VAPP_UCM_ACTBTN_STATE_NONE);
        }
    }
    else if (VAPP_UCM_SCRN_UNLOCK_REJECT_CALL == unlock_type)
    {
        if (srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL) == 1)
        {
            vapp_ucm_incoming_call_endkey();
        }
        else if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) > 0)
        {
            vapp_ucm_endkey_hdlr();
        }
    }
#endif // __MMI_UCM_SLIM__
    m_activeCallCell->hideActionArea(VFX_FALSE);
    if (m_dialPad)
    {
        m_dialPad->setHidden(VFX_FALSE);
    }
    for(VfxU32 idx = 0; idx < m_totalCallCells; ++idx)
    {
        m_callCells[idx].ptrCallCell.voiceCallCell->setLocked(VFX_FALSE);
    }
#endif // __PXS_APP_ENABLE__
}

void VappUcmMainPage::onScrnLockTimerExpiry(VfxTimer *timer)
{
    if (m_penDown) return;
    onScrnLock(VFX_TRUE);
    setScrnLockTimer(VFX_FALSE);
}

#ifdef __MMI_UCM_SLIM__
void VappUcmMainPage::onUnlockFinished(VfxObject *panel)
#else
void VappUcmMainPage::onUnlockFinished(VappScreenLockFrame *frame)
#endif // __MMI_UCM_SLIM__
{
    m_isScrnLocked = VFX_FALSE;
    VFX_OBJ_CLOSE(m_scrnLock);
    setScrnLockTimer(VFX_TRUE);
#ifdef __MMI_UCM_SLIM__
    onScrnUnlock(VAPP_UCM_SCRN_UNLOCK_ONLY);
#endif // __MMI_UCM_SLIM__
}

void VappUcmMainPage::onControlScrnLocKTimer(VappUcmScrnLockTimerEnum type)
{
    switch (type)
    {
        case VAPP_UCM_TIMER_START:
            setScrnLockTimer(VFX_TRUE);
            break;
        case VAPP_UCM_TIMER_STOP:
            setScrnLockTimer(VFX_FALSE);
            break;
        case VAPP_UCM_TIMER_RESET:
            if (m_scrnLockTimer->getIsEnabled())
            {
               setScrnLockTimer(VFX_TRUE);
            }
            break;
        default:
            VFX_ASSERT(0);
            break;
    }
}

VfxBool VappUcmMainPage::onPreviewPenInput(VfxPenEvent &event)
{
    if (VFX_PEN_EVENT_TYPE_DOWN == event.type)
    {
        m_penDown = VFX_TRUE;
    }
    else if (VFX_PEN_EVENT_TYPE_UP == event.type)
    {
        m_penDown = VFX_FALSE;
        if (!m_isScrnLocked)
        {
            setScrnLockTimer(VFX_TRUE);
        }
    }
    return VfxPage::onPreviewPenInput(event);
}

VfxBool VappUcmMainPage::onKeyInput(VfxKeyEvent & event)
{
#ifdef __MMI_EM_PROFILING_VT_LOOKBACK__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif // __MMI_EM_PROFILING_VT_LOOKBACK__

    // BACK / HOME
    if(!srv_bootup_is_completed() || m_disableBacknHomeKey
        || srv_ucm_is_outgoing_call()
        || srv_ucm_is_incoming_call()
        || isScreenLocked()
    #ifdef __MMI_VIDEO_TELEPHONY__
        || (srv_ucm_query_call_count((srv_ucm_call_state_enum)SRV_UCM_CALL_STATE_ALL, SRV_UCM_VIDEO_CALL_TYPE, NULL))>0
    #endif // __MMI_VIDEO_TELEPHONY__
        )
    {
    	if ((event.type == VFX_KEY_EVENT_TYPE_DOWN && event.keyCode == VFX_KEY_CODE_BACK) ||
            (event.type == VFX_KEY_EVENT_TYPE_DOWN && event.keyCode == VFX_KEY_CODE_HOME) )
    	{
    		return VFX_TRUE;
    	}
    }

    // SEND
    if (event.type == VFX_KEY_EVENT_TYPE_DOWN && event.keyCode == VFX_KEY_CODE_SEND)
    {
        if (m_dialPad && m_dialPad->getHidden() == VFX_FALSE && m_dialPad->isEmpty() == VFX_FALSE)
        {
            VFX_ASSERT(NULL != m_activeCallCell);
            mmi_ucm_make_call_para_struct make_call_para;
            mmi_ucm_init_call_para(&make_call_para);
            make_call_para.dial_type = m_activeCallCell->getCallType();
            make_call_para.ucs2_num_uri = (U16*)m_dialPad->getDialBuff();
            mmi_ucm_call_launch(0, &make_call_para);
        }
        else
        {
            if (srv_ucm_is_incoming_call())
            {
                for(VfxU32 idx = 0; idx < 3; ++idx)
                {
                    if (VAPP_UCM_CALL_TYPE_VOICE == m_callCells[idx].call_type
                        || VAPP_UCM_CALL_TYPE_CSD == m_callCells[idx].call_type
                        || VAPP_UCM_CALL_TYPE_DATA == m_callCells[idx].call_type)
                    {
                        if (m_callCells[idx].ptrCallCell.voiceCallCell->getCallState() == SRV_UCM_INCOMING_STATE)
                        {
                            m_callCells[idx].ptrCallCell.voiceCallCell->onActionAreaClicked(VAPP_UCM_ACT_AREA_BTN_ACCEPT_CALL, VAPP_UCM_ACTBTN_STATE_NONE);
                            break;
                        }
                    }
                #ifdef __MMI_VIDEO_TELEPHONY__
                    else if (m_callCells[idx].call_type == VAPP_UCM_CALL_TYPE_VIDEO)
                    {
                        if (m_callCells[idx].ptrCallCell.videoCallCell->getCallState() == SRV_UCM_INCOMING_STATE)
                        {
                            m_callCells[idx].ptrCallCell.videoCallCell->onCallAccept();
                            break;
                        }
                    }
                #endif // __MMI_VIDEO_TELEPHONY__
                }
            }
        }
    }

    // other keys
    switch (event.keyCode)
    {
        case VFX_KEY_CODE_0:
        case VFX_KEY_CODE_1:
        case VFX_KEY_CODE_2:
        case VFX_KEY_CODE_3:
        case VFX_KEY_CODE_4:
        case VFX_KEY_CODE_5:
        case VFX_KEY_CODE_6:
        case VFX_KEY_CODE_7:
        case VFX_KEY_CODE_8:
        case VFX_KEY_CODE_9:
        case VFX_KEY_CODE_STAR:
        case VFX_KEY_CODE_POUND:
        {
            if (!isScreenLocked() && m_activeCallCell && !m_dialPad)
            {
                onShowDialPad(VFX_TRUE);
                m_activeCallCell->m_actionArea->m_actionButtonGroup->setBtnSwitchOn(
                    m_activeCallCell->m_actionArea->m_actionButtonGroup->getBtnIndex(VAPP_UCM_ACT_AREA_BTN_KEYPAD),
                    VFX_TRUE);

                return m_dialPad->onKeyInput(event);
            }
        }
    }

    return VfxPage::onKeyInput(event);
}

void VappUcmMainPage::disableBacknHomeKey(VfxBool disable)
{
    m_disableBacknHomeKey = disable;
}

VFX_IMPLEMENT_CLASS("VappUcmActionButton", VappUcmActionButton, VcpButton);
void VappUcmActionButton::onInit()
{
    VcpButton::onInit();
    
    m_switchable = VFX_FALSE;
    m_switch = VFX_FALSE;
    m_switchBar = NULL;
    m_animateTimer = NULL;

    this->setPlacement(VCP_BUTTON_PLACEMENT_IMAGE_TOP);
    this->setTextFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_ACT_BTN_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
    this->setTextColor(VFX_COLOR_WHITE);
    setMargin(8, VAPP_UCM_ACT_BTN_TOP_MARGIN, 10, VAPP_UCM_ACT_BTN_BOTTOM_MARGIN);
    VFX_OBJ_CREATE(m_switchBar, VfxFrame, this);
    m_switchBar->setImgContent(VfxImageSrc(IMG_ID_VAPP_UCM_ICON_HOR_BAR_DISABLE));
    m_switchBar->setHidden(VFX_TRUE);
    m_signalClicked.connect(this, &VappUcmActionButton::onButtonClick);
}

void VappUcmActionButton::onDeinit()
{
    VFX_OBJ_CLOSE(m_switchBar);
    VcpButton::onDeinit();
}

void VappUcmActionButton::onButtonClick(VfxObject* obj, VfxId id)
{
    if (m_switchable)
    {
        m_switch = !m_switch;
    }
    //TBD: Change the image of switch.
    setSwitchOn(m_switch);
    m_signalBtnClicked.emit(this, id, m_switch);
}

void VappUcmActionButton::setSwitchable(VfxBool enable)
{
    m_switchable = enable;
    m_switchBar->setSize(this->getSize().width - 10, VAPP_UCM_ACT_BTN_SWITCH_BAR_HEIGHT);
    m_switchBar->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    m_switchBar->setAnchor(0.5f, 1.0f);
    m_switchBar->setPos(this->getSize().width >> 1, this->getSize().height - VAPP_UCM_ACT_BTN_SWITCH_BAR_POS_Y_END);
    if (m_switchable)
    {
        m_switchBar->setHidden(VFX_FALSE);
        setMargin(6 + 5, VAPP_UCM_ACT_BTN_TOP_MARGIN_WITH_SWITCH_BAR, 7 + 5, VAPP_UCM_ACT_BTN_BOTTOM_MARGIN_WITH_SWITCH_BAR);
    }
    else
    {
        m_switchBar->setHidden(VFX_TRUE);
    }
}

VfxBool VappUcmActionButton::getSwitchAble(void)
{
    return m_switchable;
}

void VappUcmActionButton::setBtnPos(VappUcmActionButtonPosEnum pos)
{
    VfxResId normalId  = MMI_RP_VAPP_UCM_IMG_MAX;
	VfxResId pressedId = MMI_RP_VAPP_UCM_IMG_MAX;
    switch (pos)
    {
        case VAPP_UCM_ACTBTN_POS_LEFT_TOP:
        {
            normalId = IMG_ID_VAPP_UCM_BTN_LEFTUP_N;
            pressedId = IMG_ID_VAPP_UCM_BTN_LEFTUP_P;
            break;
        }
        case VAPP_UCM_ACTBTN_POS_CENTER_TOP:
        {
            normalId = IMG_ID_VAPP_UCM_BTN_MIDDLEUP_N;
            pressedId = IMG_ID_VAPP_UCM_BTN_MIDDLEUP_P;
            break;
        }
        case VAPP_UCM_ACTBTN_POS_RIGHT_TOP:
        {
            normalId = IMG_ID_VAPP_UCM_BTN_RIGHTUP_N;
            pressedId = IMG_ID_VAPP_UCM_BTN_RIGHTUP_P;
            break;
        }
        case VAPP_UCM_ACTBTN_POS_LEFT_BOTTOM:
        {
            normalId = IMG_ID_VAPP_UCM_BTN_LEFTDOWN_N;
            pressedId = IMG_ID_VAPP_UCM_BTN_LEFTDOWN_P;
            break;
        }
        case VAPP_UCM_ACTBTN_POS_CENTER_BOTTOM:
        {
            normalId = IMG_ID_VAPP_UCM_BTN_MIDDLEDOWN_N;
            pressedId = IMG_ID_VAPP_UCM_BTN_MIDDLEDOWN_P;
            break;
        }
        case VAPP_UCM_ACTBTN_POS_RIGHT_BOTTOM:
        {
            normalId = IMG_ID_VAPP_UCM_BTN_RIGHTDOWN_N;
            pressedId = IMG_ID_VAPP_UCM_BTN_RIGHTDOWN_P;
            break;
        }
        case VAPP_UCM_ACTBTN_POS_LEFT:
        {
            normalId = IMG_ID_VAPP_UCM_BTN_LEFT_N;
            pressedId = IMG_ID_VAPP_UCM_BTN_LEFT_P;
            break;
        }
        case VAPP_UCM_ACTBTN_POS_CENTER:
        {
            normalId = IMG_ID_VAPP_UCM_BTN_MIDDLE_N;
            pressedId = IMG_ID_VAPP_UCM_BTN_MIDDLE_P;
            break;
        }
        case VAPP_UCM_ACTBTN_POS_RIGHT:
        {
            normalId = IMG_ID_VAPP_UCM_BTN_RIGHT_N;
            pressedId = IMG_ID_VAPP_UCM_BTN_RIGHT_P;
            break;
        }
        default:
            VFX_ASSERT(0);
            break;
    }
    setBgImageList(VcpStateImage(normalId, pressedId, 0, 0));
    //TBD: Set related bg image.
}

void VappUcmActionButton::setSwitchOn(VfxBool switch_on)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMS", SA_start);
#endif
    VfxResId imgId = IMG_ID_VAPP_UCM_ICON_HOR_BAR_DISABLE;
    if (switch_on)
    {
        imgId = IMG_ID_VAPP_UCM_ICON_HOR_BAR_ENABLE;
    }
    m_switchBar->setImgContent(VfxImageSrc(imgId));
    m_switch = switch_on;
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMS", SA_stop);
#endif
}

void VappUcmActionButton::onAnimateTimerTicked(VfxTimer *timer)
{
    setSwitchOn(!m_switch);
}

void VappUcmActionButton::startAnimation(VfxBool start)
{
    if (start)
    {
        if (!m_animateTimer)
        {
            VFX_OBJ_CREATE(m_animateTimer, VfxTimer, this);
        }
        m_animateTimer->setDuration(300);
        m_animateTimer->m_signalTick.connect(this, &VappUcmActionButton::onAnimateTimerTicked);
        m_animateTimer->start();
    }
    else
    {
        if (m_animateTimer)
        {
            m_animateTimer->stop();
            VFX_OBJ_CLOSE(m_animateTimer);
        }
    }
    setAutoAnimate(start);
}

VFX_IMPLEMENT_CLASS("VappUcmActionButtonGroup", VappUcmActionButtonGroup, VfxFrame);

void VappUcmActionButtonGroup::onInit()
{
    VfxFrame::onInit();

    m_btnNum = 0;
    for (VfxU32 idx = 0; idx < VAPP_UCM_BTNGRP_MAX_BTN; ++idx)
    {
        m_btns[idx] = NULL;
    }
}

void VappUcmActionButtonGroup::setType(VappUcmActionButtonGroupEnum type)
{
    switch (type)
    {
        case VAPP_UCM_ACTBTN_GRP_2_BTN:
        case VAPP_UCM_ACTBTN_GRP_3_BTN:
        case VAPP_UCM_ACTBTN_GRP_4_BTN:
        {
            m_btnNum = 2 + (type - VAPP_UCM_ACTBTN_GRP_2_BTN);
            for (VfxU32 idx = 0 ; idx < m_btnNum; ++idx)
            {
                if (m_btns[idx] == NULL)
                {
                    VFX_OBJ_CREATE(m_btns[idx], VappUcmActionButton, this);
                }
                m_btns[idx]->setId((VfxId)idx);
                m_btns[idx]->m_signalBtnClicked.connect(this, &VappUcmActionButtonGroup::onActBtnClicked);
                VappUcmActionButtonPosEnum btnPos;
                if (0 == idx)
                {
                    btnPos = VAPP_UCM_ACTBTN_POS_LEFT;
                }
                else if (m_btnNum - 1 == idx)
                {
                    btnPos = VAPP_UCM_ACTBTN_POS_RIGHT;
                }
                else
                {
                    btnPos = VAPP_UCM_ACTBTN_POS_CENTER;
                }
                setBtnPos(idx, btnPos);
            }
            setSize(VAPP_UCM_ACT_BTN_GRP_WIDTH, VAPP_UCM_ACT_BTN_GRP_HEIGHT1);
            break;
        }
        case VAPP_UCM_ACTBTN_GRP_6_BTN:
        {
            m_btnNum = 6;
            for (VfxU32 idx = 0 ; idx < m_btnNum; ++idx)
            {
                if (m_btns[idx] == NULL)
                {
                    VFX_OBJ_CREATE(m_btns[idx], VappUcmActionButton, this);
                }
                m_btns[idx]->setId((VfxId)idx);
                m_btns[idx]->m_signalBtnClicked.connect(this, &VappUcmActionButtonGroup::onActBtnClicked);
                m_btns[idx]->setBtnPos((VappUcmActionButtonPosEnum)(idx + VAPP_UCM_ACTBTN_POS_LEFT_TOP));
            }
            setSize(VAPP_UCM_ACT_BTN_GRP_WIDTH, VAPP_UCM_ACT_BTN_GRP_HEIGHT2);
            break;
        }
        case VAPP_UCM_ACTBTN_GRP_8_BTN:
        {
            m_btnNum = 8;
            VfxS32 step;
            for (VfxU32 idx = 0 ; idx < m_btnNum; ++idx)
            {
                if (m_btns[idx] == NULL)
                {
                    VFX_OBJ_CREATE(m_btns[idx], VappUcmActionButton, this);
                }
                m_btns[idx]->setId((VfxId)idx);
                m_btns[idx]->m_signalBtnClicked.connect(this, &VappUcmActionButtonGroup::onActBtnClicked);
                step = idx;
                if (step >= 2) --step;
                if (step >= 5) --step;
                m_btns[idx]->setBtnPos((VappUcmActionButtonPosEnum)(VAPP_UCM_ACTBTN_POS_LEFT_TOP + step));
            }
            setSize(VAPP_UCM_ACT_BTN_GRP_WIDTH, VAPP_UCM_ACT_BTN_GRP_HEIGHT2);
            break;
        }
        default:
            break;
    }
    relayoutBtns();
}
VfxBool VappUcmActionButtonGroup::setBtnIcon(VfxU8 btnIdx, const VcpStateImage &imageList)
{
    if (btnIdx >= m_btnNum)
    {
        //TBD: ADD TRACE
        return VFX_FALSE;
    }
    m_btns[btnIdx]->setImage(imageList);
    return VFX_TRUE;
}
VfxBool VappUcmActionButtonGroup::setBtnLabel(VfxU8 btnIdx, VfxResId resId)
{
    if (btnIdx >= m_btnNum)
    {
        //TBD: ADD TRACE
        return VFX_FALSE;
    }
    m_btns[btnIdx]->setText(resId);
    return VFX_TRUE;
}
VfxBool VappUcmActionButtonGroup::setBtnDisable(VfxU8 btnIdx, VfxBool disable)
{
    if (btnIdx >= m_btnNum)
    {
        //TBD: ADD TRACE
        return VFX_FALSE;
    }

    m_btns[btnIdx]->setTextColor(0xF0FFFFFF);
    m_btns[btnIdx]->setIsDisabled(disable);
    return VFX_TRUE;
}
VfxBool VappUcmActionButtonGroup::setBtnSwitchable(VfxU8 btnIdx, VfxBool switchable)
{
    if (btnIdx >= m_btnNum)
    {
        //TBD: ADD TRACE
        return VFX_FALSE;
    }
    m_btns[btnIdx]->setSwitchable(switchable);
    return VFX_TRUE;
}
VfxBool VappUcmActionButtonGroup::getBtnSwitchable(VfxU8 btnIdx)
{
    if (btnIdx >= m_btnNum)
    {
        //TBD: ADD TRACE
        return VFX_FALSE;
    }
    return m_btns[btnIdx]->getSwitchAble();
}

VfxBool VappUcmActionButtonGroup::setBtnId(VfxU8 btnIdx, VfxId btnId)
{
    if (btnIdx >= m_btnNum)
    {
        //TBD: ADD TRACE
        return VFX_FALSE;
    }
    m_btns[btnIdx]->setId(btnId);
    return VFX_TRUE;
}

VfxU8 VappUcmActionButtonGroup::getBtnIndex(VfxId btnId)
{
    for (VfxU32 idx = 0; idx < m_btnNum; ++idx)
    {
        if (m_btns[idx]->getId() == btnId)
        {
            return idx;
        }
    }
    return VAPP_UCM_BTNGRP_MAX_BTN;
}

VfxBool VappUcmActionButtonGroup::setBtnSwitchOn(VfxU8 btnIdx, VfxBool switch_on)
{
    if (btnIdx >= m_btnNum)
    {
        //TBD: ADD TRACE
        return VFX_FALSE;
    }
    m_btns[btnIdx]->setSwitchOn(switch_on);
    return VFX_TRUE;
}
void VappUcmActionButtonGroup::setBtnPos(VfxU8 btnIdx, VappUcmActionButtonPosEnum pos)
{
    if (btnIdx >= m_btnNum)
    {
        //TBD: ADD TRACE
        return;
    }
    m_btns[btnIdx]->setBtnPos(pos);
}
void VappUcmActionButtonGroup::onActBtnClicked(VfxObject* obj, VfxId id, VfxBool value)
{
    m_signalActBtnClicked.emit(obj, id, value);
}

void VappUcmActionButtonGroup::setPos(VfxS32 x, VfxS32 y)
{
    VfxFrame::setPos(x,y);
    m_pos.x = x;
    m_pos.y = y;
}

void VappUcmActionButtonGroup::setSize(VfxS32 width, VfxS32 height)
{
    VfxFrame::setSize(width, height);
    m_size.width = width;
    m_size.height = height;
    relayoutBtns();
}

void VappUcmActionButtonGroup::relayoutBtns()
{
    if (0 == m_size.width || 0 == m_size.height || 0 == m_btnNum)
    {
        return;
    }

    if (m_btnNum > 4)
    {
        // Two Rows
        VfxU16 btnWidth = m_size.width / (m_btnNum >> 1);
        //VfxU16 btnHeight = m_size.height>>1;

        for (VfxU32 idx = 0; idx < m_btnNum; ++idx)
        {
            if (idx < (m_btnNum >> 1))
            {
                m_btns[idx]->setPos(btnWidth * idx, 0);
                m_btns[idx]->setSize(btnWidth, (VAPP_UCM_ACT_BTN_GRP_HEIGHT2 - VAPP_UCM_ACT_BTN_GRP_HEIGHT1));
            }
            else
            {
                m_btns[idx]->setPos(btnWidth * (idx - (m_btnNum >> 1)), VAPP_UCM_ACT_BTN_GRP_HEIGHT2 - VAPP_UCM_ACT_BTN_GRP_HEIGHT1);
                m_btns[idx]->setSize(btnWidth, VAPP_UCM_ACT_BTN_GRP_HEIGHT1);
            }
        }
    }
    else
    {
        // Single Row
        VfxU16 btnWidth = m_size.width / m_btnNum;

        for (VfxU32 idx = 0; idx < m_btnNum; ++idx)
        {
            m_btns[idx]->setSize(btnWidth, VAPP_UCM_ACT_BTN_GRP_HEIGHT1);
            m_btns[idx]->setPos(btnWidth * idx, 0);
        }
    }
}

void VappUcmActionButtonGroup::disableAllBtns(VfxBool disable)
{
    for (VfxU32 idx = 0; idx < m_btnNum; ++idx)
    {
        m_btns[idx]->setIsDisabled(disable);
    }
}

void VappUcmActionButtonGroup::setBtnStartAnimate(VfxU8 btnIdx, VfxBool startAnimate)
{
    if (btnIdx >= m_btnNum)
    {
        //TBD: ADD TRACE
        return;
    }
    m_btns[btnIdx]->startAnimation(startAnimate);
}


VFX_IMPLEMENT_CLASS("VappUcmActionArea", VappUcmActionArea, VfxFrame);

void VappUcmActionArea::onInit()
{
    VfxFrame::onInit();
    m_acceptCall = NULL;
    m_rejectCall = NULL;
    m_endCall = NULL;
    m_actionButtonGroup = NULL;
    setSize(VAPP_UCM_ACT_AREA_WIDTH, VAPP_UCM_ACT_AREA_HEIGHT);
    
    VFX_OBJ_CREATE(m_actionButtonGroup, VappUcmActionButtonGroup, this);

    m_actionButtonGroup->setAnchor(0.0f, 1.0f);
    m_actionButtonGroup->setPos(VAPP_UCM_ACT_BTN_GRP_X, VAPP_UCM_ACT_BTN_GRP_HEIGHT2);
    m_actionButtonGroup->m_signalActBtnClicked.connect(this, &VappUcmActionArea::onActionButtonClick);   
}

void VappUcmActionArea::setAreaType(VappUcmActionAreaTypeEnum type)
{
    switch (type)
    {
        case VAPP_UCM_AREA_INCOMING:
        {
            if (!m_acceptCall)
            {
                VFX_OBJ_CREATE(m_acceptCall, VcpButton, this);
            }
            m_acceptCall->setBgImageList(VcpStateImage(IMG_ID_VAPP_UCM_BTN_ACCEPT_N, IMG_ID_VAPP_UCM_BTN_ACCEPT_P, 0, 0));
            m_acceptCall->setText(STR_ID_VAPP_UCM_ACCEPT);
            m_acceptCall->setTextColor(VFX_COLOR_WHITE);
            m_acceptCall->setImage(VcpStateImage(IMG_ID_VAPP_UCM_ICON_ACCEPT, IMG_ID_VAPP_UCM_ICON_ACCEPT, IMG_ID_VAPP_UCM_ICON_ACCEPT, IMG_ID_VAPP_UCM_ICON_ACCEPT));
            m_acceptCall->setTextFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_CALL_BTN_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
            m_acceptCall->setAnchor(0.0f, 1.0f);
            m_acceptCall->setPos(VAPP_UCM_TWO_BTN_X, getSize().height - VAPP_UCM_BTN_BUTTOM_GAP);
            m_acceptCall->setSize(VAPP_UCM_TWO_BTN_WIDTH, VAPP_UCM_BTN_HEIGHT);
            m_acceptCall->setId((VfxId)VAPP_UCM_ACT_AREA_BTN_ACCEPT_CALL);
            m_acceptCall->m_signalClicked.connect(this, &VappUcmActionArea::onButtonClick);
            m_acceptCall->setPlacement(VCP_BUTTON_PLACEMENT_IMAGE_TEXT_CENTER);
            if (!m_rejectCall)
            {
                VFX_OBJ_CREATE(m_rejectCall, VcpButton, this);
            }
            m_rejectCall->setBgImageList(VcpStateImage(IMG_ID_VAPP_UCM_BTN_REJECT_N, IMG_ID_VAPP_UCM_BTN_REJECT_P, 0, 0));
            m_rejectCall->setText(STR_ID_VAPP_UCM_REJECT);
            m_rejectCall->setTextColor(VFX_COLOR_WHITE);
            m_rejectCall->setTextFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_CALL_BTN_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
            m_rejectCall->setImage(VcpStateImage(IMG_ID_VAPP_UCM_ICON_REJECT, IMG_ID_VAPP_UCM_ICON_REJECT, IMG_ID_VAPP_UCM_ICON_REJECT ,IMG_ID_VAPP_UCM_ICON_REJECT));
            m_rejectCall->setAnchor(0.0f, 1.0f);
            m_rejectCall->setPos(VAPP_UCM_TWO_BTN_X + VAPP_UCM_TWO_BTN_WIDTH + VAPP_UCM_TWO_BTN_GAP, getSize().height-VAPP_UCM_BTN_BUTTOM_GAP);
            m_rejectCall->setSize(VAPP_UCM_TWO_BTN_WIDTH, VAPP_UCM_BTN_HEIGHT);
            m_rejectCall->setId((VfxId)VAPP_UCM_ACT_AREA_BTN_REJECT_CALL);
            m_rejectCall->m_signalClicked.connect(this, &VappUcmActionArea::onButtonClick);
            m_rejectCall->setPlacement(VCP_BUTTON_PLACEMENT_IMAGE_TEXT_CENTER);
            break;
        }
        case VAPP_UCM_AREA_OUTGOING:
        case VAPP_UCM_AREA_NORMAL:
        {
            if (!m_endCall)
            {
                VFX_OBJ_CREATE(m_endCall, VcpButton, this);
            }
            m_endCall->setText(STR_ID_VAPP_UCM_END_CALL);
            m_endCall->setTextColor(VFX_COLOR_WHITE);
            m_endCall->setBgImageList(VcpStateImage(IMG_ID_VAPP_UCM_BTN_REJECT_N, IMG_ID_VAPP_UCM_BTN_REJECT_P, 0, 0));
            m_endCall->setAnchor(0.0f, 1.0f);
            m_endCall->setPos(VAPP_UCM_ONE_BTN_X, getSize().height - VAPP_UCM_BTN_BUTTOM_GAP);
            m_endCall->setTextFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_CALL_BTN_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
            m_endCall->setImage(VcpStateImage(IMG_ID_VAPP_UCM_ICON_REJECT, IMG_ID_VAPP_UCM_ICON_REJECT, IMG_ID_VAPP_UCM_ICON_REJECT ,IMG_ID_VAPP_UCM_ICON_REJECT));
            m_endCall->setSize(VAPP_UCM_ONE_BTN_WIDTH, VAPP_UCM_BTN_HEIGHT);
            m_endCall->setId((VfxId)VAPP_UCM_ACT_AREA_BTN_END_CALL);
            m_endCall->m_signalClicked.connect(this, &VappUcmActionArea::onButtonClick);
            m_endCall->setPlacement(VCP_BUTTON_PLACEMENT_IMAGE_TEXT_CENTER);
            break;
        }
        default:
            break;
            //TBD: ADD TRACE
    }
}

void VappUcmActionArea::onActionButtonClick(VfxObject* obj, VfxId id, VfxBool value)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CAB", SA_start);
#endif
    VappUcmActionBtnStateEnum btn_state = VAPP_UCM_ACTBTN_STATE_NONE;
    VappUcmActionButton *btn = (VappUcmActionButton*)obj;
    if (btn->getSwitchAble())
    {
        if (value)
        {
            btn_state = VAPP_UCM_ACTBTN_STATE_ON;
        }
    }
    m_signalActions.emit(id, btn_state);
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CAB", SA_stop);
#endif
}

void VappUcmActionArea::onButtonClick(VfxObject* obj, VfxId id)
{
    m_signalActions.emit(id, VAPP_UCM_ACTBTN_STATE_NONE);
}

void VappUcmActionArea::disableAllBtns(VappUcmDisableActBtnTypeEnum type)
{
    VfxBool disable = VFX_TRUE;
    if (VAPP_UCM_DISABLE_ACT_BTN_NONE == type)
    {
        disable = VFX_FALSE;
    }
    setAutoAnimate(VFX_TRUE);
    if (m_acceptCall)
    {
        m_acceptCall->setIsDisabled(disable);
    }
    if (VAPP_UCM_DISABLE_ACT_BTN_ALL_EXCEPT_END_KEY != type)
    {
        if (m_endCall)
        {
            m_endCall->setIsDisabled(disable);
        }
        if (m_rejectCall)
        {
            m_rejectCall->setIsDisabled(disable);
        }
    }
    m_actionButtonGroup->disableAllBtns(disable);
}

VFX_IMPLEMENT_CLASS("VappUcmConfCallerPic", VappUcmConfCallerPic, VfxControl);
void VappUcmConfCallerPic::onInit()
{
    VcpPhotoBorderFrame::onInit();
    m_penDown = VFX_FALSE;
}

void VappUcmConfCallerPic::setMixedCaller()
{
    m_callIdx = -1;
}

void VappUcmConfCallerPic::setCallIdx(VfxS32 group_id, VfxS32 call_id)
{
    m_groupIdx = group_id;
    m_callIdx = call_id;
}

VfxBool VappUcmConfCallerPic::onPenInput(VfxPenEvent &event)
{
    if (VFX_PEN_EVENT_TYPE_DOWN == event.type)
    {
        m_penDown = VFX_TRUE;
    }
    else if (VFX_PEN_EVENT_TYPE_UP == event.type)
    {
        if (VFX_FALSE == m_penDown)
        {
            return VFX_TRUE;
        }
        else
        {
            if (containPoint(event.getRelPos(this)))
            {
                m_signalClicked.emit(m_groupIdx, m_callIdx);
                return VFX_TRUE;
            }
        }
    }
    else if (VFX_PEN_EVENT_TYPE_ABORT == event.type)
    {
        m_penDown = VFX_FALSE;
        return VFX_TRUE;
    }
    return VFX_TRUE;
}

VfxBool VappUcmDialButton::onPenInput(VfxPenEvent & event)
{
	if (VFX_PEN_EVENT_TYPE_LONG_TAP == event.type)
	{
		m_signallongpress.postEmit();
	}
	return VcpButton::onPenInput(event);
}

VFX_IMPLEMENT_CLASS("VappUcmDialPad", VappUcmDialPad, VfxFrame);

void VappUcmDialPad::onInit()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMK", SA_start);
#endif
    VfxFrame::onInit();
    VfxXmlLoader::loadBegin(this, VAPP_UCM_KEYPAD);

    m_top_area = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("top_area")), VfxFrame);
    m_top_area->setImgContent(VfxImageSrc(IMG_ID_VAPP_UCM_EDITOR_BG1));
    m_top_area->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);

    m_display_area = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_display_area")), VfxFrame);
    m_display_area->setImgContent(VfxImageSrc(IMG_ID_VAPP_UCM_EDITOR));
    m_display_area->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);

    m_editor_text = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_editor_text")), VcpTextView);
    m_editor_text->setIsUnhittable(VFX_TRUE);
    m_editor_text->setColor(VCP_TEXT_NORMAL_TEXT_COLOR, VFX_COLOR_BLACK);
    m_editor_text->setLineMode(VCP_TEXT_LINE_MODE_SINGLE);
    m_editor_text->setAlignMode(VCP_TEXT_ALIGN_MODE_RIGHT);
    m_editor_text->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_DIALPAD_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
    memset(m_dialBuff, 0, sizeof(m_dialBuff));
    m_dialBuffLen = 0;
    m_editor_text->setText((VfxWChar*)m_dialBuff);
    m_editor_text->disableBackground(VFX_TRUE);
    m_editor_text->setHint(NULL);

//    m_delete_key = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("delete_key")), VappUcmDialButton);
	VFX_OBJ_CREATE(m_delete_key, VappUcmDialButton, this);
	m_delete_key->setPos(VAPP_UCM_KEYPAD_BTN_DELETE_POS_X, VAPP_UCM_KEYPAD_BTN_DELETE_POS_Y);
	m_delete_key->setSize(VAPP_UCM_KEYPAD_BTN_DELETE_SIZE_X, VAPP_UCM_KEYPAD_BTN_DELETE_SIZE_Y);
	m_delete_key->setId(13);
    m_delete_key->setBgImageList(VcpStateImage(IMG_ID_VAPP_UCM_BTN_DELETE_N, IMG_ID_VAPP_UCM_BTN_DELETE_P, IMG_ID_VAPP_UCM_BTN_DELETE_D, 0));
    m_delete_key->m_signalStateChanged.connect(this, &VappUcmDialPad::onButtonStateChanged);
	m_delete_key->m_signallongpress.connect(this, &VappUcmDialPad::onLongPressDelete);

    m_key_frame = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("key_frame")), VfxFrame);
    m_key_frame->setImgContent(VfxImageSrc(IMG_ID_VAPP_UCM_EDITOR_BG2));
    m_key_frame->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);

    m_tmp_btn = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("dial_key")), VcpButton);
    m_tmp_btn->setHidden(VFX_TRUE);
    VfxXmlLoader::loadEnd();
    
    VfxU8 hor_gap = 2, ver_gap = 2, left_margin = m_display_area->getPos().x;
    for (VfxU32 idx = 0; idx < 12; ++idx)
    {
        VfxU8 hor_count = idx % 3;
        VfxU8 ver_count = idx / 3;
        VFX_OBJ_CREATE(m_number_btns[idx], VcpButton, m_key_frame);
        m_number_btns[idx]->setId((VfxId)idx);
        m_number_btns[idx]->setSize(m_tmp_btn->getSize());
        m_number_btns[idx]->setTextColor(VFX_COLOR_RES(CLR_COSMOS_TEXT_MAIN));
        m_number_btns[idx]->setTextFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_DIAL_ICON_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
        m_number_btns[idx]->setPos(left_margin + hor_gap * hor_count + m_tmp_btn->getSize().width * hor_count, VAPP_UCM_KEYPAD_TOP_MARGIN + ver_gap * (ver_count + 1) + m_tmp_btn->getSize().height * ver_count);
        m_number_btns[idx]->setBgImageList(VcpStateImage(IMG_ID_VAPP_UCM_BTN_DIAL_N, IMG_ID_VAPP_UCM_BTN_DIAL_P, IMG_ID_VAPP_UCM_BTN_DIAL_D, 0));
        m_number_btns[idx]->m_signalStateChanged.connect(this, &VappUcmDialPad::onButtonStateChanged);
        m_number_btns[idx]->setFuzzy(VFX_FALSE);
        VfxWChar digit[2];
        if (9 == idx)
        {
            digit[0] = '*';
        }
        else if (10 == idx)
        {
            digit[0] = '0';
        }
        else if (11 == idx)
        {
            digit[0] = '#';
        }
        else
        {
            digit[0] = ('1' + idx);
        }
        digit[1] = 0;
        m_number_btns[idx]->setText(digit);
    }
    m_key_frame->preCacheChildren();
    setFocused(VFX_TRUE);
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMK", SA_stop);
#endif
}

void VappUcmDialPad::onLongPressDelete(void)
{
	m_dialBuffLen = 0;
	memset(m_dialBuff, 0, sizeof(VfxWChar)*MAX_DIAL_BUFF_LENG);
	m_editor_text->setText((VfxWChar*)m_dialBuff);
}

void VappUcmDialPad::onButtonStateChanged(VfxObject* obj, VfxId id, VcpButtonStateEnum state)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CBC", SA_start);
#endif
    m_signalScrnLockTimer.emit(VAPP_UCM_TIMER_RESET);
    if (((MAX_DIAL_BUFF_LENG - 1) == m_dialBuffLen) && id != 13) // delete
    {
        VfxWChar tmp_buf[MAX_DIAL_BUFF_LENG];
        memset(tmp_buf, 0, MAX_DIAL_BUFF_LENG << 1);
        memcpy(tmp_buf, m_dialBuff + 1, (MAX_DIAL_BUFF_LENG - 2) << 1);
        memcpy(m_dialBuff, tmp_buf, MAX_DIAL_BUFF_LENG << 1);
        m_dialBuffLen = MAX_DIAL_BUFF_LENG - 2;
    }
    switch (id)
    {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        {
            if (VCP_BUTTON_STATE_PRESSED == state)
            {
                m_dialBuff[m_dialBuffLen]='1'+id;
                vapp_ucm_dtmf_key_down(KEY_1+id);
            }
            else
            {
                ++m_dialBuffLen;
                vapp_ucm_dtmf_key_up(KEY_1+id);
            }
            break;
        }
        case 9:
        {
            if (VCP_BUTTON_STATE_PRESSED == state)
            {
                m_dialBuff[m_dialBuffLen] = '*';
                vapp_ucm_dtmf_key_down(KEY_STAR);
            }
            else
            {
                ++m_dialBuffLen;
                vapp_ucm_dtmf_key_up(KEY_STAR);
            }
            break;
        }
        case 10:
        {
            if (VCP_BUTTON_STATE_PRESSED == state)
            {
                m_dialBuff[m_dialBuffLen] = '0';
                vapp_ucm_dtmf_key_down(KEY_0);
            }
            else
            {
                ++m_dialBuffLen;
                vapp_ucm_dtmf_key_up(KEY_0);
            }
            break;
        }
        case 11:
        {
            if (VCP_BUTTON_STATE_PRESSED == state)
            {
                m_dialBuff[m_dialBuffLen] = '#';
                vapp_ucm_dtmf_key_down(KEY_POUND);
            }
            else
            {
                ++m_dialBuffLen;
                vapp_ucm_dtmf_key_up(KEY_POUND);
            }
            break;
        }
        case 13:
        {
            if (VCP_BUTTON_STATE_PRESSED == state && m_dialBuffLen > 0)
            {
                m_dialBuff[--m_dialBuffLen] = 0;
            }
            break;
        }
    }
    m_editor_text->setText((VfxWChar*)m_dialBuff);
    m_editor_text->scrollToEnd();
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CBC", SA_stop);
#endif
}

VfxBool VappUcmDialPad::onKeyInput(VfxKeyEvent & event)
{
    VcpButtonStateEnum state;
    if (VFX_KEY_EVENT_TYPE_DOWN == event.type)
    {
        state = VCP_BUTTON_STATE_PRESSED;
    }
    else if (VFX_KEY_EVENT_TYPE_UP == event.type)
    {
        state = VCP_BUTTON_STATE_NORMAL;
    }
    else if (VFX_KEY_EVENT_TYPE_LONG_PRESS == event.type
		&& (VFX_KEY_CODE_CLEAR == event.keyCode 
		|| VFX_KEY_CODE_DEL == event.keyCode
		|| VFX_KEY_CODE_BACKSPACE == event.keyCode))
	{
		onLongPressDelete();
		return VfxFrame::onKeyInput(event);
	}
	else
    {
        return VfxFrame::onKeyInput(event);
    }

    VfxId id;
    switch (event.keyCode)
    {
        case VFX_KEY_CODE_1:
        case VFX_KEY_CODE_2:
        case VFX_KEY_CODE_3:
        case VFX_KEY_CODE_4:
        case VFX_KEY_CODE_5:
        case VFX_KEY_CODE_6:
        case VFX_KEY_CODE_7:
        case VFX_KEY_CODE_8:
        case VFX_KEY_CODE_9:
            id = event.keyCode - VFX_KEY_CODE_1;
            break;

        case VFX_KEY_CODE_STAR:
            id = 9;
            break;

        case VFX_KEY_CODE_0:
            id = 10;
            break;

        case VFX_KEY_CODE_POUND:
            id = 11;
            break;

        case VFX_KEY_CODE_CLEAR:
        case VFX_KEY_CODE_DEL:
        case VFX_KEY_CODE_BACKSPACE:
            id = 13;
            break;

        default:
            return VfxFrame::onKeyInput(event);

    }

    onButtonStateChanged(NULL, id, state);
    return VFX_TRUE;


}


VFX_IMPLEMENT_CLASS("VappUcmCallCell", VappUcmCallCell, VfxControl);

void VappUcmCallCell::onInit()
{
    VfxControl::onInit();

    m_cellType = VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL3;
    m_isLocked = VFX_FALSE;
    m_numCalls = 0;
    m_isProgressing = VFX_FALSE;
#ifndef __MMI_UCM_SLIM__
    m_isBTConnecting = VFX_FALSE;
#endif // __MMI_UCM_SLIM__
    m_isMorePopupShowing = VFX_FALSE;   // for UI Performance

    m_actionArea = NULL;
    m_timer = NULL;
    m_notifyTimer = NULL;
    m_recIcon = NULL;
    m_callStatus = NULL;
    m_callStatusBg = NULL;
    m_simInfoBar = NULL;

    setBgColor(VFX_COLOR_TRANSPARENT);
}

VfxBool VappUcmCallCell::onPenInput(VfxPenEvent &event)
{
    if ((VAPP_UCM_CALL_CELL_TYPE_REDUCED1 == m_cellType || VAPP_UCM_CALL_CELL_TYPE_REDUCED2 == m_cellType)
    #ifndef __MMI_UCM_SLIM__
        && !m_isBTConnecting
    #endif // __MMI_UCM_SLIM__
            )
    {
        if (containPoint(event.getRelPos(this)) && VFX_PEN_EVENT_TYPE_UP == event.type)
        {
            m_signalSwapCell.emit(this);
        }
    }
    return VFX_TRUE;   
}

void VappUcmCallCell::setCellType(VappUcmCallCellTypeEnum type)
{
    m_cellType = type;
    switch(type)
    {
        case VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1:
        case VAPP_UCM_CALL_CELL_TYPE_REDUCED1:
        {
            setPos(0, 0);
            break;
        }
        case VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL2:
        case VAPP_UCM_CALL_CELL_TYPE_REDUCED2:
        {
            setPos(0, VAPP_UCM_REDUCED_CELL_HIGHT + 1);
            break;
        }
        case VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL3:
        {
            setPos(0, ((VAPP_UCM_REDUCED_CELL_HIGHT << 1) + 2));
            break;
        }
    }
}

void VappUcmCallCell::setLocked(VfxBool isLocked)
{
    m_isLocked = isLocked;
}

void VappUcmCallCell::setCallId(VfxS32 group_id, VfxS32 call_id)
{
    m_callIndex.group_index = group_id;
    m_callIndex.call_index = call_id;
}

void VappUcmCallCell::setGroupInfo(srv_ucm_group_info_struct *info)
{
    m_groupInfo = *info;
}

void VappUcmCallCell::updateActionButtons(VappUcmActionArea *actionArea)
{
    switch (m_groupInfo.call_state)
    {
        case SRV_UCM_INCOMING_STATE:
        {
            actionArea->setAreaType(VAPP_UCM_AREA_INCOMING);
        #ifdef __MMI_UCM_REJECT_BY_SMS__
            actionArea->m_actionButtonGroup->setType(VAPP_UCM_ACTBTN_GRP_3_BTN);
        #else
            actionArea->m_actionButtonGroup->setType(VAPP_UCM_ACTBTN_GRP_2_BTN);
        #endif // __MMI_UCM_REJECT_BY_SMS__

            actionArea->m_actionButtonGroup->setBtnLabel(0, STR_ID_VAPP_UCM_SLIENT);
            actionArea->m_actionButtonGroup->setBtnIcon(0, VcpStateImage(IMG_ID_VAPP_UCM_ICON_SLIENT, IMG_ID_VAPP_UCM_ICON_SLIENT, IMG_ID_VAPP_UCM_ICON_SLIENT, IMG_ID_VAPP_UCM_ICON_SLIENT));
            actionArea->m_actionButtonGroup->setBtnId(0, VAPP_UCM_ACT_AREA_BTN_SILENT);
            VfxBool btnDisable;
            if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) > 1
                || (srv_prof_is_profile_activated(SRV_PROF_SILENT_MODE) > 0 && MMI_FALSE == srv_prof_if_can_vibrate()))
            {
                // disable silent option for waiting calls or in SILENT mode and vibrate is off
                btnDisable = VFX_TRUE;
            }
            else
            {
                btnDisable = VFX_FALSE;
            }
            actionArea->m_actionButtonGroup->setBtnDisable(0, btnDisable);
            
            actionArea->m_actionButtonGroup->setBtnLabel(1, STR_ID_VAPP_UCM_KEYPAD);
            actionArea->m_actionButtonGroup->setBtnIcon(1, VcpStateImage(IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD));
            actionArea->m_actionButtonGroup->setBtnSwitchable(1, VFX_TRUE);
            actionArea->m_actionButtonGroup->setBtnId(1, VAPP_UCM_ACT_AREA_BTN_KEYPAD);
            actionArea->m_actionButtonGroup->setBtnDisable(1, VFX_FALSE);
        #ifdef __MMI_UCM_REJECT_BY_SMS__
            actionArea->m_actionButtonGroup->setBtnLabel(2, STR_ID_VAPP_UCM_MSG_REJECT);
            actionArea->m_actionButtonGroup->setBtnIcon(2, VcpStateImage(IMG_ID_VAPP_UCM_ICON_MESSAGE, IMG_ID_VAPP_UCM_ICON_MESSAGE, IMG_ID_VAPP_UCM_ICON_MESSAGE, IMG_ID_VAPP_UCM_ICON_MESSAGE));
            actionArea->m_actionButtonGroup->setBtnId(2, VAPP_UCM_ACT_AREA_BTN_MESSAGE);
            srv_ucm_call_info_struct call_info;
            srv_ucm_query_call_data(m_callIndex, &call_info);
            if (((srv_callset_answer_mode_get_status() & SRV_CALLSET_ANSWER_MODE_AUTO)
                  && srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_NO_CSD, NULL) == 1
                  && srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) == 1)
             #ifdef __MMI_CM_WHITE_LIST__
                 || (srv_callset_whitelist_is_auto_answer_number((U8)mmi_ucs2strlen((CHAR*)call_info.remote_info.num_uri), (WCHAR*)call_info.remote_info.num_uri, NULL) == MMI_TRUE)
             #endif // __MMI_CM_WHITE_LIST__
                 || !srv_ucm_is_valid_number(m_groupInfo.call_type, call_info.remote_info.num_uri)
                 || !srv_callset_reject_by_sms_get_mode())
            {
                btnDisable = VFX_TRUE;
            }
            else
            {
                btnDisable = VFX_FALSE;
            }
            actionArea->m_actionButtonGroup->setBtnDisable(2, btnDisable);
        #endif // __MMI_UCM_REJECT_BY_SMS__
            break;
        }
        case SRV_UCM_OUTGOING_STATE:
        {
            actionArea->setAreaType(VAPP_UCM_AREA_OUTGOING);
            VappUcmActionButtonGroupEnum actionGroupType;
            VfxBool btnSwitch, btnDisable;
            VfxU8 btnIdx;
            VfxResId btnTxtId;
        #ifdef __MMI_UCM_SLIM__
            actionGroupType = VAPP_UCM_ACTBTN_GRP_6_BTN;
        #else
            actionGroupType = VAPP_UCM_ACTBTN_GRP_8_BTN;
        #endif // __MMI_UCM_SLIM__
            actionArea->m_actionButtonGroup->setType(actionGroupType);
        
            btnIdx = 0;
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, STR_ID_VAPP_UCM_NEW_CALL);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(IMG_ID_VAPP_UCM_ICON_NEW_CALL, IMG_ID_VAPP_UCM_ICON_NEW_CALL, IMG_ID_VAPP_UCM_ICON_NEW_CALL, IMG_ID_VAPP_UCM_ICON_NEW_CALL));
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_TRUE);
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_NEW_CALL);

            btnIdx = 1;
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, STR_ID_VAPP_UCM_HOLD);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(IMG_ID_VAPP_UCM_ICON_HOLD, IMG_ID_VAPP_UCM_ICON_HOLD, IMG_ID_VAPP_UCM_ICON_HOLD, IMG_ID_VAPP_UCM_ICON_HOLD));
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_TRUE);
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_HOLD);

            btnIdx = 2;            
            if (!vapp_ucm_is_recording)
            {
                btnTxtId = STR_ID_VAPP_UCM_RECORD;
            }
            else
            {
                btnTxtId = STR_ID_VAPP_UCM_STOP_RECORD;
            }
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, btnTxtId);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(IMG_ID_VAPP_UCM_ICON_REC, IMG_ID_VAPP_UCM_ICON_REC, IMG_ID_VAPP_UCM_ICON_REC, IMG_ID_VAPP_UCM_ICON_REC));
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_TRUE);
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_RECORD);

        #ifndef __MMI_UCM_SLIM__
            btnIdx = 3;
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, STR_ID_VAPP_UCM_MORE);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(IMG_ID_VAPP_UCM_ICON_MORE, IMG_ID_VAPP_UCM_ICON_MORE, IMG_ID_VAPP_UCM_ICON_MORE, IMG_ID_VAPP_UCM_ICON_MORE));
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_MORE);
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_FALSE);
        #endif // __MMI_UCM_SLIM__

        #ifndef __MMI_UCM_SLIM__
            btnIdx = 4;
        #else
            btnIdx = 3;
        #endif // __MMI_UCM_SLIM__
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, STR_ID_VAPP_UCM_MUTE);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(IMG_ID_VAPP_UCM_ICON_MUTE, IMG_ID_VAPP_UCM_ICON_MUTE, IMG_ID_VAPP_UCM_ICON_MUTE, IMG_ID_VAPP_UCM_ICON_MUTE));
            actionArea->m_actionButtonGroup->setBtnSwitchable(btnIdx, VFX_TRUE);
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_TRUE);

        #ifndef __MMI_UCM_SLIM__
            btnIdx = 5;
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, STR_ID_VAPP_UCM_BT);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(IMG_ID_VAPP_UCM_ICON_BT, IMG_ID_VAPP_UCM_ICON_BT, IMG_ID_VAPP_UCM_ICON_BT, IMG_ID_VAPP_UCM_ICON_BT));
            actionArea->m_actionButtonGroup->setBtnSwitchable(btnIdx, VFX_TRUE);
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_BLUETOOTH);
            
        #ifdef __MMI_BT_SUPPORT__
        #ifdef WIN32
            if(1)
        #else
            if(srv_btaud_get_active_device(BTAUD_CHNL_MONO, NULL)
               && srv_btaud_switchable(BTAUD_CHNL_MONO))
        #endif
            {
                if (BTAUD_SWITCH_ON == srv_btaud_get_status(BTAUD_CHNL_MONO))
                {
                    btnSwitch = VFX_TRUE;
                }
                else
                {
                    btnSwitch = VFX_FALSE;
                }
                actionArea->m_actionButtonGroup->setBtnSwitchOn(btnIdx, btnSwitch);
                btnDisable = VFX_FALSE;
            }
            else
            {
                btnDisable = VFX_TRUE;
            }
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, btnDisable);
        #else // __MMI_BT_SUPPORT__
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_TRUE);
        #endif // __MMI_BT_SUPPORT__
        #endif // __MMI_UCM_SLIM__

        #ifndef __MMI_UCM_SLIM__
            btnIdx = 6;
        #else
            btnIdx = 4;
        #endif // __MMI_UCM_SLIM__
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, STR_ID_VAPP_UCM_KEYPAD);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD));
            actionArea->m_actionButtonGroup->setBtnSwitchable(btnIdx, VFX_TRUE);
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_KEYPAD);
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_FALSE);

        #ifndef __MMI_UCM_SLIM__
            btnIdx = 7;
        #else
            btnIdx = 5;
        #endif // __MMI_UCM_SLIM__
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, STR_ID_VAPP_UCM_SPEAKER);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(IMG_ID_VAPP_UCM_ICON_SPEAKER, IMG_ID_VAPP_UCM_ICON_SPEAKER, IMG_ID_VAPP_UCM_ICON_SPEAKER, IMG_ID_VAPP_UCM_ICON_SPEAKER));
            actionArea->m_actionButtonGroup->setBtnSwitchable(btnIdx, VFX_TRUE);
        #if (!defined(__MMI_UCM_SLIM__) && defined(__MMI_BT_SUPPORT__))
            if (BTAUD_SWITCH_ON == srv_btaud_get_status(BTAUD_CHNL_MONO))
            {
                btnDisable = VFX_TRUE;
            }
            else
        #endif // __MMI_UCM_SLIM__
            {
                btnDisable = VFX_FALSE;
            }
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, btnDisable);
            if (MMI_FALSE == srv_speech_is_hand_free())
            {
                btnSwitch = VFX_FALSE;
            }
            else
            {
                btnSwitch = VFX_TRUE;
            }
            actionArea->m_actionButtonGroup->setBtnSwitchOn(btnIdx, btnSwitch);
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_SPEAKER);
            break;
        }
        case SRV_UCM_ACTIVE_STATE:
        case SRV_UCM_HOLD_STATE:
        {
            VfxBool btnDisable = VFX_FALSE;
            VfxBool btnSwitchable;
            VfxBool btnSwitch;
            VfxBool srv_busy = VFX_FALSE;
            VfxId btnId;
            VfxU8 btnIdx;
            VfxResId txtId, imgId;
            if (srv_ucm_query_call_count((srv_ucm_call_state_enum)(SRV_UCM_INCOMING_STATE | SRV_UCM_OUTGOING_STATE), SRV_UCM_CALL_TYPE_ALL, NULL) > 0)
            {
                srv_busy = VFX_TRUE;
            }
            actionArea->setAreaType(VAPP_UCM_AREA_NORMAL);
            VappUcmActionButtonGroupEnum actionGroupType;
        #ifdef __MMI_UCM_SLIM__
            actionGroupType = VAPP_UCM_ACTBTN_GRP_6_BTN;
        #else
            actionGroupType = VAPP_UCM_ACTBTN_GRP_8_BTN;
        #endif // __MMI_UCM_SLIM__
            actionArea->m_actionButtonGroup->setType(actionGroupType);

            btnIdx = 0;
            if (VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1 == m_cellType)
            {
                txtId = STR_ID_VAPP_UCM_NEW_CALL;
                imgId = IMG_ID_VAPP_UCM_ICON_NEW_CALL;
                btnId = VAPP_UCM_ACT_AREA_BTN_NEW_CALL;
                if (mmi_frm_is_scenario_started(MMI_SCENARIO_ID_HIGHEST_SCRN))
                {
                    btnDisable = VFX_TRUE;
                }
				if (srv_bootup_is_booting())
				{
					btnDisable = VFX_TRUE;
				}
            }
            else
            {
                txtId = STR_ID_VAPP_UCM_CONFERENCE;
                imgId = IMG_ID_VAPP_UCM_ICON_CONF;
                btnId = VAPP_UCM_ACT_AREA_BTN_CONFERENCE;
                if (m_numCalls >= SRV_UCM_MAX_CALL_IN_GROUP)
                {
                    btnDisable = VFX_TRUE;
                }
            }
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, txtId);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(imgId, imgId, imgId, imgId));
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, btnId);
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, srv_busy | btnDisable);

            btnIdx = 1;
            if (VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1 != m_cellType)
            {
                txtId = STR_ID_VAPP_UCM_SWAP;
                imgId = IMG_ID_VAPP_UCM_ICON_SWAP;
            }
            else if (SRV_UCM_HOLD_STATE == m_groupInfo.call_state)
            {
                txtId = STR_ID_VAPP_UCM_UNHOLD;
                imgId = IMG_ID_VAPP_UCM_ICON_ACTIVE;
            }
            else
            {
                txtId = STR_ID_VAPP_UCM_HOLD;
                imgId = IMG_ID_VAPP_UCM_ICON_HOLD;
            }
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, txtId);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(imgId, imgId, imgId, imgId));
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_HOLD);            
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, srv_busy);

            btnIdx = 2;
            if (!vapp_ucm_is_recording)
            {
                txtId = STR_ID_VAPP_UCM_RECORD;
            }
            else
            {
                txtId = STR_ID_VAPP_UCM_STOP_RECORD;
            }
            actionArea->m_actionButtonGroup->setBtnLabel(2, txtId);
            actionArea->m_actionButtonGroup->setBtnIcon(2, VcpStateImage(IMG_ID_VAPP_UCM_ICON_REC, IMG_ID_VAPP_UCM_ICON_REC, IMG_ID_VAPP_UCM_ICON_REC, IMG_ID_VAPP_UCM_ICON_REC));
            actionArea->m_actionButtonGroup->setBtnId(2, VAPP_UCM_ACT_AREA_BTN_RECORD);
            actionArea->m_actionButtonGroup->setBtnDisable(2, VFX_FALSE);

        #ifndef __MMI_UCM_SLIM__
            btnIdx = 3;
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, STR_ID_VAPP_UCM_MORE);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(IMG_ID_VAPP_UCM_ICON_MORE, IMG_ID_VAPP_UCM_ICON_MORE, IMG_ID_VAPP_UCM_ICON_MORE, IMG_ID_VAPP_UCM_ICON_MORE));
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_MORE);
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_FALSE);
        #endif // __MMI_UCM_SLIM__

        #ifndef __MMI_UCM_SLIM__
            btnIdx = 4;
        #else
            btnIdx = 3;
        #endif // __MMI_UCM_SLIM__
            if (MMI_FALSE == srv_speech_is_phone_mute())
            {
                txtId = STR_ID_VAPP_UCM_MUTE;
                imgId = IMG_ID_VAPP_UCM_ICON_MUTE;
                btnSwitchable = VFX_TRUE;
                btnSwitch =VFX_FALSE;
            }
            else
            {
                txtId = STR_ID_VAPP_UCM_MUTE;
                imgId = IMG_ID_VAPP_UCM_ICON_UNMUTE;
                btnSwitchable = VFX_TRUE;
                btnSwitch =VFX_TRUE;
            }
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, txtId);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(imgId, imgId, imgId, imgId));
            actionArea->m_actionButtonGroup->setBtnSwitchable(btnIdx, btnSwitchable);
            actionArea->m_actionButtonGroup->setBtnSwitchOn(btnIdx, btnSwitch);            
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_MUTE);
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_FALSE);
            
        #ifndef __MMI_UCM_SLIM__
            btnIdx = 5;
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, STR_ID_VAPP_UCM_BT);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(IMG_ID_VAPP_UCM_ICON_BT, IMG_ID_VAPP_UCM_ICON_BT, IMG_ID_VAPP_UCM_ICON_BT, IMG_ID_VAPP_UCM_ICON_BT));
            actionArea->m_actionButtonGroup->setBtnSwitchable(btnIdx, VFX_TRUE);
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_BLUETOOTH);
        #ifdef __MMI_BT_SUPPORT__
        #ifdef WIN32
            if (1)
        #else
            if (srv_btaud_get_active_device(BTAUD_CHNL_MONO, NULL) 
                && srv_btaud_switchable(BTAUD_CHNL_MONO))
        #endif
            {
                if (srv_btaud_get_status(BTAUD_CHNL_MONO) == BTAUD_SWITCH_ON)
                {
                    actionArea->m_actionButtonGroup->setBtnSwitchOn(btnIdx, MMI_TRUE);
                }
                else
                {
                    actionArea->m_actionButtonGroup->setBtnSwitchOn(btnIdx, MMI_FALSE);
                }
                actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_FALSE);
            }
            else
            {
                actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_TRUE);
            }
         #else
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_TRUE);
        #endif
        #endif // __MMI_UCM_SLIM__

        #ifndef __MMI_UCM_SLIM__
            btnIdx = 6;
        #else
            btnIdx = 4;
        #endif // __MMI_UCM_SLIM__
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, STR_ID_VAPP_UCM_KEYPAD);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD));
            actionArea->m_actionButtonGroup->setBtnSwitchable(btnIdx, VFX_TRUE);
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_KEYPAD);
            VappUcmMainPage *mainPage = VFX_OBJ_DYNAMIC_CAST(getParentControl(), VappUcmMainPage);
            actionArea->m_actionButtonGroup->setBtnSwitchOn(btnIdx, mainPage->isKeyPadEnabled());
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_FALSE);

        #ifndef __MMI_UCM_SLIM__
            btnIdx = 7;
        #else
            btnIdx = 5;
        #endif // __MMI_UCM_SLIM__
            actionArea->m_actionButtonGroup->setBtnLabel(btnIdx, STR_ID_VAPP_UCM_SPEAKER);
            actionArea->m_actionButtonGroup->setBtnIcon(btnIdx, VcpStateImage(IMG_ID_VAPP_UCM_ICON_SPEAKER, IMG_ID_VAPP_UCM_ICON_SPEAKER, IMG_ID_VAPP_UCM_ICON_SPEAKER, IMG_ID_VAPP_UCM_ICON_SPEAKER));
            actionArea->m_actionButtonGroup->setBtnSwitchable(btnIdx, VFX_TRUE);
        #if (!defined(__MMI_UCM_SLIM__) && defined(__MMI_BT_SUPPORT__))
            if (srv_btaud_get_status(BTAUD_CHNL_MONO) == BTAUD_SWITCH_ON)
            {
                btnDisable = VFX_TRUE;
            }
            else
        #endif
            {
                btnDisable = VFX_FALSE;
            }
            actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, btnDisable);
            if (MMI_FALSE == srv_speech_is_hand_free())
            {
                btnSwitch = VFX_FALSE;
            }
            else
            {
                btnSwitch = VFX_TRUE;
            }
            actionArea->m_actionButtonGroup->setBtnSwitchOn(btnIdx, btnSwitch);
            actionArea->m_actionButtonGroup->setBtnId(btnIdx, VAPP_UCM_ACT_AREA_BTN_SPEAKER);
            break;
        }
    }

}

void VappUcmCallCell::createActionArea(VappUcmActionArea **_actionArea)
{
    VappUcmActionArea *actionArea = NULL;
    VFX_OBJ_CREATE(actionArea, VappUcmActionArea, this);

    actionArea->setAnchor(0.0f, 1.0f);
    actionArea->setPos(0, getSize().height);
    //actionArea->setAlignParent(VFX_FRAME_ALIGNER_SIDE_BOTTOM, VFX_FRAME_ALIGNER_MODE_SIDE);
    actionArea->m_signalActions.connect(this, &VappUcmCallCell::onActionAreaClicked);
    actionArea->setSize(VAPP_UCM_ACT_AREA_WIDTH, VAPP_UCM_ACT_AREA_HEIGHT);

    actionArea->m_actionButtonGroup->setAnchor(0.0f, 1.0f);
    actionArea->m_actionButtonGroup->setPos(VAPP_UCM_ACT_BTN_GRP_X, VAPP_UCM_ACT_BTN_GRP_HEIGHT2);

    updateActionButtons(actionArea);
    actionArea->setHidden(m_isLocked);

    *_actionArea = actionArea;
}

#ifndef __MMI_UCM_SLIM__
void VappUcmCallCell::startBTSwitch()
{
    m_isBTConnecting = VFX_TRUE;
    m_actionArea->m_actionButtonGroup->setBtnStartAnimate(m_actionArea->m_actionButtonGroup->getBtnIndex(VAPP_UCM_ACT_AREA_BTN_BLUETOOTH), VFX_TRUE);
}

void VappUcmCallCell::stopBTSwitch(VfxBool connect)
{
    m_isBTConnecting = VFX_FALSE;
    m_actionArea->m_actionButtonGroup->setBtnStartAnimate(m_actionArea->m_actionButtonGroup->getBtnIndex(VAPP_UCM_ACT_AREA_BTN_BLUETOOTH), VFX_FALSE);
    m_actionArea->m_actionButtonGroup->setBtnSwitchOn(m_actionArea->m_actionButtonGroup->getBtnIndex(VAPP_UCM_ACT_AREA_BTN_BLUETOOTH), connect);

    VfxU8 btnIdx = m_actionArea->m_actionButtonGroup->getBtnIndex(VAPP_UCM_ACT_AREA_BTN_SPEAKER);
    m_actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, connect);
    if (!connect)
    {
        VfxBool btnSwitch;
        if (MMI_FALSE == srv_speech_is_hand_free())
        {
            btnSwitch = VFX_FALSE;
        }
        else
        {
            btnSwitch = VFX_TRUE;
        }
        m_actionArea->m_actionButtonGroup->setBtnSwitchOn(btnIdx, btnSwitch);
    }
    
}
#endif // __MMI_UCM_SLIM__

void VappUcmCallCell::onActionAreaClicked(VfxId btn, VappUcmActionBtnStateEnum state)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CAC", SA_start);
#endif

    VappUcmActionAreaBtnEnum btn_type = (VappUcmActionAreaBtnEnum)btn;
    srv_ucm_call_info_struct call_info;
    switch (btn_type)
    {
        case VAPP_UCM_ACT_AREA_BTN_ACCEPT_CALL:
        {
            vapp_ucm_incoming_call_sendkey();
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_REJECT_CALL:
        {
            vapp_ucm_incoming_call_endkey();
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_END_THIS_CALL:
        case VAPP_UCM_ACT_AREA_BTN_END_CALL:
        {
            vapp_ucm_endkey_hdlr();
            break;
        }
    #ifndef __MMI_UCM_SLIM__
        case VAPP_UCM_ACT_AREA_BTN_BLUETOOTH:
        {
            if (!m_isBTConnecting)
            {
                if (srv_btaud_switchable(BTAUD_CHNL_MONO))
                {
                    vapp_ucm_bt_set_audio_path();
                    startBTSwitch();
                }
                else
                {
                    vapp_ucm_display_popup(SRV_UCM_RESULT_ACTION_NOT_ALLOWED);
                }
            }
            break;
        }
    #endif // __MMI_UCM_SLIM__
        case VAPP_UCM_ACT_AREA_BTN_KEYPAD:
        {
            showDialPad(VAPP_UCM_ACTBTN_STATE_ON == state);
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_SPEAKER:
        {
            if (VAPP_UCM_ACTBTN_STATE_ON == state)
            {
                srv_speech_enable_hand_free();
            }
            else
            {
                srv_speech_disable_hand_free();
            }
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_NEW_CALL:
        {
            mmi_sim_enum sim = MMI_SIM_NONE;
            if (SRV_UCM_VOICE_CALL_TYPE == m_groupInfo.call_type)
            {
                sim = MMI_SIM1;
            }
        #if (MMI_MAX_SIM_NUM >= 2)
            else if (SRV_UCM_VOICE_CALL_TYPE_SIM2 == m_groupInfo.call_type)
            {
                sim = MMI_SIM2;
            }
        #if (MMI_MAX_SIM_NUM >= 3)
            else if (SRV_UCM_VOICE_CALL_TYPE_SIM3 == m_groupInfo.call_type)
            {
                sim = MMI_SIM3;
            }
        #if (MMI_MAX_SIM_NUM >= 4)
            else if (SRV_UCM_VOICE_CALL_TYPE_SIM4 == m_groupInfo.call_type)
            {
                sim = MMI_SIM4;
            }
        #endif // (MMI_MAX_SIM_NUM >= 4)
        #endif // (MMI_MAX_SIM_NUM >= 3)
        #endif // (MMI_MAX_SIM_NUM >= 2)
            vapp_dialer_launch_ex(sim);
            m_signalScrnLockTimer.emit(VAPP_UCM_TIMER_STOP);
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_CONFERENCE:
        {
            if (!m_isProgressing && srv_ucm_query_call_count(SRV_UCM_CALL_STATE_CONNECTED, SRV_UCM_VOICE_CALL_TYPE_ALL, NULL) > 1)
            {
                MMI_BOOL act_is_executed;
               
                srv_ucm_result_enum option_check_result = mmi_ucm_conference_option(MMI_UCM_EXEC_IF_PERMIT_PASS, &act_is_executed);

                if (SRV_UCM_RESULT_OK != option_check_result)
                {
                    vapp_ucm_display_popup(option_check_result);
                }
                else
                {
                    m_isProgressing = VFX_TRUE;
                }
            }
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_HOLD:
        {
            srv_ucm_query_call_data(m_callIndex, &call_info);
            if (SRV_UCM_ACTIVE_STATE == call_info.call_state)
            {
                if (srv_ucm_query_group_count(SRV_UCM_HOLD_STATE, SRV_UCM_CALL_TYPE_ALL, MMI_FALSE, NULL) == 1)
                {
                    vapp_ucm_swap_action();
                    m_actionArea->disableAllBtns(VAPP_UCM_DISABLE_ACT_BTN_ALL_EXCEPT_END_KEY);
                }
                else if (mmi_ucm_hold_single_option(MMI_UCM_PERMIT_ONLY) == SRV_UCM_RESULT_OK)
                {
                    vapp_ucm_hold_single_action();
                    m_actionArea->disableAllBtns(VAPP_UCM_DISABLE_ACT_BTN_ALL_EXCEPT_END_KEY);
                }
                else if(mmi_ucm_hold_conference_option(MMI_UCM_PERMIT_ONLY) == SRV_UCM_RESULT_OK)
                {
                    vapp_ucm_hold_conf_action();
                    m_actionArea->disableAllBtns(VAPP_UCM_DISABLE_ACT_BTN_ALL_EXCEPT_END_KEY);
                }
                else // 3 held calls exist
                {
                    vapp_ucm_display_info((WCHAR*)GetString(STR_ID_VAPP_UCM_NOT_ALLOW_TO_HOLD));
                }
            }
            else if (SRV_UCM_HOLD_STATE == call_info.call_state)
            {
                if (srv_ucm_query_group_count(SRV_UCM_ACTIVE_STATE, SRV_UCM_CALL_TYPE_ALL, MMI_FALSE, NULL) == SRV_UCM_MAX_ACTIVE_GROUP) // active call exists
                {
                	MMI_BOOL act_is_executed;
                    if (mmi_ucm_swap_option(MMI_UCM_PERMIT_ONLY, &act_is_executed) == SRV_UCM_RESULT_OK) 
                    {
                        vapp_ucm_swap_action();
                        m_actionArea->disableAllBtns(VAPP_UCM_DISABLE_ACT_BTN_ALL_EXCEPT_END_KEY);
                    }
                    else
                    {
                        vapp_ucm_display_info((WCHAR*)GetString(STR_ID_VAPP_UCM_NOT_ALLOW_TO_SWAP));
                    }
                }
                else // no active call exists
                {
                    if (mmi_ucm_retrieve_conference_option(MMI_UCM_PERMIT_ONLY) == SRV_UCM_RESULT_OK)
                    {
                        vapp_ucm_retrieve_conference_action();
                        m_actionArea->disableAllBtns(VAPP_UCM_DISABLE_ACT_BTN_ALL_EXCEPT_END_KEY);
                    }
                    else if (mmi_ucm_retrieve_single_option(MMI_UCM_PERMIT_ONLY) == SRV_UCM_RESULT_OK)
                    {
                        vapp_ucm_retrieve_single_action();
                        m_actionArea->disableAllBtns(VAPP_UCM_DISABLE_ACT_BTN_ALL_EXCEPT_END_KEY);
                    }
                }
            }            
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_RECORD:
        {
        #ifdef __MMI_USB_SUPPORT__
            if (srv_usb_is_in_mass_storage_mode())
            {
                vapp_usb_unavailable_popup(0);
            }
            else
        #endif // __MMI_USB_SUPPORT__
            {
                if (!vapp_ucm_is_recording)
                {
                    startRecord();
                }
                else
                {
                    stopRecord();
                }
            }
            break;
        }
    #ifndef __MMI_UCM_SLIM__
        case VAPP_UCM_ACT_AREA_BTN_MORE:
        {
            showMoreOptions();
            break;
        }
    #endif // __MMI_UCM_SLIM__
        case VAPP_UCM_ACT_AREA_BTN_MUTE:
        {
            if (VAPP_UCM_ACTBTN_STATE_ON == state)
            {
                srv_speech_mute_phone();
            }
            else
            {
                srv_speech_unmute_phone();
            }
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_SPLIT:
        {
            vapp_ucm_split_action();
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_SILENT:
        {
            mmi_ucm_suppress_incoming_tone();
            VfxU8 btnIdx = m_actionArea->m_actionButtonGroup->getBtnIndex(VAPP_UCM_ACT_AREA_BTN_SILENT);
            m_actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_TRUE);
            break;
        }
    #ifdef __MMI_UCM_REJECT_BY_SMS__
        case VAPP_UCM_ACT_AREA_BTN_MESSAGE:
        {
            vapp_ucm_stop_incoming_tone();
            VfxU8 btnIdx = m_actionArea->m_actionButtonGroup->getBtnIndex(VAPP_UCM_ACT_AREA_BTN_SILENT);
            m_actionArea->m_actionButtonGroup->setBtnDisable(btnIdx, VFX_TRUE);
            if (srv_sms_template_get_list_size())
            {
                vapp_ucm_scr->pushSMSTemplatePage();
            }
            else
            {
                if (srv_callset_reject_by_sms_get_setting() == SRV_CALLSET_REJ_BY_SMS_DEFAULT
                    && srv_ucm_is_incoming_call())
                {
                    // end call before sending sms
                    vapp_ucm_incoming_call_endkey();
                }

                VappUcEntryStruct data;
                memset(&data, 0x00, sizeof(VappUcEntryStruct));
                data.info_type = (srv_uc_info_type_enum)SRV_UC_INFO_TYPE_SMS;
                data.operation = (vappUcMsgOperationEnum)UC_OPERATION_WRITE_NEW_MSG;
                data.type = (srv_uc_state_enum)SRV_UC_STATE_WRITE_NEW_MSG;
                data.msg_type = SRV_UC_MSG_TYPE_SMS_ONLY;

                srv_uc_addr_struct addr;
                memset(&addr, 0, sizeof(srv_uc_addr_struct));
                data.addr_num = 1;
                U8 ucs2_addr[(SRV_SMS_MAX_ADDR_LEN + 1) * ENCODING_LENGTH];
                U16 addr_len;
                srv_ucm_query_call_data(m_callIndex, &call_info);
                addr_len = mmi_asc_n_to_ucs2((CHAR*)ucs2_addr, (CHAR*)call_info.remote_info.num_uri, SRV_SMS_MAX_ADDR_LEN);
                ucs2_addr[addr_len] = '\0';
                ucs2_addr[addr_len + 1] = '\0';
                addr.addr = (kal_uint8*) ucs2_addr;
                addr.type = SRV_UC_ADDRESS_TYPE_PHONE_NUMBER;
                addr.group = SRV_UC_ADDRESS_GROUP_TYPE_TO;
                data.addr = &addr;
                data.text_buffer = (U8*)GetString(STR_ID_VAPP_UCM_DEFAULT_SMS);
                data.text_num = (U16)mmi_ucs2strlen(GetString(STR_ID_VAPP_UCM_DEFAULT_SMS));

                data.sim_id = SRV_UC_SIM_ID_GSM_SIM1;
            #if (MMI_MAX_SIM_NUM >= 2)
                if (m_groupInfo.call_type & SRV_UCM_SIM2_CALL_TYPE_ALL)
                {
                    data.sim_id = SRV_UC_SIM_ID_GSM_SIM2;
                }
            #if (MMI_MAX_SIM_NUM >= 3)
                else if (m_groupInfo.call_type & SRV_UCM_SIM3_CALL_TYPE_ALL)
                {
                    data.sim_id = SRV_UC_SIM_ID_GSM_SIM3;
                }
            #if (MMI_MAX_SIM_NUM >= 4)
                else if (m_groupInfo.call_type & SRV_UCM_SIM4_CALL_TYPE_ALL)
                {
                    data.sim_id = SRV_UC_SIM_ID_GSM_SIM4;
                }
            #endif // (MMI_MAX_SIM_NUM >= 4)
            #endif // (MMI_MAX_SIM_NUM >= 3)
            #endif // (MMI_MAX_SIM_NUM >= 2)

                data.launch_mode = UC_LAUNCH_MODE_NORMAL;

                vapp_ucm_scr->enterUC(&data);
            }
            break;
        }
    #endif // __MMI_UCM_REJECT_BY_SMS__
        case VAPP_UCM_ACT_AREA_BTN1:
        {
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN2:
        {
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN3:
        {
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN4:
        {
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN5:
        {
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN6:
        {
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN7:
        {
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN8:
        {
            break;
        }
        default:
            break;
    }
    m_signalScrnLockTimer.emit(VAPP_UCM_TIMER_RESET);
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CAC", SA_stop);
#endif
}

void VappUcmCallCell::setActBtnDisable(VappUcmActionAreaBtnEnum btn_id, VfxBool disable)
{
    if (m_actionArea)
    {
        VfxU8 btn_idx = m_actionArea->m_actionButtonGroup->getBtnIndex(btn_id);
        m_actionArea->m_actionButtonGroup->setBtnDisable(btn_idx, disable);
    }
}

void VappUcmCallCell::setActBtnSwitchOn(VappUcmActionAreaBtnEnum btn_id, VfxBool switch_on)
{
    if (m_actionArea)
    {
        VfxU8 btn_idx = m_actionArea->m_actionButtonGroup->getBtnIndex(btn_id);
        m_actionArea->m_actionButtonGroup->setBtnSwitchOn(btn_idx, switch_on);
    }
}

void VappUcmCallCell::showDialPad(VfxBool show)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CDP", SA_start);
#endif
    m_signalShowDialPad.emit(show);
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CDP", SA_stop);
#endif
}

VfxWString VappUcmCallCell::getCallTimeDurationStr(void)
{
    VfxDateTime diff_time, current_time;
    VfxWChar    duration_str[16];

    if (m_callStartTime.isValidDate())
    {
        current_time.setCurrentTime();
        current_time.getDiff(m_callStartTime, diff_time);
        diff_time.getDateTimeString(VFX_DATE_TIME_TIME_HOUR | VFX_DATE_TIME_TIME_MINUTE | VFX_DATE_TIME_TIME_SECOND | VFX_DATE_TIME_DURATION_FULL_FORMAT, 
                                    duration_str, 16);
    }
    else
    {
        // for video call, call start time is invalid before START_COUNT
        duration_str[0] = L'\0';
    }
    return VFX_WSTR_MEM(duration_str);
}

void VappUcmCallCell::startCallTimer(void)
{
    if (!m_timer)
    {
        VFX_OBJ_CREATE(m_timer, VfxTimer, this);
        m_timer->setDuration(500);
        m_timer->m_signalTick.connect(this, &VappUcmCallCell::onIntCallTimerTicked);
    }
    m_timer->start();
}

void VappUcmCallCell::stopCallTimer(void)
{
    if (m_timer)
    {
        m_timer->stop();
    }
}

void VappUcmCallCell::onIntCallTimerTicked(VfxTimer *timer)
{
    if (timer == m_timer)
    {
        onCallTimerTicked(timer);
    }
    else if (timer == m_notifyTimer)
    {
        if (SRV_UCM_INCOMING_STATE == m_groupInfo.call_state)
        {
            m_callStatus->setString(STR_ID_VAPP_UCM_INCOMING);
        }
        else if (SRV_UCM_OUTGOING_STATE == m_groupInfo.call_state)
        {
            m_callStatus->setString(STR_ID_VAPP_UCM_DIALING);
        }
        else
        {
            onCallTimerTicked(timer);
            if (m_timer)
            {
                m_timer->start();
            }
        }
        if (m_recIcon)
        {
            updateRecIcon();
            m_recIcon->setHidden(VFX_FALSE);
        }
    }
}

void VappUcmCallCell::onCallTimerTicked(VfxTimer * timer)
{
    // for UI Performance
    // If Keypad or More popup is showing, there is no need to update call duration
    if (!isReducedCell())
    {
        if (m_isMorePopupShowing)   return;
        VappUcmMainPage *mainPage = VFX_OBJ_DYNAMIC_CAST(getParentControl(), VappUcmMainPage);
        if (mainPage && mainPage->isKeyPadEnabled()) return;
    }
    
    if (SRV_UCM_HOLD_STATE == m_groupInfo.call_state)
    {
        VfxWString str;
		str.loadFromRes(STR_ID_VAPP_UCM_ON_HOLD);
    #if (defined __MMI_MAINLCD_240X320__) || (defined __MMI_MAINLCD_240X400__)
        if(m_cellType == VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL3 || m_cellType == VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL2 || m_cellType == VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1)
        {
    #endif
            str += VFX_WSTR(" ");
            str += getCallTimeDurationStr();
    #if (defined __MMI_MAINLCD_240X320__) || (defined __MMI_MAINLCD_240X400__)
        }
    #endif
        m_callStatus->setString(str);
    }
    else
    {
        VfxWString str = getCallTimeDurationStr();
        m_callStatus->setString(str);
    }
}

void VappUcmCallCell::hideActionArea(VfxBool hide)
{
    if (m_actionArea)
    {
        m_actionArea->setHidden(hide);
    }
}

void VappUcmCallCell::startRecord()
{
#ifdef __LOW_COST_SUPPORT_COMMON__
    if (MMI_FALSE == srv_fmgr_drv_is_accessible(srv_fmgr_drv_get_letter_by_type(SRV_FMGR_DRV_CARD_TYPE)))
    {
        mmi_frm_nmgr_balloon(
            MMI_SCENARIO_ID_DEFAULT,
            MMI_EVENT_INFO_BALLOON,
            MMI_NMGR_BALLOON_TYPE_INFO,
            (WCHAR *)VFX_WSTR_RES(STR_ID_VAPP_UCM_INSERT_MEMORY_CARD).getBuf());
        return;
    }
#endif // __LOW_COST_SUPPORT_COMMON__
    if (!vapp_ucm_is_recording)
    {
        VfxDateTime current_time;
        VfxU16 date_str[32];
        current_time.setCurrentTime();
        current_time.getDateTimeString(VFX_DATE_TIME_DATE_MASK | VFX_DATE_TIME_TIME_MASK |VFX_DATE_TIME_FORMAT_NO_DATE_SEPARATOR, date_str, 32);
        for (VfxU32 idx = 0; idx < 32 && date_str[idx] != 0; ++idx)
        {
            if (date_str[idx] == ' ' || date_str[idx] == ':')
            {
                date_str[idx] = '_';
            }
        }
        VfxU16 filepath[128];
        VfxU8 m_drive = srv_soundrec_get_storage();
        mdi_audio_rec_param_struct rec_param;
        mdi_audio_get_record_param(MDI_AUDIO_REC_MODE_SPEECH, srv_soundrec_get_mdi_quality(), &rec_param);
        kal_wsprintf(filepath, "%c:\\%w", m_drive, RECORD_DOWNLOAD_FOLDER_NAME);
        srv_fmgr_fs_create_folder(filepath);
        kal_wsprintf(filepath, "%c:\\%w\\call_%w%w", m_drive, RECORD_DOWNLOAD_FOLDER_NAME, date_str, rec_param.file_ext);

        MMI_TRACE(TRACE_GROUP_5, TRC_VAPP_UCM_RECORD, VFX_TRUE, 0);
        mdi_result ret = mdi_audio_start_record_with_limit(filepath, rec_param.format, srv_soundrec_get_mdi_quality(), vapp_ucm_mdi_callback, NULL, 0, 0);

        if (MDI_AUDIO_SUCCESS == ret)
        {
            vapp_ucm_is_recording = VFX_TRUE;
            updateActionButtons(m_actionArea);
            updateRecIcon();
        }
        else
        {
            MMI_TRACE(TRACE_GROUP_5, TRC_VAPP_UCM_RECORD, VFX_FALSE, ret);
            VfxResId txtId;
            txtId = ((MDI_AUDIO_DISC_FULL == ret) ? STR_GLOBAL_MEMORY_FULL : STR_GLOBAL_ERROR);
            mmi_frm_nmgr_balloon(
    			MMI_SCENARIO_ID_DEFAULT,
    			MMI_EVENT_INFO_BALLOON,
    			MMI_NMGR_BALLOON_TYPE_INFO,
    			(WCHAR *)VFX_WSTR_RES(txtId).getBuf());
        }
    }
}

void VappUcmCallCell::updateRecIcon()
{
    /* common part
     * call cells shall override this virtual func to implement the specific update procedure
     */
    if (!vapp_ucm_is_recording || isReducedCell())
    {
        VFX_OBJ_CLOSE(m_recIcon);
        return;
    }

    if (!m_recIcon)
    {
        VFX_OBJ_CREATE(m_recIcon, VfxImageFrame, this);
        m_recIcon->setImgContent(VfxImageSrc(IMG_ID_VAPP_UCM_RECORDING));
    }

    // layout style 1
    VfxRect rect = m_callStatus->getRect();
    m_recIcon->setAnchor(1.0f, 0.5f);
    m_recIcon->setPos(rect.getMinX() - VAPP_UCM_REC_ICON_GAP, rect.getMidY());
    m_recIcon->bringToFront();

}

void VappUcmCallCell::stopRecord()
{
    vapp_ucm_is_recording = VFX_FALSE;
    mdi_audio_stop_record();
    updateActionButtons(m_actionArea);
    VFX_OBJ_CLOSE(m_recIcon);
}

void VappUcmCallCell::showStatusNotify(VfxWString string)
{
    if (!m_notifyTimer)
    {
        VFX_OBJ_CREATE(m_notifyTimer, VfxTimer, this);
        m_notifyTimer->setStartDelay(3000);
        m_notifyTimer->m_signalTick.connect(this, &VappUcmCallCell::onIntCallTimerTicked);
    }
    if (m_recIcon)
    {
        m_recIcon->setHidden(VFX_TRUE);
    }
    updateCallStatus(string);
    m_notifyTimer->start();
    if (m_timer)
    {
        m_timer->stop();
    }

}

void VappUcmCallCell::updateCallStatus(VfxWString& str)
{
    m_callStatus->setString(str);
}
void VappUcmCallCell::updateCallStatus(VfxResId res_id)
{
	m_callStatus->setString(res_id);
}
void VappUcmCallCell::updateCallStatus(VfxWChar* str)
{
	m_callStatus->setString(str);
}


VfxBool VappUcmCallCell::isReducedCell()
{
    switch (m_cellType)
    {
        case VAPP_UCM_CALL_CELL_TYPE_REDUCED1:
        case VAPP_UCM_CALL_CELL_TYPE_REDUCED2:
            return VFX_TRUE;

        default:
            return VFX_FALSE;
    }

}

VFX_IMPLEMENT_CLASS("VappUcmVoiceCallCell", VappUcmVoiceCallCell, VappUcmCallCell);

void VappUcmVoiceCallCell::onInit()
{
    VappUcmCallCell::onInit();

    m_confCallType = VAPP_UCM_CONF_CALL_NONE;
    m_numCalls = 0;

    m_frame = NULL;
    m_infoBar = NULL;
    m_infoBarBg = NULL;
    m_displayName = NULL;
    m_number = NULL;
    m_callerPic = NULL;
    for (VfxU32 idx = 0; idx < MAX_CONF_CALLEE; ++idx)
    {
        m_confDisplayName[idx] = NULL;
        m_confCallerPic[idx] = NULL;
    }
#if (!defined(__LOW_COST_SUPPORT_COMMON__) && !defined(__MMI_UCM_SLIM__))
    m_dialing_ani_left = NULL;
    m_dialing_ani_right = NULL;
#endif // __LOW_COST_SUPPORT_COMMON__
#if 0
/* under construction !*/
#endif
    m_confSelectMenu = NULL;
}

void VappUcmVoiceCallCell::setCallNumber(VfxU8 num)
{
    m_numCalls = num;
    if (m_numCalls > 1)
    {
	#if (defined __MMI_MAINLCD_320X480__) || (defined __MMI_MAINLCD_480X800__)
        if (VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL2 == m_cellType
            || VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL3 == m_cellType)
        {
            m_confCallType = VAPP_UCM_CONF_CALL_REDUCED;
        }
        else
        {
            m_confCallType = VAPP_UCM_CONF_CALL_NORMAL;
        }
	#else
			m_confCallType = VAPP_UCM_CONF_CALL_REDUCED;
	#endif
    }
    else
    {
        m_confCallType = VAPP_UCM_CONF_CALL_NONE;
    }
}

void VappUcmVoiceCallCell::updateInfoBar(srv_ucm_call_info_struct *call_info)
{
    VFX_ASSERT(NULL != call_info);
    VfxWString txtInfo;
    VfxResId txtId = STR_GLOBAL_END;
    if (srv_sim_ctrl_get_num_of_inserted() > 1)
    {
        if (call_info->uid_info.call_type & SRV_UCM_SIM1_CALL_TYPE_ALL)
        {
            txtId = STR_GLOBAL_SIM_1;
        }
    #if (MMI_MAX_SIM_NUM >= 2)
        else if (call_info->uid_info.call_type & SRV_UCM_SIM2_CALL_TYPE_ALL)
        {
            txtId = STR_GLOBAL_SIM_2;
        }
    #if (MMI_MAX_SIM_NUM >= 3)
        else if (call_info->uid_info.call_type & SRV_UCM_SIM3_CALL_TYPE_ALL)
        {
            txtId = STR_GLOBAL_SIM_3;
        }
    #if (MMI_MAX_SIM_NUM >= 4)
        else if (call_info->uid_info.call_type & SRV_UCM_SIM4_CALL_TYPE_ALL)
        {
            txtId = STR_GLOBAL_SIM_4;
        }
    #endif // (MMI_MAX_SIM_NUM >= 4)
    #endif // (MMI_MAX_SIM_NUM >= 3)
    #endif // (MMI_MAX_SIM_NUM >= 2)

        txtInfo = VFX_WSTR_RES(txtId);
        if (call_info->uid_info.call_type & SRV_UCM_DATA_CALL_TYPE_ALL)
        {
            txtInfo += VFX_WSTR(", ");
            txtInfo += VFX_WSTR_RES(STR_ID_VAPP_UCM_DATA_CALL);
        }
        else if (call_info->uid_info.call_type & SRV_UCM_CSD_CALL_TYPE_ALL)
        {
            txtInfo += VFX_WSTR(", ");
            txtInfo += VFX_WSTR_RES(STR_ID_VAPP_UCM_CSD_CALL);
        }
        else 
        {
            if (call_info->remote_info.line_icon)
            {
                txtInfo += VFX_WSTR(", ");
                if (IMG_ID_GCALL_LINE2 == call_info->remote_info.line_icon)
                {
                    txtId = STR_ID_VAPP_UCM_LINE2;
                }
                else
                {
                    txtId = STR_ID_VAPP_UCM_LINE1;
                }
                txtInfo += VFX_WSTR_RES(txtId);
            }
        }
    }
    else
    {
        if (call_info->uid_info.call_type & SRV_UCM_DATA_CALL_TYPE_ALL)
        {
            txtId = STR_ID_VAPP_UCM_DATA_CALL;
        }
        else if (call_info->uid_info.call_type & SRV_UCM_CSD_CALL_TYPE_ALL)
        {
            txtId = STR_ID_VAPP_UCM_CSD_CALL;
        }
        else 
        {
            if (call_info->remote_info.line_icon)
            {
                if (IMG_ID_GCALL_LINE2 == call_info->remote_info.line_icon)
                {
                    txtId = STR_ID_VAPP_UCM_LINE2;
                }
                else
                {
                    txtId = STR_ID_VAPP_UCM_LINE1;
                }
            }
            else
            {
                txtId = STR_ID_VAPP_UCM_VOICE_CALL;
            }
        }
        txtInfo = VFX_WSTR_RES(txtId);
    }
    if (m_infoBar)
    {
        m_infoBar->setString(txtInfo);
    }
}

void VappUcmVoiceCallCell::updateDisplayName(srv_ucm_call_info_struct *call_info)
{
    VFX_ASSERT(NULL != call_info);
    if (m_groupInfo.call_type & SRV_UCM_CSD_CALL_TYPE_ALL)
    {
        m_displayName->setString(STR_ID_VAPP_UCM_CSD_CALL);
    }
    else if(m_groupInfo.call_type & SRV_UCM_DATA_CALL_TYPE_ALL)
    {
        m_displayName->setString(STR_ID_VAPP_UCM_DATA_CALL);
    }
    else
    {
        m_displayName->setString(call_info->remote_info.disp_name);
    }
    m_displayName->setColor(VFX_COLOR_WHITE);
    m_displayName->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_DISPLAY_NAME_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
}

void VappUcmVoiceCallCell::updateNumber(srv_ucm_call_info_struct *call_info)
{
    VFX_ASSERT(NULL != call_info);
    VfxWString txtNumber;
#ifdef __MMI_UCM_NUMBER_TYPE__
    if (call_info->remote_info.number_type >= MMI_PHB_NUM_TYPE_USER_BASE)
    {
        WCHAR* label = srv_phb_get_field_type_label((U8)call_info->remote_info.number_type,
                                    MMI_PHB_CONTACT_FIELD_ID_NUMBER,
                                    (phb_storage_enum)srv_phb_get_storage(call_info->remote_info.phb_id.contact_index));
        txtNumber = VFX_WSTR_MEM(label);
        txtNumber += VFX_WSTR(" ");
    }
    else
    {
        VfxResId txtId;
        switch (call_info->remote_info.number_type)
        {
            case MMI_PHB_NUM_TYPE_MOBILE:
                txtId = STR_ID_VAPP_UCM_NUM_TYPE_MOBILE;
                break;
            case MMI_PHB_NUM_TYPE_HOME:
                txtId = STR_ID_VAPP_UCM_NUM_TYPE_HOME;
                break;
            case MMI_PHB_NUM_TYPE_OFFICE:
                txtId = STR_ID_VAPP_UCM_NUM_TYPE_OFFICE;
                break;
            case MMI_PHB_NUM_TYPE_FAX:
                txtId = STR_ID_VAPP_UCM_NUM_TYPE_FAX;
                break;
            default:
                txtId = STR_ID_VAPP_UCM_NUM_TYPE_MOBILE;
                break;
        }
        txtNumber = VFX_WSTR_RES(txtId);
    }
#else
        // don't display the number type
#endif // __MMI_UCM_NUMBER_TYPE__
        VfxWChar *w_number;
        VFX_ALLOC_MEM(w_number, sizeof(VfxWChar) * 64, this);
        memset(w_number, 0, 64);
        mmi_asc_to_ucs2((CHAR*)w_number, (CHAR*)call_info->remote_info.num_uri);
        if (m_groupInfo.call_type & SRV_UCM_CSD_CALL_TYPE_ALL 
            || m_groupInfo.call_type & SRV_UCM_DATA_CALL_TYPE_ALL)
        {
            txtNumber = VFX_WSTR_MEM(w_number);
        }
        else
        {
        #ifdef __IP_NUMBER__
            if (SRV_UCM_INVALID_ID != m_groupInfo.group_id
				&& srv_ucm_query_group_exist(m_groupInfo.group_id, SRV_UCM_CALL_TYPE_ALL, 
				(srv_ucm_call_state_enum)SRV_UCM_OUTGOING_STATE)
                && mmi_ucs2strlen((CHAR*)g_ucm_p->full_mo_mt_display.mo_mt_display.ip_num))
            {
                txtNumber = VFX_WSTR_MEM(g_ucm_p->full_mo_mt_display.mo_mt_display.ip_num);
				memcpy(g_ucm_ip_num.g_ip_num, g_ucm_p->full_mo_mt_display.mo_mt_display.ip_num, SRV_UCM_MAX_IP_NUMBER_LEN + 1);
				g_ucm_ip_num.group_id = m_groupInfo.group_id;
            }
			else if (g_ucm_ip_num.group_id == m_groupInfo.group_id 
				&& srv_ucm_query_group_exist(m_groupInfo.group_id, SRV_UCM_CALL_TYPE_ALL, 
				(srv_ucm_call_state_enum) (SRV_UCM_ACTIVE_STATE | SRV_UCM_HOLD_STATE)))
			{
				txtNumber = VFX_WSTR_MEM(g_ucm_ip_num.g_ip_num);
			}
        #endif
            txtNumber += VFX_WSTR_MEM(w_number);
        }
        m_number->setString(txtNumber);
        m_number->setColor(VFX_COLOR_WHITE);
        m_number->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_NUMBER_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
        VFX_FREE_MEM(w_number);

}

void VappUcmVoiceCallCell::updateCallerPic(srv_ucm_call_info_struct *call_info)
{
    VFX_ASSERT(NULL != call_info);
    if (SRV_UCM_INVALID_ID == call_info->uid_info.call_id
        || SRV_UCM_INVALID_ID == call_info->uid_info.group_id)
    {
        m_callerPic->setImgResId(IMG_COSMOS_HEAD_PORTRAIT_2);
    }
    else
    {
    #if defined(__SAT__) && !defined(__SAT_DISABLE_ICON_SUPPORT__)
        mmi_sim_enum sim_id = MMI_SIM1;
    #if (MMI_MAX_SIM_NUM >= 2)
        if (call_info->uid_info.call_type & SRV_UCM_SIM2_CALL_TYPE_ALL)
        {
            sim_id = MMI_SIM2;
        }
    #if (MMI_MAX_SIM_NUM >= 3)
        else if (call_info->uid_info.call_type & SRV_UCM_SIM3_CALL_TYPE_ALL)
        {
            sim_id = MMI_SIM3;
        }
    #if (MMI_MAX_SIM_NUM >= 4)
        else if (call_info->uid_info.call_type & SRV_UCM_SIM4_CALL_TYPE_ALL)
        {
            sim_id = MMI_SIM4;
        }
    #endif // (MMI_MAX_SIM_NUM >= 4)
    #endif // (MMI_MAX_SIM_NUM >= 3)
    #endif // (MMI_MAX_SIM_NUM >= 2)
    #ifndef  __SAT_DISABLE_ICON_SUPPORT__
        if (SRV_UCM_MODULE_ORIGIN_SAT == call_info->module_id && vapp_sat_is_calling_icon_available(sim_id))
        {
            m_callerPic->setImgContent(VfxImageSrc((VfxWChar *)(vapp_sat_get_calling_icon_path(sim_id))));
        }
        else
    #endif  // __SAT_DISABLE_ICON_SUPPORT__
    #endif // __SAT__
        {
            VfxImageSrc image;
            srv_ucm_caller_res_struct caller_res_info;
            srv_ucm_get_caller_res_info(call_info->uid_info, &caller_res_info);
            if (VFX_FLAG_HAS(caller_res_info.res_type, SRV_UCM_RES_TYPE_IMAGE_PATH))
            {
                image = VfxImageSrc(caller_res_info.pic_path);
                if (image.isEmpty())
                {
                    VfxResId imgId;
                    if (caller_res_info.pic_id)
                    {
                        imgId = caller_res_info.pic_id;
                    }
                    else
                    {
                        imgId = IMG_COSMOS_HEAD_PORTRAIT_2;
                    }
                    m_callerPic->setImgResId(imgId);
                }
                else
                {
                    m_callerPic->setImgContent(image);
                }
            }
            else if (VFX_FLAG_HAS(caller_res_info.res_type, SRV_UCM_RES_TYPE_IMAGE_ID))
            {
                m_callerPic->setImgResId(caller_res_info.pic_id);
            }
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif
        }
    }

}

void VappUcmVoiceCallCell::arrangeConfNormalScreen(void)
{
    // calculate the position of each caller
    // Set position of caller_pic, display_name
    VfxU16 h_gap, h_gap2, v_gap;
    VfxU16 total_width = m_frame->getSize().width;
    VfxU16 total_height = m_frame->getSize().height - m_infoBarBg->getSize().height - m_callStatusBg->getSize().height;

    switch (m_numCalls)
    {
        case 2:
        {
            VfxU16   text_height = m_confDisplayName[0]->getBounds().size.height;

            h_gap = (total_width - VAPP_UCM_CONF_TWO_CALLER_PIC_SIZE * 2) / 3;
            v_gap = (total_height - VAPP_UCM_CONF_TWO_CALLER_PIC_SIZE - text_height - VAPP_UCM_CONF_TEXT_PIC_GAP) / 2;
            h_gap2 = 0;
            for (VfxU32 idx = 0; idx < m_numCalls; ++idx)
            {
                m_confCallerPic[idx]->setMaxSize(VfxSize(VAPP_UCM_CONF_TWO_CALLER_PIC_SIZE, VAPP_UCM_CONF_TWO_CALLER_PIC_SIZE));
                m_confCallerPic[idx]->setPos(h_gap * (idx + 1) + (VAPP_UCM_CONF_TWO_CALLER_PIC_SIZE * idx), m_infoBarBg->getSize().height + v_gap+text_height+VAPP_UCM_CONF_TEXT_PIC_GAP);
                m_confCallerPic[idx]->setPlacement(VCP_PHOTO_BORDER_FRAME_PLACEMENT_FIT_EXACT_SIZE);

                m_confDisplayName[idx]->setAnchor(0.5f, 0.0f);
                m_confDisplayName[idx]->setPos(h_gap * (idx + 1) + (VAPP_UCM_CONF_TWO_CALLER_PIC_SIZE * idx) + (VAPP_UCM_CONF_TWO_CALLER_PIC_SIZE >> 1),
                    m_infoBarBg->getSize().height + v_gap);
                m_confDisplayName[idx]->setAutoResized(VFX_FALSE);
                m_confDisplayName[idx]->setSize(VAPP_UCM_CONF_TWO_CALLER_PIC_SIZE + 10, VAPP_UCM_DISPLAY_NAME_FONT + 2);
                m_confDisplayName[idx]->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
                m_confDisplayName[idx]->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
            }
            break;
        }
        case 3:
        {
            if (VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1 == m_cellType)
            {
                VfxU16 text_height = m_confDisplayName[0]->getBounds().size.height;

                h_gap = (total_width - VAPP_UCM_CONF_THREE_CALLER_PIC_SIZE * 3) / 4;
                v_gap = (total_height - VAPP_UCM_CONF_THREE_CALLER_PIC_SIZE - text_height - VAPP_UCM_CONF_TEXT_PIC_GAP) / 2;
                h_gap2 = 0;
                for (VfxU32 idx = 0; idx < m_numCalls; ++idx)
                {
                    m_confCallerPic[idx]->setMaxSize(VfxSize(VAPP_UCM_CONF_THREE_CALLER_PIC_SIZE, VAPP_UCM_CONF_THREE_CALLER_PIC_SIZE));
                    m_confCallerPic[idx]->setPos(h_gap * (idx + 1) + VAPP_UCM_CONF_THREE_CALLER_PIC_SIZE * idx,
                        m_infoBarBg->getSize().height + v_gap + text_height + VAPP_UCM_CONF_TEXT_PIC_GAP);
                    m_confCallerPic[idx]->setPlacement(VCP_PHOTO_BORDER_FRAME_PLACEMENT_FIT_EXACT_SIZE);

                    m_confDisplayName[idx]->setAnchor(0.5f, 0.0f);
                    m_confDisplayName[idx]->setPos((h_gap * (idx + 1)) + (VAPP_UCM_CONF_THREE_CALLER_PIC_SIZE * idx) + (VAPP_UCM_CONF_THREE_CALLER_PIC_SIZE >> 1),
                        m_infoBarBg->getSize().height + v_gap);
                    m_confDisplayName[idx]->setAutoResized(VFX_FALSE);
                    m_confDisplayName[idx]->setSize(VAPP_UCM_CONF_THREE_CALLER_PIC_SIZE + 10, VAPP_UCM_DISPLAY_NAME_FONT + 2);
                    m_confDisplayName[idx]->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
                    m_confDisplayName[idx]->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
                }
            }
            else
            {
                m_confDisplayName[0]->setLineMode(VfxTextFrame::LINE_MODE_MULTI);
                m_confDisplayName[0]->setMaxLines(2);
                m_confDisplayName[0]->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER_WITHIN_MARGIN);
                for (VfxU32 idx = 1; idx < m_numCalls; ++idx)
                {
                    VfxWString str = m_confDisplayName[0]->getString();
                    str += m_confDisplayName[idx]->getString();
                    m_confDisplayName[0]->setString(str);
                    m_confDisplayName[idx]->setHidden(VFX_TRUE);
                }
                m_confDisplayName[0]->forceUpdate();

                VfxU16 text_height = m_confDisplayName[0]->getBounds().size.height;

                v_gap = (total_height - (VAPP_UCM_CONF_THREE_CALLER_PIC_SIZE + text_height))/3;

                m_confCallerPic[0]->setMaxSize(VfxSize(VAPP_UCM_CONF_THREE_CALLER_PIC_SIZE, VAPP_UCM_CONF_THREE_CALLER_PIC_SIZE));
                m_confCallerPic[0]->setPos(total_width >> 1, m_infoBarBg->getSize().height + v_gap + text_height + v_gap);
                m_confCallerPic[0]->setPlacement(VCP_PHOTO_BORDER_FRAME_PLACEMENT_FIT_EXACT_SIZE);
                m_confDisplayName[0]->setAnchor(0.5f, 0.0f);
                m_confDisplayName[0]->setPos(total_width >> 1, m_infoBarBg->getSize().height + v_gap);
                m_confDisplayName[0]->setAutoResized(VFX_FALSE);
                m_confDisplayName[0]->setSize(VAPP_UCM_CONF_THREE_CALLER_PIC_SIZE + 10, VAPP_UCM_DISPLAY_NAME_FONT + 2);
                m_confDisplayName[0]->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
                m_confDisplayName[0]->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
            }
            break;
        }
        case 4:
        {
            if (VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1 == m_cellType)
            {
                VfxU16 text_height = m_confDisplayName[0]->getBounds().size.height;
                VfxU16 item_height = text_height + VAPP_UCM_CONF_TEXT_PIC_GAP + VAPP_UCM_CONF_FOUR_CALLER_PIC_SIZE;
                h_gap = (total_width - VAPP_UCM_CONF_FOUR_CALLER_PIC_SIZE * 3) / 4;
                h_gap2 = total_width / 2;
                v_gap = (total_height - (item_height << 1)) / 3;
                for (VfxU32 idx = 0; idx < m_numCalls; ++idx)
                {
                    m_confCallerPic[idx]->setMaxSize(VfxSize(VAPP_UCM_CONF_FOUR_CALLER_PIC_SIZE, VAPP_UCM_CONF_FOUR_CALLER_PIC_SIZE));
                    m_confCallerPic[idx]->setPlacement(VCP_PHOTO_BORDER_FRAME_PLACEMENT_FIT_EXACT_SIZE);
                    m_confDisplayName[idx]->setAnchor(0.5f, 0.0f);
                    m_confDisplayName[idx]->setAutoResized(VFX_FALSE);
                    m_confDisplayName[idx]->setSize(VAPP_UCM_CONF_FOUR_CALLER_PIC_SIZE + 10, VAPP_UCM_DISPLAY_NAME_FONT + 2);
                    m_confDisplayName[idx]->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
                    m_confDisplayName[idx]->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
                    if (3 == idx)
                    {
                        m_confCallerPic[idx]->setAnchor(0.5f, 0.0f);
                        m_confCallerPic[idx]->setPos(h_gap2,
                            m_infoBarBg->getSize().height + ((v_gap + text_height + VAPP_UCM_CONF_TEXT_PIC_GAP) << 1) + VAPP_UCM_CONF_FOUR_CALLER_PIC_SIZE);
                        m_confDisplayName[idx]->setPos(h_gap2,
                            m_infoBarBg->getSize().height + v_gap + text_height + VAPP_UCM_CONF_TEXT_PIC_GAP + VAPP_UCM_CONF_FOUR_CALLER_PIC_SIZE + v_gap);
                    }
                    else
                    {
                        m_confCallerPic[idx]->setPos((h_gap * (idx + 1)) + (VAPP_UCM_CONF_FOUR_CALLER_PIC_SIZE * idx) , m_infoBarBg->getSize().height + v_gap + text_height + VAPP_UCM_CONF_TEXT_PIC_GAP);
                        m_confDisplayName[idx]->setPos((h_gap * (idx + 1)) + (VAPP_UCM_CONF_FOUR_CALLER_PIC_SIZE * idx)  + (VAPP_UCM_CONF_FOUR_CALLER_PIC_SIZE >> 1),
                            m_infoBarBg->getSize().height + v_gap);
                    }
                }
            }
            else
            {
                VfxU16 text_height = m_confDisplayName[0]->getBounds().size.height;

                m_confDisplayName[0]->setLineMode(VfxTextFrame::LINE_MODE_MULTI);
                m_confDisplayName[0]->setMaxLines(2);
                m_confDisplayName[0]->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER_WITHIN_MARGIN);
                m_confDisplayName[0]->setAutoResized(VFX_FALSE);
                m_confDisplayName[0]->setSize(VAPP_UCM_CONF_FOUR_CALLER_PIC_SIZE + 10, VAPP_UCM_DISPLAY_NAME_FONT + 2);
                m_confDisplayName[0]->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
                m_confDisplayName[0]->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
                for (VfxU32 idx = 1; idx < m_numCalls; ++idx)
                {
                    VfxWString str = m_confDisplayName[0]->getString();
                    str += m_confDisplayName[idx]->getString();
                    m_confDisplayName[0]->setString(str);
                    m_confDisplayName[idx]->setHidden(VFX_TRUE);
                }
                m_confDisplayName[0]->forceUpdate();

                v_gap = (total_height - (VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE + text_height)) / 3;

                m_confCallerPic[0]->setSize(VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE, VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE);
                m_confCallerPic[0]->setSize(total_width >> 1, v_gap + text_height + v_gap);
                m_confDisplayName[0]->setAnchor(0.5f, 0.0f);
                m_confDisplayName[0]->setPos(total_width >> 1, m_infoBarBg->getSize().height + v_gap);
            }
            break;
        }
        case 5:
        {
            if (VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1 == m_cellType)
            {
                VfxU16 text_height = m_confDisplayName[0]->getBounds().size.height;
                VfxU16 item_height = text_height + VAPP_UCM_CONF_TEXT_PIC_GAP + VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE;
                h_gap = (total_width - VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE * 3) / 4;
                h_gap2 = (total_width - VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE * 2) / 3;
                v_gap = (total_height - (item_height << 1)) / 3;
                for (VfxU32 idx = 0; idx < m_numCalls; ++idx)
                {
                    m_confCallerPic[idx]->setMaxSize(VfxSize(VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE, VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE));
                    m_confCallerPic[idx]->setPlacement(VCP_PHOTO_BORDER_FRAME_PLACEMENT_FIT_EXACT_SIZE);
                    m_confDisplayName[idx]->setAnchor(0.5f, 0.0f);
                    m_confDisplayName[idx]->setAutoResized(VFX_FALSE);
                    m_confDisplayName[idx]->setSize(VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE + 10, VAPP_UCM_DISPLAY_NAME_FONT + 2);
                    m_confDisplayName[idx]->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
                    m_confDisplayName[idx]->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
                    if (3 == idx || 4 == idx)
                    {
                        m_confCallerPic[idx]->setPos(h_gap2 * (idx - 2) + (VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE * (idx - 3)),
                            m_infoBarBg->getSize().height + ((v_gap + text_height + VAPP_UCM_CONF_TEXT_PIC_GAP) << 1) + VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE);
                        m_confDisplayName[idx]->setPos(h_gap2 * (idx - 2)  + (VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE * (idx - 3)) + (VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE >> 1),
                            m_infoBarBg->getSize().height + v_gap + text_height + VAPP_UCM_CONF_TEXT_PIC_GAP + v_gap + VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE);
                    }
                    else
                    {
                        m_confCallerPic[idx]->setPos(h_gap * (idx + 1) + (VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE * idx),
                            m_infoBarBg->getSize().height + v_gap + text_height + VAPP_UCM_CONF_TEXT_PIC_GAP);
                        m_confDisplayName[idx]->setPos(h_gap * (idx + 1)  + (VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE * idx) + (VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE >> 1),
                            m_infoBarBg->getSize().height + v_gap);
                    }
                }
            }
            else
            {
                VfxU16 text_height = m_confDisplayName[0]->getBounds().size.height;

                m_confDisplayName[0]->setLineMode(VfxTextFrame::LINE_MODE_MULTI);
                m_confDisplayName[0]->setMaxLines(2);
                m_confDisplayName[0]->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER_WITHIN_MARGIN);
                for (VfxU32 idx = 1; idx < m_numCalls; ++idx)
                {
                    VfxWString str = m_confDisplayName[0]->getString();
                    str += m_confDisplayName[idx]->getString();
                    m_confDisplayName[0]->setString(str);
                    m_confDisplayName[idx]->setHidden(VFX_TRUE);
                }
                m_confDisplayName[0]->setAutoResized(VFX_FALSE);
                m_confDisplayName[0]->setSize(VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE + 10, VAPP_UCM_DISPLAY_NAME_FONT + 2);
                m_confDisplayName[0]->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
                m_confDisplayName[0]->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
                m_confDisplayName[0]->forceUpdate();

                v_gap = (total_height - (VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE + text_height)) / 3;

                m_confCallerPic[0]->setSize(VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE, VAPP_UCM_CONF_FIVE_CALLER_PIC_SIZE);
                m_confCallerPic[0]->setSize((total_width >> 1), v_gap + text_height + v_gap);
                m_confDisplayName[0]->setAnchor(0.5f, 0.0f);
                m_confDisplayName[0]->setPos((total_width >> 1), m_infoBarBg->getSize().height + v_gap);
            }
            break;
        }
        default:
        {
            VFX_ASSERT(0);
        }
    }// switch (m_numCalls)
}

void VappUcmVoiceCallCell::loadXML(VfxResId xml_layout_id, VfxBool is_reduced_cell)
{
        VfxXmlLoader::loadBegin(this, xml_layout_id);
        m_frame = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_frame")), VfxFrame);
        if (VAPP_UCM_CONF_CALL_NORMAL == m_confCallType 
            || VAPP_UCM_CONF_CALL_REDUCED == m_confCallType)
        {
            m_callStatus = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_callStatus")), VfxTextFrame);
            m_callStatusBg = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_callStatusBg")), VfxFrame);
            if (is_reduced_cell)
            {
                m_callerPic = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_callerPic")), VcpPhotoBorderFrame);
                m_displayName = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_displayName")), VfxTextFrame);
                m_displayName->setAutoResized(VFX_FALSE);
                m_displayName->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
                m_displayName->setAlignMode(VfxTextFrame::ALIGN_MODE_LEFT);
            }
            else
            {
                if (VAPP_UCM_CONF_CALL_REDUCED == m_confCallType)
                {
                    m_callerPic = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_callerPic")), VcpPhotoBorderFrame);
                    m_displayName = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_displayName")), VfxTextFrame);
                    m_displayName->setAutoResized(VFX_FALSE);
                    m_displayName->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
                    m_displayName->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
                }
                m_infoBar = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_infoBar")), VfxTextFrame);
                m_infoBarBg = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_infoBarBg")), VfxFrame);
            }
        }
        else
        {
            m_displayName = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_displayName")), VfxTextFrame);
            m_displayName->setAutoResized(VFX_FALSE);
            m_displayName->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
            if (xml_layout_id != VAPP_UCM_CALL_CELL_LAYOUT_REDUCED)
            {
                m_displayName->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
            }
            m_callStatus = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_callStatus")), VfxTextFrame);
            m_callStatusBg = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_callStatusBg")), VfxFrame);
            m_callerPic = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_callerPic")), VcpPhotoBorderFrame);
            if (!is_reduced_cell)
            {
                m_infoBar = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_infoBar")), VfxTextFrame);
                m_infoBarBg = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_infoBarBg")), VfxFrame);
                m_number = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_number")), VfxTextFrame);
                m_number->setAutoResized(VFX_FALSE);
                m_number->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
                m_number->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
            #if (!defined(__LOW_COST_SUPPORT_COMMON__) && !defined(__MMI_UCM_SLIM__))
                m_dialing_ani_left = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_dialing_ani_left")), VfxAnimImageFrame);
                m_dialing_ani_left->play();
                m_dialing_ani_right = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_dialing_ani_right")), VfxAnimImageFrame);
                m_dialing_ani_right->play();
            #endif // __LOW_COST_SUPPORT_COMMON__
            }
        }
        VfxXmlLoader::loadEnd();
}

void VappUcmVoiceCallCell::updateScreen()
{
    VfxResId xml_layout_id = 0;

    // 1. Decide XML layout type
    switch (m_cellType)
    {
        case VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1:
        {
            if (VAPP_UCM_CONF_CALL_NONE == m_confCallType)
            {
                xml_layout_id =  VAPP_UCM_CALL_CELL_LAYOUT_NORMAL_LEVEL1;
            }
            else
            {
                xml_layout_id = VAPP_UCM_CALL_CELL_LAYOUT_NORMAL_LEVEL1_CONF;
            }
            break;
        }
        
        case VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL2:
        {
            if (VAPP_UCM_CONF_CALL_NONE == m_confCallType)
            {
                xml_layout_id =  VAPP_UCM_CALL_CELL_LAYOUT_NORMAL_LEVEL2;
            }
            else
            {
                xml_layout_id = VAPP_UCM_CALL_CELL_LAYOUT_NORMAL_LEVEL2_CONF;
            }
            break;
        }
        case VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL3:
        {
            if (VAPP_UCM_CONF_CALL_NONE == m_confCallType)
            {
                xml_layout_id =  VAPP_UCM_CALL_CELL_LAYOUT_NORMAL_LEVEL3;
            }
            else
            {
                xml_layout_id = VAPP_UCM_CALL_CELL_LAYOUT_NORMAL_LEVEL3_CONF;
            }
            break;
        }
        case VAPP_UCM_CALL_CELL_TYPE_REDUCED1:
        case VAPP_UCM_CALL_CELL_TYPE_REDUCED2:
        {
            if (VAPP_UCM_CONF_CALL_NONE == m_confCallType)
            {
                xml_layout_id =  VAPP_UCM_CALL_CELL_LAYOUT_REDUCED;
            }
            else
            {
                xml_layout_id = VAPP_UCM_CALL_CELL_LAYOUT_REDUCED_CONF;
            }
            break;
        }
    }

    // 2. Load layout from XML
    if (!m_frame)
    {
        loadXML(xml_layout_id, isReducedCell());
    }

    if (isReducedCell())
    {
        if (!m_simInfoBar)
        {
            VFX_OBJ_CREATE(m_simInfoBar, VfxFrame, this);
        }
        m_simInfoBar->setSize(3, getSize().height - 4);
        m_simInfoBar->setPos(1, 2);
        m_simInfoBar->setBgColor(VfxColor(0xffFAAC05));
        m_simInfoBar->bringToFront();
        m_simInfoBar->setHidden(VFX_FALSE);
    }
    else if (m_simInfoBar)
    {
        m_simInfoBar->setHidden(VFX_TRUE);
    }

    // 3. Create action area if needed
    VFX_OBJ_CLOSE(m_actionArea);
    if (!isReducedCell())
    {
        //MO_2Steps-BEGIN
        if (SRV_UCM_INVALID_ID != m_groupInfo.group_id)
        //MO_2Steps-END
        {
            createActionArea(&m_actionArea);

            if (m_groupInfo.call_type & SRV_UCM_CALL_TYPE_DATA_CSD_ALL)
            {
                m_actionArea->disableAllBtns(VAPP_UCM_DISABLE_ACT_BTN_ALL_EXCEPT_END_KEY);
            }

            if (m_isLocked)
            {
                m_actionArea->setHidden(VFX_TRUE);
            }
        }
    }

    // 4. Set display data/attributes

    VfxImageSrc image;
    if (VAPP_UCM_CONF_CALL_NORMAL == m_confCallType || VAPP_UCM_CONF_CALL_REDUCED == m_confCallType)
    {
        if (!isReducedCell())
        {
            VfxWString txtInfo;
            VfxResId txtId = VFX_RES_ID_NULL;
            srv_ucm_call_info_struct *call_info;
            VFX_ALLOC_MEM(call_info, sizeof(srv_ucm_call_info_struct), this);
            srv_ucm_index_info_struct   call_index;
            call_index.group_index = m_callIndex.group_index;
            call_index.call_index = 0;
            srv_ucm_query_call_data(call_index, call_info);

            if (srv_sim_ctrl_get_num_of_inserted() > 1)
            {
                if (SRV_UCM_VOICE_CALL_TYPE == m_groupInfo.call_type)
                {
                    txtId = STR_GLOBAL_SIM_1;
                }
            #if (MMI_MAX_SIM_NUM >= 2)
                else if (m_groupInfo.call_type == SRV_UCM_VOICE_CALL_TYPE_SIM2)
                {
                    txtId = STR_GLOBAL_SIM_2;
                }
            #if (MMI_MAX_SIM_NUM >= 3)
                else if (m_groupInfo.call_type == SRV_UCM_VOICE_CALL_TYPE_SIM3)
                {
                    txtId = STR_GLOBAL_SIM_3;
                }
            #if (MMI_MAX_SIM_NUM >= 4)
                else if (m_groupInfo.call_type == SRV_UCM_VOICE_CALL_TYPE_SIM4)
                {
                    txtId = STR_GLOBAL_SIM_4;
                }
            #endif // (MMI_MAX_SIM_NUM >= 4)
            #endif // (MMI_MAX_SIM_NUM >= 3)
            #endif // (MMI_MAX_SIM_NUM >= 2)

                if (VFX_RES_ID_NULL != txtId)
                {
                    txtInfo.loadFromRes(txtId);
                }
                if (call_info->remote_info.line_icon)
                {
                    txtInfo += VFX_WSTR(", ");
                    if (IMG_ID_GCALL_LINE2 == call_info->remote_info.line_icon)
                    {
                        txtId = STR_ID_VAPP_UCM_LINE2;
                    }
                    else
                    {
                        txtId = STR_ID_VAPP_UCM_LINE1;
                    }
                    txtInfo += VFX_WSTR_RES(txtId);
                }
            }
            else
            {
                if (call_info->remote_info.line_icon)
                {
                    if (IMG_ID_GCALL_LINE2 == call_info->remote_info.line_icon)
                    {
                        txtId = STR_ID_VAPP_UCM_LINE2;
                    }
                    else
                    {
                        txtId = STR_ID_VAPP_UCM_LINE1;
                    }
                }
                else
                {
                    txtId = STR_ID_VAPP_UCM_VOICE_CALL;
                }
                txtInfo.loadFromRes(txtId);
            }
            VFX_FREE_MEM(call_info);
            m_infoBar->setString(txtInfo);
            m_infoBar->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_INFO_BAR_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
            m_infoBar->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
            m_infoBar->setVerticalToCenter(VFX_TRUE);
            m_infoBarBg->setImgContent(VfxImageSrc(IMG_ID_VAPP_UCM_TITLE_BG));
            m_infoBarBg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
        }

        if (VAPP_UCM_CONF_CALL_NORMAL == m_confCallType && !isReducedCell())
        {
            // Get display name / caller_pic, set start_time
            for (VfxU32 idx = 0; idx < m_numCalls; ++idx)
            {
                srv_ucm_call_info_struct *call_info;
                VFX_ALLOC_MEM(call_info, sizeof(srv_ucm_call_info_struct), this);
                srv_ucm_index_info_struct call_index;

                call_index.group_index = m_callIndex.group_index;
                call_index.call_index = (S32)idx;
                srv_ucm_query_call_data(call_index, call_info);
                srv_ucm_caller_res_struct *caller_res_info;
                VFX_ALLOC_MEM(caller_res_info, sizeof(srv_ucm_caller_res_struct), this);
                srv_ucm_get_caller_res_info(call_info->uid_info, caller_res_info);

                VFX_OBJ_CREATE(m_confDisplayName[idx], VfxTextFrame, m_frame);
                m_confDisplayName[idx]->setString(VFX_WSTR_MEM(call_info->remote_info.disp_name));
                m_confDisplayName[idx]->setColor(VFX_COLOR_WHITE);
                m_confDisplayName[idx]->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_DISPLAY_NAME_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));

                VFX_OBJ_CREATE(m_confCallerPic[idx], VappUcmConfCallerPic, m_frame);
                m_confCallerPic[idx]->setCallIdx(call_index.group_index, call_index.call_index);
                m_confCallerPic[idx]->m_signalClicked.connect(this, &VappUcmVoiceCallCell::onCallerPicClicked);
                // Set caller_pic content
                if (VFX_FLAG_HAS(caller_res_info->res_type, SRV_UCM_RES_TYPE_IMAGE_PATH))
                {
                    image.setPath(caller_res_info->pic_path);
                    if (image.isEmpty()) // invalid file
                    {
                        image.setResId(caller_res_info->pic_id);
                    }
                    m_confCallerPic[idx]->setImgContent(image);
                }
                else if (VFX_FLAG_HAS(caller_res_info->res_type, SRV_UCM_RES_TYPE_IMAGE_ID))
                {
                    m_confCallerPic[idx]->setImgResId(caller_res_info->pic_id);
                }
             #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
             #endif
                VFX_FREE_MEM(call_info);
                VFX_FREE_MEM(caller_res_info);
            }
        }
        else
        {
            VFX_OBJ_CREATE(m_confCallerPic[0], VappUcmConfCallerPic, m_frame);
            m_confCallerPic[0]->setImgResId(IMG_ID_VAPP_UCM_CONFERENCE_CALL);
            m_confCallerPic[0]->setMixedCaller();
            m_confCallerPic[0]->m_signalClicked.connect(this, &VappUcmVoiceCallCell::onCallerPicClicked);

            VFX_OBJ_CREATE(m_confDisplayName[0], VfxTextFrame, m_frame);
            m_confDisplayName[0]->setColor(VFX_COLOR_WHITE);
            m_confDisplayName[0]->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_DISPLAY_NAME_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
            VfxWString caller_name_list;
            for (VfxU32 idx = 0; idx < m_numCalls; ++idx)
            {
                srv_ucm_call_info_struct *call_info;
                VFX_ALLOC_MEM(call_info, sizeof(srv_ucm_call_info_struct), this);
                srv_ucm_index_info_struct   call_index;

                call_index.group_index = m_callIndex.group_index;
                call_index.call_index = (S32)idx;
                srv_ucm_query_call_data(call_index, call_info);
                caller_name_list += VFX_WSTR_MEM(call_info->remote_info.disp_name);
                if (idx != m_numCalls - 1)
                {
                    caller_name_list += VFX_WSTR(", ");
                }
                VFX_FREE_MEM(call_info);
            }
            m_confDisplayName[0]->setString(caller_name_list);
            m_confDisplayName[0]->setHidden(VFX_TRUE);
            m_displayName->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_DISPLAY_NAME_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
            m_displayName->setString(caller_name_list);
        }

        m_callStartTime = getCallStartTime(m_callIndex.group_index);
        switch (m_groupInfo.call_state)
        {
            case SRV_UCM_INCOMING_STATE:
            {
                m_callStatus->setString(STR_ID_VAPP_UCM_INCOMING);
                break;
            }
            case SRV_UCM_OUTGOING_STATE:
            {
                m_callStatus->setString(STR_ID_VAPP_UCM_DIALING);
                break;
            }
            case SRV_UCM_ACTIVE_STATE:
            {
                VfxWString str = getCallTimeDurationStr();
                m_callStatus->setString(str);
                startCallTimer();
                break;
            }
            case SRV_UCM_HOLD_STATE:
            {
                VfxWString str = VFX_WSTR_RES(STR_ID_VAPP_UCM_ON_HOLD);
            #if (defined __MMI_MAINLCD_240X320__) || (defined __MMI_MAINLCD_240X400__)
                if(m_cellType == VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL3 || m_cellType == VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL2 || m_cellType == VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1)
                {
            #endif
                    str += VFX_WSTR(" ");
                    str += getCallTimeDurationStr();
            #if (defined __MMI_MAINLCD_240X320__) || (defined __MMI_MAINLCD_240X400__)
	            }
            #endif
                m_callStatus->setString(str);
                //stopCallTimer();
                break;
            }
        }
        m_callStatus->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
        if (!isReducedCell())
        {
            m_callStatus->setVerticalToCenter(VFX_TRUE);
            m_callStatusBg->setImgContent(VfxImageSrc(IMG_ID_VAPP_UCM_TIME_BG));
            m_callStatusBg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
        }
        m_callStatus->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_CALL_STATUS_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));

        // recording icon
        updateRecIcon();

        // caller pic
        if (isReducedCell())
        {
            m_callerPic->setImgContent(VfxImageSrc(IMG_ID_VAPP_UCM_CONFERENCE_CALL));
            m_displayName->setString(m_confDisplayName[0]->getString());
            m_displayName->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_DISPLAY_NAME_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
            for (VfxU32 idx = 0; idx < m_numCalls; ++idx)
            {
				if(m_confCallerPic[idx])
	                m_confCallerPic[idx]->setHidden(VFX_TRUE);
				if(m_confDisplayName[idx])
	                m_confDisplayName[idx]->setHidden(VFX_TRUE);
            }
        }
        else if (VAPP_UCM_CONF_CALL_REDUCED == m_confCallType)
        {
            m_callerPic->forceUpdate();
            m_confCallerPic[0]->setMaxSize(m_callerPic->getSize());
            m_confCallerPic[0]->setPlacement(VCP_PHOTO_BORDER_FRAME_PLACEMENT_FIT_EXACT_SIZE);
            m_confCallerPic[0]->setAnchor(m_callerPic->getAnchor());
            m_confCallerPic[0]->setPos(m_callerPic->getPos());
            m_callerPic->setHidden(VFX_TRUE);
        }
        else
        {
            arrangeConfNormalScreen();
        }
    }
    else // m_confCallType
    {
        srv_ucm_call_info_struct *call_info;
        VFX_ALLOC_MEM(call_info, sizeof(srv_ucm_call_info_struct), this);
        srv_ucm_query_call_data(m_callIndex, call_info);

        if (!isReducedCell())
        {
            m_infoBar->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_INFO_BAR_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
            m_infoBar->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
            m_infoBar->setVerticalToCenter(VFX_TRUE);
            m_infoBarBg->setImgContent(VfxImageSrc(IMG_ID_VAPP_UCM_TITLE_BG));
            m_infoBarBg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
            updateInfoBar(call_info);
        }
        updateDisplayName(call_info);

        if (!isReducedCell())
        {
            updateNumber(call_info);
        }
        switch (call_info->call_state)
        {
            case SRV_UCM_INCOMING_STATE:
            {
                m_callStatus->setString(STR_ID_VAPP_UCM_INCOMING);
                break;
            }
            case SRV_UCM_OUTGOING_STATE:
            {
                m_callStatus->setString(STR_ID_VAPP_UCM_DIALING);
                break;
            }
            case SRV_UCM_ACTIVE_STATE:
            {
                //TBD:
                m_callStartTime.setDateTime((applib_time_struct*)&(call_info->start_time));
                VfxWString str = getCallTimeDurationStr();
                m_callStatus->setString(str);
            #if (!defined(__LOW_COST_SUPPORT_COMMON__) && !defined(__MMI_UCM_SLIM__))
                if (!isReducedCell())
                {
                    m_dialing_ani_left->setHidden(VFX_TRUE);
                    m_dialing_ani_right->setHidden(VFX_TRUE);
                }
            #endif // __LOW_COST_SUPPORT_COMMON__
                startCallTimer();
                break;
            }
            case SRV_UCM_HOLD_STATE:
            {
                m_callStartTime.setDateTime((applib_time_struct*)&(call_info->start_time));
                VfxWString str = VFX_WSTR_RES(STR_ID_VAPP_UCM_ON_HOLD);
            #if (defined __MMI_MAINLCD_240X320__) || (defined __MMI_MAINLCD_240X400__)
                if(m_cellType == VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL3 || m_cellType == VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL2 || m_cellType == VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1)
                {
            #endif
                    str += VFX_WSTR(" ");
                    str += getCallTimeDurationStr();
            #if (defined __MMI_MAINLCD_240X320__) || (defined __MMI_MAINLCD_240X400__)
	            }
            #endif
                m_callStatus->setString(str);
            #if (!defined(__LOW_COST_SUPPORT_COMMON__) && !defined(__MMI_UCM_SLIM__))
                if (!isReducedCell())
                {
                    m_dialing_ani_left->setHidden(VFX_TRUE);
                    m_dialing_ani_right->setHidden(VFX_TRUE);
                }
            #endif
                break;
            }
        }
        m_callStatus->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
        if (!isReducedCell())
        {
            m_callStatusBg->setImgContent(VfxImageSrc(IMG_ID_VAPP_UCM_TIME_BG));
            m_callStatusBg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
            m_callStatus->setVerticalToCenter(VFX_TRUE);
        }

        m_callStatus->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_CALL_STATUS_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));

        // recording icon
        updateRecIcon();
	#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	#endif
        updateCallerPic(call_info);
        VFX_FREE_MEM(call_info);
    }// m_confCallType

}


void VappUcmVoiceCallCell::onCallerPicClicked(VfxS32 group_id, VfxS32 call_id)
{
    if (-1 == call_id)
    {
        // Mixed Caller
        showConfCallerList(group_id);
    }
    else
    {
        m_confSelectCall.call_index = call_id;
        m_confSelectCall.group_index = group_id;
        vapp_ucmapp_set_active_call_info(&m_confSelectCall);
        showConfCallOptions();
    }
}

void VappUcmVoiceCallCell::onConfCallerSelectCallback(VcpMenuPopup* menu, VcpMenuPopupEventEnum menu_event, VcpMenuPopupItem* item)
{
    m_signalScrnLockTimer.emit(VAPP_UCM_TIMER_START);

    if (VCP_MENU_POPUP_EVENT_ITEM_SELECTED == menu_event)
    {
        onCallerPicClicked(m_callIndex.group_index, item->getId());
    }
    else
    {
        //m_confCallSelectMenu = NULL;
    }
}

void VappUcmVoiceCallCell::onAcceptClickButton(VfxObject* obj, VfxId id)
{
    if (VCP_CONFIRM_POPUP_BUTTON_USER_1 == id)
    {
        vapp_ucm_replace();
    }
    m_signalScrnLockTimer.emit(VAPP_UCM_TIMER_RESET);
}

void VappUcmVoiceCallCell::onActionAreaClicked(VfxId btn, VappUcmActionBtnStateEnum state)
{
    VappUcmActionAreaBtnEnum btn_type = (VappUcmActionAreaBtnEnum)btn;
    switch (btn_type)
    {
        case VAPP_UCM_ACT_AREA_BTN_ACCEPT_CALL:
        {
            VappUcmAllowToAcceptResultEnum result = vapp_ucm_allow_to_accept();
            if (VAPP_UCM_ALLOW_TO_ACCEPT_RET_OK == result)
            {
                vapp_ucm_incoming_call_sendkey();
                m_signalScrnLockTimer.emit(VAPP_UCM_TIMER_RESET);
            }
            else if (VAPP_UCM_ALLOW_TO_ACCEPT_RET_REPLACE_EXISTING == result)
            {
                VcpConfirmPopup *confPopup;
                VFX_OBJ_CREATE(confPopup, VcpConfirmPopup, this);
                confPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
                confPopup->setText(STR_ID_VAPP_UCM_REPLACE_EXISTING_CALL);
                confPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_USER_DEFINE);
                confPopup->setCustomButton(STR_GLOBAL_REPLACE, 
                                            STR_GLOBAL_CANCEL, 
                                            VCP_POPUP_BUTTON_TYPE_NORMAL,
                                            VCP_POPUP_BUTTON_TYPE_CANCEL);
                confPopup->show(VFX_TRUE);
                confPopup->m_signalButtonClicked.connect(this, &VappUcmVoiceCallCell::onAcceptClickButton);

            }
            else if (VAPP_UCM_ALLOW_TO_ACCEPT_RET_END_EXISTING == result)
            {
                VcpConfirmPopup *confPopup;
                VFX_OBJ_CREATE(confPopup, VcpConfirmPopup, this);
                confPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
                confPopup->setText(STR_ID_VAPP_UCM_CALL_WILL_BE_ENDED);
                confPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_USER_DEFINE);
                confPopup->setCustomButton(STR_GLOBAL_ACCEPT, 
                                            STR_GLOBAL_CANCEL, 
                                            VCP_POPUP_BUTTON_TYPE_NORMAL,
                                            VCP_POPUP_BUTTON_TYPE_CANCEL);
                confPopup->m_signalButtonClicked.connect(this, &VappUcmVoiceCallCell::onAcceptClickButton);
                confPopup->show(VFX_TRUE);
            }
            break;
        }
        default:
        {
            VappUcmCallCell::onActionAreaClicked(btn, state);
            break;
        }
    }
}

void VappUcmVoiceCallCell::showConfCallerList(VfxS32 group_id)
{
    VFX_OBJ_CREATE(m_confSelectMenu, VcpMenuPopup, m_confCallerPic[0]);
    m_confSelectMenu->setTitle(STR_ID_VAPP_UCM_SELECT_CONF_PEER);
    for (VfxU32 idx = 0; idx < m_numCalls; ++idx)
    {
        srv_ucm_call_info_struct call_info;
        srv_ucm_index_info_struct   call_index;

        call_index.group_index = m_callIndex.group_index;
        call_index.call_index = (S32)idx;
        srv_ucm_query_call_data(call_index, &call_info);
        m_confSelectMenu->addItem(idx, call_info.remote_info.disp_name);
    }
    m_confSelectMenu->m_signalMenuCallback.connect(this, &VappUcmVoiceCallCell::onConfCallerSelectCallback);
    m_confSelectMenu->show(VFX_TRUE);

    vapp_ucm_scr->getMainPage()->onScrnLock(VFX_FALSE);
    m_signalScrnLockTimer.emit(VAPP_UCM_TIMER_STOP);

}

void VappUcmVoiceCallCell::showConfCallOptions(void)
{
    VcpMoreCommandPopup *cmd;
    VFX_OBJ_CREATE(cmd, VcpMoreCommandPopup, m_confCallerPic[0]);
    cmd->addItem(VAPP_UCM_ACT_AREA_BTN_SPLIT, STR_ID_VAPP_UCM_SPLIT_THIS_CALL);
    if (srv_ucm_query_call_count(SRV_UCM_HOLD_STATE, SRV_UCM_CALL_TYPE_ALL, NULL) > 0)
    {
        cmd->disableItem(VAPP_UCM_ACT_AREA_BTN_SPLIT);
    }
    cmd->addItem(VAPP_UCM_ACT_AREA_BTN_END_THIS_CALL, STR_ID_VAPP_UCM_END_THIS_CALL, VCP_POPUP_BUTTON_TYPE_WARNING);
    cmd->addItem(VAPP_UCM_ACT_AREA_BTN_CLOSE, STR_GLOBAL_CLOSE, VCP_POPUP_BUTTON_TYPE_CANCEL);
    cmd->m_signalButtonClicked.connect(this, &VappUcmVoiceCallCell::onCmdOptionClicked);
    cmd->show(VFX_TRUE);

    vapp_ucm_scr->getMainPage()->onScrnLock(VFX_FALSE);
    m_signalScrnLockTimer.emit(VAPP_UCM_TIMER_STOP);
}

void VappUcmVoiceCallCell::onCmdOptionClicked(VfxObject* obj, VfxId id)
{
    // for UI Performance_BEGIN
    m_isMorePopupShowing = VFX_FALSE;
    if (SRV_UCM_HOLD_STATE == m_groupInfo.call_state || SRV_UCM_ACTIVE_STATE == m_groupInfo.call_state)
    {
        onCallTimerTicked(NULL);
    }
    // for UI Performance_END
    m_signalScrnLockTimer.emit(VAPP_UCM_TIMER_START);    
    switch (id)
    {
        case VAPP_UCM_ACT_AREA_BTN_SPLIT:
        {
            vapp_ucm_split_action();
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_END_THIS_CALL:
        {
            vapp_ucm_end_single_action();
            break;
        }
    #ifndef __MMI_UCM_SLIM__
    #ifdef __MMI_NOTE_APP__
        case VAPP_UCM_ACT_AREA_BTN_NOTE:
        {
            vapp_notes_app_launch();
            break;
        }
    #endif // __MMI_NOTE_APP__    
    #ifdef __MMI_DUAL_MIC_SUPPORT__
        case VAPP_UCM_ACT_AREA_BTN_DMNR:
        {
            MMI_BOOL newStatus;
            VfxResId txtId;
            if (MMI_FALSE == mmi_ucm_get_dual_mic_nr_status())
            {
                newStatus = MMI_TRUE;
                txtId = STR_ID_VAPP_UCM_DMNR_ON;
            }
            else
            {
                newStatus = MMI_FALSE;
                txtId = STR_ID_VAPP_UCM_DMNR_OFF;
            }
            mmi_ucm_set_dual_mic_nr_status(newStatus);
            vapp_ucm_show_info_ballon((PU16)GetString(txtId));
            break;
        }
    #endif // __MMI_DUAL_MIC_SUPPORT__
    #endif //__MMI_UCM_SLIM__
    #ifdef __CTM_SUPPORT__
        case VAPP_UCM_ACT_AREA_BTN_CTM_SETTING:
        {
            vapp_ucm_scr->pushCtmPage();
            break;
        }
    #endif // __CTM_SUPPORT__
    }

}

#ifndef __MMI_UCM_SLIM__
void VappUcmVoiceCallCell::showMoreOptions(void)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMM", SA_start);
#endif
    VcpMoreCommandPopup *cmd;
    VFX_OBJ_CREATE(cmd, VcpMoreCommandPopup, this);
#ifdef __MMI_NOTE_APP__
    cmd->addItem(VAPP_UCM_ACT_AREA_BTN_NOTE, STR_ID_VAPP_UCM_NOTES, VCP_POPUP_BUTTON_TYPE_NORMAL);
    if (srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL)
        || mmi_frm_is_scenario_started(MMI_SCENARIO_ID_HIGHEST_SCRN))
    {
        // Should prevent user from entering other APP  
        // 1.If there is incoming call, OOM will not come if there is no enough memory, as incoming call has highest priority
        // 2.If highest scrnario exists, for example if user enters security verify page
        cmd->disableItem(VAPP_UCM_ACT_AREA_BTN_NOTE);
    }
#endif // __MMI_NOTE_APP_
#ifdef __CTM_SUPPORT__
    if (srv_callset_ctm_permit_switch_setting() == SRV_CALLSET_RESULT_OK)
    {
        cmd->addItem(VAPP_UCM_ACT_AREA_BTN_CTM_SETTING, STR_ID_VAPP_UCM_CTM_SETTINGS, VCP_POPUP_BUTTON_TYPE_NORMAL);
    }
#endif // __CTM_SUPPORT__
#ifdef __MMI_DUAL_MIC_SUPPORT__
    VfxResId txtId;
    if (MMI_FALSE == mmi_ucm_get_dual_mic_nr_status())
    {
        txtId = STR_ID_VAPP_UCM_ENABLE_DMNR;
    }
    else
    {
        txtId = STR_ID_VAPP_UCM_DISABLE_DMNR;
    }
    cmd->addItem(VAPP_UCM_ACT_AREA_BTN_DMNR, txtId, VCP_POPUP_BUTTON_TYPE_NORMAL);
#endif // __MMI_DUAL_MIC_SUPPORT__
    cmd->addItem(VAPP_UCM_ACT_AREA_BTN_CLOSE, STR_GLOBAL_CLOSE, VCP_POPUP_BUTTON_TYPE_CANCEL);
    cmd->show(VFX_TRUE);
    cmd->m_signalButtonClicked.connect(this, &VappUcmVoiceCallCell::onCmdOptionClicked);
    m_isMorePopupShowing = VFX_TRUE;    // for UI Performance
    vapp_ucm_scr->getMainPage()->onScrnLock(VFX_FALSE);
    m_signalScrnLockTimer.emit(VAPP_UCM_TIMER_STOP);
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("CMM", SA_stop);
#endif
}
#endif //__MMI_UCM_SLIM__

void VappUcmVoiceCallCell::onRefreshCell(VappUcmCallCellRefreshTypeEnum refresh_type, void* data)
{
    if (VAPP_UCM_REFRESH_TYPE_ACT == refresh_type)
    {
        srv_ucm_act_notify_evt_struct *act_notify = (srv_ucm_act_notify_evt_struct *) data;
        srv_ucm_act_rsp_struct *accept_rsp;
        srv_ucm_act_rsp_struct* dial_rsp;
        srv_ucm_act_rsp_struct *rsp;
        srv_ucm_act_rsp_struct *end_rsp;

        // Update call info
        srv_ucm_group_info_struct group_info;
        VFX_ASSERT(SRV_UCM_INVALID_ID != m_groupInfo.group_id);
        MMI_BOOL call_exists = srv_ucm_query_group_index_by_group_id(m_groupInfo.group_id, m_groupInfo.call_type, &m_callIndex.group_index);
        VFX_ASSERT(call_exists);
        VfxS32 num_calls = srv_ucm_query_group_data(m_callIndex.group_index, &group_info);
        VFX_ASSERT(num_calls);
        setGroupInfo(&group_info);

        switch (act_notify->act_op)
        {
            case SRV_UCM_DIAL_ACT:
            {
                if (vapp_ucm_scr->getMainPage()->getActivateCallCell() != this)
                {
                    return;
                }
                // 1. START
                if (SRV_UCM_ACT_NOTIFY_TYPE_START == act_notify->notify_type) 
                {
                }
                // 2. END
                else if (SRV_UCM_ACT_NOTIFY_TYPE_END == act_notify->notify_type) 
                {
                    dial_rsp = (srv_ucm_act_rsp_struct*) act_notify->ptr;
                    //MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_MMI_UCM_ACT_NOTIFY_HDLR_RESULT_P1, dial_rsp->result_info.result);
                    if (dial_rsp->result_info.result == SRV_UCM_RESULT_OK)
                    {
                        // refresh screen?
                    }
                    else  // dial_rsp->result_info.result != SRV_UCM_RESULT_OK
                    {
                        vapp_ucm_display_info((WCHAR*)dial_rsp->result_info.error_msg);
                    }
                }
            }
            break;

            case SRV_UCM_ACCEPT_ACT:
            {
                if (SRV_UCM_ACT_NOTIFY_TYPE_START == act_notify->notify_type) 
                {
                    updateCallStatus(STR_ID_VAPP_UCM_CONNECTING);
                    updateRecIcon();
                }
                else
                {
                    accept_rsp = (srv_ucm_act_rsp_struct*)act_notify->ptr;
                    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_MMI_UCM_ACT_NOTIFY_HDLR_RESULT_P1, accept_rsp->result_info.result);
                    if (SRV_UCM_RESULT_OK == accept_rsp->result_info.result)
                    {
                        if (SRV_UCM_ACTIVE_STATE == m_groupInfo.call_state)
                        {
                            srv_ucm_call_info_struct call_info;
                            srv_ucm_query_call_data(m_callIndex, &call_info);
                            m_callStartTime.setDateTime((applib_time_struct*)&(call_info.start_time));
                            VfxWString str = getCallTimeDurationStr();
                            updateCallStatus(str);
                            updateRecIcon();
                            startCallTimer();

                            if (!isReducedCell())
                            {
                                VappUcmActionArea *tmp_actArea;
                                createActionArea(&tmp_actArea);
                                VfxAutoAnimate::initAnimateBegin();
                                tmp_actArea->setOpacity(0.0f);
                                
                                tmp_actArea->setAutoAnimate(VFX_TRUE);
                                m_actionArea->setAutoAnimate(VFX_TRUE);
                                tmp_actArea->setOpacity(1.0f);
                                m_actionArea->setOpacity(0.0f);
                                VfxAutoAnimate::initAnimateEnd();
                                tmp_actArea->setHidden(m_actionArea->getHidden());
                                VFX_OBJ_CLOSE(m_actionArea);
                                m_actionArea = tmp_actArea;
                                
                                if (m_groupInfo.call_type & SRV_UCM_CALL_TYPE_DATA_CSD_ALL)
                                {
                                    m_actionArea->disableAllBtns(VAPP_UCM_DISABLE_ACT_BTN_ALL_EXCEPT_END_KEY);
                                }
                            #if (!defined(__LOW_COST_SUPPORT_COMMON__) && !defined(__MMI_UCM_SLIM__))
                                m_dialing_ani_left->setHidden(VFX_TRUE);
                                m_dialing_ani_right->setHidden(VFX_TRUE);
                            #endif
                            }
                        }
                        else
                        {
                            if (!isReducedCell())
                            {
                                updateActionButtons(m_actionArea);
                            }
                        }
                    }
                    else if (vapp_ucm_scr->getMainPage()->getActivateCallCell() == this)
                    {
                        // only display on the active cell to prevent the error msg from displaying multiple times
                        vapp_ucm_display_info((WCHAR*)accept_rsp->result_info.error_msg);
                    }
                }
            }
            break;       

            case SRV_UCM_HOLD_ACT: 
            case SRV_UCM_RETRIEVE_ACT: 
            case SRV_UCM_SWAP_ACT:
            {
                if (SRV_UCM_ACT_NOTIFY_TYPE_START == act_notify->notify_type) 
                {
                    // may update call status string if need
                }
                else
                {
                    srv_ucm_act_rsp_struct *rsp = (srv_ucm_act_rsp_struct*) act_notify->ptr;
                    if (SRV_UCM_RESULT_OK == rsp->result_info.result)
                    {
                        if (SRV_UCM_HOLD_STATE == m_groupInfo.call_state)
                        {
                            VfxWString str = VFX_WSTR_RES(STR_ID_VAPP_UCM_ON_HOLD);
                        #if (defined __MMI_MAINLCD_240X320__) || (defined __MMI_MAINLCD_240X400__)
                            if (VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL3 == m_cellType
                                || VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL2 == m_cellType
                                || VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1 == m_cellType)
                            {
                        #endif
                                str += VFX_WSTR(" ");
                                str += getCallTimeDurationStr();
                        #if (defined __MMI_MAINLCD_240X320__) || (defined __MMI_MAINLCD_240X400__)
            	            }
                        #endif
                            updateCallStatus(str);
                            updateRecIcon();
                            //stopCallTimer();
                        }
                        else if (SRV_UCM_ACTIVE_STATE == m_groupInfo.call_state)
                        {
                            VfxWString str = getCallTimeDurationStr();
                            updateCallStatus(str);
                            updateRecIcon();
                            //startCallTimer();
                        }

                        if (!isReducedCell())
                        {
                            updateActionButtons(m_actionArea);
                        #if (!defined(__LOW_COST_SUPPORT_COMMON__) && !defined(__MMI_UCM_SLIM__))
                            if (VAPP_UCM_CONF_CALL_NONE == m_confCallType)
                            {
                                m_dialing_ani_left->setHidden(VFX_TRUE);
                                m_dialing_ani_right->setHidden(VFX_TRUE);
                            }
                        #endif
                        }
                    }
                    else
                    {
                        if (!isReducedCell())
                        {
                            updateActionButtons(m_actionArea);
                        }
                        vapp_ucm_display_info((WCHAR*)rsp->result_info.error_msg);
                        // show error
                    }
                }
            }
        #ifdef __MMI_UCM_DEFLECT__
            case SRV_UCM_DEFLECT_ACT:
        #endif // __MMI_UCM_DEFLECT_
            case SRV_UCM_SPLIT_ACT:  
            case SRV_UCM_CONFERENCE_ACT:
        #ifdef __MMI_UCM_ECT__
            case SRV_UCM_EXPLICIT_CALL_TRANSFER_ACT:
        #endif // __MMI_UCM_ECT__
        #ifdef __MMI_UCM_TRANSFER__
            case SRV_UCM_TRANSFER_ACT:
        #endif // __MMI_UCM_TRANSFER__
            {
                // Because for SWAP compound actions, the swapping screen will be displayed when receiving 
                // SWAP start notify. Does not show each step, hold and retrieve individually
            #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif
                rsp = (srv_ucm_act_rsp_struct*) act_notify->ptr;
                if (SRV_UCM_ACT_NOTIFY_TYPE_START == act_notify->notify_type) 
                {
                    // may update call status string if need
                }
                else
                {
                    m_isProgressing = VFX_FALSE;
                    if (SRV_UCM_RESULT_OK != rsp->result_info.result)
                    {
                        vapp_ucm_display_info((WCHAR*)rsp->result_info.error_msg);
                    }
                }
                srv_ucm_group_info_struct group_info;
                VfxS32 num_calls = srv_ucm_query_group_data(m_callIndex.group_index, &group_info);

                if (num_calls != m_numCalls)
                {
                    setCallNumber((VfxU8)num_calls);
                    arrangeConfNormalScreen();
                }
            }
            break;
          
            case SRV_UCM_END_SINGLE_ACT:
            case SRV_UCM_END_CONFERENCE_ACT:
            case SRV_UCM_END_ALL_ACT: 
//#ifdef __MMI_UCM_COMPOUND_ACTION_END_ALL_ACTIVE__				
            case SRV_UCM_END_ALL_ACTIVE_ACT:
//#endif /* __MMI_UCM_COMPOUND_ACTION_END_ALL_ACTIVE__ */
#ifdef __MMI_UCM_COMPOUND_ACTION_END_ALL_HELD__
            case SRV_UCM_END_ALL_HELD_ACT:
#endif /* __MMI_UCM_COMPOUND_ACTION_END_ALL_HELD__ */				
            case SRV_UCM_END_ALL_PROCESSING_ACT:
            {     
                // if there is no call when rece end notify with error result, don't display error popup
                if (SRV_UCM_ACT_NOTIFY_TYPE_START == act_notify->notify_type) 
                {

                    if (act_notify->act_op == SRV_UCM_END_SINGLE_ACT)
                    {
                    }
                    else if (act_notify->act_op == SRV_UCM_END_ALL_ACT)
                    {
                    }
                    // if single or conpound _2nd, means these end actions is user-aware, so ues gray screen
                    if (SRV_UCM_ACT_TYPE_SINGLE == act_notify->act_type
                        || SRV_UCM_ACT_TYPE_COMPOUND_SECOND == act_notify->act_type)
                    {
                    }
                    else // SRV_UCM_ACT_TYPE_COMPOUND_FIRST, ,means this end action is not user-aware
                    {
                        //refresh
                    }
                }
                else
                {
                    //refresh
                    end_rsp = (srv_ucm_act_rsp_struct*) act_notify->ptr;
                
                    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_MMI_UCM_ACT_NOTIFY_HDLR_RESULT_P1, end_rsp->result_info.result);

                    
                    // [UCM3.0] if compound action 1st fail, user may not understand the error msg
                    if (SRV_UCM_RESULT_OK != end_rsp->result_info.result)
                    {
                        vapp_ucm_display_info((WCHAR*)end_rsp->result_info.error_msg);
					#if 0
/* under construction !*/
					#endif
                    }
                }
            }
            break;

    		// compound actions

            case SRV_UCM_END_ALL_AND_ACCEPT_ACT:
            case SRV_UCM_END_ALL_ACTIVE_AND_ACCEPT_ACT:   
            case SRV_UCM_HOLD_AND_ACCEPT_ACT:	
            {
            }
            break;    
                 
            case SRV_UCM_END_ALL_AND_DIAL_ACT:
#ifdef __MMI_UCM_COMPOUND_ACTION_END_ALL_ACTIVE_AND_RETRIEVE__				
            case SRV_UCM_END_ALL_ACTIVE_AND_RETRIEVE_ACT:
#endif /* __MMI_UCM_COMPOUND_ACTION_END_ALL_ACTIVE_AND_RETRIEVE__ */				
            case SRV_UCM_HOLD_AND_DIAL_ACT:
            {
                // do nothing
            }
            break;

            #if (0)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif

            case SRV_UCM_START_DTMF_ACT:
            {
                if (SRV_UCM_ACT_NOTIFY_TYPE_START == act_notify->notify_type) 
                {
                    g_ucm_p->call_misc.is_dtmf_start = MMI_TRUE;
                }
                else
                {
                    MMI_ASSERT(0); // these is action without rsp, so it's impossible to get end notify
                }
            }
            break;

            case SRV_UCM_STOP_DTMF_ACT:	
            {
                if (SRV_UCM_ACT_NOTIFY_TYPE_START == act_notify->notify_type) 
                {
                    g_ucm_p->call_misc.is_dtmf_start = MMI_FALSE;
                }
                else
                {
                	MMI_ASSERT(0); // these is action without rsp, so it's impossible to get end notify
                }
            }
            break;

            default:
            {
                MMI_ASSERT(0);
            }
            break;   
        }    
    }
    else if (VAPP_UCM_REFRESH_TYPE_IND == refresh_type)
    {
        // Update call info

        srv_ucm_ind_evt_struct *ind = (srv_ucm_ind_evt_struct *) data;
        switch (ind->ind_type)
        {
            case SRV_UCM_INCOMING_CALL_IND:
            {
                break;
            }
            case SRV_UCM_OUTGOING_CALL_IND:
            {
                //MO_2Steps-BEGIN
                if (SRV_UCM_INVALID_ID == m_groupInfo.group_id)
                {
                    srv_ucm_group_info_struct group_info;
                    srv_ucm_query_group_data(m_callIndex.group_index, &group_info);
                    VFX_ASSERT(SRV_UCM_INVALID_ID != group_info.group_id);
                    setGroupInfo(&group_info);
                    createActionArea(&m_actionArea);
                    srv_ucm_call_info_struct call_info;
                    srv_ucm_query_call_data(m_callIndex, &call_info);
                    if (!isReducedCell())
                    {
                        updateInfoBar(&call_info);
                    }
                    updateDisplayName(&call_info);
                #ifdef __IP_NUMBER__
                    updateNumber(&call_info);
                #endif
                    updateCallerPic(&call_info);
                }
                //MO_2Steps-END
                break;
            }
            case SRV_UCM_ALERT_IND:
            {
                break;
            }
            case SRV_UCM_NOTIFY_IND:
            {
                break;
            }
            case SRV_UCM_CONNECT_IND:
            {
                if (SRV_UCM_OUTGOING_STATE != m_groupInfo.call_state)
                {
                    if (VAPP_UCM_CALL_CELL_TYPE_REDUCED1 != m_cellType
                        && VAPP_UCM_CALL_CELL_TYPE_REDUCED2 != m_cellType)
                    {
                        if (m_actionArea)
                        {
                            updateActionButtons(m_actionArea);
                        }
                    }
                    break;
                }
                srv_ucm_group_info_struct group_info;
                VFX_ASSERT(SRV_UCM_INVALID_ID != m_groupInfo.group_id);
                MMI_BOOL call_exists = srv_ucm_query_group_index_by_group_id(m_groupInfo.group_id, m_groupInfo.call_type, &m_callIndex.group_index);
                VFX_ASSERT(call_exists);
                VfxS32 num_calls = srv_ucm_query_group_data(m_callIndex.group_index, &group_info);
                VFX_ASSERT(num_calls);
                setGroupInfo(&group_info);

                srv_ucm_call_info_struct call_info;
                srv_ucm_query_call_data(m_callIndex, &call_info);
                updateDisplayName(&call_info);
                
                m_callStartTime.setDateTime((applib_time_struct*)&(call_info.start_time));
                VfxWString str = getCallTimeDurationStr();
                updateCallStatus(str);
                updateRecIcon();
                startCallTimer();
                if (!isReducedCell())
                {
                    updateNumber(&call_info);
                    VappUcmActionArea *tmp_actArea;
                    createActionArea(&tmp_actArea);
                    VfxAutoAnimate::initAnimateBegin();
                    tmp_actArea->setOpacity(0.0f);

                    tmp_actArea->setAutoAnimate(VFX_TRUE);
                    m_actionArea->setAutoAnimate(VFX_TRUE);
                    tmp_actArea->setOpacity(1.0f);
                    m_actionArea->setOpacity(0.0f);
                    VfxAutoAnimate::initAnimateEnd();
                    tmp_actArea->setHidden(m_actionArea->getHidden());
                    VFX_OBJ_CLOSE(m_actionArea);
                    m_actionArea = tmp_actArea;
                    if (m_groupInfo.call_type & SRV_UCM_CALL_TYPE_DATA_CSD_ALL)
                    {
                        m_actionArea->disableAllBtns(VAPP_UCM_DISABLE_ACT_BTN_ALL_EXCEPT_END_KEY);
                    }
                #if (!defined(__LOW_COST_SUPPORT_COMMON__) && !defined(__MMI_UCM_SLIM__))
                    m_dialing_ani_left->setHidden(VFX_TRUE);
                    m_dialing_ani_right->setHidden(VFX_TRUE);
                #endif

                }
                break;
            }
			#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif
            case SRV_UCM_RELEASE_IND:
            {
                // for conference call
                VfxBool update_call_cell = VFX_FALSE;
                srv_ucm_release_ind_struct *release_ind = (srv_ucm_release_ind_struct*)ind->ptr;
                if (VAPP_UCM_CONF_CALL_NONE == m_confCallType)
                {
                    if (!compareUID(&(release_ind->uid_info)))
                    {
                        return;
                    }
                }
                else
                {
                    if ((release_ind->uid_info.call_type & (SRV_UCM_VOICE_CALL_TYPE_ALL | SRV_UCM_CALL_TYPE_DATA_CSD_ALL)) 
                        && (release_ind->uid_info.group_id == m_groupInfo.group_id))
                    {
                        update_call_cell = VFX_TRUE;
                    }
                }

                if (update_call_cell)
                {
                    updateCallCell();
                }
                break;
            }
            case SRV_UCM_REFRESH_IND:
            {
                updateCallCell();
                break;
            }
        }

    }
    else
    {
        VFX_ASSERT(0);
    }
}

void VappUcmVoiceCallCell::updateCallCell(void)
{
    // Create call cell(s)
    srv_ucm_group_info_struct group_info;
    VfxS32 num_calls = srv_ucm_query_group_data(m_callIndex.group_index, &group_info);

    setCallNumber((VfxU8)num_calls);

    if (1 == num_calls && m_cellType >= VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL3)
    {
        m_callIndex.call_index = 0;
        vapp_ucmapp_set_active_call_info(&m_callIndex);
    }

    setGroupInfo(&group_info);
    VFX_OBJ_CLOSE(m_frame);
    VFX_OBJ_CLOSE(m_callStatus);
    VFX_OBJ_CLOSE(m_actionArea);
	#if 0
/* under construction !*/
	#endif

    // Launch updateScreen for each call cell
    updateScreen();

}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MAUI_SOFTWARE_LA__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MAUI_SOFTWARE_LA__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
#endif 
void VappUcmVoiceCallCell::onCallRelease()
{
#if 0
/* under construction !*/
#endif
    stopCallTimer();
    updateCallStatus(STR_ID_VAPP_UCM_CALL_ENDED);
    // there may be other call, thus recording may not be stopped, update rec icon
    updateRecIcon();
	if (m_actionArea)
	{
		m_actionArea->disableAllBtns(VAPP_UCM_DISABLE_ACT_BTN_ALL);
	}
}

VfxBool VappUcmVoiceCallCell::compareUID(srv_ucm_id_info_struct *uid_info)
{
    if (uid_info->call_type & (SRV_UCM_VOICE_CALL_TYPE_ALL | SRV_UCM_CALL_TYPE_DATA_CSD_ALL))
    {
        if (uid_info->group_id != m_groupInfo.group_id)
        {
            return VFX_FALSE;
        }
        
        if (VAPP_UCM_CONF_CALL_NONE == m_confCallType)
        {
            return VFX_TRUE;
        }
        else
        {
            for (VfxU32 idx = 0; idx < m_numCalls ; ++idx)
            {
                srv_ucm_index_info_struct index;
                index.group_index = m_callIndex.group_index;
                index.call_index = (S32)idx;
                srv_ucm_call_info_struct call_info;
                srv_ucm_query_call_data(index, &call_info);
                if (uid_info->call_id == call_info.uid_info.call_id)
                {
                    return VFX_TRUE;
                }
            }
        }
    }
    return VFX_FALSE;
}

#ifdef __MMI_UCM_REJECT_BY_SMS__
VFX_IMPLEMENT_CLASS("VappUcmSmsTemplatePage", VappUcmSmsTemplatePage, VappTextTemplateListPage);

void VappUcmSmsTemplatePage::onInit()
{
    VappTextTemplateListPage::onInit();
    m_signalTemplateTapped.connect(this, &VappUcmSmsTemplatePage::sendSMS);
    setStatusBar(VFX_TRUE);
    setTitleString(VFX_WSTR_RES(STR_ID_VAPP_UCM_SELECT_REJECT_MSG));
    // caller info frame
    VFX_OBJ_CREATE(m_frame, VfxFrame, this);
    // caller pic
    VFX_OBJ_CREATE(m_displayName, VfxTextFrame, m_frame);
    VFX_OBJ_CREATE(m_number, VfxTextFrame, m_frame);
    VFX_OBJ_CREATE(m_callerPic, VcpPhotoBorderFrame, m_frame);
    VFX_OBJ_CREATE(m_title, VfxTextFrame, this);
}

void VappUcmSmsTemplatePage::onDeinit()
{
    vapp_ucm_sms_state = VAPP_UCM_SMS_NONE;
    if (mmi_frm_is_scenario_started(MMI_SCENARIO_ID_UCM_EDIT_MSG))
    {
        mmi_frm_end_scenario(MMI_SCENARIO_ID_UCM_EDIT_MSG);
    }
    VappTextTemplateListPage::onDeinit();
}

void VappUcmSmsTemplatePage::updateCallerInfo(srv_ucm_call_info_struct *info)
{
    memcpy(&m_callerInfo, info, sizeof(srv_ucm_call_info_struct));

    // caller info frame
    m_frame->setBgColor(VFX_COLOR_WHITE);
    m_frame->setOpacity(0.8f);
    m_frame->setSize(VAPP_UCM_SCRN_WIDTH, VAPP_UCM_SMS_TEMPLATE_CELL_HEIGHT);

    srv_ucm_caller_res_struct caller_res_info;
    srv_ucm_get_caller_res_info(m_callerInfo.uid_info, &caller_res_info);

    // caller pic
    if (caller_res_info.res_type & SRV_UCM_RES_TYPE_IMAGE_PATH)
    {
        VfxImageSrc image = VfxImageSrc(caller_res_info.pic_path);
        if (image.isEmpty())
        {
            image.setResId(caller_res_info.pic_id);
        }
        m_callerPic->setImgContent(image);
    }
    else if (caller_res_info.res_type & SRV_UCM_RES_TYPE_IMAGE_ID)
    {
        m_callerPic->setImgResId(caller_res_info.pic_id);
    }
    VfxPageBar *topBar = getBar(VFX_PAGE_BAR_LOCATION_TOP);
    VfxRect barRect = topBar->getRect();
    m_callerPic->setPos(VAPP_UCM_REJECT_BY_SMS_LEFT_MARGIN, VAPP_UCM_REJECT_BY_SMS_TOP_MARGIN / 2);
    m_callerPic->setPlacement(VCP_PHOTO_BORDER_FRAME_PLACEMENT_FIT_EXACT_SIZE);
    m_callerPic->setMaxSize(VfxSize(VAPP_UCM_SMS_TEMPLATE_CELL_HEIGHT - VAPP_UCM_REJECT_BY_SMS_LEFT_MARGIN, 
                                    VAPP_UCM_SMS_TEMPLATE_CELL_HEIGHT - VAPP_UCM_REJECT_BY_SMS_LEFT_MARGIN));

    m_callerPic->forceUpdate();
    VfxRect picRect = m_callerPic->getRect();
    m_displayName->setString(m_callerInfo.remote_info.disp_name);
    m_displayName->setColor(VFX_COLOR_BLACK);
    m_displayName->setPos(picRect.getX() + picRect.getWidth() + VAPP_UCM_REJECT_BY_SMS_LEFT_MARGIN, VAPP_UCM_REJECT_BY_SMS_TOP_MARGIN / 2);
    m_displayName->setSize(GDI_LCD_WIDTH - m_displayName->getPos().x, VAPP_UCM_SMS_TEMPLATE_CELL_HEIGHT / 2);
    m_displayName->setAutoResized(VFX_FALSE);
    m_displayName->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);

    m_number->setColor(VFX_COLOR_BLACK);
    U8 ucs2_addr[(SRV_SMS_MAX_ADDR_LEN + 1) * ENCODING_LENGTH];
    U16 addr_len;
    addr_len = mmi_asc_n_to_ucs2((CHAR*)ucs2_addr, (CHAR*)m_callerInfo.remote_info.num_uri, SRV_SMS_MAX_ADDR_LEN);
    ucs2_addr[addr_len] = '\0';
    ucs2_addr[addr_len + 1] = '\0';
    if (VFX_WSTR_MEM((VfxWChar*)ucs2_addr) != VFX_WSTR_MEM(m_callerInfo.remote_info.disp_name))
    {
        m_number->setString((VfxWChar*)ucs2_addr);
        m_number->setPos(picRect.getX() + picRect.getWidth() + VAPP_UCM_REJECT_BY_SMS_LEFT_MARGIN, 
            VAPP_UCM_SMS_TEMPLATE_CELL_HEIGHT / 2 + VAPP_UCM_REJECT_BY_SMS_TOP_MARGIN / 2);    
    }
    else
    {
        m_number->setHidden(VFX_TRUE);
    }
    VfxRect frameRect = m_frame->getRect();
    m_title->setPos(0, frameRect.getY() + frameRect.getHeight() + 1);
    m_title->setSize(VAPP_UCM_SCRN_WIDTH, VAPP_UCM_SMS_TEMPLATE_TITLE_HEIGHT);
    m_title->setString(STR_ID_VAPP_UCM_SMS_TEMPLATE);

    VfxS32 titlePos = m_title->getRect().getY();
    VfxS32 titleHeight = m_title->getRect().getHeight();
    VfxS32 barHeight = vapp_ucm_scr->getStatusBar()->getRect().getHeight();
    setListMenuPos(0, titlePos + titleHeight + 1);
    setListMenuSize(VAPP_UCM_SCRN_WIDTH, VAPP_UCM_SCRN_HEIGHT - (titlePos + titleHeight + 2 + barRect.getHeight() + barHeight));
}

VfxBool VappUcmSmsTemplatePage::onKeyInput(VfxKeyEvent & event)
{
    if (srv_ucm_is_incoming_call())
    {
    	if (event.type == VFX_KEY_EVENT_TYPE_DOWN && event.keyCode == VFX_KEY_CODE_HOME)
    	{
    		return VFX_TRUE;
    	}
    }
    return VfxPage::onKeyInput(event);
}

void VappUcmSmsTemplatePage::onQueryRotateEx(VfxScreenRotateParam &param)
{
    param.rotateTo = VFX_SCR_ROTATE_TYPE_NORMAL;
}

void VappUcmSmsTemplatePage::sendSMS(VfxObject* obj, VfxWString sms_str, VfxU16 template_id)
{
    if (srv_callset_reject_by_sms_get_setting() == SRV_CALLSET_REJ_BY_SMS_DEFAULT
        && srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL) == 1)
    {
        // end call before sending sms
        vapp_ucm_incoming_call_endkey();
    }

    VappUcEntryStruct data;
    memset(&data, 0x00, sizeof(VappUcEntryStruct));
    data.text_buffer = (U8*)sms_str.getBuf();
    data.text_num = sms_str.getLength() << 1;
    data.info_type = (srv_uc_info_type_enum)SRV_UC_INFO_TYPE_SMS_TEMPLATE;
    data.operation = (vappUcMsgOperationEnum)UC_OPERATION_WRITE_NEW_MSG;
    data.type = (srv_uc_state_enum)SRV_UC_STATE_WRITE_NEW_MSG;
    data.msg_type = SRV_UC_MSG_TYPE_SMS_ONLY;

    srv_uc_addr_struct addr;
    memset(&addr, 0x00, sizeof(srv_uc_addr_struct));
    data.addr_num = 1;
    U8 ucs2_addr[(SRV_SMS_MAX_ADDR_LEN + 1) * ENCODING_LENGTH];
    U16 addr_len;
    addr_len = mmi_asc_n_to_ucs2((CHAR*)ucs2_addr, (CHAR*)m_callerInfo.remote_info.num_uri, SRV_SMS_MAX_ADDR_LEN);
    ucs2_addr[addr_len] = '\0';
    ucs2_addr[addr_len + 1] = '\0';
    addr.addr = (kal_uint8*) ucs2_addr;
    addr.type = SRV_UC_ADDRESS_TYPE_PHONE_NUMBER;
    addr.group = SRV_UC_ADDRESS_GROUP_TYPE_TO;
    data.addr = &addr;
    data.sim_id = SRV_UC_SIM_ID_GSM_SIM1;
#if (MMI_MAX_SIM_NUM >= 2)
    if (m_callerInfo.uid_info.call_type & SRV_UCM_SIM2_CALL_TYPE_ALL)
    {
        data.sim_id = SRV_UC_SIM_ID_GSM_SIM2;
    }
#if (MMI_MAX_SIM_NUM >= 3)
    else if (m_callerInfo.uid_info.call_type & SRV_UCM_SIM3_CALL_TYPE_ALL)
    {
        data.sim_id = SRV_UC_SIM_ID_GSM_SIM3;
    }
#if (MMI_MAX_SIM_NUM >= 4)
    else if (m_callerInfo.uid_info.call_type & SRV_UCM_SIM4_CALL_TYPE_ALL)
    {
        data.sim_id = SRV_UC_SIM_ID_GSM_SIM4;
    }
#endif // (MMI_MAX_SIM_NUM >= 4)
#endif // (MMI_MAX_SIM_NUM >= 3)
#endif // (MMI_MAX_SIM_NUM >= 2)

    data.launch_mode = UC_LAUNCH_MODE_NORMAL;

    //vappUcAppLauncher(&data);
    vapp_ucm_scr->enterUC(&data);
}
#endif // __MMI_UCM_REJECT_BY_SMS__

#ifdef __MMI_VIDEO_TELEPHONY__
VFX_IMPLEMENT_CLASS("VappUcmVideoCallCell", VappUcmVideoCallCell, VappUcmCallCell);

void VappUcmVideoCallCell::onInit()
{
    VappUcmCallCell::onInit();
    m_frame = NULL;
    m_infoBarBg = NULL;
    m_infoBar = NULL;
    m_displayName = NULL;
    m_number = NULL;
    m_callerPic = NULL;
    m_vtIcon = NULL;
    m_videoFrame = NULL;
    m_actionArea = NULL;
    m_timer = NULL;
    m_pageVtPreview = NULL;
#ifndef __LOW_COST_SUPPORT_COMMON__
    m_dialing_ani_left = NULL;
    m_dialing_ani_right = NULL;
#endif
    m_isBg = VFX_FALSE;
    m_needUpdateValue = VFX_FALSE;
#if 0
/* under construction !*/
#endif
    m_moreCmdPopup = NULL;
    m_cnfPopup = NULL;
    m_fakeVFrame = NULL;
    m_state = VappUcmVideoCallCell::STATE_NONE;
    m_readyToPlay = VT_READY_NONE;
    initVtStatus();

    srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);

}

void VappUcmVideoCallCell::initVtStatus(void)
{
    memset(&m_vtStatus, 0, sizeof(m_vtStatus));
    m_vtStatus.frontVtFrame = VAPP_VT_VIDEOFRAME_TYPE_LOCAL;
    m_vtStatus.view.nightModeFront = srv_callset_vt_get_night_mode(SRV_CALLSET_VT_CAMERA_FRONT);
    m_vtStatus.view.evFront = srv_callset_vt_get_ev(SRV_CALLSET_VT_CAMERA_FRONT);
    m_vtStatus.view.zoomFront = srv_callset_vt_get_zoom(SRV_CALLSET_VT_CAMERA_FRONT);
    m_vtStatus.view.nightModeBack = srv_callset_vt_get_night_mode(SRV_CALLSET_VT_CAMERA_BACK);
    m_vtStatus.view.evBack = srv_callset_vt_get_ev(SRV_CALLSET_VT_CAMERA_BACK);
    m_vtStatus.view.zoomBack = srv_callset_vt_get_zoom(SRV_CALLSET_VT_CAMERA_BACK);
    m_vtStatus.view.camMode = SRV_CALLSET_VT_CAMERA_FRONT;

    WCHAR *buf;
    VFX_ALLOC_MEM(buf, (SRV_FMGR_PATH_MAX_LEN + 1) * ENCODING_LENGTH, this);
    if (srv_callset_vt_get_incall_image_path(SRV_FMGR_PATH_MAX_LEN, buf) != SRV_CALLSET_RESULT_OK)
    {
        memset(buf, 0, (SRV_FMGR_PATH_MAX_LEN + 1) * ENCODING_LENGTH);
    }
    m_vtStatus.view.imagePath = VFX_WSTR_MEM(buf);
    VFX_FREE_MEM(buf);
}

void VappUcmVideoCallCell::onDeinit()
{
    if (m_pageVtPreview)
    {
        // keep the mastership in vt preview page
        m_pageVtPreview->m_signalVFrameMastershipReturn.disconnect(this, &VappUcmVideoCallCell::onVFrameOwnershipReturn);
        m_pageVtPreview = NULL;
        m_videoFrame = NULL;
    }
    else if (m_videoFrame)
    {
        // for the scenario that there are still other call cells after VT is released
        // (no screen transition will be triggerred)
        m_videoFrame->stop();
        m_videoFrame = NULL;
    }

    srv_backlight_turn_off();

    VappUcmCallCell::onDeinit();
}

void VappUcmVideoCallCell::updateCallerPic(srv_ucm_call_info_struct *call_info)
{
    VFX_ASSERT(NULL != call_info);
    if (SRV_UCM_INVALID_ID == call_info->uid_info.group_id
        || SRV_UCM_INVALID_ID == call_info->uid_info.call_id)
    {
        m_callerPic->setImgResId(IMG_COSMOS_HEAD_PORTRAIT_2);
    }
    else
    {
        srv_ucm_caller_res_struct caller_res_info;
        srv_ucm_get_caller_res_info(call_info->uid_info, &caller_res_info);
        // caller picture
        if (VFX_FLAG_HAS(caller_res_info.res_type, SRV_UCM_RES_TYPE_IMAGE_PATH))
        {
            VfxImageSrc image = VfxImageSrc(caller_res_info.pic_path);
            if (image.isEmpty())
            {
                image.setResId(caller_res_info.pic_id);
            }
            m_callerPic->setImgContent(image);
        }
        else if (VFX_FLAG_HAS(caller_res_info.res_type, SRV_UCM_RES_TYPE_IMAGE_ID))
        {
            m_callerPic->setImgResId(caller_res_info.pic_id);
        }
    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif
    }
}

void VappUcmVideoCallCell::updateScreen()
{
    VfxResId xml_layout_id = 0;

    srv_ucm_call_info_struct call_info;
#ifdef __MMI_EM_PROFILING_VT_LOOKBACK__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif // __MMI_EM_PROFILING_VT_LOOKBACK__
        srv_ucm_query_call_data(m_callIndex, &call_info);

    switch (m_cellType)
    {
        case VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL1:
        {
            if (call_info.call_state != SRV_UCM_ACTIVE_STATE)
            {
                xml_layout_id =  VAPP_UCM_CALL_CELL_LAYOUT_NORMAL_LEVEL1;
            }
            else
            {
                xml_layout_id = VAPP_UCM_CALL_CELL_LAYOUT_VT_INCALL_LEVEL1;
            }
            break;
        }
        
        case VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL2:
        {
            if (call_info.call_state != SRV_UCM_ACTIVE_STATE)
            {
                xml_layout_id =  VAPP_UCM_CALL_CELL_LAYOUT_NORMAL_LEVEL2;
            }
            else
            {
                xml_layout_id = VAPP_UCM_CALL_CELL_LAYOUT_VT_INCALL_LEVEL2;
            }
            break;
        }
        case VAPP_UCM_CALL_CELL_TYPE_NORMAL_LEVEL3:
        {
            xml_layout_id =  VAPP_UCM_CALL_CELL_LAYOUT_NORMAL_LEVEL3;
            break;
        }
        case VAPP_UCM_CALL_CELL_TYPE_REDUCED1:
        case VAPP_UCM_CALL_CELL_TYPE_REDUCED2:
        {
            xml_layout_id =  VAPP_UCM_CALL_CELL_LAYOUT_REDUCED;
            break;
        }
    }

    clearFrames();

    VfxXmlLoader::loadBegin(this, xml_layout_id);
    m_frame = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_frame")), VfxFrame);
    m_infoBarBg = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_infoBarBg")), VfxFrame);
    m_infoBar = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_infoBar")), VfxTextFrame);
    m_displayName = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_displayName")), VfxTextFrame);
    m_displayName->setAutoResized(VFX_FALSE);
    m_displayName->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
    if (xml_layout_id != VAPP_UCM_CALL_CELL_LAYOUT_REDUCED
    #if defined(__MMI_MAINLCD_240X320__)
        && xml_layout_id != VAPP_UCM_CALL_CELL_LAYOUT_VT_INCALL_LEVEL2
    #endif
        )
    {
        m_displayName->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
    }
    m_number = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_number")), VfxTextFrame);
    m_callStatusBg = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_callStatusBg")), VfxFrame);
    m_callStatus = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_callStatus")), VfxTextFrame);
    m_callerPic = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_callerPic")), VcpPhotoBorderFrame);
    m_vtIcon = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_vtIcon")), VfxImageFrame);
    m_vFrameMain = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_vFrameMain")), VfxFrame);
    if (m_vFrameMain)
    {
        m_vFrameMain->setHidden(VFX_TRUE);
    }
    m_vFrameSub = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_vFrameSub")), VfxFrame);
    if (m_vFrameSub)
    {
        m_vFrameSub->setHidden(VFX_TRUE);
    }
#ifndef __LOW_COST_SUPPORT_COMMON__
    m_dialing_ani_left = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_dialing_ani_left")), VfxAnimImageFrame);
    m_dialing_ani_right = VFX_OBJ_DYNAMIC_CAST(VfxXmlLoader::findObjByName(VFX_WSTR("m_dialing_ani_right")), VfxAnimImageFrame);
#endif
    VfxXmlLoader::loadEnd();

    // info bar
    if (isReducedCell())
    {
        if (!m_simInfoBar)
        {
            VFX_OBJ_CREATE(m_simInfoBar, VfxFrame, this);
        }
        m_simInfoBar->setSize(3, getSize().height - 4);
        m_simInfoBar->setPos(1, 2);
        m_simInfoBar->setBgColor(VfxColor(0xffFAAC05));
        m_simInfoBar->bringToFront();
        m_simInfoBar->setHidden(VFX_FALSE);
    }
    else
    {
        if (m_simInfoBar)
        {
            m_simInfoBar->setHidden(VFX_TRUE);
        }
        VfxResId txtId;
        if (srv_sim_ctrl_get_num_of_inserted() > 1)
        {
            txtId = STR_GLOBAL_SIM_1;
        }
        else
        {
            txtId = STR_ID_VAPP_UCM_VIDEO_CALL;
        }
        m_infoBar->setString(txtId);
        m_infoBar->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_INFO_BAR_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
        m_infoBar->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
        m_infoBar->setVerticalToCenter(VFX_TRUE);
        m_infoBarBg->setImgContent(VfxImageSrc(IMG_ID_VAPP_UCM_TITLE_BG));
        m_infoBarBg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    }

    // dispaly name
    m_displayName->setString(call_info.remote_info.disp_name);
    m_displayName->setColor(VFX_COLOR_WHITE);

    if (!isReducedCell() && SRV_UCM_ACTIVE_STATE == call_info.call_state)
    {
        m_displayName->setFont(
            VfxFontDesc(VFX_FONT_DESC_VF_SIZE(
                VAPP_UCM_DISPLAY_NAME_FONT_VT_INCALL), 
                VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
    }
    else
    {
        m_displayName->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_DISPLAY_NAME_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));
    }

    // number
    if (!isReducedCell())
    {
        VfxWString txtNumber;
    #ifdef __MMI_UCM_NUMBER_TYPE__
        switch (call_info.remote_info.number_type)
        {
            case MMI_PHB_NUM_TYPE_MOBILE:
            {
                txtNumber = VFX_WSTR_RES(STR_ID_VAPP_UCM_NUM_TYPE_MOBILE);
                break;
            }
            case MMI_PHB_NUM_TYPE_HOME:
            {
                txtNumber = VFX_WSTR_RES(STR_ID_VAPP_UCM_NUM_TYPE_HOME);
                break;
            }
            case MMI_PHB_NUM_TYPE_OFFICE:
            {
                txtNumber = VFX_WSTR_RES(STR_ID_VAPP_UCM_NUM_TYPE_OFFICE);
                break;
            }
            case MMI_PHB_NUM_TYPE_FAX:
            {
                txtNumber = VFX_WSTR_RES(STR_ID_VAPP_UCM_NUM_TYPE_FAX);
                break;
            }
            default:
            {
                if(call_info.remote_info.number_type >= MMI_PHB_NUM_TYPE_USER_BASE)
                {
                    WCHAR* label = srv_phb_get_field_type_label((U8)call_info.remote_info.number_type,
                                                MMI_PHB_CONTACT_FIELD_ID_NUMBER,
                                                (phb_storage_enum)srv_phb_get_storage(call_info.remote_info.phb_id.contact_index));
                    txtNumber = VFX_WSTR_MEM(label);
                    txtNumber += VFX_WSTR(" ");
                }
                else
                {
                    txtNumber = VFX_WSTR_RES(STR_ID_VAPP_UCM_NUM_TYPE_MOBILE);
                }
                break;
            }
        }
    #else /* __MMI_UCM_NUMBER_TYPE__ */
        /* don't display the number type */
    #endif /* __MMI_UCM_NUMBER_TYPE__ */
    
        VfxWChar w_number[64];
        memset(w_number, 0, 64);
        mmi_asc_to_ucs2((CHAR*)w_number, (CHAR*)call_info.remote_info.num_uri);
        txtNumber += VFX_WSTR_MEM(w_number);
        m_number->setAutoResized(VFX_FALSE);
        m_number->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
        m_number->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
        m_number->setString(txtNumber);
        m_number->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_NUMBER_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));

        if (call_info.call_state == SRV_UCM_ACTIVE_STATE)
        {
            m_number->setHidden(VFX_TRUE);
        }
    }

    /* call status */
    switch (call_info.call_state)
    {
        case SRV_UCM_INCOMING_STATE:
        {
            m_callStatus->setString(STR_ID_VAPP_UCM_INCOMING);
            break;
        }
        case SRV_UCM_OUTGOING_STATE:
        {
            m_callStatus->setString(STR_ID_VAPP_UCM_DIALING);
            break;
        }
        case SRV_UCM_ACTIVE_STATE:
        {
            m_callStartTime.setDateTime((applib_time_struct*)&(call_info.start_time));
            startCallTimer();
            break;
        }
    }
    m_callStatus->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
    if(!isReducedCell())
    {
        m_callStatusBg->setImgContent(VfxImageSrc(IMG_ID_VAPP_UCM_TIME_BG));
        m_callStatusBg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
        m_callStatus->setVerticalToCenter(VFX_TRUE);
    }
    m_callStatus->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_UCM_CALL_STATUS_FONT), VFX_FONT_DESC_ATTR_NORMAL, VFX_FONT_DESC_EFFECT_NONE));

    /* recording icon */
    updateRecIcon();

    if (call_info.call_state == SRV_UCM_OUTGOING_STATE)
    {
        /* speaker mode */
        if(srv_callset_vt_get_speaker_mode())
        {
            srv_speech_enable_hand_free();
        }
        else
        {
            srv_speech_disable_hand_free();
        }
    
        /* microphone mode */
        if(srv_callset_vt_get_mic_mode())
        {
            srv_speech_unmute_phone();
        }
        else
        {
            srv_speech_mute_phone();
        }
    }

    /* action area */
    VFX_OBJ_CLOSE(m_actionArea);
    if(!isReducedCell())
    {
        //MO_2Steps-BEGIN
        if (SRV_UCM_INVALID_ID != m_groupInfo.group_id)
        //MO_2Steps-END
        {
            createActionArea(&m_actionArea);
            if (m_isLocked)
            {
                m_actionArea->setHidden(VFX_TRUE);
            }
            m_actionArea->m_signalActions.connect(this, &VappUcmVideoCallCell::onActionAreaClicked);            
            updateActionArea(call_info.call_state);
        }
    }

    /* animation */
#ifndef __LOW_COST_SUPPORT_COMMON__
    if (!isReducedCell() && call_info.call_state != SRV_UCM_ACTIVE_STATE)
    {
        m_dialing_ani_left->setHidden(VFX_TRUE);
        m_dialing_ani_right->setHidden(VFX_TRUE);
    }
#endif

    if (isReducedCell() || call_info.call_state != SRV_UCM_ACTIVE_STATE)
    {
        /* caller picture */
        updateCallerPic(&call_info);

        if (!isReducedCell())
        {
            /* video call icon */
            VfxSize size = m_vtIcon->getSize(); /* keep the original size */
            m_vtIcon->setResId(VAPP_UCM_VT_DIAL); /* size will be changed */
            m_vtIcon->setSize(size);
        }

        /* camera mode */
        if ((call_info.call_state == SRV_UCM_INCOMING_STATE) &&
            (srv_callset_vt_get_answer_mode() == SRV_CALLSET_VT_ANSWER_MODE_STOP_CAMERA))
        {
            m_vtStatus.view.camMode = SRV_CALLSET_VT_CAMERA_OFF;
        }
        else if ((call_info.call_state == SRV_UCM_OUTGOING_STATE) &&
            (srv_callset_vt_get_dial_mode() == SRV_CALLSET_VT_DIAL_MODE_STOP_CAMERA))
        {
            m_vtStatus.view.camMode = SRV_CALLSET_VT_CAMERA_OFF;
        }

    }

    if (call_info.call_state == SRV_UCM_ACTIVE_STATE)
    {
        if (!m_videoFrame)
        {
            /* First time to the active state */

            /* disable scrLock during VT call */
            vapp_ucm_scr->getMainPage()->onScrnLock(VFX_FALSE);
            m_signalScrnLockTimer.emit(VAPP_UCM_TIMER_STOP);

            m_actionArea->m_actionButtonGroup->disableAllBtns(VFX_TRUE);

            mmi_frm_asm_property_struct property;
            mmi_frm_asm_property_init(&property);
            property.f_prepare_w_reserve = 1;
            property.f_hide_in_oom = 1;
            mmi_frm_asm_set_property(vapp_ucm_scr->getApp()->getGroupId(), &property);

            /* prepare memory for video frames */
            mmi_frm_asm_prepare(
                vapp_ucm_scr->getApp()->getGroupId(), 
                mmi_res_get_app_base_mem_size(vapp_ucm_scr->getApp()->getGroupId()) + mmi_res_get_app_fg_mem_size(vapp_ucm_scr->getApp()->getGroupId()), 
                vapp_ucm_proc, this, MMI_FRM_ASM_F_FORCE_PREPARE);

            /* draw fake video frames */
            VFX_OBJ_CREATE(m_fakeVFrame, VfxFrame, this);
            m_fakeVFrame->setAnchor(0.5f, 0);
            m_fakeVFrame->setRect(getVFrameRect());
            VfxFrame *main;
            VFX_OBJ_CREATE(main, VfxFrame, m_fakeVFrame);
            main->setSize(m_vFrameMain->getSize());
            main->setBgColor(VFX_COLOR_BLACK);
            main->setAnchor(0.5f, 0);
            main->setPos(m_fakeVFrame->convertPointFrom(m_vFrameMain->getPos(), this));
            VfxImageFrame *border1;
            VFX_OBJ_CREATE(border1, VfxImageFrame, m_fakeVFrame);
            border1->setAnchor(0.5f, 0);
            border1->setPos(
                m_fakeVFrame->convertPointFrom(
                    VfxPoint(m_vFrameMain->getPos().x, m_vFrameMain->getPos().y - m_videoFrame->getFrameMargin()),
                    this));
            border1->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
            border1->setResId(VAPP_UCM_VT_VFRAME_DEFAULT_BORDER);
            border1->setSize(m_vFrameMain->getSize().width + m_videoFrame->getFrameMargin() * 2, m_vFrameMain->getSize().height + m_videoFrame->getFrameMargin() * 2);
            VfxFrame *sub;
            VFX_OBJ_CREATE(sub, VfxFrame, m_fakeVFrame);
            sub->setSize(m_vFrameSub->getSize());
            sub->setBgColor(VFX_COLOR_BLACK);
            sub->setAnchor(0.5f, 0);
            sub->setPos(
                m_fakeVFrame->convertPointFrom(m_vFrameSub->getPos(), this));
            VfxImageFrame *border2;
            VFX_OBJ_CREATE(border2, VfxImageFrame, m_fakeVFrame);
            border2->setAnchor(0.5f, 0);
            border2->setPos(
                m_fakeVFrame->convertPointFrom(
                    VfxPoint(m_vFrameSub->getPos().x, m_vFrameSub->getPos().y - m_videoFrame->getFrameMargin()), 
                    this));
            border2->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);       
            border2->setResId(VAPP_UCM_VT_VFRAME_DEFAULT_BORDER);
            border2->setSize(m_vFrameSub->getSize().width + m_videoFrame->getFrameMargin() * 2, m_vFrameSub->getSize().height + m_videoFrame->getFrameMargin() * 2);
        
        #ifndef __MDP_VT_PREVIEW_UPSCALE_SUPPORT__
            if (m_vFrameMain->getSize().width > 176 || m_vFrameMain->getSize().height > 144)
            {
                main->setSize(176, 144);
                border1->setSize(176 + m_videoFrame->getFrameMargin() * 2, 144 + m_videoFrame->getFrameMargin() * 2);
            }
        #endif

        }
        else if (!m_pageVtPreview)
        {
            /* not first time in the active state and have vFrame ownership */
            m_videoFrame->bringToFront();

            vFramePause();

            if (isReducedCell())
            {
                m_videoFrame->setHidden(VFX_TRUE);
                m_videoFrame->setParamHide(VAPP_VT_VIDEOFRAME_TYPE_PEER, VFX_TRUE);
                m_videoFrame->setParamHide(VAPP_VT_VIDEOFRAME_TYPE_LOCAL, VFX_TRUE);

                m_isBg = VFX_TRUE;
            }
            else
            {
                updateVideoFrame();

                if (vapp_ucm_scr->isActive() && vapp_ucm_scr->getMainPage()->isActive())
                {
                    /* active screen and current page, move to fg */
                    m_isBg = VFX_FALSE;
                }
                else
                {
                    m_isBg = VFX_TRUE;
                }
            }
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
            vFrameResume();
        }
        else if (isReducedCell())
        {
            /* 1. not first time in the active state
             * 2. doesn't have mastership
             * 3. become reduced
             */
            m_isBg = VFX_TRUE; /* update vFrame in the background before exit preview page */
            vapp_ucm_show_info_ballon((PU16)GetString(STR_ID_VAPP_UCM_INCOMING));
        }

    }

}

void VappUcmVideoCallCell::waitReadyPlay()
{
    m_readyToPlay = (vt_ready_type_enum) (m_readyToPlay & ~VT_READY_PLAY_VIDEO);
    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_VAPP_UCM_VT_PREPARE_STATUS, m_readyToPlay);
}

void VappUcmVideoCallCell::onPrepareDone(vt_ready_type_enum vt_ready)
{  
    if (m_videoFrame || ((m_readyToPlay & VT_READY_ASM) && (m_readyToPlay & VT_READY_PLAY_VIDEO)) )
        return;
#ifdef __MMI_EM_PROFILING_VT_LOOKBACK__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
    m_readyToPlay = (vt_ready_type_enum) (m_readyToPlay | vt_ready);
#endif
    MMI_TRACE(MMI_COMMON_TRC_G5_CALL, TRC_VAPP_UCM_VT_PREPARE_STATUS, m_readyToPlay);            
    if ((m_readyToPlay & VT_READY_ASM) && (m_readyToPlay & VT_READY_PLAY_VIDEO) )
    {
        createVideoFrame();
    }
}

void VappUcmVideoCallCell::createVideoFrame()
{
    VFX_OBJ_CLOSE(m_fakeVFrame);
    VFX_OBJ_CREATE(m_videoFrame, VappVtVideoFrame, this);
    m_videoFrame->setParamAppId(vapp_ucm_scr->getApp()->getGroupId());
    updateVideoFrame();
    m_videoFrame->setParamMaxWndSize(
        m_vFrameMain->getSize(), 
        VfxSize(VAPP_UCM_RES_MAX_W, VAPP_UCM_RES_MAX_H),
        m_vFrameSub->getSize(),
        m_vFrameSub->getSize());
    VfxRect tmpRect = getVFrameRect();
    m_videoFrame->setSize(tmpRect.getWidth(), tmpRect.getHeight());
    updateVideoFrame();
    m_videoFrame->m_signalVtEvent.connect(this, &VappUcmVideoCallCell::onVFrameEvent);
    m_videoFrame->m_signalVtVideoFramePenEvent.connect(this, &VappUcmVideoCallCell::onVFramePenInput);
    m_videoFrame->start();
    m_state = VappUcmVideoCallCell::STATE_PLAY_NOT_READY;

}

void VappUcmVideoCallCell::updateActionArea(srv_ucm_call_state_enum state)
{
    switch (state)
    {
        case SRV_UCM_INCOMING_STATE:
        {
            m_actionArea->setAreaType(VAPP_UCM_AREA_INCOMING);
        #ifdef __MMI_UCM_REJECT_BY_SMS__
            m_actionArea->m_actionButtonGroup->setType(VAPP_UCM_ACTBTN_GRP_3_BTN);
        #else
            m_actionArea->m_actionButtonGroup->setType(VAPP_UCM_ACTBTN_GRP_2_BTN);
        #endif /* __MMI_UCM_REJECT_BY_SMS__ */
            m_actionArea->m_actionButtonGroup->setBtnLabel(0, STR_ID_VAPP_UCM_SLIENT);
            m_actionArea->m_actionButtonGroup->setBtnIcon(0, VcpStateImage(IMG_ID_VAPP_UCM_ICON_SLIENT, IMG_ID_VAPP_UCM_ICON_SLIENT, IMG_ID_VAPP_UCM_ICON_SLIENT, IMG_ID_VAPP_UCM_ICON_SLIENT));
            m_actionArea->m_actionButtonGroup->setBtnId(0, VAPP_UCM_ACT_AREA_BTN_SILENT);
            if(srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) > 1 ||
                (srv_prof_is_profile_activated(SRV_PROF_SILENT_MODE) > 0 && MMI_FALSE == srv_prof_if_can_vibrate()))
            {
                /* disable silent option for waiting calls or in SILENT mode and vibrate is off */
                m_actionArea->m_actionButtonGroup->setBtnDisable(0, VFX_TRUE);
            }
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(1, STR_ID_VAPP_UCM_KEYPAD);
            m_actionArea->m_actionButtonGroup->setBtnIcon(1, VcpStateImage(IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD));
            m_actionArea->m_actionButtonGroup->setBtnSwitchable(1, VFX_TRUE);
            m_actionArea->m_actionButtonGroup->setBtnId(1, VAPP_UCM_ACT_AREA_BTN_KEYPAD);
        #ifdef __MMI_UCM_REJECT_BY_SMS__
            m_actionArea->m_actionButtonGroup->setBtnLabel(2, STR_ID_VAPP_UCM_MSG_REJECT);
            m_actionArea->m_actionButtonGroup->setBtnIcon(2, VcpStateImage(IMG_ID_VAPP_UCM_ICON_MESSAGE, IMG_ID_VAPP_UCM_ICON_MESSAGE, IMG_ID_VAPP_UCM_ICON_MESSAGE, IMG_ID_VAPP_UCM_ICON_MESSAGE));
            m_actionArea->m_actionButtonGroup->setBtnId(2, VAPP_UCM_ACT_AREA_BTN_MESSAGE);
            srv_ucm_call_info_struct call_info;
            srv_ucm_query_call_data(m_callIndex, &call_info);
            if(((srv_callset_answer_mode_get_status() & SRV_CALLSET_ANSWER_MODE_AUTO)
                    && srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_NO_CSD, NULL) == 1
                    && srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) == 1)
            #ifdef __MMI_CM_WHITE_LIST__
                || (srv_callset_whitelist_is_auto_answer_number((U8)mmi_ucs2strlen((CHAR*)call_info.remote_info.num_uri), (WCHAR*)call_info.remote_info.num_uri, NULL) == MMI_TRUE)
            #endif /* __MMI_CM_WHITE_LIST__ */
                || !srv_ucm_is_valid_number(m_groupInfo.call_type, call_info.remote_info.num_uri)
                || !srv_callset_reject_by_sms_get_mode())
            {
                m_actionArea->m_actionButtonGroup->setBtnDisable(2, VFX_TRUE);
            }
            else
            {
                m_actionArea->m_actionButtonGroup->setBtnDisable(2, VFX_FALSE);
            }
        #endif /* __MMI_UCM_REJECT_BY_SMS__ */
            break;
        }
        case SRV_UCM_OUTGOING_STATE:
        {
            m_actionArea->setAreaType(VAPP_UCM_AREA_NORMAL);
            m_actionArea->m_actionButtonGroup->setType(VAPP_UCM_ACTBTN_GRP_8_BTN);
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(0, STR_ID_VAPP_UCM_SWITCH);
            m_actionArea->m_actionButtonGroup->setBtnIcon(0, VcpStateImage(VAPP_UCM_VT_SWITCH, VAPP_UCM_VT_SWITCH, VAPP_UCM_VT_SWITCH, VAPP_UCM_VT_SWITCH));
            m_actionArea->m_actionButtonGroup->setBtnDisable(0, VFX_TRUE);
            m_actionArea->m_actionButtonGroup->setBtnId(0, VAPP_UCM_ACT_AREA_BTN_SWITCH);
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(1, STR_ID_VAPP_UCM_HIDE);
            m_actionArea->m_actionButtonGroup->setBtnIcon(1, VcpStateImage(VAPP_UCM_VT_HIDE, VAPP_UCM_VT_HIDE, VAPP_UCM_VT_HIDE, VAPP_UCM_VT_HIDE));
            m_actionArea->m_actionButtonGroup->setBtnDisable(1, VFX_TRUE);
            m_actionArea->m_actionButtonGroup->setBtnId(1, VAPP_UCM_ACT_AREA_BTN_HIDE);
    
            switch (m_vtStatus.view.camMode)
            {
                case SRV_CALLSET_VT_CAMERA_FRONT:
                    m_actionArea->m_actionButtonGroup->setBtnLabel(2, STR_ID_VAPP_UCM_REAR_CAMERA);
                    break;
    
                case SRV_CALLSET_VT_CAMERA_BACK:
                    m_actionArea->m_actionButtonGroup->setBtnLabel(2, STR_ID_VAPP_UCM_CAMERA_OFF);
                    break;
    
                case SRV_CALLSET_VT_CAMERA_OFF:
                    m_actionArea->m_actionButtonGroup->setBtnLabel(2, STR_ID_VAPP_UCM_FRONT_CAMERA);
                    break;
            }
            m_actionArea->m_actionButtonGroup->setBtnDisable(2, VFX_TRUE);
            m_actionArea->m_actionButtonGroup->setBtnIcon(2, VcpStateImage(VAPP_UCM_VT_CAMERA, VAPP_UCM_VT_CAMERA, VAPP_UCM_VT_CAMERA, VAPP_UCM_VT_CAMERA));
            m_actionArea->m_actionButtonGroup->setBtnId(2, VAPP_UCM_ACT_AREA_BTN_CAMERA);
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(3, STR_ID_VAPP_UCM_MORE);
            m_actionArea->m_actionButtonGroup->setBtnDisable(3, VFX_TRUE);
            m_actionArea->m_actionButtonGroup->setBtnId(3, VAPP_UCM_ACT_AREA_BTN_MORE);
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(4, STR_ID_VAPP_UCM_MUTE);
            m_actionArea->m_actionButtonGroup->setBtnSwitchable(4, VFX_TRUE);
            m_actionArea->m_actionButtonGroup->setBtnDisable(4, VFX_TRUE);
            if(srv_speech_is_phone_mute() == MMI_TRUE)
            {
                m_actionArea->m_actionButtonGroup->setBtnSwitchOn(4, VFX_TRUE);
            }
            else
            {
                m_actionArea->m_actionButtonGroup->setBtnSwitchOn(4, VFX_FALSE);
            }
            m_actionArea->m_actionButtonGroup->setBtnId(4, VAPP_UCM_ACT_AREA_BTN_MUTE);
            
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(5, STR_ID_VAPP_UCM_BT);
            m_actionArea->m_actionButtonGroup->setBtnIcon(5, VcpStateImage(IMG_ID_VAPP_UCM_ICON_BT, IMG_ID_VAPP_UCM_ICON_BT, IMG_ID_VAPP_UCM_ICON_BT, IMG_ID_VAPP_UCM_ICON_BT));
            m_actionArea->m_actionButtonGroup->setBtnSwitchable(5, VFX_TRUE);
            m_actionArea->m_actionButtonGroup->setBtnId(5, VAPP_UCM_ACT_AREA_BTN_BLUETOOTH);
    #ifdef __MMI_BT_SUPPORT__
        if ((srv_bt_cm_is_profile_connected(SRV_BT_CM_HFP_CONNECTION) || srv_bt_cm_is_profile_connected(SRV_BT_CM_HSP_CONNECTION)) == MMI_FALSE)
        {
            m_actionArea->m_actionButtonGroup->setBtnDisable(5, VFX_TRUE);
        }
        else
        {
            m_actionArea->m_actionButtonGroup->setBtnSwitchOn(0, srv_bt_cm_is_incall_aud_swap2bt());
        }
    #endif
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(6, STR_ID_VAPP_UCM_KEYPAD);
            m_actionArea->m_actionButtonGroup->setBtnSwitchable(6, VFX_TRUE);
            m_actionArea->m_actionButtonGroup->setBtnId(6, VAPP_UCM_ACT_AREA_BTN_KEYPAD);
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(7, STR_ID_VAPP_UCM_SPEAKER);
            m_actionArea->m_actionButtonGroup->setBtnIcon(7, VcpStateImage(IMG_ID_VAPP_UCM_ICON_SPEAKER, IMG_ID_VAPP_UCM_ICON_SPEAKER, IMG_ID_VAPP_UCM_ICON_SPEAKER, IMG_ID_VAPP_UCM_ICON_SPEAKER));
            m_actionArea->m_actionButtonGroup->setBtnSwitchable(7, VFX_TRUE);
            if (srv_btaud_get_status(BTAUD_CHNL_MONO) == BTAUD_SWITCH_ON)
            {
                m_actionArea->m_actionButtonGroup->setBtnDisable(7, VFX_TRUE);
            }
            else
            {
                m_actionArea->m_actionButtonGroup->setBtnDisable(7, VFX_FALSE);
                if(srv_speech_is_hand_free() == MMI_TRUE)
                {
                    m_actionArea->m_actionButtonGroup->setBtnSwitchOn(7, VFX_TRUE);
                }
                else
                {
                    m_actionArea->m_actionButtonGroup->setBtnSwitchOn(7, VFX_FALSE);
                }
            }
            m_actionArea->m_actionButtonGroup->setBtnId(7, VAPP_UCM_ACT_AREA_BTN_SPEAKER);

            break;
        }
        case SRV_UCM_ACTIVE_STATE:
        {
            m_actionArea->setAreaType(VAPP_UCM_AREA_NORMAL);
            m_actionArea->m_actionButtonGroup->setType(VAPP_UCM_ACTBTN_GRP_8_BTN);
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(0, STR_ID_VAPP_UCM_SWITCH);
            m_actionArea->m_actionButtonGroup->setBtnIcon(0, VcpStateImage(VAPP_UCM_VT_SWITCH, VAPP_UCM_VT_SWITCH, VAPP_UCM_VT_SWITCH, VAPP_UCM_VT_SWITCH));
            m_actionArea->m_actionButtonGroup->setBtnId(0, VAPP_UCM_ACT_AREA_BTN_SWITCH);
    
            if (m_vtStatus.frontHidden)
            {
                m_actionArea->m_actionButtonGroup->setBtnLabel(1, STR_ID_VAPP_UCM_UNHIDE);
                m_actionArea->m_actionButtonGroup->setBtnIcon(1, VcpStateImage(VAPP_UCM_VT_UNHIDE, VAPP_UCM_VT_UNHIDE, VAPP_UCM_VT_UNHIDE, VAPP_UCM_VT_UNHIDE));
            }
            else
            {
                m_actionArea->m_actionButtonGroup->setBtnLabel(1, STR_ID_VAPP_UCM_HIDE);
                m_actionArea->m_actionButtonGroup->setBtnIcon(1, VcpStateImage(VAPP_UCM_VT_HIDE, VAPP_UCM_VT_HIDE, VAPP_UCM_VT_HIDE, VAPP_UCM_VT_HIDE));
            }
            m_actionArea->m_actionButtonGroup->setBtnId(1, VAPP_UCM_ACT_AREA_BTN_HIDE);
    
            switch (m_vtStatus.view.camMode)
            {
                case SRV_CALLSET_VT_CAMERA_FRONT:
                    m_actionArea->m_actionButtonGroup->setBtnLabel(2, STR_ID_VAPP_UCM_REAR_CAMERA);
                    break;
    
                case SRV_CALLSET_VT_CAMERA_BACK:
                    m_actionArea->m_actionButtonGroup->setBtnLabel(2, STR_ID_VAPP_UCM_CAMERA_OFF);
    
                    break;
    
                case SRV_CALLSET_VT_CAMERA_OFF:
                   m_actionArea->m_actionButtonGroup->setBtnLabel(2, STR_ID_VAPP_UCM_FRONT_CAMERA);
                   break;
            }
            m_actionArea->m_actionButtonGroup->setBtnIcon(2, VcpStateImage(VAPP_UCM_VT_CAMERA, VAPP_UCM_VT_CAMERA, VAPP_UCM_VT_CAMERA, VAPP_UCM_VT_CAMERA));
            m_actionArea->m_actionButtonGroup->setBtnId(2, VAPP_UCM_ACT_AREA_BTN_CAMERA);
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(3, STR_ID_VAPP_UCM_MORE);
            m_actionArea->m_actionButtonGroup->setBtnIcon(3, VcpStateImage(IMG_ID_VAPP_UCM_ICON_MORE, IMG_ID_VAPP_UCM_ICON_MORE, IMG_ID_VAPP_UCM_ICON_MORE, IMG_ID_VAPP_UCM_ICON_MORE));
            m_actionArea->m_actionButtonGroup->setBtnId(3, VAPP_UCM_ACT_AREA_BTN_MORE);

            m_actionArea->m_actionButtonGroup->setBtnLabel(4, STR_ID_VAPP_UCM_MUTE);
            m_actionArea->m_actionButtonGroup->setBtnIcon(4, VcpStateImage(IMG_ID_VAPP_UCM_ICON_MUTE, IMG_ID_VAPP_UCM_ICON_MUTE, IMG_ID_VAPP_UCM_ICON_MUTE, IMG_ID_VAPP_UCM_ICON_MUTE));
            m_actionArea->m_actionButtonGroup->setBtnSwitchable(4, VFX_TRUE);
            if(srv_speech_is_phone_mute() == MMI_TRUE)
            {
                m_actionArea->m_actionButtonGroup->setBtnSwitchOn(4, VFX_TRUE);
            }
            else
            {
                m_actionArea->m_actionButtonGroup->setBtnSwitchOn(4, VFX_FALSE);
            }
            m_actionArea->m_actionButtonGroup->setBtnId(4, VAPP_UCM_ACT_AREA_BTN_MUTE);
            
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(5, STR_ID_VAPP_UCM_BT);
            m_actionArea->m_actionButtonGroup->setBtnIcon(5, VcpStateImage(IMG_ID_VAPP_UCM_ICON_BT, IMG_ID_VAPP_UCM_ICON_BT, IMG_ID_VAPP_UCM_ICON_BT, IMG_ID_VAPP_UCM_ICON_BT));
            m_actionArea->m_actionButtonGroup->setBtnSwitchable(5, VFX_TRUE);
            m_actionArea->m_actionButtonGroup->setBtnId(5, VAPP_UCM_ACT_AREA_BTN_BLUETOOTH);
    #ifdef __MMI_BT_SUPPORT__
        if ((srv_bt_cm_is_profile_connected(SRV_BT_CM_HFP_CONNECTION) || srv_bt_cm_is_profile_connected(SRV_BT_CM_HSP_CONNECTION)) == MMI_FALSE)
        {
            m_actionArea->m_actionButtonGroup->setBtnDisable(5, VFX_TRUE);
        }
        else
        {
            m_actionArea->m_actionButtonGroup->setBtnSwitchOn(0, srv_bt_cm_is_incall_aud_swap2bt());
        }
    #endif
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(6, STR_ID_VAPP_UCM_KEYPAD);
            m_actionArea->m_actionButtonGroup->setBtnIcon(6, VcpStateImage(IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD, IMG_ID_VAPP_UCM_ICON_KEYPAD));
            m_actionArea->m_actionButtonGroup->setBtnSwitchable(6, VFX_TRUE);
            m_actionArea->m_actionButtonGroup->setBtnId(6, VAPP_UCM_ACT_AREA_BTN_KEYPAD);
    
            m_actionArea->m_actionButtonGroup->setBtnLabel(7, STR_ID_VAPP_UCM_SPEAKER);
            m_actionArea->m_actionButtonGroup->setBtnIcon(7, VcpStateImage(IMG_ID_VAPP_UCM_ICON_SPEAKER, IMG_ID_VAPP_UCM_ICON_SPEAKER, IMG_ID_VAPP_UCM_ICON_SPEAKER, IMG_ID_VAPP_UCM_ICON_SPEAKER));
            m_actionArea->m_actionButtonGroup->setBtnSwitchable(7, VFX_TRUE);
            if (srv_btaud_get_status(BTAUD_CHNL_MONO) == BTAUD_SWITCH_ON)
            {
                m_actionArea->m_actionButtonGroup->setBtnDisable(7, VFX_TRUE);
            }
            else
            {
                m_actionArea->m_actionButtonGroup->setBtnDisable(7, VFX_FALSE);
                if(srv_speech_is_hand_free() == MMI_TRUE)
                {
                    m_actionArea->m_actionButtonGroup->setBtnSwitchOn(7, VFX_TRUE);
                }
                else
                {
                    m_actionArea->m_actionButtonGroup->setBtnSwitchOn(7, VFX_FALSE);
                }
            }
            m_actionArea->m_actionButtonGroup->setBtnId(7, VAPP_UCM_ACT_AREA_BTN_SPEAKER);
		#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
		#endif
            break;
        }
    }   

}

VfxRect VappUcmVideoCallCell::getVFrameRect()
{
    VfxS32 maxX, minX, maxY, minY;
    maxX = (m_vFrameMain->getRect().getMaxX() > m_vFrameSub->getRect().getMaxX()) ? 
                m_vFrameMain->getRect().getMaxX() : m_vFrameSub->getRect().getMaxX();
    minX = (m_vFrameMain->getRect().getMinX() < m_vFrameSub->getRect().getMinX()) ? 
                m_vFrameMain->getRect().getMinX() : m_vFrameSub->getRect().getMinX();
    maxY = (m_vFrameMain->getRect().getMaxY() > m_vFrameSub->getRect().getMaxY()) ? 
                m_vFrameMain->getRect().getMaxY() : m_vFrameSub->getRect().getMaxY();
    minY = (m_vFrameMain->getRect().getMinY() < m_vFrameSub->getRect().getMinY()) ? 
                m_vFrameMain->getRect().getMinY() : m_vFrameSub->getRect().getMinY();

    return VfxRect(minX - m_videoFrame->getFrameMargin(), 
                minY - m_videoFrame->getFrameMargin(), 
                maxX - minX + 2 * m_videoFrame->getFrameMargin(),
                maxY - minY + 2 * m_videoFrame->getFrameMargin());
}

void VappUcmVideoCallCell::updateVideoFrame()
{
    m_videoFrame->setAnchor(0.5f, 0);
    m_videoFrame->setRect(getVFrameRect());
    m_videoFrame->setHidden(VFX_FALSE);
    m_videoFrame->setFrameRect((m_vtStatus.frontVtFrame == VAPP_VT_VIDEOFRAME_TYPE_LOCAL) ? 
        VAPP_VT_VIDEOFRAME_TYPE_PEER : VAPP_VT_VIDEOFRAME_TYPE_LOCAL,
        m_videoFrame->convertRectFrom(
            VfxRect(
                m_vFrameMain->getPos().x, 
                m_vFrameMain->getPos().y + m_vFrameMain->getSize().height/2, 
                m_vFrameMain->getSize().width, 
                m_vFrameMain->getSize().height), 
            this));

#ifndef __MDP_VT_PREVIEW_UPSCALE_SUPPORT__
    if (m_vFrameMain->getSize().width > 176 || m_vFrameMain->getSize().height > 144)
    {
        m_videoFrame->setFrameRect((m_vtStatus.frontVtFrame == VAPP_VT_VIDEOFRAME_TYPE_LOCAL) ? 
            VAPP_VT_VIDEOFRAME_TYPE_PEER : VAPP_VT_VIDEOFRAME_TYPE_LOCAL,
            m_videoFrame->convertRectFrom(
                VfxRect(
                    m_vFrameMain->getPos().x, 
                    m_vFrameMain->getPos().y + 144/2, 
                    176, 
                    144), 
                this));
    }
#endif

    m_videoFrame->setFrameRect(
        m_vtStatus.frontVtFrame, 
        m_videoFrame->convertRectFrom(
            VfxRect(
                m_vFrameSub->getPos().x, 
                m_vFrameSub->getPos().y + m_vFrameSub->getSize().height/2, 
                m_vFrameSub->getSize().width, 
                m_vFrameSub->getSize().height), 
            this));

    m_videoFrame->setParamFrameFront(m_vtStatus.frontVtFrame);
    
    updateLocalView();

    m_videoFrame->setParamFrameMode(VAPP_VT_VIDEOFRAME_TYPE_PEER, VAPP_VT_VIDEOFRAME_SRC_VIDEO);

    m_videoFrame->setParamHide(
        (m_vtStatus.frontVtFrame == VAPP_VT_VIDEOFRAME_TYPE_LOCAL) ? 
            VAPP_VT_VIDEOFRAME_TYPE_PEER : VAPP_VT_VIDEOFRAME_TYPE_LOCAL, 
        VFX_FALSE);
    m_videoFrame->setParamHide(m_vtStatus.frontVtFrame, m_vtStatus.frontHidden);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
}

void VappUcmVideoCallCell::updateLocalView()
{
    switch (m_vtStatus.view.camMode)
    {
        case SRV_CALLSET_VT_CAMERA_FRONT:
            m_videoFrame->setParamFrameMode(VAPP_VT_VIDEOFRAME_TYPE_LOCAL, VAPP_VT_VIDEOFRAME_SRC_VIDEO);
            m_videoFrame->setParamSensorId(VAPP_VT_VIDEOFRAME_CAMERA_FRONT);
            m_videoFrame->setParamNightMode((VfxU16)m_vtStatus.view.nightModeFront);
            m_needUpdateValue = VFX_TRUE;
            break;
    
        case SRV_CALLSET_VT_CAMERA_BACK:
            m_videoFrame->setParamFrameMode(VAPP_VT_VIDEOFRAME_TYPE_LOCAL, VAPP_VT_VIDEOFRAME_SRC_VIDEO);
            m_videoFrame->setParamSensorId(VAPP_VT_VIDEOFRAME_CAMERA_BACK);
            m_videoFrame->setParamNightMode((VfxU16)m_vtStatus.view.nightModeBack);
            m_needUpdateValue = VFX_TRUE;
            break;
    
        case SRV_CALLSET_VT_CAMERA_OFF:
            m_videoFrame->setParamFrameMode(VAPP_VT_VIDEOFRAME_TYPE_LOCAL, VAPP_VT_VIDEOFRAME_SRC_IMAGE);
    
            if (m_vtStatus.view.imagePath.isEmpty())
            {
                m_videoFrame->setParamFrameContent(VAPP_VT_VIDEOFRAME_TYPE_LOCAL, VfxImageSrc(IMG_ID_CALLSET_VT_DEFAULT_IMAGE));
            }
            else if (m_videoFrame->setParamFrameContent(VAPP_VT_VIDEOFRAME_TYPE_LOCAL, VfxImageSrc(m_vtStatus.view.imagePath)) != VAPP_VT_VIDEOFRAME_ERROR_NO_ERROR)
            {
                m_videoFrame->setParamFrameContent(VAPP_VT_VIDEOFRAME_TYPE_LOCAL, VfxImageSrc(IMG_ID_CALLSET_VT_DEFAULT_IMAGE));;
            }
    
            m_videoFrame->setParamSensorId(VAPP_VT_VIDEOFRAME_CAMERA_OFF);
            break;
    }
}

void VappUcmVideoCallCell::updateLocalValue()
{
    VappVtVideoFrameEvCapStruct evCap;
    int i = 0;

    if (m_vtStatus.view.camMode != SRV_CALLSET_VT_CAMERA_OFF)
    {
        m_videoFrame->getEVCap(&evCap);
        for (; i < evCap.count; i++)
        {
            if (evCap.supportItem[i] == VAPP_VT_VIDEOFRAME_EV_0)
                break;
        }
        if (i == evCap.count)
        {
            /* abnormal */
            VFX_ASSERT(0);
        }
    }

    VappVtVideoFrameEvEnum v;
    switch (m_vtStatus.view.camMode)
    {
        case SRV_CALLSET_VT_CAMERA_FRONT:
            v = getVFrameAppEv(m_vtStatus.view.evFront);
            if (v == VAPP_VT_VIDEOFRAME_EV_TOTAL)
            {
                v = VAPP_VT_VIDEOFRAME_EV_0;
            }
            m_videoFrame->setEVValue(v);

            m_videoFrame->setZoomValue((VfxU16)m_vtStatus.view.zoomFront);
            break;

        case SRV_CALLSET_VT_CAMERA_BACK:
            v = getVFrameAppEv(m_vtStatus.view.evBack);
            if (v == VAPP_VT_VIDEOFRAME_EV_TOTAL)
            {
                v = VAPP_VT_VIDEOFRAME_EV_0;
            }
            m_videoFrame->setEVValue(v);

            m_videoFrame->setZoomValue((VfxU16)m_vtStatus.view.zoomBack);
            break;
        }
}

void VappUcmVideoCallCell::clearFrames()
{
    /* clear all frames except for video frame */
    VFX_OBJ_CLOSE(m_callStatus);
    VFX_OBJ_CLOSE(m_actionArea);
    VFX_OBJ_CLOSE(m_moreCmdPopup);
    VFX_OBJ_CLOSE(m_cnfPopup);
    VFX_OBJ_CLOSE(m_frame);
}

void VappUcmVideoCallCell::onActionAreaClicked(VfxId btn, VappUcmActionBtnStateEnum state)
{
    VappUcmActionAreaBtnEnum btn_type = (VappUcmActionAreaBtnEnum)btn;
    switch (btn_type)
    {
        case VAPP_UCM_ACT_AREA_BTN_ACCEPT_CALL:
        {
            onCallAccept();
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_SWITCH:
        {
            vFramePause();
            if (m_vtStatus.frontHidden)
            {
                m_videoFrame->setParamHide(m_vtStatus.frontVtFrame, VFX_FALSE);
                m_videoFrame->setParamHide(
                    (m_vtStatus.frontVtFrame == VAPP_VT_VIDEOFRAME_TYPE_LOCAL) ? 
                        VAPP_VT_VIDEOFRAME_TYPE_PEER : VAPP_VT_VIDEOFRAME_TYPE_LOCAL, 
                    VFX_TRUE);
            }

            m_vtStatus.frontVtFrame = (m_vtStatus.frontVtFrame == VAPP_VT_VIDEOFRAME_TYPE_LOCAL) ? 
                VAPP_VT_VIDEOFRAME_TYPE_PEER : VAPP_VT_VIDEOFRAME_TYPE_LOCAL;

            m_videoFrame->setFrameRect(
                (m_vtStatus.frontVtFrame == VAPP_VT_VIDEOFRAME_TYPE_LOCAL) ? 
                    VAPP_VT_VIDEOFRAME_TYPE_PEER : VAPP_VT_VIDEOFRAME_TYPE_LOCAL,
                m_videoFrame->convertRectFrom(
                    VfxRect(
                        m_vFrameMain->getPos().x, 
                        m_vFrameMain->getPos().y + m_vFrameMain->getSize().height/2, 
                        m_vFrameMain->getSize().width, 
                        m_vFrameMain->getSize().height), 
                    this));
        
        #ifndef __MDP_VT_PREVIEW_UPSCALE_SUPPORT__
            if (m_vFrameMain->getSize().width > 176 || m_vFrameMain->getSize().height > 144)
            {
                m_videoFrame->setFrameRect(
                    (m_vtStatus.frontVtFrame == VAPP_VT_VIDEOFRAME_TYPE_LOCAL) ? 
                        VAPP_VT_VIDEOFRAME_TYPE_PEER : VAPP_VT_VIDEOFRAME_TYPE_LOCAL,
                    m_videoFrame->convertRectFrom(
                        VfxRect(
                            m_vFrameMain->getPos().x, 
                            m_vFrameMain->getPos().y + 144/2, 
                            176, 
                            144), 
                        this));
            }
        #endif
        
            m_videoFrame->setFrameRect(
                m_vtStatus.frontVtFrame, 
                m_videoFrame->convertRectFrom(
                    VfxRect(
                        m_vFrameSub->getPos().x, 
                        m_vFrameSub->getPos().y + m_vFrameSub->getSize().height/2, 
                        m_vFrameSub->getSize().width, 
                        m_vFrameSub->getSize().height), 
                    this));
        
            m_videoFrame->setParamFrameFront(m_vtStatus.frontVtFrame);

            vFrameResume();
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_HIDE:
        {
            if (m_vtStatus.frontHidden)
            {
                vFramePause();
                m_videoFrame->setParamHide(m_vtStatus.frontVtFrame, VFX_FALSE);
                vFrameResume();
                m_actionArea->m_actionButtonGroup->setBtnLabel(1, STR_ID_VAPP_UCM_HIDE);
                m_vtStatus.frontHidden = VFX_FALSE;
            }
            else
            {
                vFramePause();
                m_videoFrame->setParamHide(m_vtStatus.frontVtFrame, VFX_TRUE);
                vFrameResume();
                m_actionArea->m_actionButtonGroup->setBtnLabel(1, STR_ID_VAPP_UCM_UNHIDE);
                m_vtStatus.frontHidden = VFX_TRUE;
            }
            break;
        }
        case VAPP_UCM_ACT_AREA_BTN_CAMERA:
        {
            switch(m_vtStatus.view.camMode)
            {
                case SRV_CALLSET_VT_CAMERA_FRONT:
                    m_vtStatus.view.camMode = SRV_CALLSET_VT_CAMERA_BACK;
                    m_actionArea->m_actionButtonGroup->setBtnLabel(2, STR_ID_VAPP_UCM_CAMERA_OFF);
                    break;

                case SRV_CALLSET_VT_CAMERA_BACK:
                    m_vtStatus.view.camMode = SRV_CALLSET_VT_CAMERA_OFF;
                    m_actionArea->m_actionButtonGroup->setBtnLabel(2, STR_ID_VAPP_UCM_FRONT_CAMERA);
                    break;

                case SRV_CALLSET_VT_CAMERA_OFF:
                    m_vtStatus.view.camMode = SRV_CALLSET_VT_CAMERA_FRONT;
                    m_actionArea->m_actionButtonGroup->setBtnLabel(2, STR_ID_VAPP_UCM_REAR_CAMERA);
                    break;

                default:
                    return;
            }
            vFramePause();
            updateLocalView();
            vFrameResume();
            break;
        }
        default:
            VappUcmCallCell::onActionAreaClicked(btn, state);
            break;
    }

}


void VappUcmVideoCallCell::showMoreOptions(void)
{
    VFX_OBJ_CREATE(m_moreCmdPopup, VcpMoreCommandPopup, this);
    m_moreCmdPopup->addItem(OPTION_SNAPSHOT, STR_ID_VAPP_UCM_SNAPSHOT, VCP_POPUP_BUTTON_TYPE_NORMAL);
    m_moreCmdPopup->addItem(OPTION_ADJUST_LOCAL_IMG, STR_ID_VAPP_UCM_ADJUST_LOCAL_IMG, VCP_POPUP_BUTTON_TYPE_NORMAL);
    m_moreCmdPopup->addItem(OPTION_SWITCH_TO_VOICE_CALL, STR_ID_VAPP_UCM_SWITCH_TO_VOICE_CALL, VCP_POPUP_BUTTON_TYPE_NORMAL);
    if (srv_ucm_query_call_count((srv_ucm_call_state_enum)(SRV_UCM_OUTGOING_STATE|SRV_UCM_INCOMING_STATE), SRV_UCM_CALL_TYPE_ALL, NULL))
    {
        /* not allow */
        m_moreCmdPopup->disableItem(OPTION_SWITCH_TO_VOICE_CALL);
    }
#ifdef __MMI_DUAL_MIC_SUPPORT__
    if (mmi_ucm_get_dual_mic_nr_status())
    {
        m_moreCmdPopup->addItem(OPTION_DMNR, STR_ID_VAPP_UCM_DISABLE_DMNR, VCP_POPUP_BUTTON_TYPE_NORMAL);
    }
    else
    {
        m_moreCmdPopup->addItem(OPTION_DMNR, STR_ID_VAPP_UCM_ENABLE_DMNR, VCP_POPUP_BUTTON_TYPE_NORMAL);
    }
#endif /* __MMI_DUAL_MIC_SUPPORT__ */
#ifdef __MMI_UCM_VT_MSG__
    m_moreCmdPopup->addItem(OPTION_SMS, STR_ID_VAPP_UCM_SMS, VCP_POPUP_BUTTON_TYPE_NORMAL);
#endif /* __MMI_UCM_VT_MSG__ */
    m_moreCmdPopup->addItem(OPTION_CLOSE, STR_GLOBAL_CLOSE, VCP_POPUP_BUTTON_TYPE_CANCEL);
    m_moreCmdPopup->m_signalButtonClicked.connect(this, &VappUcmVideoCallCell::onCmdBtnClicked);
    m_moreCmdPopup->setAutoDestory(VFX_FALSE);
    m_moreCmdPopup->show(VFX_TRUE);
    m_isMorePopupShowing = VFX_TRUE;    // for UI Performance

}

void VappUcmVideoCallCell::onCmdBtnClicked(VfxObject* sender, VfxId id)
{
    if (id != VCP_POPUP_BUTTON_NO_PRESSED)
    {
        if (m_moreCmdPopup)
        {
            m_moreCmdPopup->exit(VFX_TRUE);
            m_moreCmdPopup = NULL;
            m_isMorePopupShowing = VFX_FALSE;   // for UI Performance
            if (SRV_UCM_HOLD_STATE == m_groupInfo.call_state || SRV_UCM_ACTIVE_STATE == m_groupInfo.call_state)
            {
                onCallTimerTicked(NULL);
            }
        }
    }

    if (!srv_ucm_query_call_count(SRV_UCM_ACTIVE_STATE, SRV_UCM_VIDEO_CALL_TYPE, NULL)
    #ifdef __MMI_EM_PROFILING_VT_LOOKBACK__
/* under construction !*/
    #endif /* __MMI_EM_PROFILING_VT_LOOKBACK__ */
        )
    {
        /* don't handle click cb during call release procdure */
        return;
    }

    switch (id)
    {
        case OPTION_SNAPSHOT:
        {
            WCHAR *buf;
            VFX_ALLOC_MEM(buf, (SRV_FMGR_PATH_MAX_LEN + 1)*ENCODING_LENGTH, this);
            memset(buf, 0, (SRV_FMGR_PATH_MAX_LEN + 1)*ENCODING_LENGTH);

            /* path */
            S32 drvLetter;
            drvLetter = FS_GetDrive(FS_DRIVE_V_NORMAL, 2, FS_DRIVE_V_NORMAL);
            if(drvLetter > 0)
            {
                mmi_wsprintf_ex(buf, SRV_FMGR_PATH_MAX_FILE_NAME_LEN, (WCHAR*)L"%c:\\", drvLetter);
            }
            srv_fmgr_path_append_ex(buf, SRV_FMGR_PATH_MAX_FILE_NAME_LEN, (VfxWChar*)SHOOTING_DOWNLOAD_FOLDER_NAME, MMI_TRUE);

            
            if (srv_fmgr_fs_path_exist(buf) < 0)
            {
                VfxS32 ret = srv_fmgr_fs_create_folder(buf);
                if (ret < 0)
                {
                    vapp_ucm_show_info_ballon((PU16)GetString(srv_fmgr_fs_error_get_string(ret)));
                    VFX_FREE_MEM(buf);
                    break;
                }
            }

            /* file name */
            VfxDateTime tmpDateTime;
            tmpDateTime.setCurrentTime();
            VfxWString fileName = tmpDateTime.getDateTimeString(
                VFX_DATE_TIME_DATE_YEAR | VFX_DATE_TIME_DATE_MONTH | VFX_DATE_TIME_DATE_DAY | 
                VFX_DATE_TIME_TIME_HOUR | VFX_DATE_TIME_TIME_MINUTE | VFX_DATE_TIME_TIME_SECOND | 
                VFX_DATE_TIME_FORMAT_NO_DATE_SEPARATOR);
            WCHAR *buf2;
            VFX_ALLOC_MEM(buf2, (SRV_FMGR_PATH_MAX_LEN - mmi_wcslen(buf) + 1)*ENCODING_LENGTH, this);
            memset(buf2, 0, (SRV_FMGR_PATH_MAX_LEN - mmi_wcslen(buf) + 1)*ENCODING_LENGTH);
            mmi_wcsncpy(buf2, fileName.getBuf(), SRV_FMGR_PATH_MAX_LEN - mmi_wcslen(buf));
            const WCHAR *invalidStr = srv_fmgr_path_get_invalid_chars();
             for (VfxU32 i = 0; i < (VfxU32)mmi_wcslen(buf2); i++)
             {
                 VfxU32 j = 0;
                 while(invalidStr[j])
                 {
                     if ((buf2[i] == L' ') || 
                         (buf2[i] == invalidStr[j]))
                     {
                         buf2[i] = L'_';
                     }
                     j++;
                 }
             }
            fileName = VFX_WSTR_MEM(buf2);
            VFX_FREE_MEM(buf2);
            fileName += VFX_WSTR(".jpg");
            srv_fmgr_path_append(buf, SRV_FMGR_PATH_MAX_FILE_NAME_LEN, fileName.getBuf());

            vFramePause();
            VappVtVideoFrameErrorEnum vtCaptureRet = m_videoFrame->capture(VAPP_VT_VIDEOFRAME_TYPE_PEER, (CHAR*)buf);
            if (VAPP_VT_VIDEOFRAME_ERROR_CAPTURE_DISK_FULL == vtCaptureRet)
            {
                vapp_ucm_show_info_ballon((PU16)GetString(STR_GLOBAL_NOT_ENOUGH_MEMORY));
            }
            else if (VAPP_VT_VIDEOFRAME_ERROR_NO_ERROR != vtCaptureRet)
            {
                vapp_ucm_show_info_ballon((PU16)GetString(STR_GLOBAL_ERROR));
            }
            else
            {
                vapp_ucm_show_info_ballon((PU16)GetString(STR_ID_VAPP_UCM_SNAPSHOT_SAVED));
            }
            vFrameResume();

            VFX_FREE_MEM(buf);
            break;
        }

        case OPTION_ADJUST_LOCAL_IMG:
        {
            m_vtStatus.view.videoFrame = m_videoFrame;
        #ifdef __MMI_EM_PROFILING_VT_LOOKBACK__
/* under construction !*/
        #endif /* __MMI_EM_PROFILING_VT_LOOKBACK__ */
            vFramePause();
            VFX_OBJ_CREATE_EX(m_pageVtPreview, VappCallSetPageVtPreview, vapp_ucm_scr, (VFX_TRUE, &(m_vtStatus.view)));
            m_pageVtPreview->m_signalVFrameMastershipReturn.connect(this, &VappUcmVideoCallCell::onVFrameOwnershipReturn);
            vapp_ucm_scr->pushPage(VFX_ID_NULL, m_pageVtPreview);
            break;
        }

        case OPTION_SWITCH_TO_VOICE_CALL:
        {
            srv_ucm_call_info_struct call_info;

            if (srv_ucm_query_call_count(
                    (srv_ucm_call_state_enum)(SRV_UCM_OUTGOING_STATE|SRV_UCM_INCOMING_STATE), 
                    SRV_UCM_CALL_TYPE_ALL, NULL))
            {
                /* error message */
                return;
            }

            if (!srv_ucm_query_call_data(m_callIndex, &call_info))
            {
                /* error message */
                return;
            }

            srv_ucm_dial_act_req_struct act_req;
            srv_ucm_result_enum result;

            /* get current active video call number */
            memset(&act_req, 0, sizeof(srv_ucm_dial_act_req_struct));
            act_req.call_type = SRV_UCM_VOICE_CALL_TYPE;
            mmi_asc_to_ucs2((CHAR*)act_req.num_uri, (CHAR*)call_info.remote_info.num_uri);
            act_req.module_id = SRV_UCM_MODULE_ORIGIN_COMMON;

            result = srv_ucm_query_act_permit(SRV_UCM_END_ALL_AND_DIAL_ACT,&act_req);

            if (result != SRV_UCM_RESULT_OK)
            {
                /* error popup */
            }
            else
            {
                srv_ucm_act_request(
                                SRV_UCM_END_ALL_AND_DIAL_ACT, 
                                &act_req, NULL, NULL);
            }
            break;
        }
    #ifdef __MMI_DUAL_MIC_SUPPORT__
        case OPTION_DMNR:
        {
            if(MMI_TRUE == mmi_ucm_get_dual_mic_nr_status())
            {
                mmi_ucm_set_dual_mic_nr_status(MMI_FALSE);
                vapp_ucm_show_info_ballon((PU16)GetString(STR_ID_VAPP_UCM_DMNR_OFF));
            }
            else
            {
                mmi_ucm_set_dual_mic_nr_status(MMI_TRUE);
                vapp_ucm_show_info_ballon((PU16)GetString(STR_ID_VAPP_UCM_DMNR_ON));
            }
            break;
        }
    #endif /* __MMI_DUAL_MIC_SUPPORT__ */
    #ifdef __MMI_UCM_VT_MSG__
        case OPTION_SMS:
        {
            if (srv_sms_is_sms_ready())
            {
                vapp_ucm_scr->pushMsgFolderPage();
            }
            else
            {
                mmi_frm_nmgr_balloon(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_INFO_BALLOON, MMI_NMGR_BALLOON_TYPE_FAILURE, (WCHAR*)(VFX_WSTR_RES(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE)).getBuf());
            }
            break;
        }
    #endif /* __MMI_UCM_VT_MSG__ */
    }
}

void VappUcmVideoCallCell::onVFrameOwnershipReturn(VappCallSetPageVtPreview *sender, VappCallSetVtStatusStruct *status)
{
    /* vFrame shall already be paused */
    m_state = VappUcmVideoCallCell::STATE_PAUSE;

    addChildFrame(m_videoFrame);
    m_pageVtPreview = NULL;

    if (isReducedCell())
    {
        m_videoFrame->setHidden(VFX_TRUE);
        m_videoFrame->setParamHide(VAPP_VT_VIDEOFRAME_TYPE_PEER, VFX_TRUE);
        m_videoFrame->setParamHide(VAPP_VT_VIDEOFRAME_TYPE_LOCAL, VFX_TRUE);
    }
    else
    {
        updateVideoFrame();
    }
    m_videoFrame->m_signalVtEvent.connect(this, &VappUcmVideoCallCell::onVFrameEvent);
    m_videoFrame->m_signalVtVideoFramePenEvent.connect(this, &VappUcmVideoCallCell::onVFramePenInput);

    if (vapp_ucm_scr->getApp()->isActive() && !isReducedCell())
    {
        m_isBg = VFX_FALSE;
    }
    else
    {
        m_isBg = VFX_TRUE;
    }

    /* jpg decoding cannot be done simultaneously with video decoding */
    /* thus v frame shall be resumed after the screen is entered */
    VfxTimer *timer;
    VFX_OBJ_CREATE(timer, VfxTimer, this);
    timer->setStartDelay(500);
    timer->m_signalTick.connect(this, &VappUcmVideoCallCell::onAfterVFrameOwnershipReturn);
    timer->start();

}

void VappUcmVideoCallCell::onAfterVFrameOwnershipReturn(VfxTimer *timer)
{
    if (!m_videoFrame)
    {
        /* video frame has been stopped or destroyed before timer expiry */
        return;
    }
    vFrameResume();
    VFX_OBJ_CLOSE(timer);
}

void VappUcmVideoCallCell::onSendImgCnfClicked(VfxObject* sender, VfxId id)
{
    if (!m_cnfPopup)
        return;

    m_cnfPopup->exit(VFX_TRUE);
    m_cnfPopup = NULL;

    if (!srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_VIDEO_CALL_TYPE, NULL))
    {
        /* handle the race condition that the user presses confirm btn during release animation */
        /* release_ind may not be handled during another call's release animation (ex. 1A voice + 1W VT -> replace)
            thus we cannot exit the confirm in the release indication */
        return;
    }

    switch (id)
    {
        case VCP_CONFIRM_POPUP_BUTTON_USER_1:
            /* don't need to change current camera mode */
            break;

        case VCP_CONFIRM_POPUP_BUTTON_USER_2:
            m_vtStatus.view.camMode = SRV_CALLSET_VT_CAMERA_OFF;
            break;

        default:
            return;
    }

    vapp_ucm_incoming_call_sendkey();
}

void VappUcmVideoCallCell::onSendImgCnfClicked2(VfxObject* sender, VfxId id)
{
    if (!m_cnfPopup)
        return;

    m_cnfPopup->exit(VFX_TRUE);
    m_cnfPopup = NULL;

    if (!srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_VIDEO_CALL_TYPE, NULL))
    {
        /* handle the race condition that the user presses confirm btn during release animation */
        /* release_ind may not be handled during another call's release animation (ex. 1A voice + 1W VT -> replace)
            thus we cannot exit the confirm in the release indication */
        return;
    }

    switch (id)
    {
        case VCP_CONFIRM_POPUP_BUTTON_USER_1:
            /* don't need to change current camera mode */
            break;

        case VCP_CONFIRM_POPUP_BUTTON_USER_2:
            m_vtStatus.view.camMode = SRV_CALLSET_VT_CAMERA_OFF;
            break;

        default:
            return;
    }

    vapp_ucm_replace();
}

void VappUcmVideoCallCell::onAcceptCnfClicked(VfxObject* sender, VfxId id)
{
    if (!m_cnfPopup)
        return;

    if (id != VCP_POPUP_BUTTON_NO_PRESSED)
    {
        m_cnfPopup->exit(VFX_TRUE);
        m_cnfPopup = NULL;
    }

    if(id == VCP_CONFIRM_POPUP_BUTTON_USER_1)
    {
        if (srv_callset_vt_get_answer_mode() == SRV_CALLSET_VT_ANSWER_MODE_PROMPT)
        {
            VFX_OBJ_CREATE(m_cnfPopup, VcpConfirmPopup, this);
            m_cnfPopup->setInfoType(VCP_POPUP_TYPE_QUESTION);
            VfxWString tmpStr = VFX_WSTR_RES(STR_ID_VAPP_UCM_SEND_LOCAL_IMG);
            tmpStr += VFX_WSTR(" <");
            tmpStr += m_displayName->getString();
            tmpStr += VFX_WSTR("> ");
            tmpStr += VFX_WSTR_RES(STR_ID_UCM_QUESTION_MARK);
            m_cnfPopup->setText(tmpStr);
            m_cnfPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_USER_DEFINE);
            m_cnfPopup->setCustomButton(STR_GLOBAL_SEND, STR_ID_VAPP_UCM_NOT_SEND, 
                                    VCP_POPUP_BUTTON_TYPE_NORMAL, VCP_POPUP_BUTTON_TYPE_NORMAL);
            m_cnfPopup->m_signalButtonClicked.connect(this, &VappUcmVideoCallCell::onSendImgCnfClicked2);
            m_cnfPopup->setAutoDestory(VFX_FALSE);

            m_cnfPopup->show(VFX_TRUE);
        }
        else
        {
            vapp_ucm_replace();
        }
    }

}

void VappUcmVideoCallCell::onRefreshCell(VappUcmCallCellRefreshTypeEnum refresh_type, void* data)
{
    if (!data)
    {
        /* ignore */
        return;
    }

    /* need to stop vFrame in VAPP_UCM_REFRESH_TYPE_ACTIVE_SCREEN(backward and inactive)
        while the call table may have been modified at this moment (during call release animation) */
    /* don't update group info when refreshing active screen */
    if (refresh_type != VAPP_UCM_REFRESH_TYPE_ACTIVE_SCREEN)
    {
        srv_ucm_group_info_struct group_info;
        if (!srv_ucm_query_group_data(m_callIndex.group_index, &group_info))
        {
            return;
        }
        setGroupInfo(&group_info);
    }

    srv_ucm_call_info_struct call_info;
    if (refresh_type == VAPP_UCM_REFRESH_TYPE_ACT)
    {
        srv_ucm_act_notify_evt_struct *act_notify = (srv_ucm_act_notify_evt_struct*)data;

        switch (act_notify->act_op)
        {
            case SRV_UCM_ACCEPT_ACT:
            case SRV_UCM_END_ALL_AND_ACCEPT_ACT:
            case SRV_UCM_END_ALL_ACTIVE_AND_ACCEPT_ACT:
            {
                if (!srv_ucm_query_call_data(m_callIndex, &call_info))
                {
                    return;
                }

                if (SRV_UCM_ACT_NOTIFY_TYPE_START == act_notify->notify_type) 
                {
                    m_callStatus->setString(STR_ID_VAPP_UCM_CONNECTING);
                }
                else
                {
                    srv_ucm_act_rsp_struct *accept_rsp = 
                        (srv_ucm_act_rsp_struct*)act_notify->ptr;
                    MMI_ASSERT(accept_rsp);
                    if(accept_rsp->result_info.result == SRV_UCM_RESULT_OK)
                    {
                        if(srv_callset_vt_get_speaker_mode())
                        {
                            srv_speech_enable_hand_free();
                        }
                        else
                        {
                            srv_speech_disable_hand_free();
                        }

                        if(srv_callset_vt_get_mic_mode())
                        {
                            srv_speech_unmute_phone();
                        }
                        else
                        {
                            srv_speech_mute_phone();
                        }

                        updateScreen();
                    }
                    else if (vapp_ucm_scr->getMainPage()->getActivateCallCell() == this)
                    {
                        //showStatusNotify(VFX_WSTR_MEM(accept_rsp->result_info.error_msg));
                        vapp_ucm_display_info((WCHAR*)accept_rsp->result_info.error_msg);
                    }
                }
            }
            break;       

            default:
                break;   
        }
    }
    else if(refresh_type == VAPP_UCM_REFRESH_TYPE_IND)
    {
        srv_ucm_ind_evt_struct *ind = (srv_ucm_ind_evt_struct*)data;
        switch (ind->ind_type)
        {
            //MO_2Steps-BEGIN
            case SRV_UCM_OUTGOING_CALL_IND:
            {
                VFX_ASSERT(SRV_UCM_INVALID_ID != m_groupInfo.group_id);
                if (SRV_UCM_INVALID_ID != m_groupInfo.group_id)
                {
                    createActionArea(&m_actionArea);
                    srv_ucm_call_info_struct call_info;
                    srv_ucm_query_call_data(m_callIndex, &call_info);
                    m_displayName->setString(call_info.remote_info.disp_name);
                    updateCallerPic(&call_info);
                }
                break;
            }
            //MO_2Steps-END
            case SRV_UCM_CONNECT_IND:
            {
                srv_ucm_connect_ind_struct *conn_ind = (srv_ucm_connect_ind_struct*)(ind->ptr);
                MMI_ASSERT(conn_ind);

                if (!srv_ucm_query_call_data(m_callIndex, &call_info) ||
                    memcmp(&(conn_ind->uid_info), &(call_info.uid_info), sizeof(srv_ucm_id_info_struct)))
                {
                    return;
                }

                updateScreen();
                break;
            }
			#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif
#if 0       /* don't need to handle start_count. start timer when connected and use ucm srv start time to check if the time duration is valid */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
        }
    }
    else if ((refresh_type == VAPP_UCM_REFRESH_TYPE_ACTIVE_SCREEN)
                && m_videoFrame
                && !m_pageVtPreview /* don't have the ownership */
                && !isReducedCell()) /* stay in bg, don't need to move */                
    {
        if (srv_shutdown_is_running())
        {
            if (!(*((VfxBool*)data)) && !m_isBg)
            {
                if (srv_ucm_query_call_count(SRV_UCM_ACTIVE_STATE, SRV_UCM_VIDEO_CALL_TYPE, NULL))
                {
                    /* inactive and in fg, move to bg */
                    /* need to suspend hw layer display before vFrame is removed from the scenario tree */
                    vFramePause();
                    m_isBg = VFX_TRUE;
                    vFrameResume();
                }
                else
                {
                    /* shall stop vFrame before all screen transition animation starts */
                    m_videoFrame->stop();
                    m_videoFrame = NULL;
                }
            }
        }
        else
        {
            if (*((VfxBool*)data) && m_isBg)
            {
                /* active and in bg, move to fg */
                /* resume hw layer display after vFrame is recovered to the scenario tree */
                vFramePause();
                m_isBg = VFX_FALSE;
                vFrameResume();
            }
            else if (!(*((VfxBool*)data)) && !m_isBg)
            {
                if (srv_ucm_query_call_count(SRV_UCM_ACTIVE_STATE, SRV_UCM_VIDEO_CALL_TYPE, NULL))
                {
                    /* inactive and in fg, move to bg */
                    /* need to suspend hw layer display before vFrame is removed from the scenario tree */
                    vFramePause();
                    m_isBg = VFX_TRUE;
                    vFrameResume();
                }
                else
                {
                    /* shall stop vFrame before all screen transition animation starts */
                    m_videoFrame->stop();
                    m_videoFrame = NULL;
                }
            }
        }
    }
    else
    {
        /* ignore */
    }
}

void VappUcmVideoCallCell::onVFrameEvent(VappVtVideoFrameEvtEnum evt, VfxS32 param)
{
    switch (evt)
    {
        case VAPP_VT_VIDEOFRAME_EVENT_START:
            m_state = VappUcmVideoCallCell::STATE_PLAY_READY;
            if (m_actionArea)
            {
                m_actionArea->m_actionButtonGroup->disableAllBtns(VFX_FALSE);
                updateActionArea(SRV_UCM_ACTIVE_STATE);
            }
            break;

        case VAPP_VT_VIDEOFRAME_EVENT_RESUME:
            m_state = VappUcmVideoCallCell::STATE_PLAY_READY;
            if (m_actionArea)
            {
                m_actionArea->m_actionButtonGroup->disableAllBtns(VFX_FALSE);
                updateActionArea(SRV_UCM_ACTIVE_STATE);
            }
            break;

        case VAPP_VT_VIDEOFRAME_EVENT_ENC_PATH_BUILT:
            if (param && m_needUpdateValue)
            {
                updateLocalValue();
                m_needUpdateValue = VFX_FALSE;
            }
            break;
    }
}

void VappUcmVideoCallCell::onVFramePenInput(VfxPenEventTypeEnum type, VappVtVideoFrameTypeEnum frame)
{
    if (type != VFX_PEN_EVENT_TYPE_UP)
    {
        return;
    }

    if (frame == VAPP_VT_VIDEOFRAME_TYPE_LOCAL)
    {
        onCmdBtnClicked(this, 2);
    }
    
}

void VappUcmVideoCallCell::vFramePause()
{
    if (m_state == VappUcmVideoCallCell::STATE_PLAY_NOT_READY)
    {
        MMI_ASSERT(!m_isBg);
        m_videoFrame->abortResume();
        m_state = VappUcmVideoCallCell::STATE_PAUSE;
        return;
    }

    if (m_state != VappUcmVideoCallCell::STATE_PLAY_READY)
    {
        return;
    }

    if (m_actionArea)
    {
        m_actionArea->m_actionButtonGroup->disableAllBtns(VFX_TRUE);
    }
    if (m_isBg)
    {
        m_videoFrame->backgroundPause();
    }
    else
    {
        m_videoFrame->pause();
    }

    m_state = VappUcmVideoCallCell::STATE_PAUSE;
}

void VappUcmVideoCallCell::vFrameResume()
{
    if (m_state != VappUcmVideoCallCell::STATE_PAUSE)
    {
        return;
    }

    m_state = VappUcmVideoCallCell::STATE_PLAY_NOT_READY;

    if (m_isBg)
    {
        m_videoFrame->backgroundResume();
    }
    else
    {
        m_videoFrame->resume();
    }

}

void VappUcmVideoCallCell::onCallRelease()
{
    if (m_moreCmdPopup)
    {
        m_moreCmdPopup->exit(VFX_TRUE);
        m_moreCmdPopup = NULL;
    }

    stopCallTimer();

    if (isReducedCell())
    {
        updateCallStatus(STR_ID_VAPP_UCM_CALL_ENDED);
        /* there may be other call, thus recording may not be stopped, update rec icon */
        updateRecIcon();
    }
    else
    {
        if (m_videoFrame)
        {
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
		#endif
        }
        else
        {
            updateCallStatus(STR_ID_VAPP_UCM_CALL_ENDED);
            updateRecIcon();
        }
    }
}

void VappUcmVideoCallCell::onCallAccept()
{
    if (m_cnfPopup)
    {
        /* already in the accept process */
        return;
    }

    VappUcmAllowToAcceptResultEnum result = vapp_ucm_allow_to_accept();
    if (result == VAPP_UCM_ALLOW_TO_ACCEPT_RET_OK)
    {
        if (srv_callset_vt_get_answer_mode() == SRV_CALLSET_VT_ANSWER_MODE_PROMPT)
        {
            VFX_OBJ_CREATE(m_cnfPopup, VcpConfirmPopup, this);
            m_cnfPopup->setInfoType(VCP_POPUP_TYPE_QUESTION);
            VfxWString tmpStr = VFX_WSTR_RES(STR_ID_VAPP_UCM_SEND_LOCAL_IMG);
            tmpStr += VFX_WSTR(" <");
            tmpStr += m_displayName->getString();
            tmpStr += VFX_WSTR("> ");
            tmpStr += VFX_WSTR_RES(STR_ID_UCM_QUESTION_MARK);
            m_cnfPopup->setText(tmpStr);
            m_cnfPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_USER_DEFINE);
            m_cnfPopup->setCustomButton(STR_GLOBAL_SEND, STR_ID_VAPP_UCM_NOT_SEND, 
                                    VCP_POPUP_BUTTON_TYPE_NORMAL, VCP_POPUP_BUTTON_TYPE_NORMAL);
            m_cnfPopup->m_signalButtonClicked.connect(this, &VappUcmVideoCallCell::onSendImgCnfClicked);
            m_cnfPopup->setAutoDestory(VFX_FALSE);
        
            m_cnfPopup->show(VFX_TRUE);
        }
        else
        {
            vapp_ucm_incoming_call_sendkey();
        }
    }
    else if (result == VAPP_UCM_ALLOW_TO_ACCEPT_RET_REPLACE_EXISTING)
    {
        VFX_OBJ_CREATE(m_cnfPopup, VcpConfirmPopup, this);
        m_cnfPopup->setInfoType(VCP_POPUP_TYPE_WARNING);
        m_cnfPopup->setText(STR_ID_VAPP_UCM_REPLACE_EXISTING_CALL);
        m_cnfPopup->setButtonSet(VCP_CONFIRM_BUTTON_SET_USER_DEFINE);
        m_cnfPopup->setCustomButton(STR_GLOBAL_REPLACE, 
                                    STR_GLOBAL_CANCEL, 
                                    VCP_POPUP_BUTTON_TYPE_NORMAL,
                                    VCP_POPUP_BUTTON_TYPE_CANCEL);
        m_cnfPopup->setAutoDestory(VFX_FALSE);

        m_cnfPopup->show(VFX_TRUE);
        m_cnfPopup->m_signalButtonClicked.connect(this, &VappUcmVideoCallCell::onAcceptCnfClicked);
    }

}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
VappVtVideoFrameEvEnum VappUcmVideoCallCell::getVFrameAppEv(srv_callset_vt_ev_enum ev)
{
    switch (ev)
    {
        case SRV_CALLSET_VT_EV_0:
            return VAPP_VT_VIDEOFRAME_EV_0;

        case SRV_CALLSET_VT_EV_P1:
            return VAPP_VT_VIDEOFRAME_EV_P1;

        case SRV_CALLSET_VT_EV_P2:
            return VAPP_VT_VIDEOFRAME_EV_P2;

        case SRV_CALLSET_VT_EV_P3:
            return VAPP_VT_VIDEOFRAME_EV_P3;
        
        case SRV_CALLSET_VT_EV_P4:
            return VAPP_VT_VIDEOFRAME_EV_P4;
        
        case SRV_CALLSET_VT_EV_N1:
            return VAPP_VT_VIDEOFRAME_EV_N1;

        case SRV_CALLSET_VT_EV_N2:
            return VAPP_VT_VIDEOFRAME_EV_N2;

        case SRV_CALLSET_VT_EV_N3:
            return VAPP_VT_VIDEOFRAME_EV_N3;
        
        case SRV_CALLSET_VT_EV_N4:
            return VAPP_VT_VIDEOFRAME_EV_N4;

        default:
            return VAPP_VT_VIDEOFRAME_EV_TOTAL;
    }
}
#endif /* __MMI_VIDEO_TELEPHONY__ */
VFX_IMPLEMENT_CLASS("VappUcmNotification", VappUcmNotification, VsrvNCell);

void VappUcmNotification::onInit()
{
    VsrvNCell::onInit();
    m_ucmNCenterCell = NULL;
    m_timer = NULL;
    m_callCount = 0;
}

void VappUcmNotification::onDeinit()
{
    stopCallTimer();
    VFX_OBJ_CLOSE(m_ucmNCenterCell);
    VFX_OBJ_CLOSE(m_timer);
    VsrvNCell::onDeinit();
}

void VappUcmNotification::onCreateView(void* viewData, VfxU32 viewDataSize)
{
    VsrvNCell::onCreateView(viewData, viewDataSize);

    if (!m_ucmNCenterCell)
    {
        setSize(VAPP_NCENTER_ONGOING_CELL_WIDTH, VAPP_NCENTER_ONGOING_CELL_HEIGHT);
        VFX_OBJ_CREATE(m_ucmNCenterCell, VappNCenterOngoingCell, this);
        m_ucmNCenterCell->setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE, VFX_FRAME_ALIGNER_MODE_SIDE,
                                            VFX_FRAME_ALIGNER_MODE_SIDE, VFX_FRAME_ALIGNER_MODE_SIDE);
        m_ucmNCenterCell->setNotification(getNotification());
    }
    
    updateView();

    m_callCount = srv_ucm_query_call_count(SRV_UCM_CALL_STATE_CONNECTED, SRV_UCM_CALL_TYPE_NO_CSD, NULL);
    if (m_callCount > 0)
    {
        mmi_frm_cb_reg_event(EVT_ID_SRV_UCM_STATUS_CHANGE, VappUcmNotification::onCallStatusChange, this);
    }
}

void VappUcmNotification::onCloseView()
{
    mmi_frm_cb_dereg_event(EVT_ID_SRV_UCM_STATUS_CHANGE, VappUcmNotification::onCallStatusChange, this);
}

mmi_ret VappUcmNotification::onCallStatusChange(mmi_event_struct *evt)
{
    VappUcmNotification *nCell = (VappUcmNotification*)(evt->user_data);

    if (!nCell)
    {
        return MMI_RET_OK;
    }

    VfxS32 callCount = srv_ucm_query_call_count(SRV_UCM_CALL_STATE_CONNECTED, SRV_UCM_CALL_TYPE_NO_CSD, NULL);
    if (nCell->m_callCount != callCount)
    {
        nCell->m_callCount = callCount;

        if (nCell->m_callCount)
        {
            nCell->updateView();
        }
    }

    return MMI_RET_OK;

}

VfxWString VappUcmNotification::getCallTimeDurationStr(void)
{
    VfxDateTime diff_time, current_time;
    VfxWChar    duration_str[16];

    current_time.setCurrentTime();
    current_time.getDiff(m_callStartTime, diff_time);
    diff_time.getDateTimeString(VFX_DATE_TIME_TIME_HOUR | VFX_DATE_TIME_TIME_MINUTE | VFX_DATE_TIME_TIME_SECOND | VFX_DATE_TIME_DURATION_FULL_FORMAT, 
                                duration_str, 16);
    return VFX_WSTR_MEM(duration_str);
}

void VappUcmNotification::startCallTimer(void)
{
    if (!m_timer)
    {
        VFX_OBJ_CREATE(m_timer, VfxTimer, this);
        m_timer->setDuration(990);
        m_timer->m_signalTick.connect(this, &VappUcmNotification::onCallTimerTicked);
    }
    m_timer->start();
}

void VappUcmNotification::stopCallTimer(void)
{
    if (m_timer)
    {
        m_timer->stop();
    }
}

void VappUcmNotification::onCallTimerTicked(VfxTimer *timer)
{
    VfxWString main_str = m_callStatus;
    main_str += VFX_WSTR("(");
    main_str += getCallTimeDurationStr();
    main_str += VFX_WSTR(")");
    m_ucmNCenterCell->setMainText(main_str);
}

void VappUcmNotification::updateView(void)
{
    srv_ucm_group_info_struct group_info;
    srv_ucm_call_info_struct call_info;
    VfxS32 call_count = 0;

    VfxU8 total_calls = srv_ucm_query_call_count(SRV_UCM_ACTIVE_STATE, SRV_UCM_CALL_TYPE_NO_CSD, g_ucm_p->call_misc.index_list);
    if (0 == total_calls)
    {
         total_calls = srv_ucm_query_call_count(SRV_UCM_HOLD_STATE, SRV_UCM_CALL_TYPE_NO_CSD, g_ucm_p->call_misc.index_list);
    }
    VFX_ASSERT(total_calls);

    call_count = srv_ucm_query_group_data(g_ucm_p->call_misc.index_list[0].group_index, &group_info);
    srv_ucm_query_call_data(g_ucm_p->call_misc.index_list[0], &call_info);
    vapp_ucmapp_set_active_call_info(&(g_ucm_p->call_misc.index_list[0]));
    
    VfxWString main_str;
    VfxResId txtId = MMI_RP_VAPP_UCM_IMG_MAX;
	VfxResId imgId = MMI_RP_VAPP_UCM_IMG_MAX;
    if (SRV_UCM_HOLD_STATE == group_info.call_state)
    {
        imgId = IMG_ID_VAPP_UCM_NMGR_HELD;
        txtId = STR_ID_VAPP_UCM_NCENTER_STR_HELD;
    }
    else if (SRV_UCM_ACTIVE_STATE == group_info.call_state)
    {
        imgId = IMG_ID_VAPP_UCM_NMGR_ACTIVE;
        txtId = STR_ID_VAPP_UCM_NCENTER_STR_ACTIVE;
    }
    m_ucmNCenterCell->setIcon(VfxImageSrc(imgId));
    main_str.loadFromRes(txtId);
    m_callStatus = main_str;
    m_callStartTime = getCallStartTime(g_ucm_p->call_misc.index_list[0].group_index);
    main_str += VFX_WSTR("(");
    VfxWString call_duration = getCallTimeDurationStr();
    main_str += call_duration;
    main_str += VFX_WSTR(")");
    m_ucmNCenterCell->setMainText(main_str);
    VfxWString subStr;
    if (call_count > 1)
    {
        subStr.loadFromRes(STR_ID_VAPP_UCM_CONFERENCE);
    }
    else
    {
        subStr.loadFromMem(call_info.remote_info.disp_name);
    }
    m_ucmNCenterCell->setSubText(subStr);
    total_calls = srv_ucm_query_call_count(SRV_UCM_CALL_STATE_CONNECTED, SRV_UCM_CALL_TYPE_NO_DATA_CSD, NULL);
    if (total_calls > 1)
    {
        txtId = STR_ID_VAPP_UCM_END_ALL_CALLS;
    }
    else
    {
        txtId = STR_ID_VAPP_UCM_END_THIS_CALL_Q_MARK;
    }
    VfxWString endCallString = VFX_WSTR_RES(txtId);
    endCallString += VFX_WSTR_RES(STR_ID_UCM_QUESTION_MARK);
    m_ucmNCenterCell->setQuestionText(endCallString);
    
    startCallTimer();

}

void vapp_ucm_ncell_process_intent(VsrvNotification* noti, VsrvNIntent intent, void* viewData, VfxU32 viewDataSize)
{
    switch (intent.type)
    {
        case VSRV_NINTENT_TYPE_LAUNCH:
        {
            if (srv_ucm_is_any_call())
            {
                if (vapp_ucm_scr)
                {
                    mmi_frm_set_active_group(vapp_ucm_get_app_id());
                }
                else
                {
                    vapp_ucm_launch();
                }
            }            
        }
        break;
        case VSRV_NINTENT_TYPE_TERMINATE:
        {
            vapp_ucm_end_all_action();
        }
        break;
        default:
        {
        }
        break;
    }
}

extern "C"
mmi_ret vapp_ucm_update_ncell(mmi_event_struct *evt)
{
    switch (evt->evt_id)
    {
        case EVT_ID_VAPP_UCM_BG_RUN_START:
        {
            VsrvNGroupSingleTitle *ngroup = NULL;
            VSRV_NGROUP_CREATE_EX(ngroup, VsrvNGroupSingleTitle, (VAPP_UCM));
            ngroup->setTitle(VFX_WSTR_RES(STR_ID_VAPP_UCM_CALL));
            VsrvNotificationCustom *noti = NULL;
            VSRV_NOTIFICATION_CREATE_EX(noti, VsrvNotificationCustom, ((VsrvNGroup *)ngroup, 0));
            noti->setCategory(VSRV_NOTIFICAITON_CUSTOM_CATEGORY_ONGOING);
            noti->setIntentCallback(vapp_ucm_ncell_process_intent);
            noti->addCustomViewInfo(VFX_OBJ_CLASS_INFO(VappUcmNotification), VSRV_NVIEWER_TYPE_GENERAL);
            noti->notify();
        }
            break;
        case EVT_ID_VAPP_UCM_BG_RUN_END:
        {
            VSRV_NOTIFICATION_CLOSE_EX((VsrvNGroupId)VAPP_UCM, 0);
        }
            break;
        default:
            break;
    }
    return MMI_RET_OK;
}

#ifndef __MMI_UCM_SLIM__
VFX_IMPLEMENT_CLASS("VappUcmScrnLockCard", VappUcmScrnLockCard, VappScreenLockCard);
void VappUcmScrnLockCard::onInit()
{
    VappScreenLockCard::onInit();

    VFX_OBJ_CREATE(m_imgIcon, VfxImageFrame, this);
    m_imgIcon->setResId(IMG_ID_VAPP_SCREEN_LOCK_CARD_ICON_PHONE);
    m_imgIcon->setAnchor(0.5f, 0.5f);
    m_imgIcon->setPos(getSize().width / 2, getSize().height / 2 + VAPP_SCREEN_LOCK_CARD_OFFSET_BTW_IMG_AND_REAL_CARD / 2);
}

void VappUcmScrnLockCard::onUnlocked()
{
    m_signalUnlockCard.emit(m_actType);
}

void VappUcmScrnLockCard::setActType(VappUcmCallCellScrnUnlockTypeEnum act_type)
{
    m_actType = act_type;
    VfxResId imgId1, imgId2;
    if (VAPP_UCM_SCRN_UNLOCK_ACCEPT_CALL == m_actType)
    {
        imgId1 = IMG_ID_VAPP_SCREEN_LOCK_UNCLICKED_CARD1;
        imgId2 = IMG_ID_VAPP_UCM_LOCK_ACCEPT_CALL;
    }
    else
    {
        imgId1 = IMG_ID_VAPP_SCREEN_LOCK_UNCLICKED_CARD3;
        imgId2 = IMG_ID_VAPP_UCM_LOCK_REJECT_CALL;
    }
    m_imgUnpress->setResId(imgId1);
    m_imgIcon->setResId(imgId2);
}

VFX_IMPLEMENT_CLASS("VappUcmScrnLockUnlockCard", VappUcmScrnLockUnlockCard, VappScreenLockUnlockCard);
void VappUcmScrnLockUnlockCard::onUnlocked()
{
    m_signalUnlockCard.emit(VAPP_UCM_SCRN_UNLOCK_ONLY);
}

VFX_IMPLEMENT_CLASS("VappUcmScrnLockFrame", VappUcmScrnLockFrame, VappScreenLockFrame);
void VappUcmScrnLockFrame::onInit()
{
    VappScreenLockFrame::onInit();
    setCacheMode(VFX_CACHE_MODE_PREVENT);
    VFX_OBJ_CREATE(m_acceptCallCard, VappUcmScrnLockCard, this);
    m_acceptCallCard->setActType(VAPP_UCM_SCRN_UNLOCK_ACCEPT_CALL);

    VFX_OBJ_CREATE(m_unlockCard, VappUcmScrnLockUnlockCard, this);

    VFX_OBJ_CREATE(m_rejectCallCard, VappUcmScrnLockCard, this);
    m_rejectCallCard->setActType(VAPP_UCM_SCRN_UNLOCK_REJECT_CALL);

    addCard(m_acceptCallCard);
    addCard(m_unlockCard);
    addCard(m_rejectCallCard);

    m_acceptCallCard->m_signalUnlockCard.connect(this, &VappUcmScrnLockFrame::onCardUnlock);
    m_rejectCallCard->m_signalUnlockCard.connect(this, &VappUcmScrnLockFrame::onCardUnlock);
    m_unlockCard->m_signalUnlockCard.connect(this, &VappUcmScrnLockFrame::onCardUnlock);

    if (srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL) == 0)
    {
        m_acceptCallCard->setHidden(VFX_TRUE);
        m_rejectCallCard->setHidden(VFX_TRUE);
    }

    capture();
}

void VappUcmScrnLockFrame::onCardUnlock(VappUcmCallCellScrnUnlockTypeEnum unlock_type)
{
    m_signalScrnUnlock.emit(unlock_type);
}

void VappUcmScrnLockFrame::hideCard(VappUcmCallCellScrnUnlockTypeEnum card_type, VfxBool hide)
{
    if (VAPP_UCM_SCRN_UNLOCK_ACCEPT_CALL == card_type)
    {
        m_acceptCallCard->setHidden(hide);
    }
    else if (VAPP_UCM_SCRN_UNLOCK_REJECT_CALL == card_type)
    {
        m_rejectCallCard->setHidden(hide);
    }
    else if (VAPP_UCM_SCRN_UNLOCK_ONLY == card_type)
    {
        m_unlockCard->setHidden(hide);
    }
}
#else
VFX_IMPLEMENT_CLASS("VappUcmScrnLockPanel", VappUcmScrnLockPanel, VfxControl);
void VappUcmScrnLockPanel::onInit()
{
    VfxControl::onInit();
    m_pressed = VFX_FALSE;
    m_counter = 0;    
    setBgColor(VFX_COLOR_TRANSPARENT);
    setSize(LCD_WIDTH, 110);

    // bg
    VfxImageFrame *bgImg;
    VFX_OBJ_CREATE(bgImg, VfxImageFrame, this);
    bgImg->setResId(IMG_ID_VAPP_SCREEN_LOCK_RHYTHM_SCREENLOCK_BG);
    bgImg->setSize(getSize());
    bgImg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);

    // hint text
    VfxTextFrame *hintText;
    VFX_OBJ_CREATE(hintText, VfxTextFrame, this);
    hintText->setString(STR_ID_VAPP_UCM_SLIDE_DOWN_UNLOCK);
    hintText->setAnchor(0.5f, 0.5f);
    hintText->setPos(LCD_WIDTH / 2, 60);
    hintText->setAutoResized(VFX_TRUE);

    // lock icon
    VfxImageFrame *lockIcon;
    VFX_OBJ_CREATE(lockIcon, VfxImageFrame, this);
    lockIcon->setResId(IMG_ID_VAPP_UCM_ICON_LOCK);
    lockIcon->setAnchor(0.5f, 0.5f);
    lockIcon->setPos((LCD_WIDTH - hintText->getSize().width - lockIcon->getSize().width - 8) / 2, 60);

    // arrow 
    VfxS32 y = 97;
    VfxImageSrc img_arrow(IMG_ID_VAPP_SCREEN_LOCK_RHYTHM_ARROW);
    VfxSize size_arrow = img_arrow.getSize();
    for(VfxU32 i = 0; i < 3; i++)
    {
        VFX_OBJ_CREATE(m_arrow[i], VfxImageFrame, this);
        m_arrow[i]->setAnchor(0.5f, 1.0f);
        m_arrow[i]->setImgContent(img_arrow);
        m_arrow[i]->setPos(LCD_WIDTH / 2, y);

        y += size_arrow.height;                
    }

    // arrow animation
    VFX_OBJ_CREATE(m_timerArrowAnimation, VfxTimer, this);
    m_timerArrowAnimation->setStartDelay(250);
    m_timerArrowAnimation->setDuration(250);
    m_timerArrowAnimation->m_signalTick.connect(this, &VappUcmScrnLockPanel::onTimerArrowAnimation);
    m_timerArrowAnimation->start();
}

void VappUcmScrnLockPanel::onTimerArrowAnimation(VfxTimer *timer)
{
    m_counter %= 3;
    VfxU32 j;
    for (VfxU32 i = 0; i < 3; i++)
    {
        j = (m_counter - i + 3) % 3;
        m_arrow[i]->setOpacity(0.4f + j * 0.3f);
    }
    m_counter++;
}

VfxBool VappUcmScrnLockPanel::onPenInput(VfxPenEvent &event)
{
    VfxPoint pt = event.getRelPos(this);
    if (VFX_PEN_EVENT_TYPE_DOWN == event.type)
    {
        m_pressed = VFX_TRUE;
        
        VfxFloat anchor_y = (VfxFloat)pt.y / getSize().height;
        VfxAutoAnimate::begin();
        VfxAutoAnimate::setDisable(VFX_TRUE);
        setAnchor(0.0f, anchor_y);
        setPos(0, event.pos.y - 24);
        VfxAutoAnimate::commit();
        setOpacity(0.7f);

        return VFX_TRUE;
    }
    else if (VFX_PEN_EVENT_TYPE_MOVE == event.type)
    {
        if (m_pressed)
        {
            pt = event.getRelPos(this);

            VfxAutoAnimate::begin();
            VfxAutoAnimate::setDisable(VFX_TRUE);
            forcePos(VfxPoint(0, event.pos.y > event.downPos.y ? event.pos.y-24 : event.downPos.y-24));
            VfxAutoAnimate::commit();
        }
        return VFX_TRUE;
    }
    else if (VFX_PEN_EVENT_TYPE_UP == event.type)
    {
        if (m_pressed)
        {
            m_pressed = VFX_FALSE;
            
            if(getPos().y > event.downPos.y + 35)
            {
                dismiss();
            }
            else if(getPos().y <= event.downPos.y)
            {
                restoreOriginPosition(VFX_TRUE);
            }
            else
            {
                restoreOriginPosition(VFX_FALSE);
            }
        }
        return VFX_TRUE;
    }
    else if(event.type == VFX_PEN_EVENT_TYPE_ABORT)
    {
        restoreOriginPosition(VFX_FALSE);
        return VFX_TRUE;
    }

    return VfxControl::onPenInput(event);

}

void VappUcmScrnLockPanel::restoreOriginPosition(VfxBool isNoAnimation)
{
    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(isNoAnimation);
    setPos(0, 296);
    setOpacity(1.0f);
    setAnchor(0.0f, 1.0f);
    VfxAutoAnimate::commit();
    m_pressed = VFX_FALSE;
}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
void VappUcmScrnLockPanel::dismiss()
{
    VfxS32Timeline *tl;
    VFX_OBJ_CREATE(tl, VfxS32Timeline, this);
    tl->setTarget(this);
    tl->setTargetPropertyId(VRT_FRAME_PROPERTY_ID_POS_Y);
    tl->setIsFromCurrent(VFX_TRUE);
    tl->setToValue(LCD_HEIGHT + getSize().height);
    tl->setDuration(250);
    tl->m_signalStopped.connect(this, &VappUcmScrnLockPanel::onTimelineStopped);
    tl->start();
}

void VappUcmScrnLockPanel::onTimelineStopped(VfxBaseTimeline *timeline, VfxBool isCompleted)
{
    m_signalScrnUnlock.postEmit(this);
}

#endif // __MMI_UCM_SLIM__

