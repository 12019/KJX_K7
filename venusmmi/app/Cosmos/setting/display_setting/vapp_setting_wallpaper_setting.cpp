/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2008
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES. ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vapp_setting_wallpaper_setting.cpp
 *
 * Project:
 * --------
 *  Venus
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
/***************************************************************************** 
 * Include
 *****************************************************************************/
#include "vfx_mc_include.h"
#include "vcp_include.h"
#include "mmi_rp_vapp_setting_def.h"
#include "mmi_rp_srv_venus_component_tool_bar_def.h"
#include "mmi_rp_vcui_wallpaper_setting_def.h"
#include "Mmi_rp_vapp_bootup_def.h"

#include "vapp_wallpaper_setting_method_gprot.h"
#include "vapp_setting_wallpaper_setting_gprot.h"
#include "vapp_setting_wallpaper_setting.h"
#include "vapp_wallpaper_content_provider.h"
#include "vapp_wallpaper_kit.h"
#include "vapp_wallpaper_setting_provider.h"

#include "vcui_gallery_gprot.h"
#include "vapp_wallpaper_cfg.h"
#include "vapp_setting_framework.h"
#include "vapp_setting_framework_gprot.h"

#include "vcui_wallpaper_setting_gprot.h"
#include "Vapp_usb_gprot.h"
extern "C"
{
#include "gdi_primitive.h"
#include "mdi_include.h"
#include "PhoneSetupResList.h"
#include "mmi_rp_file_type_def.h"
#include "Mmi_rp_app_usbsrv_def.h"
#ifdef __MMI_USB_SUPPORT__
#include "UsbSrvGprot.h"
#endif
#ifdef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
#include "mdi_video.h"
#include "UCMSrvGprot.h"
#endif

#include "mmi_msg_struct.h"
#include "MMIDataType.h"
#include "ps_public_enum.h"
#include "CustVenusThemeRes.h"
}
/***************************************************************************** 
 * Define
 *****************************************************************************/
#ifdef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
typedef struct
{
    VfxId   thumbnailId;
    VfxId   videoId;
} VappSystemVideoStruct;
#endif
/***************************************************************************** 
 * Typedef
 *****************************************************************************/
#if defined(__MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__) && !defined(__LOW_COST_SUPPORT_COMMON__)
const VappSystemVideoStruct g_systemVideoInfo[]=
    {
        {IMG_ID_SYS_VIDEO_THUMB_01,VDO_ID_SYS_MP4_01},
        {IMG_ID_SYS_VIDEO_THUMB_02,VDO_ID_SYS_MP4_02}
    };
const VfxS32 g_systemVideoNum = sizeof(g_systemVideoInfo) / sizeof(VappSystemVideoStruct);
#endif

filetypes_file_type_enum vapp_wallpaper_support_types[] = 
{
    FMGR_TYPE_BMP, 
    FMGR_TYPE_WBMP, 
    FMGR_TYPE_WBM, 
    FMGR_TYPE_GIF, 
#ifdef JPG_DECODE        
    FMGR_TYPE_JPG, 
    FMGR_TYPE_JPEG,     
#endif         
#if defined(GDI_USING_PNG)
    FMGR_TYPE_PNG, 
#endif
#if defined(__DRM_V02__)
    FMGR_TYPE_ODF, 
#endif
#ifdef M3D_MMI_SUPPORT
    FMGR_TYPE_M3D, 
#endif
#ifdef __MMI_VUI_HOMESCREEN_LIVE_WALLPAPER_MAV__
    FMGR_TYPE_MAV,
#endif

    //supported videos;
#ifdef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
#ifdef MP4_DECODE
    FMGR_TYPE_3GP,
    FMGR_TYPE_MP4,
    FMGR_TYPE_3G2,
#endif /* MP4_DECODE */
#endif /* __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__ */
    /* End of file type */
    FMGR_TYPE_UNKNOWN,
};

static VfxPage *WallpaperSettingPage = NULL; // Used for allocate memory for live wallpaper thumb

U32 get_theme_wallpaper_num()
{
    VfxS32 themeNum = 0;

    if (mmi_res_is_theme_image(IMG_ID_WP_THEME_START))
    {
        themeNum = MMI_WP_THEME_NUM;
    }
    
    return themeNum;
}
void vapp_setting_home_screen_wallpaper_setting_launch(VfxMainScr *mainScr)
{
    VappSettingWallpaperResPage *page;
    VFX_OBJ_CREATE_EX(page, VappSettingWallpaperResPage, mainScr, (VAPP_WALLPAPER_HOME_SCREEN));
    mainScr->pushPage('RSPG', page);
}

void vapp_setting_lock_screen_wallpaper_setting_launch(VfxMainScr *mainScr)
{
    VappSettingWallpaperResPage *page;
    VFX_OBJ_CREATE_EX(page, VappSettingWallpaperResPage, mainScr, (VAPP_WALLPAPER_LOCK_SCREEN));
    mainScr->pushPage(0, page);
}

void* get_live_wallpaper(U32 item_idx, void *parent, void *user_data)
{
    VFX_ASSERT(user_data);

    VappLiveWallpaperContentProvider *wp = (VappLiveWallpaperContentProvider*)user_data;
    return wp->getLiveWallpaper(item_idx, parent);

}

static MMI_BOOL decode_live_wallpaper_thumb(U32 item_idx, VappWallpaperThumbStruct *thumb, void *user_data)
{
    VFX_ASSERT(user_data);
    if(user_data && thumb)
    {
        VappLiveWallpaperContentProvider *wp = (VappLiveWallpaperContentProvider*)user_data;
        VfxImageBuffer buf;
        kal_mem_set(&buf, 0, sizeof(buf));
        const VfxU32 BPP = thumb->bpp;
        buf.ptr = thumb->buf_ptr;
        buf.width = thumb->width;
        buf.height = thumb->height;
        buf.pitchBytes = buf.width * BPP;
        buf.colorFormat = (VfxColorTypeEnum)thumb->cf;
        if(wp->decodeLiveWallpaperThumb(item_idx, buf))
        {
            return MMI_TRUE;
        }
    }
    return MMI_FALSE;
}
MMI_IMG_ID get_static_wallpaper(U32 item_idx, void *user_data)
{
    U32 theme_wp_num = get_theme_wallpaper_num();

    if (item_idx < theme_wp_num)
	{
        return IMG_ID_WP_THEME_START + item_idx;
    }
    if (item_idx < __MMI_WALLPAPER_NUM__ + theme_wp_num)
	{
	    return IMG_ID_PHNSET_WP_START + (item_idx - theme_wp_num);
	}
	return 0;
}

MMI_IMG_ID get_static_wallpaper_for_lock(U32 item_idx, void *user_data)
{
    if (item_idx < __MMI_WALLPAPER_NUM__)
	{
	    return IMG_ID_PHNSET_WP_START + item_idx;
	}
	return 0;
}

#ifdef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
MMI_IMG_ID get_video_wallpaper(U32 item_idx, void *user_data)
{
    #if !defined(__LOW_COST_SUPPORT_COMMON__)
    if (item_idx < g_systemVideoNum)
    {
        return g_systemVideoInfo[item_idx].videoId;
    }
    #endif
    return 0;
}
#endif

MMI_IMG_ID get_wallpaper_thumb(VappWpResType wpResType, U32 item_idx, void *user_data)
{
    switch(wpResType)
    {
        case VAPP_WALLPAPER_STATIC_WALLPAPER:
        {
            U32 theme_wp_num = get_theme_wallpaper_num();
            if (item_idx < theme_wp_num)
            {
                return IMG_ID_WP_THEME_THUMB_START + item_idx;
            }
            else
            {
                return (IMG_ID_PHNSET_WP_THUMB_START + (item_idx - theme_wp_num));
            }
            }

        case VAPP_WALLPAPER_LIVE_WALLPAPER:
            {
                ASSERT(WallpaperSettingPage != NULL && user_data);
                VappLiveWallpaperContentProvider *wp = (VappLiveWallpaperContentProvider*)user_data;
    	        return wp->getLiveWallpaperThumb(item_idx);
            }
    
    #if defined(__MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__) && !defined(__LOW_COST_SUPPORT_COMMON__)
        case VAPP_WALLPAPER_VIDEO_WALLPAPER:
            return g_systemVideoInfo[item_idx].thumbnailId;
    #endif
        default:
            ASSERT(0);
    }

    return 0;
}

MMI_IMG_ID get_wallpaper_thumb_for_lock(VappWpResType wpResType, U32 item_idx, void *user_data)
{
    switch(wpResType)
    {
        case VAPP_WALLPAPER_STATIC_WALLPAPER:
        {
                return (IMG_ID_PHNSET_WP_THUMB_START + item_idx );
        }

        case VAPP_WALLPAPER_LIVE_WALLPAPER:
            {
                ASSERT(WallpaperSettingPage != NULL && user_data);
                VappLiveWallpaperContentProvider *wp = (VappLiveWallpaperContentProvider*)user_data;
    	        return wp->getLiveWallpaperThumb(item_idx);
            }
    
    #if defined(__MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__) && !defined(__LOW_COST_SUPPORT_COMMON__)
        case VAPP_WALLPAPER_VIDEO_WALLPAPER:
            return g_systemVideoInfo[item_idx].thumbnailId;
    #endif
        default:
            ASSERT(0);
    }

    return 0;
}



#ifdef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
VfxId getOffset(filetypes_file_type_enum* base, filetypes_file_type_enum member)
{
    for (VfxId index=0; base[index]!=FMGR_TYPE_UNKNOWN; ++index)
        if (base[index] == member)
            return index;
    return FMGR_TYPE_COUNT;
}
#endif

static void vapp_wallpaper_set_file_filter_by_struct(FMGR_FILTER *filter, filetypes_file_type_enum *filter_struct)
{
    FMGR_FILTER_INIT(filter);
    if (!filter || !filter_struct)
	{
	    return;
	}
    VfxU8 i;    
    for (i = 0; filter_struct[i] != FMGR_TYPE_UNKNOWN; i++)
	{
        FMGR_FILTER_SET(filter, filter_struct[i]); 		
	}
}

extern "C"
{
#ifndef __SLIM_AT__    
VfxU8 vapp_wallpaper_at_handler(void* msg, VfxU32 mod_id)
{
        mmi_set_mmi_default_prof_ind_struct *mmi_set_prof_struct = (mmi_set_mmi_default_prof_ind_struct*) msg;

        mmi_at_general_res_req_struct *rsp;
		rsp = (mmi_at_general_res_req_struct*) OslConstructDataPtr(sizeof(mmi_at_general_res_req_struct));
        VappWallpaperSettingProvider *setting = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingProvider);
        
        VappWallpaperSettingInterface *method = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingInterface);
        

        switch (mmi_set_prof_struct->category)
        {
            case ESDP_CATEGORY_WALLPAPER:
            {
                         
                VAPP_WALLPAPER_ID_HANDLE wallpaper_static_handle = NULL;
                
                wallpaper_static_handle = vapp_wallpaper_provider_get_res_image_wallpaper_id_handle(mmi_set_prof_struct->param3-1);
                vapp_wallpaper_setting_save_wallpaper_id_handle(VAPP_WALLPAPER_SRC_HOMESCREEN, wallpaper_static_handle);
                vapp_wallpaper_id_handle_close(wallpaper_static_handle);
                wallpaper_static_handle = NULL; 
            
            }
            rsp->result = KAL_TRUE;
            break;
                
            case ESDP_CATEGORY_SCREENSAVER:
            {
                
                VAPP_WALLPAPER_ID_HANDLE wallpaper_static_handle = NULL;

                wallpaper_static_handle = vapp_wallpaper_provider_get_res_image_wallpaper_id_handle(mmi_set_prof_struct->param3-1);
                vapp_wallpaper_setting_save_wallpaper_id_handle(VAPP_WALLPAPER_SRC_LOCK, wallpaper_static_handle);
                vapp_wallpaper_id_handle_close(wallpaper_static_handle);
                wallpaper_static_handle = NULL; 

            }
            rsp->result = KAL_TRUE;
            break;
            
            case ESDP_CATEGORY_PWRONDISPLAY:
                #if defined(__MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__) && !defined(__LOW_COST_SUPPORT_COMMON__)
                {
                    VfxU16 id = mmi_set_prof_struct->param3 - 1;
                    if (!id)
                    {
                        id = VDO_ID_SYS_INVALID_VID;
                    }
                    else
                    {
                        id = id-1+VDO_ID_SYS_MP4_01;
                    }
                	method->setWallpaperId(VAPP_VIDEO_PWR_ON_SCREEN, 
                                        VAPP_WALLPAPER_VIDEO_WALLPAPER,
                                        id);   
                        
                }
                rsp->result = KAL_TRUE;
                #else
                rsp->result = KAL_FALSE;
                #endif /* __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__ */
                break;
                
            case ESDP_CATEGORY_PWROFFDISPLAY:
                #if defined(__MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__) && !defined(__LOW_COST_SUPPORT_COMMON__)
                {
                    VfxU16 id = mmi_set_prof_struct->param3 - 1;
                    if (!id)
                    {
                        id = VDO_ID_SYS_INVALID_VID;
                    }
                    else
                    {
                        id = id-1+VDO_ID_SYS_MP4_01;
                    }
                    method->setWallpaperId(VAPP_VIDEO_PWR_OFF_SCREEN, 
                                            VAPP_WALLPAPER_VIDEO_WALLPAPER,
                                            id); 
                }
                rsp->result = KAL_TRUE;
                #else
                rsp->result = KAL_FALSE;
                #endif /* __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__ */
                break;
                
            default:
            	OslFreeDataPtr(rsp);
                return 0;
        }

		mmi_frm_send_ilm((oslModuleType)mod_id, MSG_ID_MMI_AT_GENERAL_RES_REQ, (oslParaType*)rsp, NULL);

        mmi_frm_nmgr_balloon(
                MMI_SCENARIO_ID_DEFAULT,
                MMI_EVENT_INFO_BALLOON,
                MMI_NMGR_BALLOON_TYPE_SUCCESS, 
                VFX_WSTR_RES(STR_ID_VAPP_SETTING_WALLPAPER_SET_SUCCESSFULLY).getBuf());
        return 1;

    return 0;
}
#endif //__SLIM_AT__

mmi_id vapp_wallpaper_init(mmi_event_struct *evt)
{
#ifndef __SLIM_AT__
	mmi_frm_set_protocol_event_handler(MSG_ID_MMI_SET_MMI_DEFAULT_PROF_IND, (PsIntFuncPtr)vapp_wallpaper_at_handler, MMI_TRUE);
#endif
	return MMI_RET_OK;
}
}
/***************************************************************************** 
 * Class 
 *****************************************************************************/
/***************************************************************************** 
 * VappSettingWallpaperResPage
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappSettingWallpaperResPage", VappSettingWallpaperResPage, VfxPage);
void VappSettingWallpaperResPage::onInit()
{
    VfxPage::onInit();

    VcpTitleBar *titleBar;
    VFX_OBJ_CREATE(titleBar, VcpTitleBar, this);
    switch (m_wpType)
    {
    case VAPP_WALLPAPER_HOME_SCREEN:
        titleBar->setTitle((VfxResId)STR_ID_VAPP_SETTING_WALLPAPER_HOME_SCREEN);		
	break;
    case VAPP_WALLPAPER_LOCK_SCREEN:
        titleBar->setTitle((VfxResId)STR_ID_VAPP_SETTING_WALLPAPER_LOCK_SCREEN);		
	break;
    default:
        break;		
    }
    setTopBar(titleBar);    
    
    VFX_OBJ_CREATE(m_listMenu, VcpListMenu, this);

    m_listMenu->setPos(0, 0);
    m_listMenu->setSize(getSize());
    m_listMenu->setAlignParent(
        VFX_FRAME_ALIGNER_MODE_SIDE,
        VFX_FRAME_ALIGNER_MODE_SIDE,
        VFX_FRAME_ALIGNER_MODE_SIDE,
        VFX_FRAME_ALIGNER_MODE_SIDE);
    
    m_listMenu->setContentProvider(this);
    m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_SINGLE_TEXT);
    m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_NORMAL, VFX_FALSE);
    m_listMenu->setMenuControlMode(VCP_LIST_MENU_CONTROL_MODE_DISCLOSURE);
    m_listMenu->m_signalItemTapped.connect(this, &VappSettingWallpaperResPage::onSelectItem);  

    m_liveWallpaperProvider = NULL;

    WallpaperSettingPage = this;

#ifdef __MMI_USB_SUPPORT__
    mmi_frm_cb_reg_event(EVT_ID_USB_ENTER_MS_MODE, VappSettingWallpaperResPage::usbMassStorageModeHdlr, this);
#endif /* __MMI_USB_SUPPORT__ */

}

void VappSettingWallpaperResPage::onDeinit()
{
#ifdef __MMI_USB_SUPPORT__    
    mmi_frm_cb_dereg_event(EVT_ID_USB_ENTER_MS_MODE, VappSettingWallpaperResPage::usbMassStorageModeHdlr, this);
#endif /* __MMI_USB_SUPPORT__ */
    WallpaperSettingPage = NULL;    

    VfxPage::onDeinit();
}

VfxBool VappSettingWallpaperResPage::getItemText(VfxU32 index, VcpListMenuFieldEnum fieldType, VfxWString &text, VcpListMenuTextColorEnum &color)
{

    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)	
    {
        switch (index)
        {
        case 0: 
            text.loadFromRes((VfxResId)STR_ID_VAPP_SETTING_WALLPAPER_SYSTEM);
            break;
        case 1: 
            text.loadFromRes((VfxResId)STR_ID_VAPP_SETTING_WALLPAPER_GALLERY);
            break; 
        default:
            break;
        }

        color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;
        return VFX_TRUE;
    }
    return VFX_FALSE;
}

VfxBool VappSettingWallpaperResPage::getItemImage(VfxU32 index, VcpListMenuFieldEnum fieldType, VfxImageSrc &image)
{
    if (fieldType == VCP_LIST_MENU_FIELD_DISCLOSURE_IMG)
    {
        image.setResId(VCP_IMG_LIST_MENU_DEFAULT_DISCLOSURE);
        return VFX_TRUE;
    }
    return VFX_FALSE;
}
void VappSettingWallpaperResPage::onSelectItem(VcpListMenu *listMenu, VfxU32 selectIdx)
{
    switch (selectIdx)
    {
    case VAPP_WALLPAPER_SETTING_SYSTEM:
    {
        m_wpSourceType = VAPP_WALLPAPER_SETTING_SYSTEM;
        m_cuiId = vcui_gallery_wallpaper_picker_create(getApp()->getGroupId());
        
        if(NULL == m_cuiId)
        {
            break;
        }

        vcui_gallery_set_title_id(m_cuiId, STR_ID_VAPP_SETTING_WALLPAPER_SYSTEM);

        IWallpaperSourceStruct source;

        if(NULL == m_liveWallpaperProvider)
        {
            VFX_OBJ_CREATE(m_liveWallpaperProvider, VappLiveWallpaperContentProvider, this);
        }
        
        // VAPP_WALLPAPER_LAST_ITEM contains wide wallpaper, should not be count
        if (m_wpType == VAPP_WALLPAPER_LOCK_SCREEN)
    	{
    	    // Do not display live wallpaper for lock screen wallpaper setting
            source.live_wallpaper_count = 0;
            source.static_wallpaper_count = __MMI_WALLPAPER_NUM__;
            source.get_static_wallpaper_img_id = &get_static_wallpaper_for_lock; 
            source.get_thumb_img_id = &get_wallpaper_thumb_for_lock;
    	}
        else
        {
            source.live_wallpaper_count = m_liveWallpaperProvider->getLiveWallpaperTotalNum();
            source.static_wallpaper_count = (__MMI_WALLPAPER_NUM__ + get_theme_wallpaper_num());
            source.get_static_wallpaper_img_id = &get_static_wallpaper;
            source.get_thumb_img_id = &get_wallpaper_thumb;
        }

        source.live_wallpaper_title = STR_ID_VAPP_SETTING_WALLPAPER_LIVE;
        source.static_wallpaper_title = STR_ID_VAPP_SETTING_WALLPAPER_STATIC;
        #ifdef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
            #if !defined(__LOW_COST_SUPPORT_COMMON__)
            source.video_wallpaper_count = g_systemVideoNum;
            #else
            source.video_wallpaper_count = 0;
            #endif
            source.video_wallpaper_title = STR_ID_VAPP_SETTING_WALLPAPER_VIDEO;
        #endif
        source.get_live_wallpaper = &get_live_wallpaper;

        #ifdef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
            source.get_video_wallpaper_vid_id = &get_video_wallpaper;
        #endif

        source.decode_wallpaper_thumb = &decode_live_wallpaper_thumb;
        
        source.user_data = m_liveWallpaperProvider;

        vcui_gallery_wallpaper_picker_set_source_info(m_cuiId, &source);

        vfxSetCuiCallerScr(m_cuiId,getMainScr()); 
        vcui_gallery_run(m_cuiId);
		break;
    }
    case VAPP_WALLPAPER_SETTING_GALLERY:
    {      
#ifdef __MMI_USB_SUPPORT__
        if (srv_usb_is_in_mass_storage_mode())
    	{
    	    vapp_usb_unavailable_popup(0);
            return;
    	}
#endif /* __MMI_USB_SUPPORT__ */

        m_wpSourceType = VAPP_WALLPAPER_SETTING_GALLERY;
        #ifdef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
            VfxMainScr *mainScr = VFX_OBJ_DYNAMIC_CAST(findScreen(), VfxMainScr);
            if (mainScr)
        	{
                VappSettingWallpaperGalleryPage *page;
                VFX_OBJ_CREATE_EX(page, VappSettingWallpaperGalleryPage, mainScr, (m_wpType));
                mainScr->pushPage('GLRY', page);	
        	}
        #else            
        FMGR_FILTER filter;
        vapp_wallpaper_set_file_filter_by_struct(&filter, vapp_wallpaper_support_types);
        m_cuiId = vcui_gallery_image_picker_create(getApp()->getGroupId(), MMI_FALSE, &filter);
        vcui_gallery_picker_set_auto_close(m_cuiId, MMI_FALSE);
        
        vfxSetCuiCallerScr(m_cuiId,getMainScr()); 
        vcui_gallery_run(m_cuiId);
        #endif
    }
        break;
	default:
    		ASSERT(0);
		break;
	}    
}    
void VappSettingWallpaperResPage::setWallpaperFromSystem()
{
    VappWpResType wpType;
    VfxU32 idxPicked = 0;
    vcui_gallery_wallpaper_picker_get_picked_wallpaper(m_cuiId, &wpType, &idxPicked);
    if (idxPicked != (VfxU32)-1)
	{
        VappWallpaperId id;
        if (wpType == VAPP_WALLPAPER_LIVE_WALLPAPER)
    	{
    	    m_liveWallpaperProvider->getLiveWallpaperId(idxPicked, id);
    	}
        else if (wpType == VAPP_WALLPAPER_STATIC_WALLPAPER)
        {
            // TODO: idxPicked should be actual resource wallpaper id
            if (m_wpType == VAPP_WALLPAPER_HOME_SCREEN)
            {
            m_liveWallpaperProvider->getStaticImageWallpaperId(id, get_static_wallpaper(idxPicked, NULL));
            }
            else
            {
                m_liveWallpaperProvider->getStaticImageWallpaperId(id, get_static_wallpaper_for_lock(idxPicked, NULL));
            }
        }
    #if defined(__MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__) && !defined(__LOW_COST_SUPPORT_COMMON__)
        else if (wpType == VAPP_WALLPAPER_VIDEO_WALLPAPER)
        {
            m_liveWallpaperProvider->getResourceVideoWallpaperId(id, g_systemVideoInfo[idxPicked].videoId);
        }
    #endif    

        // store the wallpaper id
        VappWallpaperSettingProvider *wallpaperStore = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingProvider);
        const VappWallpaperSrcEnum src = (m_wpType == CUI_WALLPAPER_SETTING_HOME_SCREEN) ? VAPP_WALLPAPER_SRC_HOMESCREEN : VAPP_WALLPAPER_SRC_LOCK;
        wallpaperStore->setDefaultWallpaper(src, id, this);
        wallpaperStore->notifyWallpaperUpdate(src);
	}
    mmi_id cuiId = m_cuiId;
    closeWallpaperPage();
    vcui_gallery_close(cuiId);
    mmi_frm_nmgr_balloon(
        MMI_SCENARIO_ID_DEFAULT,
        MMI_EVENT_INFO_BALLOON,
        MMI_NMGR_BALLOON_TYPE_SUCCESS, 
        VFX_WSTR_RES(STR_ID_VAPP_SETTING_WALLPAPER_SET_SUCCESSFULLY).getBuf());
}

#ifndef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
void VappSettingWallpaperResPage::setWallpaperFromGallery()
{
    WCHAR buffer[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1)];
    memset(buffer, 0 ,(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1));
    VfxU32 bufferSize = (SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1);
    vcui_gallery_picker_get_single_path(m_cuiId, buffer, &bufferSize);
    if (buffer[0])
	{
        cui_wallpaper_setting_create_struct arg;
        arg.filename = buffer;
        arg.screen_type = (cui_wallpaper_setting_screen_type_enum)m_wpType;
        arg.user_data = this;
        m_wallpaperSettingCuiId = vcui_wallpaper_setting_create(getApp()->getGroupId(), &arg);
        if (m_wallpaperSettingCuiId == GRP_ID_INVALID)
    	{
    	    return;
    	}
        vcui_wallpaper_setting_run(m_wallpaperSettingCuiId);
	}    
}
#endif
mmi_ret VappSettingWallpaperResPage::onProc(mmi_event_struct *evt)
{
    switch (evt->evt_id)
    {
    // Gallery CUI
    case EVT_ID_VCUI_GALLERY_CLOSE_GID:
    case EVT_ID_VCUI_GALLERY_PICKER_RESULT_READY:
    {
        vcui_gallery_evt_struct *galleryEvt = (vcui_gallery_evt_struct*)evt;
        if (galleryEvt->result != VCUI_GALLERY_RESULT_OK)
    	{
  	    vcui_gallery_close(m_cuiId);
        VFX_OBJ_CLOSE(m_liveWallpaperProvider);
            return MMI_RET_OK;
    	}
        if (m_wpSourceType == VAPP_WALLPAPER_SETTING_SYSTEM)
    	{
    	    setWallpaperFromSystem();
    	}
    #ifndef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
        else
        {
            setWallpaperFromGallery();
        }
    #endif
        return MMI_RET_OK;
    }
    // Wallpaper setting CUI
    #ifndef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
    case EVT_ID_CUI_WALLPAPER_SETTING_DONE:
    {
        cui_wallpaper_setting_event_struct *wallpaperSettingEvt = (cui_wallpaper_setting_event_struct*)evt;
        mmi_id cuiId = m_cuiId;
        closeWallpaperPage();
        vcui_wallpaper_setting_close(wallpaperSettingEvt->sender_id);
        switch (m_wpSourceType)
    	{
    	case VAPP_WALLPAPER_SETTING_GALLERY:
    	    vcui_gallery_close(cuiId);
            break;
            
        default:
            break;
    	}
        mmi_frm_nmgr_balloon(
            MMI_SCENARIO_ID_DEFAULT,
            MMI_EVENT_INFO_BALLOON,
            MMI_NMGR_BALLOON_TYPE_SUCCESS, 
            VFX_WSTR_RES(STR_ID_VAPP_SETTING_WALLPAPER_SET_SUCCESSFULLY).getBuf());
        return MMI_RET_OK;
    }
    case EVT_ID_CUI_WALLPAPER_SETTING_ERROR:
    case EVT_ID_CUI_WALLPAPER_SETTING_CANCEL:
	{
        cui_wallpaper_setting_event_struct *wallpaperSettingEvt = (cui_wallpaper_setting_event_struct*)evt;
        vcui_wallpaper_setting_close(wallpaperSettingEvt->sender_id);
        m_wallpaperSettingCuiId = 0;
        return MMI_RET_OK;
	}
	#endif /* __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__ */
	default:
        break;		
	}
    return MMI_RET_DONT_CARE;
}

void VappSettingWallpaperResPage::closeWallpaperPage()
{
    VfxMainScr *mainScr = getMainScr();
    mainScr->popPage();
}

void VappSettingWallpaperResPage::closeStorageRelatedPage()
{
    if (m_wpSourceType != VAPP_WALLPAPER_SETTING_SYSTEM)
	{
	    if (m_cuiId)
		{
		    switch (m_wpSourceType)
			{
            case VAPP_WALLPAPER_SETTING_GALLERY:
                vcui_gallery_close(m_cuiId);
                VFX_OBJ_CLOSE(m_liveWallpaperProvider);
                break;

			default:
				break;
			}            
		}
        if (m_wallpaperSettingCuiId)
    	{
    	    vcui_wallpaper_setting_close(m_wallpaperSettingCuiId);
    	}
	}
}


#ifdef __MMI_USB_SUPPORT__
mmi_ret VappSettingWallpaperResPage::usbMassStorageModeHdlr(mmi_event_struct *evt)
{
    VappSettingWallpaperResPage *page = VFX_OBJ_DYNAMIC_CAST(((VfxObject*)evt->user_data), VappSettingWallpaperResPage);
    if (evt->evt_id == EVT_ID_USB_ENTER_MS_MODE && page)
    {
    	page->closeStorageRelatedPage();
    }
    return MMI_RET_OK;
}
#endif /* __MMI_USB_SUPPORT__ */
/***************************************************************************** 
 * VappWallpaperIconCell
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappWallpaperIconCell", VappWallpaperIconCell, VcpFormItemLauncherCell);
void VappWallpaperIconCell::onInit()
{
    VcpFormItemLauncherCell::onInit();
    VFX_OBJ_CREATE(m_imageFrame, VfxImageFrame, this);

    m_mainText->setRect(VfxRect(TEXT_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH, 
                                 m_mainText->getPos().y,
                                 getRect().getWidth() - TEXT_LEFT_GAPS - TEXT_RIGHT_GAPS - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH) - (ACCESSORY_WIDTH + ACCESSORY_RIGHT_GAPS),
                                 m_mainText->getRect().getHeight()));
} 

void VappWallpaperIconCell::setIconSrc(VfxImageSrc imageSrc) 
{
    m_imageFrame->setImgContent(imageSrc);
    VfxS32 width, height;

    width = IMG_MAX_WIDTH;
    height = IMG_MAX_HEIGHT;

    VfxBool cannotResize = VFX_FALSE;
    if(VFX_IMAGE_SRC_TYPE_IMAGE_BUFFER == imageSrc.getType() &&
       VRT_COLOR_TYPE_UYVY422 == imageSrc.getImageBuffer().colorFormat)
    {
        cannotResize = VFX_TRUE;
    }
    if(cannotResize)
    {
        m_imageFrame->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_CENTER);
    }
    else
    {
        m_imageFrame->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE_ASPECT_FILL);
    }
    m_imageFrame->setSize(width, height);
    m_imageFrame->setRect(VfxRect(IMG_LEFT_GAPS + ((IMG_MAX_WIDTH - width) / 2), 
                             (getBounds().getHeight() - height) / 2,
                             width,
                             height));
}

void VappWallpaperIconCell::onUpdate()
{
    VcpFormItemLauncherCell::onUpdate();
    if (m_mainText)
    {
        const VfxS32 newX = TEXT_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH;
        const VfxS32 offset = newX - m_mainText->getPos().x;
        m_mainText->setPos(newX, m_mainText->getPos().y);	
        const VfxSize originalSize = m_mainText->getSize();
        m_mainText->setSize(originalSize.width - offset, originalSize.height);
    }
}

/***************************************************************************** 
 * VappWallpaperHomeScreenCell
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappWallpaperHomeScreenCell", VappWallpaperHomeScreenCell, VappWallpaperIconCell);
VappWallpaperHomeScreenCell::VappWallpaperHomeScreenCell()
    : m_userVideoFile(VFX_WSTR_EMPTY), m_recThumbBuffer(NULL)
{}

void VappWallpaperHomeScreenCell::onInit()
{
    VappWallpaperIconCell::onInit();
    m_appGroupId = 0;
    m_type = VAPP_WALLPAPER_HOME_SCREEN;
    
    setMainText((VfxResId)STR_ID_VAPP_SETTING_WALLPAPER_HOME_SCREEN);
    m_signalTap.connect(this, &VappWallpaperHomeScreenCell::onTap);
    setAccessory(VCPFORM_NEXT_ITEM_ICON);

	updateCell();

    VappWallpaperSettingInterface *settingInterface = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingInterface);
    settingInterface->m_signalWallpaperIsUpdated.connect(this, &VappWallpaperHomeScreenCell::updateCell);
}

void VappWallpaperHomeScreenCell::onDeinit()
{
    if (m_recThumbBuffer)
    {       
        if (m_appGroupId != 0)
        {
            applib_asm_free_r(m_appGroupId, m_recThumbBuffer);
            m_recThumbBuffer = NULL; 
        }
    }
    
    VappWallpaperIconCell::onDeinit();
}

void VappWallpaperHomeScreenCell::updateCell()
{
    setIconSrc(getItemImage(m_type));
}

static VfxBool isFileExist(const WCHAR *filePath)
{
    FS_HANDLE handle;
    handle = FS_Open(filePath, FS_READ_ONLY);
    if(handle > 0)
    {
        FS_Close(handle);
        return VFX_TRUE;
    }
    return VFX_FALSE;
}

VfxImageSrc VappWallpaperHomeScreenCell::getItemImage(U8 type)
{
	const VappWallpaperType wallpaperType = (VappWallpaperType)type;
    const VappWallpaperSrcEnum src = (VAPP_WALLPAPER_HOME_SCREEN == wallpaperType) ? VAPP_WALLPAPER_SRC_HOMESCREEN : VAPP_WALLPAPER_SRC_LOCK;
    // retrieve wallpaper id
    VappWallpaperSettingProvider *wallpaperStore = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingProvider);
    VappWallpaperId wid = wallpaperStore->getDefaultWallpaper(src, this);
    
    // the return value
    VfxImageSrc wallpaperIconImage;
    wallpaperIconImage.setNull();

    // special cases
    if(VAPP_WALLPAPER_FACTORY_VIDEO == wid.getSource())
    {
        // special case: video wallpaper (res and user file)
        #ifdef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
        if(VappWallpaperId::TYPE_KIND_INTEGER == wid.getTypeKind())
        {
            #if defined(__MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__) && !defined(__LOW_COST_SUPPORT_COMMON__)
            wallpaperIconImage.setResId(get_wallpaper_thumb(VAPP_WALLPAPER_VIDEO_WALLPAPER, (VfxU32)wid.getIntType()-VDO_ID_SYS_MP4_01, this));
            #endif
        }
        else if(VappWallpaperId::TYPE_KIND_WSTRING == wid.getTypeKind())
        {
            VfxWString wallpaperFile = VFX_WSTR_MEM(wid.getWStringType());
            if(isFileExist(wallpaperFile))
            {
                wallpaperIconImage = getThumbnail(wallpaperFile);
            }
            else
            {
                // restore wallpaper if user file is missing
                wallpaperIconImage.setNull();
                VappWallpaperSettingInterface *setting = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingInterface);
	            setting->restoreWallpaper(wallpaperType);
            }
        }
        #endif
    }
    else if((VAPP_WALLPAPER_FACTORY_IMAGE == wid.getSource() || VAPP_WALLPAPER_FACTORY_USERFILE == wid.getSource())
            && VappWallpaperId::TYPE_KIND_WSTRING == wid.getTypeKind())
    {
        // special case: user image
        VfxWString wallpaperFile = VFX_WSTR_MEM(wid.getWStringType());
        if(isFileExist(wallpaperFile))
        {
            VfxBool usePath = VFX_FALSE;

            #if !defined(__LOW_COST_SUPPORT_COMMON__)
            if(VAPP_WALLPAPER_FACTORY_IMAGE == wid.getSource())
            {
                // non-slim case, we will have cache file, so set path directly
                usePath = VFX_TRUE;
            }
            #endif
            
            if(usePath)
            {
                wallpaperIconImage.setPath(wallpaperFile);
            }
            else
            {
                // othercases, the file may be removed during this cell's life cycle,
                // so decode thumbnail into buffer.
                // e.g. MAUI_03167120
                wallpaperIconImage = getThumbnail(wallpaperFile, VFX_FALSE);
            }
        }
        else
        {
            // restore wallpaper if user file is missing
            wallpaperIconImage.setNull();
            VappWallpaperSettingInterface *setting = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingInterface);
	        setting->restoreWallpaper(wallpaperType);
        }
    }

    if(!wallpaperIconImage.isNull())
    {
        return wallpaperIconImage;
    }
    
    // generic case: live wallpaper ,static wallpaper, others.
    // create wallpaper instance to query thumbnail
    VappWallpaper *wallpaper = VappWallpaperKit::createWallpaperWithoutSetup(this, src);
    if (NULL == wallpaper)
    {
        VappWallpaperSettingInterface *setting = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingInterface);
	    setting->restoreWallpaper(wallpaperType);
        // try again
        wallpaper = VappWallpaperKit::createWallpaperWithoutSetup(this, src);
        VFX_ASSERT(NULL != wallpaper);
    }

    if(NULL == wallpaper)
    {
        wallpaperIconImage.setNull();
        return wallpaperIconImage;
    }
	
    VfxResId resId = wallpaper->getThumbnail();
    if(resId)
    {
        wallpaperIconImage.setResId(resId);
    }
    else if(wallpaper->getThumbnailImageSrc(wallpaperIconImage))
    {
                // successfully retrieved image source.
                // TODO: print message for VfxImageBuffer case.
    }
    else
    {
        wallpaperIconImage.setNull();
        // allocate image buffer for decoding
        const VfxS32 width = ((IMG_MAX_WIDTH+1)>>1)<<1;
        const VfxS32 height = ((IMG_MAX_HEIGHT+1)>>1)<<1;
        if (m_recThumbBuffer == NULL)
        {
            VappSettingMainScr *mainScr = VFX_OBJ_DYNAMIC_CAST(findScreen(), VappSettingMainScr);
            if (mainScr)
        	{
                m_appGroupId = mainScr->getApp()->getGroupId();
                m_recThumbBuffer = (VfxU8 *)applib_asm_alloc_nc_r(m_appGroupId, width*height*2);
                VFX_ASSERT(m_recThumbBuffer);
        	}
        }
        VfxImageBuffer imageBuf;
        imageBuf.ptr = (VfxU8*)m_recThumbBuffer;
        imageBuf.pitchBytes = width*2;
        imageBuf.width = width;
        imageBuf.height = height;
        imageBuf.colorFormat = VRT_COLOR_TYPE_RGB565;
        if(wallpaper->getThumbnailImage(imageBuf))
        {
            wallpaperIconImage.setImageBuffer(imageBuf);
        }
        
    }
    VFX_OBJ_CLOSE(wallpaper);

    return wallpaperIconImage;
}

void VappWallpaperHomeScreenCell::onTap(VcpFormItemCell *cell, VfxId selectIdx)
{
    VfxMainScr *mainScr = VFX_OBJ_DYNAMIC_CAST(findScreen(), VfxMainScr);
    if (mainScr)
	{
        VappSettingWallpaperResPage *page;
        VFX_OBJ_CREATE_EX(page, VappSettingWallpaperResPage, mainScr, ((VappWallpaperType)m_type));
        mainScr->pushPage('RSPG', page);	
	}   
}   

const VfxImageSrc VappWallpaperHomeScreenCell::getThumbnail(const VfxWString& userFile, VfxBool isVideo)
{
    if (!m_userVideoFile.isEmpty()&&m_userVideoFile == userFile)
    {        
        return m_userVideoThumb;
    }

    VappSettingMainScr *mainScr = VFX_OBJ_DYNAMIC_CAST(findScreen(), VappSettingMainScr);
    if (mainScr)
	{
        m_appGroupId = mainScr->getApp()->getGroupId();
	}   
    if (m_appGroupId == 0)
    {
        return VfxImageSrc();
    }

    // Image & default using RGB565
    vrt_color_type_enum thumbFormat = VRT_COLOR_TYPE_RGB565;
    gdi_color_format thumbFormatGDI = GDI_COLOR_FORMAT_16;
    VfxS32 bpp = gdi_bits_per_pixel(thumbFormatGDI) / 8;
    if(isVideo)
    {
        // It's possible that video does not support RGB thumbnail
        #if !defined(__MDI_DISPLAY_RGB565_SUPPORT__) && defined(__MDI_DISPLAY_YUYV422_SUPPORT__)
        thumbFormat = VRT_COLOR_TYPE_UYVY422;
        thumbFormatGDI = GDI_COLOR_FORMAT_UYVY422;
        bpp = gdi_bits_per_pixel(thumbFormatGDI) / 8;
        #endif
    }
  
    VfxS32 width = ((IMG_MAX_WIDTH+1)>>1)<<1;
    VfxS32 height = ((IMG_MAX_HEIGHT+1)>>1)<<1;
    if (m_recThumbBuffer == NULL)
    {
        m_recThumbBuffer = (VfxU8 *)applib_asm_alloc_nc_r(m_appGroupId, width*height*bpp);
    }

    MMI_EXT_ASSERT(m_recThumbBuffer != NULL, m_appGroupId, width*height, 0); 
    
    // suspend VRT
    VFX_OBJ_GET_INSTANCE(VfxRenderer)->suspendUntilCommit();

    gdi_handle thumHandle = GDI_LAYER_EMPTY_HANDLE;
    gdi_layer_create_cf_using_outside_memory(
                                        thumbFormatGDI,
                                        0, 0, width, height,
                                        &thumHandle, m_recThumbBuffer, width*height*bpp);

    ASSERT(thumHandle != GDI_LAYER_EMPTY_HANDLE);

    gdi_layer_push_and_set_active(thumHandle);
    gdi_layer_clear(GDI_COLOR_BLACK);
    gdi_layer_pop_and_restore_active();

    // get frame
    if(isVideo)
    {
        mdi_video_info_struct video_info;
        mdi_video_ply_set_scenario_type(MDI_VIDEO_SCENARIO_PREVIEW);

        MDI_RESULT ret = mdi_video_ply_open_clip_file(m_appGroupId, (const CHAR*)(userFile.getBuf()), &video_info);
        if (ret != MDI_RES_VDOPLY_SUCCEED)
        {
            gdi_layer_free(thumHandle);
            m_userVideoThumb = VfxImageSrc();
            return m_userVideoThumb;
        }

        mdi_video_ply_set_frame_mode(MDI_VIDEO_FRAME_MODE_FIT_OUTSIDE);
        ret = mdi_video_ply_seek_and_get_frame(0, thumHandle);
        mdi_video_ply_close_clip_file();
    }
    else
    {
        // image case
        S32 imgWidth = 0;
        S32 imgHeight = 0;
        GDI_RESULT res = GDI_SUCCEED;
        res = gdi_image_get_dimension_file((S8*)userFile.getBuf(), &imgWidth, &imgHeight);
        S32 offsetX = 0, offsetY = 0, targetW = width, targetH = height;
        gdi_util_fit_box(
                        GDI_UTIL_MODE_SHORT_SIDE_FIT,
                        width,
                        height,
                        imgWidth,
                        imgHeight,
                        &offsetX,
                        &offsetY,
                        &targetW,
                        &targetH
                        );
        res = gdi_imgdec_draw_resized_file(thumHandle, 
                                            offsetX, 
                                            offsetY, 
                                            targetW,
                                            targetH,
                                            (U8*)userFile.getBuf());
        if (res != GDI_SUCCEED)
        {
            gdi_layer_free(thumHandle);
            m_userVideoThumb = VfxImageSrc();
            return m_userVideoThumb;
        }
    }
    
    gdi_layer_free(thumHandle);
    
    VfxImageBuffer imageBuf;
    imageBuf.ptr = (VfxU8*)m_recThumbBuffer;
    imageBuf.pitchBytes = width*bpp;
    imageBuf.width = width;
    imageBuf.height = height;
    imageBuf.colorFormat = thumbFormat;

    m_userVideoThumb = VfxImageSrc(imageBuf);
    m_userVideoFile = userFile;

    return m_userVideoThumb;

}

/***************************************************************************** 
 * VappWallpaperLockScreenCell
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappWallpaperLockScreenCell", VappWallpaperLockScreenCell, VappWallpaperHomeScreenCell);
void VappWallpaperLockScreenCell::onInit()
{
    VappWallpaperIconCell::onInit();
    
    m_type = VAPP_WALLPAPER_LOCK_SCREEN;
    
    setMainText((VfxResId)STR_ID_VAPP_SETTING_WALLPAPER_LOCK_SCREEN);
    m_signalTap.connect(this, &VappWallpaperLockScreenCell::onTap);
    setAccessory(VCPFORM_NEXT_ITEM_ICON);
	updateCell();

    VappWallpaperSettingInterface *settingInterface = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingInterface);
    settingInterface->m_signalWallpaperIsUpdated.connect(this, &VappWallpaperLockScreenCell::updateCell);
}


/***************************************************************************** 
 * Class 
 *****************************************************************************/
/***************************************************************************** 
 * VappSettingWallpaperGalleryPage
 *****************************************************************************/
#ifdef __MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__
VFX_IMPLEMENT_CLASS("VappSettingWallpaperGalleryPage", VappSettingWallpaperGalleryPage, VfxPage);
void VappSettingWallpaperGalleryPage::onInit()
{
    VfxPage::onInit();

    VcpTitleBar *titleBar;
    VFX_OBJ_CREATE(titleBar, VcpTitleBar, this);
    titleBar->setTitle((VfxResId)STR_ID_VAPP_SETTING_WALLPAPER_GALLERY);		
    setTopBar(titleBar);    
    
    VFX_OBJ_CREATE(m_listMenu, VcpListMenu, this);

    m_listMenu->setPos(0, 0);
    m_listMenu->setSize(getSize());
    m_listMenu->setAlignParent(
        VFX_FRAME_ALIGNER_MODE_SIDE,
        VFX_FRAME_ALIGNER_MODE_SIDE,
        VFX_FRAME_ALIGNER_MODE_SIDE,
        VFX_FRAME_ALIGNER_MODE_SIDE);
    
    m_listMenu->setContentProvider(this);
    m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_SINGLE_TEXT);
    m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_NORMAL, VFX_FALSE);
    m_listMenu->setMenuControlMode(VCP_LIST_MENU_CONTROL_MODE_DISCLOSURE);
    m_listMenu->m_signalItemTapped.connect(this, &VappSettingWallpaperGalleryPage::onSelectItem);  
    
    #ifdef __MMI_USB_SUPPORT__
       mmi_frm_cb_reg_event(EVT_ID_USB_ENTER_MS_MODE, VappSettingWallpaperGalleryPage::usbMassStorageModeHdlr, this);
    #endif
}

void VappSettingWallpaperGalleryPage::onDeinit()
{
    #ifdef __MMI_USB_SUPPORT__
       mmi_frm_cb_dereg_event(EVT_ID_USB_ENTER_MS_MODE, VappSettingWallpaperGalleryPage::usbMassStorageModeHdlr, this);
    #endif

    VfxPage::onDeinit();

}

VfxBool VappSettingWallpaperGalleryPage::getItemText(VfxU32 index, VcpListMenuFieldEnum fieldType, VfxWString &text, VcpListMenuTextColorEnum &color)
{
    if (index < (VfxU32)getCount())
    {
        if (fieldType == VCP_LIST_MENU_FIELD_TEXT)	
        {
            switch (index)
            {
            case 0: 
                text.loadFromRes((VfxResId)STR_ID_VAPP_SETTING_WALLPAPER_PICTURE);
                break;
            case 1: 
                text.loadFromRes((VfxResId)STR_ID_VAPP_SETTING_WALLPAPER_VIDEO);
                break; 
            default:
                ASSERT(0);
            }

            color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;
            return VFX_TRUE;
        }
    }
    return VFX_FALSE;
}

VfxBool VappSettingWallpaperGalleryPage::getItemImage(VfxU32 index, VcpListMenuFieldEnum fieldType, VfxImageSrc &image)
{
    if (fieldType == VCP_LIST_MENU_FIELD_DISCLOSURE_IMG)
    {
        image.setResId(VCP_IMG_LIST_MENU_DEFAULT_DISCLOSURE);
        return VFX_TRUE;
    }
    return VFX_FALSE;
}
void VappSettingWallpaperGalleryPage::onSelectItem(VcpListMenu *listMenu, VfxU32 selectIdx)
{
    switch (selectIdx)
    {
    case 0:
    {
        #ifdef __MMI_USB_SUPPORT__
            if (srv_usb_is_in_mass_storage_mode())
            {
                vapp_usb_unavailable_popup(0);
                return;
            }
        #endif /* __MMI_USB_SUPPORT__ */
        
        FMGR_FILTER filter;
        vapp_wallpaper_set_file_filter_by_struct(&filter, vapp_wallpaper_support_types);
        m_cuiId = vcui_gallery_image_picker_create(getApp()->getGroupId(), MMI_FALSE, &filter);
        vcui_gallery_picker_set_auto_close(m_cuiId, MMI_FALSE);
        vcui_gallery_run(m_cuiId);
		break;
    }
    case 1:     // For video
    { 
        #ifdef __MMI_USB_SUPPORT__
            if (srv_usb_is_in_mass_storage_mode())
            {
                vapp_usb_unavailable_popup(0);
                return;
            }
        #endif /* __MMI_USB_SUPPORT__ */

        FMGR_FILTER filter;
        VfxId index = getOffset(vapp_wallpaper_support_types, FMGR_TYPE_3GP);
        ASSERT(index != FMGR_TYPE_COUNT);
        vapp_wallpaper_set_file_filter_by_struct(&filter, vapp_wallpaper_support_types+index);
    
        m_cuiId = vcui_gallery_video_picker_create(getApp()->getGroupId(), MMI_FALSE, &filter);
        vcui_gallery_picker_set_auto_close(m_cuiId, MMI_FALSE);
        vcui_gallery_run(m_cuiId);

		break;
    }
	default:
		break;
	}
}    

void VappSettingWallpaperGalleryPage::setWallpaperFromGallery()
{
    WCHAR buffer[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1)];
    memset(buffer, 0 ,(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1));
    VfxU32 bufferSize = (SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1);
    vcui_gallery_picker_get_single_path(m_cuiId, buffer, &bufferSize);
    if (buffer[0])
	{
        cui_wallpaper_setting_create_struct arg;
        arg.filename = buffer;
        arg.screen_type = (cui_wallpaper_setting_screen_type_enum)m_wpType;
        arg.user_data = this;
        m_wallpaperSettingCuiId = vcui_wallpaper_setting_create(getApp()->getGroupId(), &arg);
        if (m_wallpaperSettingCuiId == GRP_ID_INVALID)
    	{
    	    return;
    	}
        vcui_wallpaper_setting_run(m_wallpaperSettingCuiId);
	}    
}

mmi_ret VappSettingWallpaperGalleryPage::onProc(mmi_event_struct *evt)
{
    switch (evt->evt_id)
    {
    // Gallery CUI
    case EVT_ID_VCUI_GALLERY_CLOSE_GID:
    case EVT_ID_VCUI_GALLERY_PICKER_RESULT_READY:
    {
        vcui_gallery_evt_struct *galleryEvt = (vcui_gallery_evt_struct*)evt;
        if (galleryEvt->result != VCUI_GALLERY_RESULT_OK)
    	{
      	    vcui_gallery_close(m_cuiId);
            return MMI_RET_OK;
    	}
        setWallpaperFromGallery();

        return MMI_RET_OK;
    }
    // Wallpaper setting CUI
    case EVT_ID_CUI_WALLPAPER_SETTING_DONE:
    {
        cui_wallpaper_setting_event_struct *wallpaperSettingEvt = (cui_wallpaper_setting_event_struct*)evt;
        mmi_id cuiId = m_cuiId;
        closeWallpaperPage();
        closeWallpaperPage();
        vcui_wallpaper_setting_close(wallpaperSettingEvt->sender_id);
    	    vcui_gallery_close(cuiId);
        
        mmi_frm_nmgr_balloon(
            MMI_SCENARIO_ID_DEFAULT,
            MMI_EVENT_INFO_BALLOON,
            MMI_NMGR_BALLOON_TYPE_SUCCESS, 
            VFX_WSTR_RES(STR_ID_VAPP_SETTING_WALLPAPER_SET_SUCCESSFULLY).getBuf());
        return MMI_RET_OK;
    }
    case EVT_ID_CUI_WALLPAPER_SETTING_ERROR:
    case EVT_ID_CUI_WALLPAPER_SETTING_CANCEL:
	{
        cui_wallpaper_setting_event_struct *wallpaperSettingEvt = (cui_wallpaper_setting_event_struct*)evt;
        vcui_wallpaper_setting_close(wallpaperSettingEvt->sender_id);
        m_wallpaperSettingCuiId = 0;
        return MMI_RET_OK;
	}
	default:
        break;		
	}
    return MMI_RET_DONT_CARE;
}

void VappSettingWallpaperGalleryPage::closeWallpaperPage()
{
    VfxMainScr *mainScr = getMainScr();
    mainScr->popPage();
}

void VappSettingWallpaperGalleryPage::closeStorageRelatedPage()
{
    if (m_cuiId)
{
    vcui_gallery_close(m_cuiId);
    }
    if (m_wallpaperSettingCuiId)
    {
        vcui_wallpaper_setting_close(m_wallpaperSettingCuiId);
    }
    closeWallpaperPage();
    closeWallpaperPage();
}


#ifdef __MMI_USB_SUPPORT__
mmi_ret VappSettingWallpaperGalleryPage::usbMassStorageModeHdlr(mmi_event_struct *evt)
{
    VappSettingWallpaperGalleryPage *page = VFX_OBJ_DYNAMIC_CAST(((VfxObject*)evt->user_data), VappSettingWallpaperGalleryPage);
    if (evt->evt_id == EVT_ID_USB_ENTER_MS_MODE && page)
    {
    	page->closeStorageRelatedPage();
    }
    return MMI_RET_OK;
}
#endif
/***************************************************************************** 
 * VappCustomImageTextFrame
 *****************************************************************************/
void VappCustomImageFrame::onLayoutElements()
{
    if (m_imageFrame)
    {
        VfxBool cannotResize = VFX_FALSE;
        VfxImageSrc imageSrc = m_imageFrame->getImgContent();
        if(VFX_IMAGE_SRC_TYPE_IMAGE_BUFFER == imageSrc.getType() &&
           VRT_COLOR_TYPE_UYVY422 == imageSrc.getImageBuffer().colorFormat)
        {
            cannotResize = VFX_TRUE;
        }
        if(cannotResize)
        {
            m_imageFrame->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_CENTER);
        }
        else
        {
            m_imageFrame->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE_ASPECT_FILL);
        }

        m_imageFrame->setSize(IMG_MAX_WIDTH, IMG_MAX_HEIGHT);
        m_imageFrame->setRect(VfxRect(IMG_LEFT_GAPS,
                                      (getBounds().getHeight() - IMG_MAX_HEIGHT) / 2,
                                      IMG_MAX_WIDTH,
                                      IMG_MAX_HEIGHT));

        m_imageFrame->setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE,
                                     VFX_FRAME_ALIGNER_MODE_SIDE,
                                     VFX_FRAME_ALIGNER_MODE_SIDE,
                                     VFX_FRAME_ALIGNER_MODE_SIDE);
    }

    
    if (m_textFrame)
    {
        m_textFrame->setRect(VfxRect(TEXT_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH, 
                             (getBounds().getHeight() - m_textFrame->getBounds().getHeight()) / 2,
                             getRect().getWidth() - TEXT_LEFT_GAPS - TEXT_RIGHT_GAPS - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH),
                             m_textFrame->getRect().getHeight()));
        //m_textFrame->setPos(TEXT_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH, m_textFrame->getPos().y);	
    }
}

/***************************************************************************** 
 * VappSettingSystemVideoPage
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappSettingSystemVideoPage",VappSettingSystemVideoPage,VfxPage);

void VappSettingSystemVideoPage::onInit()
{
    VfxPage::onInit();

    VcpTitleBar *titleBar;
    VFX_OBJ_CREATE(titleBar, VcpTitleBar, this);
    if (m_wpType == VAPP_VIDEO_PWR_ON_SCREEN)
        titleBar->setTitle((VfxResId)STR_ID_VAPP_SETTING_PWR_ON_VIDEO); 
    else if (m_wpType == VAPP_VIDEO_PWR_OFF_SCREEN)
        titleBar->setTitle((VfxResId)STR_ID_VAPP_SETTING_PWR_OFF_VIDEO); 
    else
        titleBar->setTitle((VfxResId)STR_ID_VAPP_SETTING_WALLPAPER_SYSTEM_VIDEO);
    setTopBar(titleBar);

    VFX_OBJ_CREATE(m_listMenu, VcpListMenu, this);    
    m_listMenu->setPos(0, 0);
    m_listMenu->setSize(getSize());
    m_listMenu->setAlignParent( VFX_FRAME_ALIGNER_MODE_SIDE,
                                VFX_FRAME_ALIGNER_MODE_SIDE,
                                VFX_FRAME_ALIGNER_MODE_SIDE,
                                VFX_FRAME_ALIGNER_MODE_SIDE);
    
    m_listMenu->setContentProvider(this);
    m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_CUSTOM);
    m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_TAIL_SINGLE_CHECK_MARK, VFX_FALSE);
    m_listMenu->setMenuControlMode( VCP_LIST_MENU_CONTROL_MODE_NORMAL);
    m_listMenu->m_signalItemTapped.connect(this, &VappSettingSystemVideoPage::onSelectItem);

        VcpToolBar *gallery;
        VFX_OBJ_CREATE(gallery, VcpToolBar, this);
        gallery->addItem('GALL', (VfxResId)STR_ID_VAPP_SETTING_WALLPAPER_GALLERY, IMG_ID_VAPP_WALLPAPER_SETTING_CUI_TOOBAR_WALLPAPER);
        gallery->m_signalButtonTap.connect(this, &VappSettingSystemVideoPage::onEnterVideoGallery);
        setBottomBar(gallery);

#ifdef __MMI_USB_SUPPORT__
       mmi_frm_cb_reg_event(EVT_ID_USB_ENTER_MS_MODE, VappSettingSystemVideoPage::usbMassStorageModeHdlr, this);
#endif /* __MMI_USB_SUPPORT__ */
}

void VappSettingSystemVideoPage::onDeinit()
{
#ifdef __MMI_USB_SUPPORT__    
        mmi_frm_cb_dereg_event(EVT_ID_USB_ENTER_MS_MODE, VappSettingSystemVideoPage::usbMassStorageModeHdlr, this);
#endif /* __MMI_USB_SUPPORT__ */

    VfxPage::onDeinit();
    }

void VappSettingSystemVideoPage::onEntered()
{
    VfxPage::onEntered();
    m_isGallery = VFX_FALSE;
}

#ifdef __MMI_USB_SUPPORT__
mmi_ret VappSettingSystemVideoPage::usbMassStorageModeHdlr(mmi_event_struct *evt)
{
    VappSettingSystemVideoPage *page = VFX_OBJ_DYNAMIC_CAST(((VfxObject*)evt->user_data), VappSettingSystemVideoPage);
    if (evt->evt_id == EVT_ID_USB_ENTER_MS_MODE && page)
    {
    	page->closeStorageRelatedPage();
    }
    return MMI_RET_OK;
}
#endif /* __MMI_USB_SUPPORT__ */

void VappSettingSystemVideoPage::closeStorageRelatedPage()
{
    if (!m_isGallery)
    {
        return ;
    }
    if (m_cuiId)
	{
            vcui_gallery_close(m_cuiId);
	}            
    if (m_wallpaperSettingCuiId)
    {
	vcui_wallpaper_setting_close(m_wallpaperSettingCuiId);
  }
    closeWallpaperPage();
}


VfxBool VappSettingSystemVideoPage::getItemText(
    VfxU32 index,                    // [IN] the index of item
    VcpListMenuFieldEnum fieldType,  // [IN] the type of the field in the cell
    VfxWString &text,                // [OUT] the text resource
    VcpListMenuTextColorEnum &color  // [OUT] the text color
    )
{
	if (index >= (VfxU32)getCount())
        return VFX_FALSE;
    
	if (fieldType == VCP_LIST_MENU_FIELD_TEXT)	
	{
    	    if (0 == index)
            {
                text.loadFromRes((VfxResId)STR_GLOBAL_DEFAULT);
            }
            else
            {
                #if !defined(__LOW_COST_SUPPORT_COMMON__)
                text.loadFromRes((VfxResId)(STR_ID_SYS_VDO_NAME_01+index-1)); 
                #endif
            }
	    color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;
	    return VFX_TRUE;
	}

	return VFX_FALSE;
}

VfxU32 VappSettingSystemVideoPage::getCount() const 
{   
#if !defined(__LOW_COST_SUPPORT_COMMON__)
    return g_systemVideoNum+1;
#else
    return 1;
#endif

}

void VappSettingSystemVideoPage::setWallpaperFromGallery()
{
    WCHAR buffer[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1)];
    memset(buffer, 0 ,(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1));
    VfxU32 bufferSize = (SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1);
    vcui_gallery_picker_get_single_path(m_cuiId, buffer, &bufferSize);
    if (buffer[0])
    {
        cui_wallpaper_setting_create_struct arg;
        arg.filename = buffer;
        arg.screen_type = (cui_wallpaper_setting_screen_type_enum)m_wpType;
        arg.user_data = this;
        m_wallpaperSettingCuiId = vcui_wallpaper_setting_create(getApp()->getGroupId(), &arg);
        if (m_wallpaperSettingCuiId == GRP_ID_INVALID)
    	{
    	    return;
    	}
        vcui_wallpaper_setting_run(m_wallpaperSettingCuiId);
    }    
}
	
mmi_ret VappSettingSystemVideoPage::onProc(mmi_event_struct *evt)
{
    switch (evt->evt_id)
    {
        // Gallery CUI
        case EVT_ID_VCUI_GALLERY_CLOSE_GID:
        case EVT_ID_VCUI_GALLERY_PICKER_RESULT_READY:
        {
            vcui_gallery_evt_struct *galleryEvt = (vcui_gallery_evt_struct*)evt;
            if (galleryEvt->result != VCUI_GALLERY_RESULT_OK)
        	{
          	    vcui_gallery_close(m_cuiId);
                return MMI_RET_OK;
        	}

	    setWallpaperFromGallery();			
            return MMI_RET_OK;
            } 

        // Wallpaper setting CUI
        case EVT_ID_CUI_WALLPAPER_SETTING_DONE:
        {
            cui_wallpaper_setting_event_struct *wallpaperSettingEvt = (cui_wallpaper_setting_event_struct*)evt;
            mmi_id cuiId = m_cuiId;
            closeWallpaperPage();
            vcui_wallpaper_setting_close(wallpaperSettingEvt->sender_id);
        	vcui_gallery_close(cuiId);
 
            mmi_frm_nmgr_balloon(
                MMI_SCENARIO_ID_DEFAULT,
                MMI_EVENT_INFO_BALLOON,
                MMI_NMGR_BALLOON_TYPE_SUCCESS, 
                VFX_WSTR_RES(STR_ID_VAPP_SETTING_WALLPAPER_SET_SUCCESSFULLY).getBuf());
            return MMI_RET_OK;
        }
        
        case EVT_ID_CUI_WALLPAPER_SETTING_ERROR:
        case EVT_ID_CUI_WALLPAPER_SETTING_CANCEL:
    	{
            cui_wallpaper_setting_event_struct *wallpaperSettingEvt = (cui_wallpaper_setting_event_struct*)evt;
            vcui_wallpaper_setting_close(wallpaperSettingEvt->sender_id);
            return MMI_RET_OK;
    	}
        default:
            break;
    }
    
        return MMI_RET_DONT_CARE;
}

VfxBool VappSettingSystemVideoPage::getItemImage(VfxU32 index, VcpListMenuFieldEnum fieldType, VfxImageSrc &image)
{
    if (fieldType == VCP_LIST_MENU_FIELD_ICON)
    {
        if (0 == index)
        {
            image = VfxImageSrc(IMG_ID_VAPP_BOOTUP_ANIMATION);            
        }
        else
        {
            #if !defined(__LOW_COST_SUPPORT_COMMON__)
            image = VfxImageSrc(g_systemVideoInfo[index-1].thumbnailId);
            #endif
        }

        return VFX_TRUE;
    }
    return VFX_FALSE;
}

VcpListMenuCellClientBaseFrame* 
	VappSettingSystemVideoPage::getItemCustomContentFrame(VfxU32 index, VfxFrame *parentFrame)
{
	VFX_ASSERT(index < getCount());

    VappCustomImageFrame *custFrame = NULL;

    VFX_OBJ_CREATE(custFrame, VappCustomImageFrame, parentFrame);

    VFX_ASSERT(NULL != custFrame);
    return (VcpListMenuCellClientBaseFrame *)custFrame;
}

void VappSettingSystemVideoPage::closeItemCustomContentFrame(
								VfxU32 index,
								VcpListMenuCellClientBaseFrame *cell)
{	
	VFX_OBJ_CLOSE(cell);
}


void VappSettingSystemVideoPage::onSelectItem(VcpListMenu *listMenu, VfxU32 selectIdx)
{
    if (0 == selectIdx)
    {
        VappWallpaperSettingInterface *setting = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingInterface);
        //VappWpSetErrorCode errorCode;
    	setting->setWallpaperId(m_wpType, VAPP_WALLPAPER_VIDEO_WALLPAPER, VDO_ID_SYS_INVALID_VID);
        closeWallpaperPage();
        mmi_frm_nmgr_balloon(
            MMI_SCENARIO_ID_DEFAULT,
            MMI_EVENT_INFO_BALLOON,
            MMI_NMGR_BALLOON_TYPE_SUCCESS, 
            VFX_WSTR_RES(STR_ID_VAPP_SETTING_WALLPAPER_SET_SUCCESSFULLY).getBuf());        
    }
    else
    {
    VfxMainScr *mainScr = getMainScr();
    m_isGallery = VFX_FALSE;
    VfxId vdoId = indexToVideoId(selectIdx);
    VFX_OBJ_CREATE_EX(m_previewPage, VappSettingVideoPreviewPage, mainScr,(m_wpType, vdoId));
    mainScr->pushPage('PREW', m_previewPage);
}
}

void VappSettingSystemVideoPage::closeWallpaperPage()
{
    getMainScr()->popPage();
}

VfxId VappSettingSystemVideoPage::indexToVideoId(VfxId index) const
{
#if !defined(__LOW_COST_SUPPORT_COMMON__)
    if (index < getCount())
        return g_systemVideoInfo[index-1].videoId;
#else
    return 0;
#endif
}

void VappSettingSystemVideoPage::onEnterVideoGallery(VfxObject* sender, VfxId id)
{
    #ifdef __MMI_USB_SUPPORT__
        if (srv_usb_is_in_mass_storage_mode())
        {
            vapp_usb_unavailable_popup(0);
            return;
        }
    #endif /* __MMI_USB_SUPPORT__ */
    m_isGallery = VFX_TRUE;
    FMGR_FILTER filter;
    VfxId index = getOffset(vapp_wallpaper_support_types, FMGR_TYPE_3GP);
    ASSERT(index != FMGR_TYPE_COUNT);
    vapp_wallpaper_set_file_filter_by_struct(&filter, vapp_wallpaper_support_types+index);
    
    m_cuiId = vcui_gallery_video_picker_create(getApp()->getGroupId(), MMI_FALSE, &filter);
    vcui_gallery_picker_set_auto_close(m_cuiId, MMI_FALSE);
    vcui_gallery_run(m_cuiId);
}

/***************************************************************************** 
* VappSettingVideoPreviewPage
*****************************************************************************/
VFX_IMPLEMENT_CLASS("VappSettingVideoPreviewPage",VappSettingVideoPreviewPage,VfxPage);
VappSettingVideoPreviewPage::VappSettingVideoPreviewPage()
        : m_wpType(VAPP_VIDEO_PWR_ON_SCREEN)
{
}

VappSettingVideoPreviewPage::VappSettingVideoPreviewPage(VappWallpaperType wpType, VfxId videoId)
    : m_wpType(wpType), m_videoId(videoId), m_player(NULL)
{}

void VappSettingVideoPreviewPage::onInit()
{
    VfxPage::onInit();
    //m_isBackWard = VFX_FALSE;
    VcpTitleBar* titleBar = NULL;
    VFX_OBJ_CREATE(titleBar, VcpTitleBar, this);
    titleBar->setTitle((VfxResId)STR_GLOBAL_PREVIEW);
    setTopBar(titleBar);
    
    VcpToolBar* buttomBar = NULL;
    VFX_OBJ_CREATE(buttomBar, VcpToolBar, this);
    buttomBar->m_signalButtonTap.connect(this, &VappSettingVideoPreviewPage::onPreviewClick);
    buttomBar->addItem('OKAY', (VfxResId)STR_GLOBAL_OK, VCP_IMG_TOOL_BAR_COMMON_ITEM_OK);
    buttomBar->addItem('BACK', (VfxResId)STR_GLOBAL_CANCEL, VCP_IMG_TOOL_BAR_COMMON_ITEM_CANCEL);
    setBottomBar(buttomBar); 

    setBgColor(VFX_COLOR_BLACK);
    setTranslucent(VFX_TRUE);
    setBarAutoHide(VFX_FALSE);
}

void VappSettingVideoPreviewPage::onEnter(VfxBool isBackward)
{
    VfxPage::onEnter(isBackward);
    if (NULL == m_player)
    { 
        createPlayer();
    }

    m_isEntered = VFX_FALSE;
    m_isVideoOpened = VFX_FALSE;
    
    if (m_player)
    {
        m_player->openResId(m_videoId);
    }
}

void VappSettingVideoPreviewPage::createPlayer()
    { 
       VappVideoPlayerPlayOption option;
       if (m_wpType == VAPP_VIDEO_PWR_ON_SCREEN ||m_wpType== VAPP_VIDEO_PWR_OFF_SCREEN)
        {
           option.configAsBootVideoPreview();
        }
       
       option.useRingVol = VFX_FALSE;
       
       VFX_OBJ_CREATE_EX(m_player, VappVideoPlayerComponent, this,(option));
       m_player->setPos(0, 0); 
       m_player->setSize(LCD_WIDTH, LCD_HEIGHT);
       m_player->m_signalFileOpened.connect(this, &VappSettingVideoPreviewPage::onFileReady);
       m_player->m_signalPlaybackFinished.connect(this, &VappSettingVideoPreviewPage::onPlayFinished);
}

void VappSettingVideoPreviewPage::onEntered()
{
    VfxPage::onEntered();
    // register the UCM.
    mmi_frm_cb_reg_event(EVT_ID_SRV_UCM_INDICATION, &VappSettingVideoPreviewPage::onEvent, this);
    //m_player->openResId(m_videoId);
    m_isEntered = VFX_TRUE;

    if (m_isVideoOpened)
    {
        playVideo(m_player, m_openStatus);
    }
}

void VappSettingVideoPreviewPage::onExit(VfxBool isBackward)
{
    if (m_player)
    {
      m_player->pause();
      m_player->swithVideoLayerToSW(VFX_TRUE);
    }
    VfxPage::onExit(isBackward);
}

void VappSettingVideoPreviewPage::onExited2()
{
    mmi_frm_cb_dereg_event(EVT_ID_SRV_UCM_INDICATION, &VappSettingVideoPreviewPage::onEvent, this);

    if (m_player != NULL)
    {
        m_player->stop();
    	m_player->closeFile();
    }   

    VfxPage::onExited2();
}

// TODO: The num and name are not prepared.

void VappSettingVideoPreviewPage::closeWallpaperPage()
{
    back();  
}

void VappSettingVideoPreviewPage::playVideo(VappVideoPlayerComponent *player, MDI_RESULT openStatus)
{
    MDI_RESULT playResult = MDI_RES_VDOPLY_SUCCEED;
    if(player && MDI_RES_VDOPLY_SUCCEED == openStatus)
    {
        playResult = player->play();
    }
    if(MDI_RES_VDOPLY_SUCCEED != playResult &&
       MDI_RES_VDOPLY_ERR_MEMORY_INSUFFICIENT != playResult)
    {
        setOKayStatus(VFX_FALSE);
    }
    else
    {
        setOKayStatus(VFX_TRUE);
    }
}

void VappSettingVideoPreviewPage::onFileReady(VappVideoPlayerComponent *player, MDI_RESULT result)
{
    m_openStatus = result;
    if(MDI_RES_VDOPLY_SUCCEED != result && MDI_RES_VDOPLY_ERR_MEMORY_INSUFFICIENT != result)
    {
        setOKayStatus(VFX_FALSE);
    }
    else
    {
        m_isVideoOpened = VFX_TRUE;
        if (m_isEntered)
        {
            playVideo(player, m_openStatus);
        }
	}
}

void VappSettingVideoPreviewPage::onPlayFinished(VappVideoPlayerComponent *player, MDI_RESULT result)
{
    if(MDI_RES_VDOPLY_SUCCEED != result && MDI_RES_VDOPLY_ERR_MEMORY_INSUFFICIENT != result)
    {
	return ;
}
}

void VappSettingVideoPreviewPage::setOKayStatus(VfxBool status)
{
    VfxPageBar *bar = getBar(VFX_PAGE_BAR_LOCATION_BOTTOM);
    VcpToolBar *buttomBar = VFX_OBJ_DYNAMIC_CAST(bar, VcpToolBar);
    if (buttomBar)
    {
        buttomBar->setDisableItem('OKAY', !status);
    }
}

// handle the UCM
mmi_ret VappSettingVideoPreviewPage::onEvent(mmi_event_struct *param)
{
    VappSettingVideoPreviewPage *pThis = VFX_OBJ_DYNAMIC_CAST(((VfxObject*)param->user_data), VappSettingVideoPreviewPage);
    if(NULL == pThis)
    {
        return MMI_TRUE;
    }

    switch(param->evt_id)
    {
        case EVT_ID_SRV_UCM_INDICATION:
        // handle background call finish to resume video
        if(NULL != pThis->m_player)
        {
            srv_ucm_ind_evt_struct *ind = (srv_ucm_ind_evt_struct *)param;
            if (ind->ind_type == SRV_UCM_RELEASE_IND && !srv_ucm_is_any_call())
        {
                MDI_RESULT playResult = MDI_RES_VDOPLY_SUCCEED;
                playResult = pThis->m_player->play();

                pThis->setOKayStatus(MDI_RES_VDOPLY_SUCCEED == playResult ||
                                          MDI_RES_VDOPLY_ERR_MEMORY_INSUFFICIENT == playResult);
        }
    }
        break;
    }

    return MMI_TRUE;
}

void VappSettingVideoPreviewPage::closeSpecPage()
{
    switch(m_wpType)
    {
        case VAPP_VIDEO_PWR_ON_SCREEN:                
            getMainScr()->closePage('PWON');
            break;
            
        case VAPP_VIDEO_PWR_OFF_SCREEN:                
            getMainScr()->closePage('PWOF');
            break;

        default:
            break;
}
}

void VappSettingVideoPreviewPage::onPreviewClick(VfxObject* sender, VfxId id)
{
    if (id == 'OKAY')
    {
        proccessSetVideo();
    }
    else if (id == 'BACK')
    {    
        closeWallpaperPage();  
    }
}

void  VappSettingVideoPreviewPage::proccessSetVideo()
{
    VappWallpaperSettingInterface *setting = VFX_OBJ_GET_INSTANCE(VappWallpaperSettingInterface);
    VappWpSetErrorCode errorCode;

    closeSpecPage();
    m_player->pause();
    // store video wallpape resource id
    errorCode = setting->setWallpaperId(m_wpType, VAPP_WALLPAPER_VIDEO_WALLPAPER, m_videoId);

    closeWallpaperPage();
    mmi_frm_nmgr_balloon(
            MMI_SCENARIO_ID_DEFAULT,
            MMI_EVENT_INFO_BALLOON,
            MMI_NMGR_BALLOON_TYPE_SUCCESS, 
            VFX_WSTR_RES(STR_ID_VAPP_SETTING_WALLPAPER_SET_SUCCESSFULLY).getBuf());
}

#endif //__MMI_VUI_HOMESCREEN_VIDEO_WALLPAPER__

