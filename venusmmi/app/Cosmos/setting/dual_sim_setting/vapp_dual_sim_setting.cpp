/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2008
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES. ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  
 *
 * Project:
 * --------
 *  Venus
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 *  
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * Include
 *****************************************************************************/
#include "vfx_mc_include.h"
#include "vcp_include.h"
#include "vapp_dual_sim_setting.h"
#include "mmi_rp_vapp_setting_def.h"
#include "../network_connectivity/vapp_network_checking.h"
//#include "vapp_setting_dual_sim_setting.h"
extern "C"
{
#include "GlobalResDef.h"
#include "GeneralSettingSrvGprot.h"
#include "gpiosrvGprot.h"
#include "PenCalibrationSrvGprot.h"
#include "nvram_common_defs.h"
#include "SimCtrlSrvGprot.h"
#include "UcmSrvGprot.h"
#include "app_datetime.h"
}
/***************************************************************************** 
 * Define
 *****************************************************************************/
#ifndef __MMI_UART_SETTING__
    const U8 maxSimNum = 2;
#endif //__MMI_UART_SETTING
/***************************************************************************** 
 * Temp
 *****************************************************************************/
// TODO: SHOULD BE REMOVED 
extern "C"
{
#include "MMIDataType.h"
#include "PhoneSetupGprots.h"
#include "PhoneSetup.h"
#include "ps_public_enum.h"
#include "custom_nvram_config.h"
#include "ModeSwitchSrvGprot.h"
#include "MMI_phnset_dispchar.h"
#include "Custom_mmi_default_value.h"
#include "ModeSwitchAppGprot.h"
#include "fileMgrSrvGprot.h"
#include "ScheduledPowerOnOffGprot.h"
#include "Gui_data_types.h"

#include "netsetSrvGprot.h"
#include "PlmnEnum.h"
#include "vapp_worldclock_gprot.h"
#include "nvram_data_items.h"
#include "lang_interface.h"

#if (defined(__SIM_HOT_SWAP_SUPPORT__) || defined(__SIM_RECOVERY_ENHANCEMENT__))
#include "SimCtrlSrvGprot.h"
#endif 

#if 0
#if defined(__MMI_IME_FTE_ENHANCE__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

U8 PhnsetGetMainMenuStyle(void)
{
    return 0;
}

void EntryPhnsetSetDT(void)
{
}

void EntryPhnsetLang(void)
{
}

#ifdef __MMI_SCREEN_SWITCH_EFFECT__
void PhnsetSetScreenSwitchEffectStatus(mmi_phnset_sse_status_enum status)
{
}

mmi_phnset_sse_status_enum PhnsetGetScreenSwitchEffectStatus(void)
{
    return MMI_PHNSET_SSE_SIMPLE;
}
#endif
    
U8 PhnsetGetFontSize(void)
{
    return 0;
}

void PhnsetWallpaperBadFileCallBack(U16 strID)
{
}

void PhnsetSetUARTConfig(rmmi_sim_uart_setting_enum uart_config)
{
    srv_setting_set_uart_setting(uart_config);
}

PHNSET_CNTX g_phnset_cntx;

U8 mmi_flight_mode_power_on_ind_hdlr(void *msg)
{
    return 0;
}

U8 PhnsetGetDateFormat(void)
{
    return srv_setting_get_date_format();
}

U8 PhnsetGetDateSeperatorFormat(void)
{
    return srv_setting_get_date_seperator();
}

MMI_BOOL PhnsetGetShowDateTimeStatus(void)
{
    return MMI_FALSE;
}

U8 PhnsetGetTimeFormat(void)
{
    return srv_setting_get_time_format();
}

MMI_ID_TYPE idle_screen_wallpaper_ID;
CHAR *idle_screen_wallpaper_name;
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
void PhnsetReinitHomeCityIdx(void)
{
}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
U8 mmi_phnset_get_language_idx(void)    
{
#ifdef __MMI_VECTOR_FONT_MEMORY_CARD_SUPPORT__
    U8 langSSC[SSC_SIZE];
    srv_setting_get_language(langSSC);
    return (U8)(mmi_lang_support(langSSC));
#else
    return srv_setting_get_language();
#endif  /*__MMI_VECTOR_FONT_MEMORY_CARD_SUPPORT__*/
}

U8 PhnsetGetHomeCity(void)
{
    return (U8)mmi_wc_get_home_index();
}

U8 PhnsetGetDefEncodingType(void)
{
    return srv_setting_get_encoding_type();
}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
rmmi_sim_uart_setting_enum PhnsetGetUARTConfig(void)
{
    return srv_setting_get_uart_setting();
}

mmi_ret verify_uart_setting(mmi_event_struct *evt)
{    
    rmmi_sim_uart_setting_enum curUart = srv_setting_get_uart_setting();
    
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G7_SETTING, "[vapp_dual_sim_setting.cpp] Before verify uart = %d", curUart);
    rmmi_sim_uart_setting_enum expectUart = RMMI_SIM_UART_SETTING_NONE;
    
    if (srv_sim_ctrl_is_inserted(mmi_frm_index_to_sim(curUart)))
    {
        expectUart = curUart;
    }
    else
    {
        for (S32 i=0; i<MMI_MAX_SIM_NUM; ++i)
        {
            if (srv_sim_ctrl_is_inserted(mmi_frm_index_to_sim(i)))
            {
                expectUart = (rmmi_sim_uart_setting_enum)i;
                break;
            }
        }
        
        if (RMMI_SIM_UART_SETTING_NONE == expectUart)
        {
            expectUart = RMMI_UART_TO_SIM1;
        }
    }
    
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G7_SETTING, "[vapp_dual_sim_setting.cpp] after verify expUart = %d", expectUart);
    srv_setting_set_primary_card(mmi_frm_index_to_sim(expectUart));
    return MMI_RET_OK;
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
void InitSettingNVRAM(void)
{
    srv_gpio_setting_contrast_restore();
    srv_setting_init_language();

#if defined(__MMI_TOUCH_SCREEN__) || defined(__MMI_HANDWRITING_PAD__)
    srv_setting_pen_calibration_init_data();
#endif 
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
BOOL ATSetHomeCity(U8 CityIndex)
{
    return false;
}

BOOL PhnsetSetDisplayFromAT(U8 idx, U8 type)
{
    return false;
}

void EntryScrSettingMenu(void)
{
}

#if 0
/* under construction !*/
/* under construction !*/
#ifdef __MMI_SET_DEF_ENCODING_TYPE__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
#endif

#ifdef __MMI_VECTOR_FONT_MEMORY_CARD_SUPPORT__
void SetCurrentLanguage(U8* langSSC)
{
    srv_setting_set_language(langSSC);
}
#else
void SetCurrentLanguage(S8 nIndex)
{
    srv_setting_set_language(nIndex);
}
#endif /*__MMI_VECTOR_FONT_MEMORY_CARD_SUPPORT__*/


#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
S32 PhnsetScreenSaverBadFileCallBack(U16 StrId)
{
    return 0;
}

MMI_ID_TYPE idle_screen_cache_id;
CHAR *idle_screen_cache_name;
CHAR *idle_screen_wallpaper_name_original;

const U8 *mmi_netset_get_wlan_provider_name(void)
{
    return NULL;
}

MMI_BOOL mmi_phnset_check_themeid_wallpaper(U16 imgID)
{
    return MMI_FALSE;
}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

MMI_BOOL PhnsetSetLangByNvramValue(void)
{
    srv_setting_init_language();
    return MMI_TRUE;
}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
U8 ssc_disable_flag = MMI_FALSE;    /* diamond, 2005/05/13 for SSC disable */

#if defined(__MMI_DUAL_SIM_DYNAMIC_MODE__) || defined(__MMI_DUAL_SIM_STATIC_MODE__)
mmi_mode_switch_type_enum mmi_mode_switch_get_switch_type(void)
{
    return MMI_MODE_SWITCH_DYNAMIC_MODE;
}
#endif
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
U8 PhnsetGetATDisplayBound(void)
{
    return 7;
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
U8 PhnsetGetCalendarIdleScreen(void)
{
    return 0;
}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
S16 mmi_netset_retrieve_opname_from_plmn(U8 *plmn, U8 *opname)
{
    return srv_netset_get_opname(plmn, (WCHAR*)opname);
}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
}

extern "C"
{
static WCHAR g_vapp_sim_name[MMI_MAX_SIM_NUM][NVRAM_EF_SIM_NAME_MAX_LEN];
const static mmi_id g_vapp_sim_name_string_id[MMI_MAX_SIM_NUM] = 
{
    STR_GLOBAL_SIM_1
#if (MMI_MAX_SIM_NUM >=2)
    ,STR_GLOBAL_SIM_2
#if (MMI_MAX_SIM_NUM >=3)
    ,STR_GLOBAL_SIM_3
#if (MMI_MAX_SIM_NUM >=4)
    ,STR_GLOBAL_SIM_4
#endif
#endif
#endif
};

static VfxBool is_current_sim_in_call(VfxU16 sim_index)
{
    S32 group_index_list[SRV_UCM_MAX_GROUP];
    S32 group_count = srv_ucm_query_group_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, MMI_FALSE, group_index_list);

    if (group_count > 0)
    {
        srv_ucm_call_type_enum call_type[] = {SRV_UCM_SIM1_CALL_TYPE_ALL 
                                                #if (MMI_MAX_SIM_NUM >= 2)
                                                            ,SRV_UCM_SIM2_CALL_TYPE_ALL
                                                #if (MMI_MAX_SIM_NUM >= 3)
                                                            ,SRV_UCM_SIM3_CALL_TYPE_ALL
                                                #if (MMI_MAX_SIM_NUM >= 4)
                                                            ,SRV_UCM_SIM4_CALL_TYPE_ALL
                                                #endif /* MMI_MAX_SIM_NUM >= 4 */
                                                #endif /* MMI_MAX_SIM_NUM >= 3 */
                                                #endif /* MMI_MAX_SIM_NUM >= 2 */
                                                };
        
        for (S32 i = 0; i < group_count; ++i)
        {
            srv_ucm_group_info_struct group_info;      
            srv_ucm_query_group_data(group_index_list[i], &group_info);
            
            if (group_info.call_type & call_type[sim_index])
            {
                return VFX_TRUE;
            }
        }
    }
    
    return VFX_FALSE;
}

static MMI_BOOL sim_name_is_init = MMI_FALSE;
static U8 sim_should_default = 0;
static void vapp_sim_settings_init_sim_name(void)
{
    S16 error;
    
    if (sim_name_is_init)
	{
	    return;
	}

    for (U8 i = 0; i < MMI_MAX_SIM_NUM; i++)
	{
	    mmi_sim_enum sim = mmi_frm_index_to_sim(i);
        
	    // Check if the sim is same as the prvious, if not the set the name as VFX_WSTR_EMPTY.        
	    srv_sim_ctrl_change_check_enum sim_chged_chk_result = srv_sim_ctrl_get_change_check(sim);
        srv_sim_ctrl_ua_cause_enum sim_ua_cause = srv_sim_ctrl_get_unavailable_cause(sim);
        
        MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G7_SETTING, "[mult_sim_setting][sim_name] sim change check(%d) unavailable cause(%d)", sim_chged_chk_result, sim_ua_cause);
        if (((SRV_SIM_CTRL_CHANGE_CHECK_CHANGED == sim_chged_chk_result)     // valid sim changed
            || (SRV_SIM_CTRL_UA_CAUSE_NOT_INSERTED == sim_ua_cause)          // sim not inserted
            || (SRV_SIM_CTRL_UA_CAUSE_RECOVERY == sim_ua_cause)              // sim recoveried started
            ) && (sim_should_default & (1<<i))== 0            
            || (SRV_SIM_CTRL_UA_CAUSE_UBCHV1_BLOCKED == sim_ua_cause)
        )
        {
            g_vapp_sim_name[i][0] = 0x0000;
            WriteRecord(NVRAM_EF_SIM_NAME_LID,(i + 1), (void*)g_vapp_sim_name[i], NVRAM_EF_SIM_NAME_SIZE, &error);
            sim_should_default |= (1<<i);
        }
        else
	{
        ReadRecord(NVRAM_EF_SIM_NAME_LID, (i + 1), (void*)g_vapp_sim_name[i], NVRAM_EF_SIM_NAME_SIZE, &error);		
	}
	}

    sim_name_is_init = MMI_TRUE;
}

MMI_BOOL vapp_sim_settings_get_sim_name_ext(mmi_sim_enum sim, WCHAR* buffer, U8 buffer_length)
{
    WCHAR *str_ptr;
    U32 idx = mmi_frm_sim_to_index(sim);

    if (idx > MMI_MAX_SIM_NUM || !buffer)
	{
	    return MMI_FALSE;
	}
    
    vapp_sim_settings_init_sim_name();

    memset(buffer, 0, buffer_length);

    // Not inserted, display "Empty slot"
    if (!srv_sim_ctrl_is_inserted(sim))
	{
	    return MMI_FALSE;
	}
    // Check if it is default value (0x00 initialized)
    else if (g_vapp_sim_name[idx][0] == 0x0000)
	{	
	    return MMI_FALSE;
	}
    else
    {
        str_ptr = g_vapp_sim_name[idx];
    }

    if (mmi_wcslen(str_ptr) > buffer_length)
	{
        // The input buffer length is not enough for the SIM name
	    return MMI_FALSE;
	}

    mmi_wcscpy(buffer, str_ptr);
    return MMI_TRUE;
}

MMI_BOOL vapp_sim_settings_set_sim_name_ext(mmi_sim_enum sim, const WCHAR* buffer)
{
    S16 error;

    if (mmi_wcslen(buffer) > NVRAM_EF_SIM_NAME_MAX_LEN || !buffer)
	{
	    // Input length is larger than SIM name max length
        return MMI_FALSE;
	}

    U32 idx = mmi_frm_sim_to_index(sim);
    memset(g_vapp_sim_name[idx], 0, NVRAM_EF_SIM_NAME_MAX_LEN);
    mmi_wcscpy(g_vapp_sim_name[idx], buffer);
    WriteRecord(NVRAM_EF_SIM_NAME_LID, (idx + 1), (void*)g_vapp_sim_name[idx], NVRAM_EF_SIM_NAME_SIZE, &error);
    return MMI_TRUE;
}
//For sim hot swap
#if (defined(__SIM_HOT_SWAP_SUPPORT__) || defined(__SIM_RECOVERY_ENHANCEMENT__))
static mmi_sim_enum g_sim_changed;

static void srv_set_gsm_mode(mmi_sim_enum changed_sim, VfxBool changed_status)
{
    U8 data[NVRAM_EF_SYS_CACHE_OCTET_SIZE];
    S16 error = 0;
    ReadRecord(NVRAM_EF_SYS_CACHE_OCTET_LID, NVRAM_SYS_FLIGHTMODE_STATE, &data, NVRAM_EF_SYS_CACHE_OCTET_SIZE, &error);
    
    if (changed_status)
          data[L4C_SETTING_DUAL_SIM_MODE] |= (U8)changed_sim;
    else
    {
        data[L4C_SETTING_DUAL_SIM_MODE] &= (U8)~changed_sim;
    }

    WriteRecord(NVRAM_EF_SYS_CACHE_OCTET_LID, NVRAM_SYS_FLIGHTMODE_STATE, &data, NVRAM_EF_SYS_CACHE_OCTET_SIZE, &error);
}
mmi_ret sim_hot_swap_recovery_srv_cb(mmi_event_struct* evt)
{
    const mmi_sim_enum changed_sim = g_sim_changed;

    #ifdef __MMI_DUAL_SIM_DYNAMIC_MODE__
    VappNetworkCheckingController *networkCheckingController = VFX_OBJ_GET_INSTANCE(VappNetworkCheckingController);
    if (srv_mode_switch_get_network_mode(changed_sim) == SRV_MODE_SWITCH_ON)
    {
        networkCheckingController->enableNetworkChecking(changed_sim);
    }
    
    srv_mode_switch_type_enum mode = srv_mode_switch_get_current_mode();
    if (mode == SRV_MODE_SWITCH_ALL_OFF)
    {
        networkCheckingController->showChooseSimPop();
    }    
    VFX_OBJ_CLOSE_INSTANCE(VappNetworkCheckingController);
    #endif /* __MMI_DUAL_SIM_DYNAMIC_MODE__ */
    
	return MMI_RET_OK;
}

mmi_ret vapp_sim_hot_swap_recovery_srv_proc(mmi_event_struct* evt)
{
    extern mmi_ret vapp_nw_info_signal_on_mode_switched(mmi_event_struct *evt);
    
    srv_sim_ctrl_event_detected_evt_struct *sim_evt = (srv_sim_ctrl_event_detected_evt_struct *)evt; 
    srv_mode_switch_type_enum mode = srv_mode_switch_get_current_mode();
    VfxU16 modeMask = (VfxU16)mode;
    VfxBool switch_status;
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G7_SETTING, "[mult_sim_setting] vapp_sim_hot_swap_recovery_srv_proc() cur mod(%d)", modeMask);
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G7_SETTING, "[mult_sim_setting] sim hot swap or recovery, type(%d), changed sim(%d)", sim_evt->type, sim_evt->sim);

    g_sim_changed = sim_evt->sim;
   switch(sim_evt->type)
    {
        case SRV_SIM_CTRL_EVENT_DET_INSERTED:
        case SRV_SIM_CTRL_EVENT_DET_RECOVERY_END:
            modeMask |= (VfxU16)sim_evt->sim;
            switch_status = VFX_TRUE;
            sim_name_is_init = MMI_FALSE;
            sim_should_default &= (VfxU8)(~(sim_evt->sim));
            break;
            
        case SRV_SIM_CTRL_EVENT_DET_REMOVED:
        case SRV_SIM_CTRL_EVENT_DET_RECOVERY_START:
            modeMask &= (VfxU16)(~(sim_evt->sim));
            switch_status = VFX_FALSE;
            break;

        default:
            return MMI_RET_OK;
    }
    
    // Special case:
    // If there was not sim inserted, but now sim2/3/4 is instered. sim1 rf shold be off.
    if (!srv_sim_ctrl_is_inserted(MMI_SIM1) && (modeMask & 1))
    {
        modeMask &= (VfxU16)(~MMI_SIM1);
    }

    // Special case:
    // If some sim has been off, now plug out it. the related signal should be hide.
    if (modeMask == mode)
    {
        vapp_nw_info_signal_on_mode_switched(NULL);
    }

    // Special case:
    // If there is not sim inserted, should switch on sim1 rf.
    if (srv_sim_ctrl_get_num_of_inserted() == 0)
    {
        MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G7_SETTING, "[mult_sim_setting] vapp_sim_hot_swap_recovery_srv_proc() not sim inserted");       
        modeMask = SRV_MODE_SWITCH_SIM1;
    }
    
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G7_SETTING, "[mult_sim_setting] vapp_sim_hot_swap_recovery_srv_proc() changed mod(%d)", modeMask);       
    if (srv_mode_switch_is_network_service_available())
    {
        srv_mode_switch_switch_rf_mode((srv_mode_switch_type_enum)modeMask, &sim_hot_swap_recovery_srv_cb, NULL);
    }
    else
    {
        srv_set_gsm_mode(sim_evt->sim, switch_status);
    }
    
    mmi_event_struct postInvoke;         
    MMI_FRM_INIT_EVENT(&postInvoke, 0);
    MMI_FRM_POST_EVENT(&postInvoke, verify_uart_setting, NULL);

    VfxAppLauncher::terminate(VAPP_SETTING);

    return MMI_RET_OK;
}
#endif
}

VfxWString vapp_sim_settings_get_sim_name(mmi_sim_enum sim)
{
    VfxWChar buffer[NVRAM_EF_SIM_NAME_MAX_LEN];
    if (vapp_sim_settings_get_sim_name_ext(sim, buffer, NVRAM_EF_SIM_NAME_MAX_LEN))
	{
	    return VFX_WSTR_MEM(buffer);
	}
    return VFX_WSTR_NULL;
}

VfxBool vapp_sim_settings_set_sim_name(mmi_sim_enum sim, VfxWString name)
{
    if (vapp_sim_settings_set_sim_name_ext(sim, (WCHAR*)name.getBuf()))
	{
	    return VFX_TRUE;
	}
    else
    {
        return VFX_FALSE;
    }
}

VfxWString vapp_sim_settings_get_sim_name_with_sim_id(mmi_sim_enum sim)
{
    VfxU8 simID = mmi_frm_sim_to_index(sim);
    if (simID > MMI_MAX_SIM_NUM)
	{
	    return VFX_WSTR_NULL;
	}
    VfxWString simName = vapp_sim_settings_get_sim_name(sim);
    VfxWString retString(g_vapp_sim_name_string_id[simID]);

    if (!simName.isNull())
	{
	    retString += VFX_WSTR(" ");
	    retString += VFX_WSTR_RES(STR_ID_VAPP_SETTING_SIM_NAME_LEFT_BRACKET);
		retString += simName;
		retString += VFX_WSTR_RES(STR_ID_VAPP_SETTING_SIM_NAME_RIGHT_BRACKET);
	}
    return retString;
}

VfxBool vapp_multi_sim_cell_checking_hdlr(void)
{
    VfxU32 count = 0;
    for (VfxU32 i = 0; i < MMI_MAX_SIM_NUM; i++)
	{
        if (srv_sim_ctrl_is_inserted(mmi_frm_index_to_sim(i)))
    	{
    	    count++;
    	}
	}
    // Do not displayed when no SIM or only one SIM inserted.
    return (count <= 1 ? VFX_FALSE : VFX_TRUE);
}
/***************************************************************************** 
 * Class 
 *****************************************************************************/
#ifdef __GEMINI__
/***************************************************************************** 
 * VappUARTSettingCell
 *****************************************************************************/
#pragma arm section code = "DYNAMIC_CODE_SETTING_ROCODE", rodata = "DYNAMIC_CODE_SETTING_RODATA"  
#ifdef __MMI_UART_SETTING__
VFX_IMPLEMENT_CLASS("VappUARTSettingCell", VappUARTSettingCell, VcpFormItemLauncherCell);
void VappUARTSettingCell::onInit()
{
    VcpFormItemLauncherCell::onInit();
    setAccessory(VCPFORM_NEXT_ITEM_ICON);
    m_signalTap.connect(this, &VappUARTSettingCell::onTap);
    setMainText(STR_ID_VAPP_SETTING_UART_SETTING);
    setHintText(getHint());
}
void VappUARTSettingCell::onTap(VcpFormItemCell* sender, VfxId senderId)
{
    // Entry a new page    
    VappPrimaryCardSettingContentProvider *settingPageContentProvider;
    
    VfxMainScr *mainScr = VFX_OBJ_DYNAMIC_CAST(findScreen(), VfxMainScr);
    if (mainScr)
	{
		VFX_OBJ_CREATE(settingPageContentProvider, VappPrimaryCardSettingContentProvider, mainScr);
		settingPageContentProvider->m_signalUpdate.connect(this, &VappUARTSettingCell::onContextUpdate);
		settingPageContentProvider->setHighlightItem(mmi_frm_sim_to_index(m_primaryCard));
		mainScr->pushPage(0, settingPageContentProvider);	
	}    
}

VfxWString VappUARTSettingCell::getHint()
{   
    U32 idx = mmi_frm_sim_to_index(m_primaryCard);
    return VFX_WSTR_RES(g_vapp_sim_name_string_id[idx]);
}
#endif /*__MMI_UART_SETTING__*/

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/***************************************************************************** 
 * VappPrimaryCardSettingContentProvider
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappPrimaryCardSettingContentProvider", VappPrimaryCardSettingContentProvider, VfxPage);
void VappPrimaryCardSettingContentProvider::onInit()
{
    VfxPage::onInit();
    
    VcpTitleBar *titleBar;
    VFX_OBJ_CREATE(titleBar, VcpTitleBar, this);
    #ifdef __MMI_UART_SETTING__
        m_sim_num = 0;
        memset(m_sim_exist, 0xFF, sizeof(m_sim_exist));
        for (S32 idx = 0; idx < MMI_MAX_SIM_NUM; ++idx)
        {
            if (srv_sim_ctrl_is_inserted(mmi_frm_index_to_sim(idx)))
            {
                m_sim_exist[m_sim_num] = idx;
                ++m_sim_num;
            }
        }
        titleBar->setTitle(STR_ID_VAPP_SETTING_UART_SETTING);
    #else
    titleBar->setTitle(STR_ID_VAPP_SETTING_SET_PRIMARY_CARD);
    #endif //__MMI_UART_SETTING__
    setTopBar(titleBar);
    
    VFX_OBJ_CREATE(m_listMenu, VcpListMenu, this);

    m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_SINGLE_TEXT);
	m_listMenu->setContentProvider(this);

	m_listMenu->setMenuMode(VCP_LIST_MENU_MODE_HEAD_SINGLE_CHECK_MARK, VFX_TRUE);
    
	m_listMenu->setRect(0, 0, LCD_WIDTH, LCD_HEIGHT);		 
    m_listMenu->m_signalItemTapped.connect(this, &VappPrimaryCardSettingContentProvider::onSelectItem);  
}

VfxU32 VappPrimaryCardSettingContentProvider::getCount() const
{
#ifdef __MMI_UART_SETTING__
    return m_sim_num;
#else
    return maxSimNum;
#endif // __MMI_UART_SETTING__
}
    

VfxBool VappPrimaryCardSettingContentProvider::getItemText(VfxU32 index, VcpListMenuFieldEnum fieldType, VfxWString &text, VcpListMenuTextColorEnum &color)
{
	if (index < (VfxU32)getCount())
	{
		if (fieldType == VCP_LIST_MENU_FIELD_TEXT)	
		{
		#ifdef __MMI_UART_SETTING__
            VfxU8 idx = m_sim_exist[index];
            text.loadFromRes(g_vapp_sim_name_string_id[idx]);
            #else
            text.loadFromRes(STR_GLOBAL_SIM_1 + index);
            #endif //__MMI_UART_SETTING__
            
		   color = VCP_LIST_MENU_TEXT_COLOR_NORMAL;
		   return VFX_TRUE;
		}
	}
	return VFX_FALSE;
}

void VappPrimaryCardSettingContentProvider::setHighlightItem(VfxU32 highlightItem)
{
    #ifdef __MMI_UART_SETTING__
        for (VfxU32 idx=0; idx<m_sim_num; ++idx)
        {
            if (m_sim_exist[idx] == highlightItem)
            {
                m_highlightItem = idx;
                break;
            }
        }
    #else
        m_highlightItem = highlightItem;   
    #endif
}

void VappPrimaryCardSettingContentProvider::onSelectItem(VcpListMenu *listMenu, VfxU32 selectIdx)
{
    m_selectItem = selectIdx;
    if (m_selectItem != m_highlightItem)
	{
	#ifdef __MMI_UART_SETTING__        
    	    mmi_sim_enum sim = mmi_frm_index_to_sim(m_sim_exist[m_selectItem]);
            srv_setting_set_primary_card(sim);
    	    m_signalUpdate.emit(sim);
            getMainScr()->popPage();
        #else // __MMI_UART_SETTING__
	    VfxWString popupString = 
            (m_selectItem == 0) ? VFX_WSTR_RES(STR_GLOBAL_SIM_1) : VFX_WSTR_RES(STR_GLOBAL_SIM_2);

	    VFX_OBJ_CREATE(m_popup, VcpConfirmPopup, getMainScr());
        m_popup->setText(popupString);
        m_popup->setInfoType(VCP_POPUP_TYPE_WARNING);
        m_popup->setTextAlignMode((VfxTextFrame::AlignModeEnum)1);
        m_popup->setButtonSet(VCP_CONFIRM_BUTTON_SET_USER_DEFINE);
        m_popup->setCustomButton(STR_GLOBAL_OK, STR_GLOBAL_CANCEL, VCP_POPUP_BUTTON_TYPE_WARNING, VCP_POPUP_BUTTON_TYPE_CANCEL);
        m_popup->setAutoDestory(VFX_TRUE);
        m_popup->m_signalButtonClicked.connect(this, &VappPrimaryCardSettingContentProvider::onConfirmBtnClicked);
        m_popup->show(VFX_TRUE);
        #endif //__MMI_UART_SETTING__
	}
    else
    {
        getMainScr()->popPage();
    }

}    

void VappPrimaryCardSettingContentProvider::onConfirmBtnClicked(VfxObject* sender, VfxId id)
{
    if (id == 'USR1')
	{
	    mmi_sim_enum sim = MMI_SIM_NONE;
	    switch (m_selectItem)
		{
		case 0:
			sim = MMI_SIM1;
			break;

		case 1:
			sim = MMI_SIM2;
			break;

		default:
			break;
		}
            srv_setting_set_primary_card(sim);
	    m_signalUpdate.emit(sim);
            getMainScr()->popPage();
	}
}
/***************************************************************************** 
 * VappBootupQuerySettingCell
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappBootupQuerySettingCell", VappBootupQuerySettingCell, VcpFormItemSwitchCell);
void VappBootupQuerySettingCell::onInit()
{
	VcpFormItemSwitchCell::onInit();

    setMainText(STR_ID_VAPP_SETTING_DISPLAY_BOOT_UP_MODE);
    //setSwitchStatus(m_switchState);
    setIsTappable(VFX_FALSE);
    if (srv_mode_switch_is_network_service_available())
    {
    setSwitchStatus(m_switchState);
    }
    else
    {
        setSwitchStatus(VFX_FALSE); 
        setIsDisabled(VFX_TRUE);
    }
    m_signalSwitchChangeReq.connect(this, &VappBootupQuerySettingCell::onSwitch);
    mmi_frm_cb_reg_event(EVT_ID_SRV_MODE_SWITCH_FINISH_NOTIFY, VappBootupQuerySettingCell::flightModeSwitchHdlr, this);
}
void VappBootupQuerySettingCell::onDeinit()
{
    mmi_frm_cb_dereg_event(EVT_ID_SRV_MODE_SWITCH_FINISH_NOTIFY, VappBootupQuerySettingCell::flightModeSwitchHdlr, this);
    VcpFormItemSwitchCell::onDeinit();
}

mmi_ret VappBootupQuerySettingCell::flightModeSwitchHdlr(mmi_event_struct *evt)
{
    VappBootupQuerySettingCell *cell = VFX_OBJ_DYNAMIC_CAST(((VfxObject*)evt->user_data), VappBootupQuerySettingCell);
    if (NULL == cell)
    {
        return MMI_RET_OK;
    }
    
    if (!srv_mode_switch_is_network_service_available())
    {
        cell->setSwitchStatus(VFX_FALSE);
        cell->setIsDisabled(VFX_TRUE);
    }
    else
    {
        cell->setSwitchStatus(cell->getStatus());
        cell->setIsDisabled(VFX_FALSE);        
    }
    
    return MMI_RET_OK;
}

void VappBootupQuerySettingCell::onSwitch(VcpFormItemSwitchCell* sender, VfxId senderId, VfxBool switchValue)
{
    m_switchState = switchValue;
	srv_mode_switch_enable_query_mode((switchValue == VFX_TRUE) ? MMI_TRUE : MMI_FALSE);
    setSwitchStatus(m_switchState);
}

/***************************************************************************** 
 * VappMultiSimSettingCaptionCell
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VappMultiSimSettingCaptionCell", VappMultiSimSettingCaptionCell, VcpFormItemCaption);
void VappMultiSimSettingCaptionCell::onInit()
{
    VcpFormItemCaption::onInit();
    setText(STR_ID_VAPP_SETTING_MULTI_SIM_SETTING);
}
    
/***************************************************************************** 
 * VappSimSettingCell
 *****************************************************************************/
VfxBool VappSimSettingCell::m_simIsInit[MMI_MAX_SIM_NUM] = {0};
VFX_IMPLEMENT_CLASS("VappSimSettingCell", VappSimSettingCell, VcpFormItemSwitchCell);
void VappSimSettingCell::onInit()
{
	VcpFormItemSwitchCell::onInit();

    m_sim = getSimforInit();

    setMainText(g_vapp_sim_name_string_id[mmi_frm_sim_to_index(m_sim)]);
    setIsTappable(VFX_TRUE);
    
    m_signalSwitchChangeReq.connect(this, &VappSimSettingCell::onSwitch);
    m_signalTap.connect(this, &VappSimSettingCell::onTapped);

    mmi_frm_cb_reg_event(EVT_ID_SRV_MODE_SWITCH_PRE_NOTIFY, VappSimSettingCell::onSwitchProc, getObjHandle());
    mmi_frm_cb_reg_event(EVT_ID_SRV_MODE_SWITCH_FINISH_NOTIFY, VappSimSettingCell::onSwitchProc, getObjHandle());

    if (!srv_sim_ctrl_is_inserted(m_sim))
	{
	    setIsHidden(VFX_TRUE);
	}
	else
	{
    updateCell();		
	}
}

void VappSimSettingCell::onDeinit()
{
    mmi_frm_cb_dereg_event(EVT_ID_SRV_MODE_SWITCH_PRE_NOTIFY, VappSimSettingCell::onSwitchProc, getObjHandle());
    mmi_frm_cb_dereg_event(EVT_ID_SRV_MODE_SWITCH_FINISH_NOTIFY, VappSimSettingCell::onSwitchProc, getObjHandle());

    deinitSim(m_sim);
    
    VcpFormItemSwitchCell::onDeinit();
}

void VappSimSettingCell::onSwitch(VcpFormItemSwitchCell* sender, VfxId senderId, VfxBool switchValue)
{
    if (!switchValue)
    {
        U32 sim_idx = mmi_frm_sim_to_index(m_sim);
        if (is_current_sim_in_call(sim_idx))
        {
            mmi_frm_nmgr_balloon(
                MMI_SCENARIO_ID_DEFAULT,
                MMI_EVENT_INFO_BALLOON,
                MMI_NMGR_BALLOON_TYPE_FAILURE, 
                VFX_WSTR_RES(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE_IN_CALL).getBuf());
    	    return;
        }
    }
    
	showProcessInd();

    kal_uint32 startTime = app_getcurrtime();
    MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G7_SETTING, "[vapp_dual_sim_setting.cpp] switch sim start time = %u sec", startTime);
    
    srv_mode_switch_type_enum mode = srv_mode_switch_get_current_mode();
    VfxU16 modeMask = (VfxU16)mode;
    if (switchValue)
	{
	    modeMask |= (VfxU16)m_sim;
	}
    else
    {
        modeMask &= (VfxU16)(~m_sim);
    }
	
	srv_mode_switch_switch_rf_mode((srv_mode_switch_type_enum)modeMask, VappSimSettingCell::onSwitchProc, getObjHandle());    
}

void VappSimSettingCell::onCellTap(VfxPenEvent &event)
{
    VcpFormItemSwitchCell::onCellTap(event);
    if(getIsDisabled())
    {
        return;
    }
    if(event.type == VFX_PEN_EVENT_TYPE_UP)
    {
        m_signalTap.emit(this, m_id);
    }
    else if(event.type == VFX_PEN_EVENT_TYPE_LONG_TAP)
    {
        m_signalLongTap.emit(this, m_id);
    }    
}

void VappSimSettingCell::onTapped(VcpFormItemCell* sender, VfxId id)
{
    VappSimNameSettingPage *page;
    VFX_OBJ_CREATE_EX(page, VappSimNameSettingPage, this, (m_sim));
    page->m_signalSimNameUpdate.connect(this, &VappSimSettingCell::updateCell);
    VfxMainScr *mainScr = (VfxMainScr*)findScreen();
    mainScr->pushPage(0, page);
}

void VappSimSettingCell::updateCell()
{
    // update current network mode.
    m_switchState = srv_mode_switch_get_network_mode(m_sim) == SRV_MODE_SWITCH_ON ? VFX_TRUE : VFX_FALSE;
    
    if (!srv_mode_switch_is_network_service_available())
    {
	setIsDisabled(VFX_TRUE);
        setSwitchStatus(VFX_FALSE);
    }
    else
    {
        setIsDisabled(VFX_FALSE);
    setSwitchStatus(m_switchState);
    }

    // update sim name.
    m_simName = vapp_sim_settings_get_sim_name(m_sim);
    if (!m_simName.isNull() && !m_simName.isEmpty())
	{
	    setHintText(m_simName);
	}    
    else
    {
        setHintText(VFX_WSTR_EMPTY);
    }
}

void VappSimSettingCell::checkService()
{
    #ifdef __MMI_DUAL_SIM_DYNAMIC_MODE__    
    if (srv_mode_switch_get_network_mode(m_sim) == SRV_MODE_SWITCH_ON)
    {
        VappNetworkCheckingController *networkCheckingController = VFX_OBJ_GET_INSTANCE(VappNetworkCheckingController);
        networkCheckingController->enableNetworkChecking(m_sim);
    }
    #endif /* __MMI_DUAL_SIM_DYNAMIC_MODE__ */
}
    
mmi_ret VappSimSettingCell::onSwitchProc(mmi_event_struct *evt)
{
    VappSimSettingCell *cell = (VappSimSettingCell*)VfxObject::handleToObject((VfxObjHandle)evt->user_data);
    if (NULL == cell)
    {
        return MMI_RET_OK;
    }
    switch (evt->evt_id)
	{
	case EVT_ID_SRV_MODE_SWITCH_PRE_NOTIFY:
        cell->setIsDisabled(VFX_TRUE);
		break;
    case EVT_ID_SRV_MODE_SWITCH_FINISH_NOTIFY:
        // Check if sim is inserted?
        cell->updateCell();
        cell->checkService();
            
        MMI_PRINT(MOD_MMI_COMMON_APP, MMI_COMMON_TRC_G7_SETTING, "[vapp_dual_sim_setting.cpp] switch sim end time = %u sec", app_getcurrtime());
        break;
	default:
		break;
	}
    return MMI_RET_OK;
}

mmi_sim_enum VappSimSettingCell::getSimforInit()
{
    VfxU32 i;
    for (i = 0; i < MMI_MAX_SIM_NUM; i++)
	{
	    mmi_sim_enum sim = mmi_frm_index_to_sim(i);
		if (m_simIsInit[i] == VFX_FALSE)
		{
            m_simIsInit[i] = VFX_TRUE;
		    return sim;
		}
	}
    return MMI_SIM_NONE;
}

void VappSimSettingCell::deinitSim(mmi_sim_enum sim)
{
    m_simIsInit[mmi_frm_sim_to_index(sim)] = VFX_FALSE;
}

/***************************************************************************** 
 * VappSimNameSettingPage
 *****************************************************************************/
#define VAPP_SIM_NAME_SETTING_PAGE_DONE_BUTTON   (0)
#define VAPP_SIM_NAME_SETTING_PAGE_CANCEL_BUTTON (1)
void VappSimNameSettingPage::onInit()
{
    VfxPage::onInit();
        
    VcpTitleBar *titleBar;
    VFX_OBJ_CREATE(titleBar, VcpTitleBar, this);
    titleBar->setTitle(STR_ID_VAPP_SETTING_EDIT_SIM_NAME);
    setTopBar(titleBar);

    VcpToolBar *toolBar;
    VFX_OBJ_CREATE(toolBar, VcpToolBar, this);
    toolBar->addItem(VAPP_SIM_NAME_SETTING_PAGE_DONE_BUTTON, STR_GLOBAL_DONE, VCP_IMG_TOOL_BAR_COMMON_ITEM_OK);
    toolBar->addItem(VAPP_SIM_NAME_SETTING_PAGE_CANCEL_BUTTON, STR_GLOBAL_CANCEL, VCP_IMG_TOOL_BAR_COMMON_ITEM_CANCEL);
    toolBar->m_signalButtonTap.connect(this, &VappSimNameSettingPage::onToolBarTapped);
    setBottomBar(toolBar);    

    VcpForm *form;
    VFX_OBJ_CREATE(form, VcpForm, this);
	form->setPos(0, 0);
    form->setSize(getSize());
//	form->setBgColor(VFX_COLOR_WHITE);
	form->enableVerticalScrollIndicator(VFX_TRUE);
	form->setBorderColor(VFX_COLOR_BLACK);   
    form->setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE, VFX_FRAME_ALIGNER_MODE_SIDE, VFX_FRAME_ALIGNER_MODE_SIDE, VFX_FRAME_ALIGNER_MODE_SIDE);

    VFX_OBJ_CREATE(m_textInputCell, VcpFormItemTextInput, this);
    m_textInputCell->setLabelText(STR_ID_VAPP_SETTING_SIM_NAME);
    
    VfxWString simName = vapp_sim_settings_get_sim_name(m_sim);
    if (!simName.isNull())
	{
        m_textInputCell->setText(simName);
	}

    VcpTextEditor *textEditor = m_textInputCell->getTextBox();
    textEditor->setMaxLength(NVRAM_EF_SIM_NAME_MAX_LEN - 1);
    textEditor->setIME(IMM_INPUT_TYPE_SENTENCE);
    textEditor->setLineMode(VCP_TEXT_LINE_MODE_SINGLE);
    textEditor->setAutoActivated(VFX_TRUE);

    VcpFunctionBar *funcBar;
    VFX_OBJ_CREATE(funcBar, VcpFunctionBar, this);
  //  funcBar->addItem(VAPP_SIM_NAME_SETTING_PAGE_DONE_BUTTON, VFX_WSTR_RES(STR_GLOBAL_DONE));
  //  funcBar->addItem(VAPP_SIM_NAME_SETTING_PAGE_CANCEL_BUTTON, VFX_WSTR_RES(STR_GLOBAL_CANCEL));
    funcBar->addItem((VfxResId)STR_GLOBAL_DONE, (VfxId)VAPP_SIM_NAME_SETTING_PAGE_DONE_BUTTON);
    funcBar->addItem((VfxResId)STR_GLOBAL_CANCEL, (VfxId)VAPP_SIM_NAME_SETTING_PAGE_CANCEL_BUTTON);
    funcBar->m_signalButtonTap.connect(this, &VappSimNameSettingPage::onToolBarTapped);
    textEditor->setFunctionBar(funcBar);
    
    form->addItem(m_textInputCell, 0);
    
    mmi_frm_cb_reg_event(EVT_ID_SRV_MODE_SWITCH_PRE_NOTIFY, &VappSimNameSettingPage::onFlightModeHdlr, getObjHandle());
}

void VappSimNameSettingPage::onDeinit()
{
    mmi_frm_cb_dereg_event(EVT_ID_SRV_MODE_SWITCH_PRE_NOTIFY, &VappSimNameSettingPage::onFlightModeHdlr, getObjHandle());

    VfxPage::onDeinit();
}

mmi_ret VappSimNameSettingPage::onFlightModeHdlr(mmi_event_struct* evt)
{
    VappSimNameSettingPage *page = (VappSimNameSettingPage*)VfxObject::handleToObject((VfxObjHandle)evt->user_data);
    
    if (page && EVT_ID_SRV_MODE_SWITCH_PRE_NOTIFY == evt->evt_id)
    {
        VfxMainScr* scr = page->getMainScr();
        scr->popPage();        
    }
    return MMI_RET_OK;
}

void VappSimNameSettingPage::onToolBarTapped(VfxObject *obj, VfxId id)
{
    if (id == VAPP_SIM_NAME_SETTING_PAGE_DONE_BUTTON)
	{
	    VfxWString newSimName = m_textInputCell->getText();
        VfxWString simName = vapp_sim_settings_get_sim_name(m_sim);
        if (newSimName != simName)
    	{
    	    vapp_sim_settings_set_sim_name(m_sim, newSimName);
            m_signalSimNameUpdate.emit();
    	}
	}
    getMainScr()->popPage();
}
#pragma arm section code, rodata

#endif /*__GEMINI__*/
