/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2008
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES. ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vapp_music_player_coverflow.cpp
 *
 * Project:
 * --------
 *  Venus
 *
 * Description:
 * ------------
 *  FTO Music Player 3D cover flow page
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#include "mmi_features.h"
#if defined(__COSMOS_MUSICPLY__) && defined(__COSMOS_MUSICPLY_COVER_FLOW__) && defined(__COSMOS_3D_V10__)
#ifdef __COSMOS_3D_V10__

#include "vapp_music_player.h"
#include "vapp_music_player_coverflow_3d.h"
#include "vapp_music_player_ctrlPLSV.h"
#include "vapp_music_player_ctrlmediacache.h"
#include "vapp_music_player_util.h"
#include "vapp_music_player_include.h"
#include "mmi_rp_vapp_music_player_def.h"
#include "mmi_rp_app_cosmos_global_def.h"
#include "mmi_rp_srv_venus_component_title_bar_def.h"

#include "vfx_asset_loader.h"
#include "vfx_material.h"
#include "vfx_pass.h"
#include "vfx_render_buffer.h"
#include "vfx_shader.h"
#include "vfx_compositing_mode.h"
#include "vfx_blender.h"

#define VAPP_MUSICPLY_CF_3D_REFLECT_YOFFSET 127.8f
#define VAPP_MUSICPLY_CF_3D_DISC_OPEN_DURATION 1500
#define VAPP_MUSICPLY_CF_3D_DISC_CLOSE_DURATION 1000
#define VAPP_MUSICPLY_CF_3D_DISC_MODEL_PLAYICON_IDX 3
#define VAPP_MUSICPLY_CF_3D_DISC_OPEN_PLAYICON_IDX 2


/***************************************************************************** 
 * VappMusicPlayerCoverFlow3DPage Implementation
 *****************************************************************************/

VFX_IMPLEMENT_CLASS("VappMusicPlayerCoverFlow3DPage", VappMusicPlayerCoverFlow3DPage, VappMusicPlayerPlayerBase);

void VappMusicPlayerCoverFlow3DPage::onInit()
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_ONINIT);

    VappMusicPlayerPlayerBase::onInit();

    setStatusBar(VFX_FALSE);

    m_openCDBoxIndex = -1;

    m_openCDBoxAnimTL = NULL;

    m_openCDBoxCamAnim = NULL;

    m_openCDBoxItem.item = NULL;
    m_openCDBoxItem.anim = NULL;
    m_openCDBoxItem.boxMesh = NULL;
    m_openCDBoxItem.texUniforms = NULL;
    m_openCDBoxItem.reflectUniforms = NULL;
    
	m_playingAlbumIdx = -1;
}

void VappMusicPlayerCoverFlow3DPage::onDeinit()
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_ONDEINIT);

    closeMetaParser();

    if (m_openCDBoxAnimTL)
    {
        m_openCDBoxAnimTL->stop();
    }

    VappMusicPlayerApp *app = VFX_OBJ_DYNAMIC_CAST(getApp(), VappMusicPlayerApp);
    if (app)
    {
        app->clearCoverFlowPtr(this);
    }

    VappMusicPlayerPlayerBase::onDeinit();
}

void VappMusicPlayerCoverFlow3DPage::onEnter(VfxBool isBackward)
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_ONENTER, isBackward);

    VappMusicPlayerPlayerBase::onEnter(isBackward);

    if (m_provider && m_provider->isUsingMediaCache())
    {
        if (m_provider->getCurrMediaCacheViewType() == VIEW_TYPE_NONE && m_provider->getMediaCacheState() == IDLE)
        {
            hideAllCellImages();
        }
    }

    if (isCDBoxOpened())
    {
        VfxImageSrc imgSrc;
        getOpenAlbumImage(imgSrc);

        setOpenCDBoxCover(imgSrc);
    }
    
	// To redraw content
	m_menu->updateMenu();

    if (m_openCDBoxAnimTL)
    {
        m_openCDBoxAnimTL->setFromValue(0.0f);
        m_openCDBoxAnimTL->setToValue(1.0f);
        m_openCDBoxAnimTL->setDuration(1);
        m_openCDBoxAnimTL->start();
    }

    VappMusicPlayerApp *app = VFX_OBJ_DYNAMIC_CAST(getApp(), VappMusicPlayerApp);
    if (app)
    {
        app->updateWaitIconPos(VFX_FALSE, VFX_FALSE);

        app->resetKeyInput();

        if (!isBackward)
        {
            VappMusicPlayerScreen* scr = app->getRootScreen();
            scr->setBgColor(VRT_COLOR_MAKE(255, 127, 127, 127));
        }
    }
}

void VappMusicPlayerCoverFlow3DPage::onEntered()
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_ONENTERED);
    
    VappMusicPlayerPlayerBase::onEntered();

    VappMusicPlayerApp *app = VFX_OBJ_DYNAMIC_CAST(getApp(), VappMusicPlayerApp);
    if (app)
    {
        VappMusicPlayerScreen* scr = app->getRootScreen();
        scr->setBgColor(VFX_COLOR_TRANSPARENT);
    }

    if (!m_onEnteredTimer)
    {
        VFX_OBJ_CREATE(m_onEnteredTimer, VfxTimer, this);
        m_onEnteredTimer->setDuration(10);
        m_onEnteredTimer->m_signalTick.connect(this, &VappMusicPlayerCoverFlow3DPage::onEnteredPostProc);
    }
    m_onEnteredTimer->start();
}

void VappMusicPlayerCoverFlow3DPage::onEnteredPostProc(VfxTimer *t)
{
    m_provider->setMediaCache();

    m_provider->lockFirstVisibleCell();

    VFX_OBJ_CLOSE(m_onEnteredTimer);
    m_onEnteredTimer = NULL;
}

void VappMusicPlayerCoverFlow3DPage::onExit(VfxBool isBackward)
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_ONEXIT, isBackward);
    
    VappMusicPlayerApp *app = VFX_OBJ_DYNAMIC_CAST(getApp(), VappMusicPlayerApp);
    if (app)
    {
        app->resetKeyInput();

        VappMusicPlayerScreen* scr = app->getRootScreen();
        scr->setBgColor(VRT_COLOR_MAKE(255, 127, 127, 127));
    }

    m_provider->pauseMediaCache();

    VappMusicPlayerPlayerBase::onExit(isBackward);
}

void VappMusicPlayerCoverFlow3DPage::onExited()
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_ONEXITED);
    
    VappMusicPlayerApp *app = VFX_OBJ_DYNAMIC_CAST(getApp(), VappMusicPlayerApp);
    if (app)
    {
        VappMusicPlayerScreen* scr = app->getRootScreen();
        scr->setBgColor(VFX_COLOR_RES(CLR_COSMOS_BG_MAIN));
    }

    VappMusicPlayerPlayerBase::onExited();
}

void VappMusicPlayerCoverFlow3DPage::onExited2()
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_ONEXITED2);
    
    hideAllCellImages();

    VappMusicPlayerApp *app = VFX_OBJ_DYNAMIC_CAST(getApp(), VappMusicPlayerApp);
    if (app && app->isMakingCall())
    {
        app->exitCoverFlow();
    }

    VappMusicPlayerPlayerBase::onExited2();
}

void VappMusicPlayerCoverFlow3DPage::onQueryRotateEx(VfxScreenRotateParam &param)
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_ONQUERYROTATE, param.rotateTo);

    if(param.rotateTo == VFX_SCR_ROTATE_TYPE_90 || param.rotateTo == VFX_SCR_ROTATE_TYPE_270)
    {
        m_pageOrientation = param.rotateTo;
    }
    else
    {
        param.rotateTo = m_pageOrientation;
    }
}

void VappMusicPlayerCoverFlow3DPage::initUI()
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_INITUI);

    VappMusicPlayerPlayerBase::initUI();
    
    VappMusicPlayerApp *app = VFX_OBJ_DYNAMIC_CAST(getApp(), VappMusicPlayerApp);
    VFX_ASSERT(app);

    m_provider = app->getProvider();
    m_ctrlMediaCache = m_provider->getCtrlMediaCache();
    m_playingAlbumIdx = m_provider->getActiveAlbumIndex();

    VFX_OBJ_CREATE(m_listMenuProvider, VappMusicPlayerListMenuProvider, this);
    m_listMenuProvider->setDataProvider(m_provider);
    m_listMenuProvider->setViewType(VIEW_TYPE_COVER_FLOW);

#if defined(__MMI_MAINLCD_240X320__)
    VfxS32 w = 320;
    VfxS32 h = 240;
#elif defined(__MMI_MAINLCD_240X400__)
    VfxS32 w = 400;
    VfxS32 h = 240;
#elif defined(__MMI_MAINLCD_320X480__)
    VfxS32 w = 480;
    VfxS32 h = 320;
#else
    VfxS32 w = 800;
    VfxS32 h = 480;
#endif

    setSize(w, h);

    VFX_OBJ_CREATE(m_frame, VfxFrame, this);
    m_frame->setSize(w, h);
    m_frame->setCacheMode(VFX_CACHE_MODE_PREVENT_PARENTS);
    m_frame->setAnchor(0.5f, 0.5f);
    m_frame->setPos(getSize().width/2, getSize().height/2);
    m_frame->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);

    // 3D world
    VFX_OBJ_CREATE(m_3dWorld, VfxWorld, this);
    
    VfxAssetLoader::loadSceneBegin(m_3dWorld, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_SCENE_SCENE_SCN);
    
    m_camera = VFX_OBJ_DYNAMIC_CAST(VfxAssetLoader::findObjByName(VFX_STR("Camera-node")), VfxCamera);
    m_light = VFX_OBJ_DYNAMIC_CAST(VfxAssetLoader::findObjByName(VFX_STR("Omni001-node")), VfxLight);
    m_floor = VFX_OBJ_DYNAMIC_CAST(VfxAssetLoader::findObjByName(VFX_STR("Floor-node")), VfxMesh);
	m_floor->setOpacity(0.8);
    m_bgPlane = VFX_OBJ_DYNAMIC_CAST(VfxAssetLoader::findObjByName(VFX_STR("Wall-node")), VfxMesh);
    m_bgPlane->sendToBack();
    VfxAssetLoader::loadSceneEnd();

    m_frame->setWorld(m_3dWorld);

    m_cdboxPool.init(this);

    // 3D wheel menu
    VFX_OBJ_CREATE(m_menu, VappMusicPlayerCoverFlow3DMenu, m_frame);
    m_menu->setPos(VfxPoint(0, 0));
    m_menu->setBounds(m_frame->getBounds());
    m_menu->setFocused(VFX_TRUE);
    m_menu->m_beginScrolling.connect(this, &VappMusicPlayerCoverFlow3DPage::onMenuScrollStateChanged);
    m_menu->m_endScrolling.connect(this, &VappMusicPlayerCoverFlow3DPage::onMenuScrollStateChanged);
    
    // Album title
    VFX_OBJ_CREATE(m_textAlbumTitle, VfxTextFrame, m_frame);
    m_textAlbumTitle->setAlignMode(VfxTextFrame::ALIGN_MODE_LEFT);
    m_textAlbumTitle->setAutoResized(VFX_FALSE);
    m_textAlbumTitle->setAutoFontSize(VFX_FALSE);
    m_textAlbumTitle->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
    m_textAlbumTitle->setColor(VRT_COLOR_WHITE);
    m_textAlbumTitle->setIsUnhittable(VFX_TRUE);

    // Artist name
    VFX_OBJ_CREATE(m_textAlbumArtist, VfxTextFrame, m_frame);
    m_textAlbumArtist->setAlignMode(VfxTextFrame::ALIGN_MODE_LEFT);
    m_textAlbumArtist->setAutoResized(VFX_FALSE);
    m_textAlbumArtist->setAutoFontSize(VFX_FALSE);
    m_textAlbumArtist->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
    m_textAlbumArtist->setColor(VRT_COLOR_WHITE);
    m_textAlbumArtist->setIsUnhittable(VFX_TRUE);

    if (getAlbumCount() == 0)
    {
        // Hint string for empty DB
        VFX_OBJ_CREATE(m_textEmptyDB, VfxTextFrame, m_frame);
        m_textEmptyDB->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
        m_textEmptyDB->setLineMode(VfxTextFrame::LINE_MODE_MULTI);
        m_textEmptyDB->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
        m_textEmptyDB->setAnchor(0.5f, 0.5f);
        m_textEmptyDB->setAutoResized(VFX_TRUE);
        m_textEmptyDB->setAutoFontSize(VFX_FALSE);
        m_textEmptyDB->setColor(VRT_COLOR_BLACK);
        m_textEmptyDB->setIsUnhittable(VFX_TRUE);
        m_textEmptyDB->setString(VFX_WSTR_RES(STR_ID_VAPP_MUSIC_PLAYER_NO_SONG));
    }
   

#if defined(__MMI_MAINLCD_240X320__)
    m_textAlbumTitle->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(20), VFX_FE1_1));
    m_textAlbumTitle->setSize(220, 22);
    m_textAlbumTitle->setPos(37, 189);

    m_textAlbumArtist->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(16), VFX_FE1_1));
    m_textAlbumArtist->setSize(220, 18);
    m_textAlbumArtist->setPos(37, 212);

    if (m_textEmptyDB)
    {
        m_textEmptyDB->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(20), VFX_FE1_1));
        m_textEmptyDB->setSize(280, 45);
        m_textEmptyDB->setPos(getSize().width/2, getSize().height/2 - 10);
    }

    m_btnPlayPause = createButtonEx(
                     this, 
                     VfxRect(getSize().width - 41 - 15, getSize().height - 40 - 10, 41, 40), 
                     FUNC_ID_BTN_PLAY_PAUSE, 
                     VcpStateImage(IMG_ID_VAPP_MUSICPLY_BTN_PLAY_N, IMG_ID_VAPP_MUSICPLY_BTN_PLAY_N, IMG_ID_VAPP_MUSICPLY_BTN_PLAY_D, 0),
                     VcpStateImage(IMG_ID_VAPP_MUSICPLY_BTN_BG1_N, IMG_ID_VAPP_MUSICPLY_BTN_BG1_P, IMG_ID_VAPP_MUSICPLY_BTN_BG1_N, 0));

#elif defined(__MMI_MAINLCD_240X400__)
    m_textAlbumTitle->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(20), VFX_FE1_1));
    m_textAlbumTitle->setSize(260, 22);
    m_textAlbumTitle->setPos(62, 189);

    m_textAlbumArtist->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(16), VFX_FE1_1));
    m_textAlbumArtist->setSize(260, 18);
    m_textAlbumArtist->setPos(62, 212);

    if (m_textEmptyDB)
    {
        m_textEmptyDB->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(20), VFX_FE1_1));
        m_textEmptyDB->setSize(350, 45);
        m_textEmptyDB->setPos(getSize().width/2, getSize().height/2 - 10);
    }

    m_btnPlayPause = createButtonEx(
                     this, 
                     VfxRect(getSize().width - 41 - 15, getSize().height - 40 - 10, 41, 40), 
                     FUNC_ID_BTN_PLAY_PAUSE, 
                     VcpStateImage(IMG_ID_VAPP_MUSICPLY_BTN_PLAY_N, IMG_ID_VAPP_MUSICPLY_BTN_PLAY_N, IMG_ID_VAPP_MUSICPLY_BTN_PLAY_D, 0),
                     VcpStateImage(IMG_ID_VAPP_MUSICPLY_BTN_BG1_N, IMG_ID_VAPP_MUSICPLY_BTN_BG1_P, IMG_ID_VAPP_MUSICPLY_BTN_BG1_N, 0));

#elif defined(__MMI_MAINLCD_320X480__)
    m_textAlbumTitle->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(26), VFX_FE1_1));
    m_textAlbumTitle->setSize(315, 30);
    m_textAlbumTitle->setPos(80, 256);

    m_textAlbumArtist->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(20), VFX_FE1_1));
    m_textAlbumArtist->setSize(315, 22);
    m_textAlbumArtist->setPos(80, 281);

    if (m_textEmptyDB)
    {
        m_textEmptyDB->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(26), VFX_FE1_1));
        m_textEmptyDB->setSize(400, 60);
        m_textEmptyDB->setPos(getSize().width/2, getSize().height/2);
    }

    m_btnPlayPause = createButtonEx(
                     this, 
                     VfxRect(getSize().width - 60 - 20, getSize().height - 60 - 10, 60, 60), 
                     FUNC_ID_BTN_PLAY_PAUSE, 
                     VcpStateImage(IMG_ID_VAPP_MUSICPLY_BTN_PLAY_N, IMG_ID_VAPP_MUSICPLY_BTN_PLAY_N, IMG_ID_VAPP_MUSICPLY_BTN_PLAY_D, 0),
                     VcpStateImage(IMG_ID_VAPP_MUSICPLY_BTN_BG1_N, IMG_ID_VAPP_MUSICPLY_BTN_BG1_P, IMG_ID_VAPP_MUSICPLY_BTN_BG1_N, 0));

#elif defined(__MMI_MAINLCD_480X800__)
    m_textAlbumTitle->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(40), VFX_FE1_1));
    m_textAlbumTitle->setSize(500, 55);
    m_textAlbumTitle->setPos(130, 385);

    m_textAlbumArtist->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(30), VFX_FE1_1));
    m_textAlbumArtist->setSize(500, 35);
    m_textAlbumArtist->setPos(130, 432);

    if (m_textEmptyDB)
    {
        m_textEmptyDB->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(40), VFX_FE1_1));
        m_textEmptyDB->setSize(700, 94);
        m_textEmptyDB->setPos(getSize().width/2, getSize().height/2 - 15);
    }

    m_btnPlayPause = createButtonEx(
                     this, 
                     VfxRect(getSize().width - 93 - 20, getSize().height - 93 - 10, 93, 93), 
                     FUNC_ID_BTN_PLAY_PAUSE, 
                     VcpStateImage(IMG_ID_VAPP_MUSICPLY_BTN_PLAY_N, IMG_ID_VAPP_MUSICPLY_BTN_PLAY_N, IMG_ID_VAPP_MUSICPLY_BTN_PLAY_D, 0),
                     VcpStateImage(IMG_ID_VAPP_MUSICPLY_BTN_BG1_N, IMG_ID_VAPP_MUSICPLY_BTN_BG1_P, IMG_ID_VAPP_MUSICPLY_BTN_BG1_N, 0));
#endif
    
    setSceneTreeOrder();

    m_menu->setFocus(0, 0);
    //m_menu->setFocus(1, 1000);
	//focusActiveAlbum();
}

void VappMusicPlayerCoverFlow3DPage::setSceneTreeOrder()
{
    // Bring components to front
    m_floor->bringToFront();
    m_textAlbumTitle->bringToFront();
    m_textAlbumArtist->bringToFront();
    m_btnPlayPause->bringToFront();
}

void VappMusicPlayerCoverFlow3DPage::setBgPlaneOrder()
{
    m_bgPlane->sendToBack();
}

vrt_render_dirty_type_enum VappMusicPlayerCoverFlow3DPage::fpeCallback(vrt_frame_visual_property_struct *target_frame,
                                            const vrt_frame_visual_property_struct *watch_frame,
                                            void *user_data,
                                            vrt_u32 user_data_size)
{
    return VRT_RENDER_DIRTY_TYPE_CONTENT_DIRTY;
}

VfxFrame* VappMusicPlayerCoverFlow3DPage::get3DFrame()
{
    return m_frame;
}

CDBoxItem* VappMusicPlayerCoverFlow3DPage::getCDBox(VfxU32 index, VfxBool &isNewCreated)
{   
    CDBoxItem *item = NULL;

    VfxU32 count = m_cdboxPool.size();
    for (VfxU32 idx = 0; idx < count; ++idx)
    {
        item = m_cdboxPool[idx];
        if (item->index == -1)
        {
            MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_GETCDBOX_1, index, idx, count);
            
            // found an available item
            item->index = index;
            isNewCreated = VFX_FALSE;
			
			// Play icon
			item->boxMesh->setSubMeshVisible(VAPP_MUSICPLY_CF_3D_DISC_MODEL_PLAYICON_IDX, m_playingAlbumIdx == index);
            
            item->item->setVisible(VFX_TRUE);

            return item;
        }
    }

    // no available item, create a new one
    VfxGroup *group;
    VFX_OBJ_CREATE(group, VfxGroup, m_3dWorld);

    VFX_OBJ_CREATE(item, CDBoxItem, m_menu);
    item->index = index;
    item->item = group;
	item->image = NULL;
	item->texture = NULL;
    
    VfxMesh *mesh = NULL;
    VfxMaterial *mtl = NULL;
    VfxPass *pass = NULL;
    VfxTexture *tex = NULL;
    VfxShaderVariable *var = NULL;
    VfxShaderUniforms *uniforms = NULL;
    VfxPass *reflectPass = NULL;
    VfxCompositingMode *modeConfig;
    VfxFloat Z_FACTOR = -1.0f;
    VfxFloat Z_OFFSET = -1.0f;
    
    // Load mesh start
    VfxAssetLoader::loadSceneBegin(group, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_DISC_MODEL_DISC_MODEL_SCN);
    
    group->setPickable(VFX_TRUE);

    // CDBox node
    mesh = VFX_OBJ_DYNAMIC_CAST(VfxAssetLoader::findObjByName(VFX_STR("Disc-node")), VfxMesh);
    item->discMesh = mesh;
    mesh->bringToFront();
    mesh->setPickable(VFX_TRUE);

    // config cover-mtl
    mtl = mesh->getMaterial(0);
    mtl->setPassCount(2);
    pass = mtl->getPass(0);

    // Add texture uniforms
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, pass);
    var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    pass->addShaderUniforms(uniforms);
    item->texUniforms = uniforms;

    // Bind light position
    bindLightPos(pass);

    // set cubemap texture mode to NEAREST
    var = pass->getUniformVariable(VFX_STR("uEnvSampler"));
    tex = *reinterpret_cast<VfxTexture**>(var->getDataPtr());
    tex->setFilter(VFX_FILTER_BASE_LEVEL, VFX_FILTER_NEAREST);

    var = pass->getUniformVariable(VFX_STR("uEnvSpeSampler"));
    tex = *reinterpret_cast<VfxTexture**>(var->getDataPtr());
    tex->setFilter(VFX_FILTER_BASE_LEVEL, VFX_FILTER_NEAREST);

    // Add reflection pass
    reflectPass = addReflectionPass(mtl, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_COVER_VERT_SHADER, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_COVER_FRAG_SHADER);
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uYOffset"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(VAPP_MUSICPLY_CF_3D_REFLECT_YOFFSET);
    reflectPass->addShaderUniforms(uniforms);
    
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    reflectPass->addShaderUniforms(uniforms);
    item->reflectUniforms = uniforms;

    bindLightPos(reflectPass);

    swapPass(mtl, 0, 1);

    // config holder-mtl
    mtl = mesh->getMaterial(1);
    mtl->setPassCount(2);
    pass = mtl->getPass(0);

    // Bind light position
    bindLightPos(pass);

    // Add reflection pass
    reflectPass = addReflectionPass(mtl, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_DISC_VERT_SHADER, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_DISC_FRAG_SHADER);
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uYOffset"), VFX_TYPE_ID_FLOAT, 1);
    reflectPass->addShaderUniforms(uniforms);
    VfxFloat holderOffset = 128.0f;
    var->setValue(holderOffset);

    var = uniforms->addUniformVariable(VRT_STR("uOpacity"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(1.0f);
    reflectPass->addShaderUniforms(uniforms);

    var = uniforms->addUniformVariable(VRT_STR("uColor"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(0.7f);
    reflectPass->addShaderUniforms(uniforms);

    bindLightPos(reflectPass);
    swapPass(mtl, 0, 1);

	// config box-mtl
    mtl = mesh->getMaterial(2);
    mtl->setPassCount(2);
    pass = mtl->getPass(0);

    // Bind light position
    bindLightPos(pass);

    // Disable depth buffer Writing so that the floor can be drawn
    VFX_OBJ_CREATE(modeConfig, VfxCompositingMode, pass);
    modeConfig->setDepthWriteEnable(VFX_FALSE);
    pass->setCompositingMode(modeConfig);

    // Add reflection pass
    reflectPass = addReflectionPass(mtl, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_DISC_VERT_SHADER, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_DISC_FRAG_SHADER);
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uYOffset"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(VAPP_MUSICPLY_CF_3D_REFLECT_YOFFSET);
    reflectPass->addShaderUniforms(uniforms);

    var = uniforms->addUniformVariable(VRT_STR("uOpacity"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(0.4f);
    reflectPass->addShaderUniforms(uniforms);

    var = uniforms->addUniformVariable(VRT_STR("uColor"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(0.0f);
    reflectPass->addShaderUniforms(uniforms);

    bindLightPos(reflectPass);
    swapPass(mtl, 0, 1);

    // Play icon (sub mesh 4)
    mesh->setSubMeshVisible(VAPP_MUSICPLY_CF_3D_DISC_MODEL_PLAYICON_IDX, m_playingAlbumIdx == index);

    mtl = mesh->getMaterial(3);
	mtl->setPassCount(2);
    pass = mtl->getPass(0);
    bindLightPos(pass);

    VFX_OBJ_CREATE(modeConfig, VfxCompositingMode, pass);
    modeConfig->setDepthOffset(Z_FACTOR, Z_OFFSET);
    pass->setCompositingMode(modeConfig);

    // Add reflection pass
    reflectPass = addReflectionPass(mtl, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_PLAYICON_VERT_SHADER, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_PLAYICON_FRAG_SHADER);

    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uYOffset"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(40.0f);
    reflectPass->addShaderUniforms(uniforms);

    VfxImageSrc imgSrc;
    VfxImage2D *image;
    VfxTexture2D *texture;
	
    imgSrc.setResId(V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_PLAYICON);
    VFX_OBJ_CREATE_EX(image, VfxImage2D, var, (imgSrc));
    VFX_OBJ_CREATE_EX(texture, VfxTexture2D, var, (image));
    
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    var->setValue(texture);
    reflectPass->addShaderUniforms(uniforms);

    VfxImageSrc imgSrc2;
	imgSrc2.setResId(V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_PLAYICON_ALPHA);
    VFX_OBJ_CREATE_EX(image, VfxImage2D, var, (imgSrc2));
    VFX_OBJ_CREATE_EX(texture, VfxTexture2D, var, (image));
    
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uAlphaSampler"), VFX_TYPE_ID_SAMPLER, 1);
    var->setValue(texture);
    reflectPass->addShaderUniforms(uniforms);

    bindLightPos(reflectPass);

    VFX_OBJ_CREATE(modeConfig, VfxCompositingMode, reflectPass);
    modeConfig->setDepthOffset(Z_FACTOR, Z_OFFSET);
    reflectPass->setCompositingMode(modeConfig);

    swapPass(mtl, 0, 1);
    
    item->boxMesh = mesh;

    // Load mesh complete
    VfxAssetLoader::loadSceneEnd();

    // Add to CD box pool
    m_cdboxPool.pushBack(item);

    VfxU32 count2 = m_cdboxPool.size();

    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_GETCDBOX_2, index, count2);

    isNewCreated = VFX_TRUE;
    return item;
}

void VappMusicPlayerCoverFlow3DPage::bindLightPos(VfxPass *pass)
{
    VfxShaderVariable *var = pass->getUniformVariable(VFX_STR("uLightPos"));
    
    if (var == NULL)
    {
        VfxShaderUniforms *uniforms = NULL;
        VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, pass);
        var = uniforms->addUniformVariable(VRT_STR("uLightPos"), VFX_TYPE_ID_VEC3, 1);
        var->bindValue(m_light, VFX_BINDING_WORLD_SPACE_POSITION);
        pass->addShaderUniforms(uniforms);
    }
    else
    {
        var->bindValue(m_light, VFX_BINDING_WORLD_SPACE_POSITION);
    }
}

VfxPass* VappMusicPlayerCoverFlow3DPage::addReflectionPass(VfxMaterial *mtl, VfxResId vs, VfxResId fs)
{
    VfxPass *reflectPass;
    VFX_OBJ_CREATE(reflectPass, VfxPass, mtl);
    mtl->setPass(mtl->getPassCount() - 1, reflectPass);

    VfxShaderProgram *sp;
    VFX_OBJ_CREATE_EX(sp, VfxShaderProgram, reflectPass, (vs, fs));
    reflectPass->setShaderProgram(sp);

    return reflectPass;
}

void VappMusicPlayerCoverFlow3DPage::swapPass(VfxMaterial *mtl, VfxU32 index1, VfxU32 index2)
{
    VfxU32 passCount = mtl->getPassCount();
    VFX_DEV_ASSERT(passCount > index1 && passCount > index2);
    VfxPass *pass1 = mtl->getPass(index1);
    VfxPass *pass2 = mtl->getPass(index2);
    mtl->setPass(index1, pass2);
    mtl->setPass(index2, pass1);
}

void VappMusicPlayerCoverFlow3DPage::releaseCDBox(VfxU32 index, VfxGroup *item)
{
    VfxU32 count = m_cdboxPool.size();
    for (VfxU32 idx = 0; idx < count; ++idx)
    {
        CDBoxItem *cdbox = m_cdboxPool[idx];
        if (cdbox->index == index && cdbox->item == item)
        {
            MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_RELEASECDBOX_1, index, count);

            // found releasing item
            cdbox->index = -1;
            cdbox->anim->setCustomTimingFunc(NULL, NULL, 0);
            cdbox->opacityTL->setCustomTimingFunc(NULL, NULL, 0);
            cdbox->item->setVisible(VFX_FALSE);

            return;
        }
    }

    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_RELEASECDBOX_2, index, count);
    
    VFX_DEV_ASSERT("VappMusicPlayerCoverFlow3DPage::releaseCDBox(), item not found");
}

void VappMusicPlayerCoverFlow3DPage::setCDBoxCover(VfxU32 index, VfxImageSrc &imgSrc)
{
    CDBoxItem *item = findCDBoxItem(index);

    if (item == NULL)
    {
        return;
    }

    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_SETCDBOXCOVER, index);
    
    VfxShaderUniforms *uniforms = item->texUniforms;
    VfxShaderVariable *var = uniforms->getUniformVariable(VRT_STR("uDiffuseSampler"));
    if (var == NULL)
    {
        var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    }

    VfxImage2D *image;
    VFX_OBJ_CREATE_EX(image, VfxImage2D, var, (imgSrc));
    VfxTexture2D *texture;
    VFX_OBJ_CREATE_EX(texture, VfxTexture2D, var, (image));
    var->setValue(texture);

	if (item->image)
	{
		VFX_OBJ_CLOSE(item->image);
	}
	item->image = image;

	if (item->texture)
	{
		VFX_OBJ_CLOSE(item->texture);
	}
	item->texture = texture;

    uniforms = item->reflectUniforms;
    var = uniforms->getUniformVariable(VRT_STR("uDiffuseSampler"));
    if (var == NULL)
    {
        var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    }
    
    var->setValue(texture);
}


void VappMusicPlayerCoverFlow3DPage::setOpenCDBoxCover(VfxImageSrc &imgSrc)
{
    CDBoxItem *item = &m_openCDBoxItem;

    if (item == NULL)
    {
        return;
    }

    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_SETOPENCDBOXCOVER, m_openCDBoxIndex);
    
    VfxShaderUniforms *uniforms = item->texUniforms;
    VfxShaderVariable *var = uniforms->getUniformVariable(VRT_STR("uDiffuseSampler"));
    if (var == NULL)
    {
        var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    }

    VfxImage2D *image;
    VFX_OBJ_CREATE_EX(image, VfxImage2D, var, (imgSrc));
    VfxTexture2D *texture;
    VFX_OBJ_CREATE_EX(texture, VfxTexture2D, var, (image));

    var->setValue(texture);
    
    uniforms = item->reflectUniforms;
    var = uniforms->getUniformVariable(VRT_STR("uDiffuseSampler"));
    if (var == NULL)
    {
        var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    }
    var->setValue(texture);

    uniforms = item->CDtexUniforms;
    var = uniforms->getUniformVariable(VRT_STR("uDiffuseSampler"));
    if (var == NULL)
    {
        var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    }
    
    var->setValue(texture);

    uniforms = item->CDreflectUniforms;
    var = uniforms->getUniformVariable(VRT_STR("uDiffuseSampler"));
    if (var == NULL)
    {
        var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    }
    
    var->setValue(texture);

}


CDBoxItem* VappMusicPlayerCoverFlow3DPage::findCDBoxItem(VfxU32 index)
{
    VfxU32 count = m_cdboxPool.size();
    for (VfxU32 idx = 0; idx < count; ++idx)
    {
        CDBoxItem *cdbox = m_cdboxPool[idx];
        if (cdbox->index == index)
        {
            return cdbox;
        }
    }

    return NULL;
}

VfxS32 VappMusicPlayerCoverFlow3DPage::findPickedNode(VfxNode *node)
{
    VfxU32 count = m_cdboxPool.size();
    for (VfxU32 idx = 0; idx < count; ++idx)
    {
        CDBoxItem *cdbox = m_cdboxPool[idx];
        {
            if (node == cdbox->discMesh)
            {
                MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_FINDPICKEDNODE, idx);
                return cdbox->index;
            }
        }
    }

    return -1;
}

void VappMusicPlayerCoverFlow3DPage::focusActiveAlbum()
{
	m_menu->setFocus(m_playingAlbumIdx, 100);
}

void VappMusicPlayerCoverFlow3DPage::openCDBoxSongList(VfxU32 index)
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_OPENCDBOXSONGLIST, index);

    if (m_openCDBoxItem.item)
    {
        VFX_OBJ_CLOSE(m_openCDBoxItem.item);
    }
    VFX_OBJ_CREATE(m_openCDBoxItem.item, VfxGroup, m_3dWorld);

    VfxBool ret = VFX_FALSE;
    VfxMesh *mesh = NULL;
    VfxMaterial *mtl = NULL;
    VfxPass *pass = NULL;
    VfxPass *reflectPass = NULL;
    VfxShaderVariable *var = NULL;
    VfxShaderUniforms *uniforms = NULL;
    VfxCompositingMode *modeConfig;
    VfxFloat Z_FACTOR = 1.0f;
    VfxFloat Z_OFFSET = 1.0f;
    VfxImageSrc imgSrc;
    VfxImage2D *image;
    VfxTexture *tex = NULL;
    VfxTexture2D *texture = NULL;

	m_openCDBoxIndex = VfxS32(index);

    // Start load scene
    ret = VfxAssetLoader::loadSceneBegin(m_openCDBoxItem.item, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_DISC_OPEN_DISC_OPEN_SCN);
    
    // Box Back Mesh, material: Holder, CD, Cover_CD, Box
    mesh = VFX_OBJ_DYNAMIC_CAST(VfxAssetLoader::findObjByName(VFX_STR("Box_Back-node")), VfxMesh);

    // holder material
    mtl = mesh->getMaterial(0);
    mtl->setPassCount(2);
    pass = mtl->getPass(0);
    bindLightPos(pass);

    // Add reflection pass
    reflectPass = addReflectionPass(mtl, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_DISC_VERT_SHADER, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_DISC_FRAG_SHADER);
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uYOffset"), VFX_TYPE_ID_FLOAT, 1);
    reflectPass->addShaderUniforms(uniforms);
    VfxFloat holderOffset = 140.0f;
    var->setValue(holderOffset);

    var = uniforms->addUniformVariable(VRT_STR("uOpacity"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(1.0f);
    reflectPass->addShaderUniforms(uniforms);

    var = uniforms->addUniformVariable(VRT_STR("uColor"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(0.7f);
    reflectPass->addShaderUniforms(uniforms);

    bindLightPos(reflectPass);
    swapPass(mtl, 0, 1);

    // cd disc material
    mtl = mesh->getMaterial(1);
    mtl->setPassCount(2);
    pass = mtl->getPass(0);
    bindLightPos(pass);

    // Add reflection pass
    reflectPass = addReflectionPass(mtl, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_DISC_VERT_SHADER, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_DISC_FRAG_SHADER);
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uYOffset"), VFX_TYPE_ID_FLOAT, 1);
    reflectPass->addShaderUniforms(uniforms);
    VfxFloat cdOffset = 143.0f;
    var->setValue(cdOffset);

    var = uniforms->addUniformVariable(VRT_STR("uOpacity"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(0.4f);
    reflectPass->addShaderUniforms(uniforms);

    var = uniforms->addUniformVariable(VRT_STR("uColor"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(0.55f);
    reflectPass->addShaderUniforms(uniforms);

    bindLightPos(reflectPass);
    swapPass(mtl, 0, 1);

    // cover cd material
    mtl = mesh->getMaterial(2);
    mtl->setPassCount(2);
    pass = mtl->getPass(0);

    VFX_OBJ_CREATE(modeConfig, VfxCompositingMode, pass);
    modeConfig->setDepthOffset(-1, -1);
    pass->setCompositingMode(modeConfig);

    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, pass);
    var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    pass->addShaderUniforms(uniforms);
    m_openCDBoxItem.CDtexUniforms = uniforms;

    bindLightPos(pass);

    // Add reflection pass
    reflectPass = addReflectionPass(mtl, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_COVER_VERT_SHADER, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_COVER_FRAG_SHADER);
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uYOffset"), VFX_TYPE_ID_FLOAT, 1);
    reflectPass->addShaderUniforms(uniforms);
    VfxFloat cdCoverOffset = 143.0f;
    var->setValue(cdCoverOffset);

    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);    
    var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    reflectPass->addShaderUniforms(uniforms);
    m_openCDBoxItem.CDreflectUniforms = uniforms;

    bindLightPos(reflectPass);
    swapPass(mtl, 0, 1);

    VFX_OBJ_CREATE(modeConfig, VfxCompositingMode, reflectPass);
    modeConfig->setDepthOffset(-1, -1);
    reflectPass->setCompositingMode(modeConfig);

    // box material
    mtl = mesh->getMaterial(3);
    mtl->setPassCount(2);
    pass = mtl->getPass(0);
    bindLightPos(pass);

    VFX_OBJ_CREATE(modeConfig, VfxCompositingMode, pass);
    modeConfig->setDepthWriteEnable(VFX_FALSE);
    pass->setCompositingMode(modeConfig);

    // Add reflection pass
    reflectPass = addReflectionPass(mtl, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_DISC_VERT_SHADER, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_DISC_FRAG_SHADER);
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uYOffset"), VFX_TYPE_ID_FLOAT, 1);
    reflectPass->addShaderUniforms(uniforms);
    VfxFloat boxOffset = 141.0f;
    var->setValue(boxOffset);

    var = uniforms->addUniformVariable(VRT_STR("uOpacity"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(0.4f);
    reflectPass->addShaderUniforms(uniforms);

    var = uniforms->addUniformVariable(VRT_STR("uColor"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(0.0f);
    reflectPass->addShaderUniforms(uniforms);

    bindLightPos(reflectPass);
    swapPass(mtl, 0, 1);

    // Box Front Mesh, material: Cover, List, PlayIcon, Box
    mesh = VFX_OBJ_DYNAMIC_CAST(VfxAssetLoader::findObjByName(VFX_STR("Box_Front-node")), VfxMesh);

    // cover material
    mtl = mesh->getMaterial(0);
    mtl->setPassCount(2);
    pass = mtl->getPass(0);

    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, pass);
    var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    pass->addShaderUniforms(uniforms);
    m_openCDBoxItem.texUniforms = uniforms;

    bindLightPos(pass);

    // set cubemap texture mode to NEAREST
    var = pass->getUniformVariable(VFX_STR("uEnvSampler"));
    tex = *reinterpret_cast<VfxTexture**>(var->getDataPtr());
    tex->setFilter(VFX_FILTER_BASE_LEVEL, VFX_FILTER_NEAREST);

    var = pass->getUniformVariable(VFX_STR("uEnvSpeSampler"));
    tex = *reinterpret_cast<VfxTexture**>(var->getDataPtr());
    tex->setFilter(VFX_FILTER_BASE_LEVEL, VFX_FILTER_NEAREST);

    // Add reflection pass
    reflectPass = addReflectionPass(mtl, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_COVER_VERT_SHADER, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_COVER_FRAG_SHADER);
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uYOffset"), VFX_TYPE_ID_FLOAT, 1);
    reflectPass->addShaderUniforms(uniforms);
    VfxFloat coverOffset = 127.0f;
    var->setValue(coverOffset);

    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);    
    var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    reflectPass->addShaderUniforms(uniforms);
    m_openCDBoxItem.reflectUniforms = uniforms;

    bindLightPos(reflectPass);
    swapPass(mtl, 0, 1);

    // list material
    mtl = mesh->getMaterial(1);
    mtl->setPassCount(2);
    pass = mtl->getPass(0);
    bindLightPos(pass);

    VFX_OBJ_CREATE(modeConfig, VfxCompositingMode, pass);
    modeConfig->setDepthOffset(Z_FACTOR, Z_OFFSET);
    pass->setCompositingMode(modeConfig);

    var = pass->getUniformVariable(VFX_STR("uDiffuseSampler"));
    if (var == NULL)
    {
        VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, pass);
        var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
        pass->addShaderUniforms(uniforms);
    }

	// create song list panel as texture frame
    m_provider->pauseMediaCache();
    VFX_OBJ_CREATE_EX(m_panelSongList, VappMusicPlayerCoverFlow3DSongListPanel, this, (index));
    m_frame->setPropertyEffectCallback(m_panelSongList,
                                    fpeCallback,
                                    NULL,
                                    0,
                                    VRT_FPE_TRIGGER_TYPE_CONTENT_DIRTY);
    m_panelSongList->setListMenuDisabled(VFX_TRUE);

    VFX_OBJ_CREATE_EX(m_textureList, VfxTextureFrame, var, (m_panelSongList));
    m_textureList->setFilter(VFX_FILTER_BASE_LEVEL, VFX_FILTER_LINEAR);
    var->setValue(m_textureList);

    // Add reflection pass
    reflectPass = addReflectionPass(mtl, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_LIST_VERT_SHADER, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_LIST_FRAG_SHADER);
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uYOffset"), VFX_TYPE_ID_FLOAT, 1);
    reflectPass->addShaderUniforms(uniforms);
    VfxFloat listOffset = 126.0f;
    var->setValue(listOffset);
    
    var = reflectPass->getUniformVariable(VFX_STR("uDiffuseSampler"));
    if (var == NULL)
    {
        VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
        var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
        reflectPass->addShaderUniforms(uniforms);
    }
    var->setValue(m_textureList);

    bindLightPos(reflectPass);
    swapPass(mtl, 0, 1);

    // Play Icon
    mesh->setSubMeshVisible(VAPP_MUSICPLY_CF_3D_DISC_OPEN_PLAYICON_IDX, m_playingAlbumIdx == index);

    mtl = mesh->getMaterial(VAPP_MUSICPLY_CF_3D_DISC_OPEN_PLAYICON_IDX);
	mtl->setPassCount(2);
    pass = mtl->getPass(0);
    bindLightPos(pass);

    VFX_OBJ_CREATE(modeConfig, VfxCompositingMode, pass);
    modeConfig->setDepthOffset(Z_FACTOR, Z_OFFSET);
    pass->setCompositingMode(modeConfig);

    // Add reflection pass
    reflectPass = addReflectionPass(mtl, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_PLAYICON_VERT_SHADER, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_PLAYICON_FRAG_SHADER);

    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uYOffset"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(40.0f);
    reflectPass->addShaderUniforms(uniforms);

    VfxImageSrc imgSrc2;
	
    imgSrc2.setResId(V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_PLAYICON);
    VFX_OBJ_CREATE_EX(image, VfxImage2D, var, (imgSrc2));
    VFX_OBJ_CREATE_EX(texture, VfxTexture2D, var, (image));
    
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uDiffuseSampler"), VFX_TYPE_ID_SAMPLER, 1);
    var->setValue(texture);
    reflectPass->addShaderUniforms(uniforms);

    VfxImageSrc imgSrc3;
	imgSrc3.setResId(V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_PLAYICON_ALPHA);
    VFX_OBJ_CREATE_EX(image, VfxImage2D, var, (imgSrc3));
    VFX_OBJ_CREATE_EX(texture, VfxTexture2D, var, (image));
    
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uAlphaSampler"), VFX_TYPE_ID_SAMPLER, 1);
    var->setValue(texture);
    reflectPass->addShaderUniforms(uniforms);

    bindLightPos(reflectPass);

    VFX_OBJ_CREATE(modeConfig, VfxCompositingMode, reflectPass);
    modeConfig->setDepthOffset(Z_FACTOR, Z_OFFSET);
    reflectPass->setCompositingMode(modeConfig);

    swapPass(mtl, 0, 1);
    
    m_openCDBoxItem.boxMesh = mesh;

    // box material
    mtl = mesh->getMaterial(3);
    mtl->setPassCount(2);
    pass = mtl->getPass(0);
    bindLightPos(pass);

    VFX_OBJ_CREATE(modeConfig, VfxCompositingMode, pass);
    modeConfig->setDepthWriteEnable(VFX_FALSE);
    pass->setCompositingMode(modeConfig);

    // Add reflection pass
    reflectPass = addReflectionPass(mtl, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_DISC_VERT_SHADER, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_REFLECTION_DISC_FRAG_SHADER);
    VFX_OBJ_CREATE(uniforms, VfxShaderUniforms, reflectPass);
    var = uniforms->addUniformVariable(VRT_STR("uYOffset"), VFX_TYPE_ID_FLOAT, 1);
    reflectPass->addShaderUniforms(uniforms);
    boxOffset = VAPP_MUSICPLY_CF_3D_REFLECT_YOFFSET;
    var->setValue(boxOffset);

    var = uniforms->addUniformVariable(VRT_STR("uOpacity"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(0.4f);
    reflectPass->addShaderUniforms(uniforms);

    var = uniforms->addUniformVariable(VRT_STR("uColor"), VFX_TYPE_ID_FLOAT, 1);
    var->setValue(0.0f);
    reflectPass->addShaderUniforms(uniforms);

    VFX_OBJ_CREATE(modeConfig, VfxCompositingMode, reflectPass);
    modeConfig->setDepthWriteEnable(VFX_FALSE);
    reflectPass->setCompositingMode(modeConfig);

    bindLightPos(reflectPass);
    swapPass(mtl, 0, 1);
    
    // Load mesh complete
    VfxAssetLoader::loadSceneEnd();

    getOpenAlbumImage(imgSrc);
    setOpenCDBoxCover(imgSrc);

    // anim & timeline will be closed with group
    if (!m_openCDBoxAnimTL)
    {
        VFX_OBJ_CREATE(m_openCDBoxAnimTL, VfxFloatTimeline, m_3dWorld);
        m_openCDBoxAnimTL->setTargetPropertyId(VRT_CUSTOM_PROPERTY_ID_VAR_FLOAT);
        m_openCDBoxAnimTL->setTarget(m_3dWorld);
        m_openCDBoxAnimTL->setFromValue(0.0f);
        m_openCDBoxAnimTL->setToValue(1.0f);
        m_openCDBoxAnimTL->m_signalStopped.connect(this, &VappMusicPlayerCoverFlow3DPage::onCDBoxOpenAnimTLStopped);
    }

    m_openCDBoxAnimTL->setDuration(VAPP_MUSICPLY_CF_3D_DISC_OPEN_DURATION);

    // Load camera animation
    if (m_openCDBoxCamAnim)
    {
        VFX_OBJ_CLOSE(m_openCDBoxCamAnim);
    }
    VFX_OBJ_CREATE(m_openCDBoxCamAnim, VfxAnimation, m_3dWorld);
    ret = VfxAssetLoader::loadAnimation(m_openCDBoxCamAnim, m_3dWorld, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_SCENE_SCENE_ANI);
    m_openCDBoxCamAnim->setTimelineTime(m_openCDBoxAnimTL, 1.0f, 0.0f, VFX_TIMELINE_TIME_WRAP_TYPE_NONE);
    
    // Load disc open aniamtion
    VFX_OBJ_CREATE(m_openCDBoxItem.anim, VfxAnimation, m_openCDBoxItem.item);
    ret = VfxAssetLoader::loadAnimation(m_openCDBoxItem.anim, m_openCDBoxItem.item, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_DISC_OPEN_DISC_OPEN_ANI);
    m_openCDBoxItem.anim->setTimelineTime(m_openCDBoxAnimTL, 1.0f, 0.0f, VFX_TIMELINE_TIME_WRAP_TYPE_NONE);
    
    m_openCDBoxAnimTL->start();


    // hide original cdbox in wheel menu
    CDBoxItem *cdbox1 = findCDBoxItem(index);
    if (cdbox1)
    {
        cdbox1->item->setVisible(VFX_FALSE);
    }

    m_openCDBoxItem.item->bringToFront();
    m_panelSongList->bringToFront();
    setSceneTreeOrder();

    m_textAlbumTitle->setHidden(VFX_TRUE);
    m_textAlbumArtist->setHidden(VFX_TRUE);
}

void VappMusicPlayerCoverFlow3DPage::closeCDBoxSongList()
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_CLOSECDBOXSONGLIST);

    m_panelSongList->setHints(VFX_FRAME_HINTS_TEXTURE_HIDDEN);
    m_panelSongList->setListMenuDisabled(VFX_TRUE);

    m_openCDBoxAnimTL->setFromValue(1.0f);
    m_openCDBoxAnimTL->setToValue(0.0f);
    m_openCDBoxAnimTL->setDuration(VAPP_MUSICPLY_CF_3D_DISC_CLOSE_DURATION);
    m_openCDBoxAnimTL->start();

    m_textureList->setFilter(VFX_FILTER_BASE_LEVEL, VFX_FILTER_LINEAR);
}

void VappMusicPlayerCoverFlow3DPage::doCloseCDBoxSongList()
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_DOCLOSECDBOXSONGLIST);

    if (m_openCDBoxItem.item)
    {
        VFX_OBJ_CLOSE(m_openCDBoxItem.item);
        m_openCDBoxItem.anim = NULL;
    }

    m_openCDBoxItem.boxMesh = NULL;

    // show original cdbox in wheel menu
    CDBoxItem *cdbox = findCDBoxItem(m_openCDBoxIndex);
    if (cdbox)
    {
        MediaCacheTask task = m_ctrlMediaCache->getTask(m_openCDBoxIndex);
        if (task.m_state == MediaCacheTask::NONE_PROC || task.m_state == MediaCacheTask::PROCESSING || task.m_state == MediaCacheTask::DUMP)
        {
            // temporary use large image during media cache decoding
            VfxImageSrc imgSrc;
            getOpenAlbumImage(imgSrc);
            setCDBoxCover(m_openCDBoxIndex, imgSrc);
        }

        cdbox->item->setVisible(VFX_TRUE);
    }

    m_openCDBoxIndex = -1;

    m_menu->setFocused(VFX_TRUE);
    
    m_openCDBoxAnimTL = NULL;

    m_textAlbumTitle->setHidden(VFX_FALSE);
    m_textAlbumArtist->setHidden(VFX_FALSE);

    if (m_panelSongList)
    {
        VFX_OBJ_CLOSE(m_panelSongList);
        m_panelSongList = NULL;
        m_frame->setPropertyEffectCallback(this,
                                        NULL,
                                        NULL,
                                        0,
                                        VRT_FPE_TRIGGER_TYPE_CONTENT_DIRTY);
    }
    
}

void VappMusicPlayerCoverFlow3DPage::onCDBoxOpenAnimTLStopped(VfxBaseTimeline *timeline, VfxBool stopped)
{
    if (m_openCDBoxAnimTL == NULL)
    {
        return;
    }
    
    VfxFloat toValue = m_openCDBoxAnimTL->getToValue();

    VappMusicPlayerApp *app = VFX_OBJ_DYNAMIC_CAST(getApp(), VappMusicPlayerApp);

    if (toValue == 1.0f) // Opening complete
    {
        MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_ONCDBOXOPENANIMSTOPPED);
        
        m_panelSongList->setListMenuDisabled(VFX_FALSE);

        // show the original list menu
        m_panelSongList->setHints(VFX_FRAME_HINTS_TEXTURE);

        m_textureList->setFilter(VFX_FILTER_BASE_LEVEL, VFX_FILTER_NEAREST);
    }
    else // Closing complete
    {
        MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_ONCDBOXCLOSEANIMSTOPPED);
        
        // close animation
        doCloseCDBoxSongList();

        // trigger setViewType
        if (app)
        {
		    app->onKeyBack();
        }

        m_provider->setMediaCache();
        m_provider->getNextItemImage();
    }

    if (app)
    {
        app->resetPenInput();
    }
}

VfxBool VappMusicPlayerCoverFlow3DPage::isCDBoxOpened()
{
    return m_panelSongList != NULL;
}

VfxBool VappMusicPlayerCoverFlow3DPage::isCDBoxOpeningAnimation()
{
    return m_openCDBoxAnimTL && m_openCDBoxAnimTL->getIsEnabled();
}

VfxBool VappMusicPlayerCoverFlow3DPage::onKeyInput(VfxKeyEvent &event)
{
	if (event.type == VFX_KEY_EVENT_TYPE_DOWN && event.keyCode == VFX_KEY_CODE_BACK)
    {
        MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_ONKEYINPUT);
        
        VappMusicPlayerApp *app = VFX_OBJ_DYNAMIC_CAST(getApp(), VappMusicPlayerApp);
        if (app && !isCDBoxOpeningAnimation())
        {
            app->onScreenRotate(VFX_SCR_ROTATE_TYPE_NORMAL);

            return VFX_TRUE;
        }
    }

    return VappMusicPlayerPlayerBase::onKeyInput(event);
}

VfxBool VappMusicPlayerCoverFlow3DPage::onPenInput(VfxPenEvent &event)
{
    return VFX_FALSE;
}

void VappMusicPlayerCoverFlow3DPage::setAlbumCover(VfxImageBuffer &imgBuf)
{
}

VfxU32 VappMusicPlayerCoverFlow3DPage::getAlbumCount()
{
    return m_listMenuProvider->getCount();
}

void VappMusicPlayerCoverFlow3DPage::getAlbumInfo(VfxU32 idx, VfxWString& artist, VfxWString& album)
{
    VcpListMenuTextColorEnum color;
    m_provider->getItemText(idx, VCP_LIST_MENU_FIELD_TEXT, album, color);
    m_provider->getItemText(idx, VCP_LIST_MENU_FIELD_SUB_TEXT1, artist, color);
}

VfxU32 VappMusicPlayerCoverFlow3DPage::getAlbumID(VfxU32 idx)
{
    return m_listMenuProvider->getID(idx);
}

void VappMusicPlayerCoverFlow3DPage::getAlbumImage(VfxU32 idx, VfxImageSrc &imgSrc)
{
    m_listMenuProvider->getItemImage(idx, VCP_LIST_MENU_FIELD_ICON, imgSrc);
}

void VappMusicPlayerCoverFlow3DPage::getOpenAlbumImage(VfxImageSrc &imgSrc)
{
    initMetaParser();
    
    VfxImageBuffer imgBuf;
    imgBuf.ptr = NULL;
    imgBuf.width = 0;
    imgBuf.height = 0;

    VfxU32 ID = m_panelSongList->getFirstSongId();

    VfxBool useDefault = VFX_TRUE;
    
    if((ID > 0) && getAlbumCoverBySongId(ID, m_panelSongList->getSize().width, m_panelSongList->getSize().height, imgBuf, VFX_FALSE))
    {
        useDefault = VFX_FALSE;
    }    

    if (useDefault)
    {
        imgSrc.setResId(IMG_ID_VAPP_MUSICPLY_DEFAULT_COVER_NO_TEXT);
    }
    else
    {
        imgSrc.setImageBuffer(imgBuf);
    }
}

void VappMusicPlayerCoverFlow3DPage::updateCellImage(VfxU32 index, VfxImageBuffer imgBuf)
{
    // update album cover
    VfxImageSrc imgSrc(imgBuf);
    setCDBoxCover(index, imgSrc);
}


void VappMusicPlayerCoverFlow3DPage::hideAllCellImages(VfxBool isAnim)
{
    // reset to default album cover

	VfxU32 count = m_cdboxPool.size();
    
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_HIDEALLCELLIMAGES, isAnim);

	for (VfxU32 idx = 0; idx < count; ++idx)
	{
        VfxImageSrc imgSrc;
        imgSrc.setResId(IMG_ID_VAPP_MUSICPLY_DEFAULT_COVER_NO_TEXT);

        CDBoxItem *cdbox = m_cdboxPool[idx];		
		setCDBoxCover(cdbox->index, imgSrc);
	}
}

void VappMusicPlayerCoverFlow3DPage::hideAlbumDetailPanel(VfxBool anim)
{
    // hide song list panel
    doCloseCDBoxSongList();
}

void VappMusicPlayerCoverFlow3DPage::updateAlbumInfo(VfxU32 index)
{
    VfxWString album, artist;
    getAlbumInfo(index, artist, album);

    m_textAlbumTitle->setString(album);
    m_textAlbumArtist->setString(artist);
}

void VappMusicPlayerCoverFlow3DPage::updateAlbumPanelItem(VfxS32 index)
{
    if (m_panelSongList)
    {
        m_panelSongList->updateListMenu(index);
    }
}

void VappMusicPlayerCoverFlow3DPage::onPlaybackStateChange(PlaybackStateEnum state)
{
    VappMusicPlayerPlayerBase::onPlaybackStateChange(state);

    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_ONPLAYBACKSTATECHANGE, state);
    
    if (m_panelSongList && state == PB_STATE_PLAY)
    {
        m_panelSongList->updateListMenu();
    }

    // show/hide play icon
    if (state == PB_STATE_NONE || state == PB_STATE_CLOSE)
    {
        if (m_playingAlbumIdx != -1)    
        {
            showHideAlbumPlayIcon(m_playingAlbumIdx, VFX_FALSE);
        }

        m_playingAlbumIdx = -1;
    }
    else
    {
        VfxS32 newPlayingIndex = m_provider->getActiveAlbumIndex();

        if (newPlayingIndex != -1 && newPlayingIndex != m_playingAlbumIdx)
        {
            showHideAlbumPlayIcon(m_playingAlbumIdx, VFX_FALSE);

            showHideAlbumPlayIcon(newPlayingIndex, VFX_TRUE);

            m_playingAlbumIdx = newPlayingIndex;
        }
    }
    
}

void VappMusicPlayerCoverFlow3DPage::showHideAlbumPlayIcon(VfxS32 index, VfxBool isShow)
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_SHOWHIDEPLAYICON, index, isShow);

	CDBoxItem *cdbox = findCDBoxItem(index);
    if (cdbox)
    {
        cdbox->boxMesh->setSubMeshVisible(VAPP_MUSICPLY_CF_3D_DISC_MODEL_PLAYICON_IDX, isShow);
    }

    if (m_openCDBoxItem.boxMesh && m_openCDBoxIndex == index)
    {
        m_openCDBoxItem.boxMesh->setSubMeshVisible(VAPP_MUSICPLY_CF_3D_DISC_OPEN_PLAYICON_IDX, isShow);
    }
}

void VappMusicPlayerCoverFlow3DPage::onMenuScrollStateChanged(VfxObject* obj)
{
    VappMusicPlayerCoverFlow3DMenu *menu = VFX_OBJ_DYNAMIC_CAST(obj, VappMusicPlayerCoverFlow3DMenu);
    if (menu)
    {
        if (m_ctrlPlayback && m_ctrlPlayback->getPlayState() == PB_STATE_SEEKING)
        {
            return;
        }
        
        m_btnPlayPause->setIsUnhittable(menu->isScrolling());
    }
}


/***************************************************************************** 
 * Class VappMusicPlayerCoverFlow3DMenuCache
 *****************************************************************************/

VappMusicPlayerCoverFlow3DMenuCache::VappMusicPlayerCoverFlow3DMenuCache() : 
    m_itemCount(0), 
    m_itemTotalCount(VCP_MENUCACHE_ADDITION),
    m_items(NULL),
    m_menu(NULL)
{
}

VappMusicPlayerCoverFlow3DMenuCache::~VappMusicPlayerCoverFlow3DMenuCache()
{
    VFX_DEV_ASSERT(m_itemTotalCount == 0);
    VFX_DEV_ASSERT(m_itemCount == 0);
    VFX_DEV_ASSERT(m_items == NULL);
}

void VappMusicPlayerCoverFlow3DMenuCache::init(VappMusicPlayerCoverFlow3DMenu* parent)
{
    VFX_DEV_ASSERT(m_menu == NULL);
    m_menu = parent;
   
    VFX_ALLOC_MEM(m_items, m_itemTotalCount * sizeof(ItemPtr), m_menu);
    memset(m_items, 0, sizeof(ItemPtr) * m_itemTotalCount);
}

void VappMusicPlayerCoverFlow3DMenuCache::deinit()
{
    VFX_DEV_ASSERT(m_itemCount == 0);
    VFX_DEV_ASSERT(m_menu);

    VFX_FREE_MEM(m_items);

    m_menu = NULL;
    m_items = NULL;
    m_itemCount = 0;
    m_itemTotalCount = 0;
}

VfxBool VappMusicPlayerCoverFlow3DMenuCache::isInCache(Key p)
{
    if (!p.isValid())
        return VFX_FALSE;

    VfxS32 idx = bisect_left(p);

    if (idx < m_itemCount && m_items[idx]->key == p)
        return VFX_TRUE;
    
    return VFX_FALSE;
}

VfxGroup* VappMusicPlayerCoverFlow3DMenuCache::getItem(Key p)
{
    if (!p.isValid())
        return NULL;
    
    VfxS32 idx = bisect_left(p);
    if (idx >= m_itemCount) // cannot find
        return NULL;

    if (m_items[idx]->key != p)
        return NULL;

    return m_items[idx]->ptr.get();
}

void VappMusicPlayerCoverFlow3DMenuCache::setItem(Key p, VfxGroup* group)
{
    if (!p.isValid())
    {
        VFX_ASSERT(0);
        return;
    }
    
    VfxS32 idx = bisect_left(p);

    if (idx < m_itemCount && m_items[idx]->key == p)
    {
        m_items[idx]->ptr = group;
    }
    else
    {
        VFX_DEV_ASSERT(idx <= m_itemCount);

        if (m_itemCount == m_itemTotalCount)
        {
            // the space is not enough
            ItemPtr *new_items;

            m_itemTotalCount += VCP_MENUCACHE_ADDITION;

            //VFX_NEW_ARRAY(new_items, ItemPtr, m_itemTotalCount);
            VFX_ALLOC_MEM(new_items, m_itemTotalCount * sizeof(ItemPtr), m_menu);

            memset(new_items, 0, sizeof(ItemPtr) * m_itemTotalCount);
            memcpy(new_items, m_items, sizeof(ItemPtr) * m_itemCount);
            
            VFX_FREE_MEM(m_items);

            m_items = new_items;
        }
    
        VFX_DEV_ASSERT(m_itemTotalCount > m_itemCount);

        m_itemCount++;
        for (VfxS32 i = m_itemCount - 1; i > idx; i--)
        {
            m_items[i] = m_items[i - 1];
        }
        VFX_ALLOC_NEW(m_items[idx], Item, m_menu);
        m_items[idx]->key = p;
        m_items[idx]->ptr = group;
    }
}


void VappMusicPlayerCoverFlow3DMenuCache::closeItem(Key p)
{
    VFX_DEV_ASSERT(m_menu);
    VfxGroup* group = getItem(p);
    removeItem(p);
    if (group)
    {
        m_menu->closeCell(p.cell, p.subCell, group);
    }
}

void VappMusicPlayerCoverFlow3DMenuCache::removeItem(Key p)
{
    if (!p.isValid())
    {
        VFX_DEV_ASSERT(0);
        return;
    }

    if (m_itemCount == 0)
    {
        // nothing can remove
        return;
    }

    VfxS32 idx = bisect_left(p);

    if (idx >= m_itemCount || m_items[idx]->key != p)
    {
        // Cannot found item
        return;
    }

    if (idx < m_itemCount && m_items[idx]->key == p)
    {
        VFX_DELETE(m_items[idx]);
        for (VfxS32 i = idx; i < m_itemCount - 1; i++)
        {
            m_items[i] = m_items[i + 1];
        }
        m_itemCount--;
    }

    // we can reduce space
    if (m_itemTotalCount - m_itemCount >= 2 * VCP_MENUCACHE_ADDITION)
    {
        // the space is not enough

        VfxS32 newTotal = VFX_MAX(m_itemCount, VCP_MENUCACHE_ADDITION);

        newTotal = VCP_MENUCACHE_ADDITION * ((newTotal + VCP_MENUCACHE_ADDITION - 1) / VCP_MENUCACHE_ADDITION);

        ItemPtr *new_items;
        //VFX_NEW_ARRAY(new_items, ItemPtr, newTotal);
        VFX_ALLOC_MEM(new_items, newTotal * sizeof(ItemPtr), m_menu);
        memset(new_items, 0, sizeof(ItemPtr) * newTotal);

        memcpy(new_items, m_items, sizeof(ItemPtr) * m_itemCount);
        m_itemTotalCount = newTotal;
        //VFX_DELETE_ARRAY(m_items);
        VFX_FREE_MEM(m_items);
        m_items = new_items;

    }
}

void VappMusicPlayerCoverFlow3DMenuCache::clear()
{
    for (VfxS32 i = m_itemCount - 1; i >= 0; i--)
    {
        Key p = m_items[i]->key;            

        m_menu->closeCell(p.cell, p.subCell, m_items[i]->ptr.get());
        VFX_DELETE(m_items[i]);

        m_itemCount--;
    }
    VFX_DEV_ASSERT(m_itemCount == 0);
}

VfxS32 VappMusicPlayerCoverFlow3DMenuCache::bisect_left(Key key)
{
    VfxS32 lo = 0, hi = m_itemCount, mid;
    while (lo < hi)
    {
        mid = (lo + hi) / 2;
        if (m_items[mid]->key < key) 
            lo = mid + 1;
        else
            hi = mid;
    }
    return lo;
}


/***************************************************************************** 
 * VappMusicPlayerCoverFlow3DMenu Implementation
 *****************************************************************************/

VFX_IMPLEMENT_VIRTUAL_CLASS("VappMusicPlayerCoverFlow3DMenu", VappMusicPlayerCoverFlow3DMenu, VfxControl);

void VappMusicPlayerCoverFlow3DMenu::onInit()
{
    Super::onInit();

    // save this
    m_signature = (VfxU32)getObjHandle();

    m_cache.init(this);

    VfxObject *obj = findObject(this, VFX_OBJ_CLASS_INFO(VappMusicPlayerCoverFlow3DPage));
    if (obj != NULL)
    {
        m_page = VFX_OBJ_DYNAMIC_CAST(obj, VappMusicPlayerCoverFlow3DPage);
    }
    VFX_DEV_ASSERT(m_page != NULL);

    m_signalBoundsChanged.connect(this, &Self::onViewBoundsChanged);
    registerKeyHandler(VFX_KEY_CODE_SPECIAL_ALL_ARROW);

	// Tracker is a invisible object for FPE
    VFX_OBJ_CREATE(m_tracker, VfxFrame, this);
    m_tracker->setOpacity(0);
    m_tracker->setAutoAnimate(VFX_TRUE);
    m_tracker->setFilterTiming(0.0f);

	// Create the monitor timeline
    VFX_OBJ_CREATE(m_monitorTl, VfxFloatTimeline, this);

	// Create the timer to detect scrolling state
    VFX_OBJ_CREATE(m_timer, VfxTimer, this);
    m_timer->m_signalTick.connect(this, &Self::onTimerTick);

    // Create the timer to detect scrolling state
    VFX_OBJ_CREATE(m_changeStateTimer, VfxTimer, this);
    //m_changeStateTimer->m_signalTick.connect(this, &Self::onEndofChangeTimer);

    // Get the sub cell count
    m_subCellCount = getSubCellCount();

    VFX_OBJ_CREATE(m_mainTimeline, VfxFloatTimeline, this);
    m_mainTimeline->setTargetPropertyId(VRT_CUSTOM_PROPERTY_ID_VAR_FLOAT);
    m_mainTimeline->setTarget(this);
    m_mainTimeline->setFromValue(0);
    m_mainTimeline->setRepeatCount(1);
    m_mainTimeline->setCustomInterpolateFunc(freezeFunc, NULL, 0);
    m_mainTimeline->setTimingFunc(VFX_TIMING_FUNC_ID_EASE_IN_EASE_OUT);

    m_totalCount = m_page->getAlbumCount();

    checkUpdate();
}

void VappMusicPlayerCoverFlow3DMenu::onDeinit()
{
    m_cache.clear();
    m_cache.deinit();
    Super::onDeinit();
}

VfxTimelineInterpolationRetEnum VappMusicPlayerCoverFlow3DMenu::interpolateFunc(
    void *output,
    const void *fromValue,
    const void *toValue,
    VfxTypeIdEnum typeId,
    VfxFloat t, 
    void *data,
    VfxU32 dataSize
)
{
    VappMusicPlayerCoverFlow3DMenuCellHeader* header = (VappMusicPlayerCoverFlow3DMenuCellHeader*)data;
    VfxFloat cellRelPos = header->cell - t;
    
    *((vrt_float*)output) = cellRelPos/5.0f + 0.5f;
    return VFX_TIMELINE_INTERPOLATION_RET_MONITOR;
}

VfxTimelineInterpolationRetEnum VappMusicPlayerCoverFlow3DMenu::opacityFunc(
    void *output,
    const void *fromValue,
    const void *toValue,
    VfxTypeIdEnum typeId,
    VfxFloat t, 
    void *data,
    VfxU32 dataSize
)
{    
    if (t < 0.05 || t > 1.0f)
    {
        *((vrt_float*)output) = 0;
    }
    else
    {
        *((vrt_float*)output) = 1;
    }
    
    //VappMusicPlayerCoverFlow3DMenuCellHeader* header = (VappMusicPlayerCoverFlow3DMenuCellHeader*)data;
    //VFX_TRACE(("opacityFunc: index :%d, t : %f ,output :%f\n", header->cell, t, (*((vrt_float*)output))));
    return VFX_TIMELINE_INTERPOLATION_RET_DONE;
}


VfxTimelineInterpolationRetEnum VappMusicPlayerCoverFlow3DMenu::freezeFunc(
    void *output,
    const void *fromValue,
    const void *toValue,
    VfxTypeIdEnum typeId,
    VfxFloat t, 
    void *data,
    VfxU32 dataSize
)
{    
    *((vrt_float*)output) = (*((vrt_float *)toValue)- *((vrt_float *)fromValue)) * t + *((vrt_float *)fromValue);
    //VFX_TRACE(("freezeFunc: from : %f To: %f output :%f\n", (*(vrt_float *)fromValue)), (*((vrt_float *)toValue), *((vrt_float*)output)));
    return VFX_TIMELINE_INTERPOLATION_RET_MONITOR;
}

VfxFloat normalizingTimingFuncCallback(VfxFloat t, void *data, VfxU32 dataSize)
{    
    VappMusicPlayerCoverFlow3DMenuCellHeader* header = (VappMusicPlayerCoverFlow3DMenuCellHeader*)data;
    
    VfxFloat shift = -0.25;

    VfxFloat cellRelPos = header->cell - t + shift;

    VappMusicPlayerCoverFlow3DMenu *pThis = (VappMusicPlayerCoverFlow3DMenu*)header->self;
    VfxS32 visibleCount = pThis->getVisibleCount();
    VfxS32 focusedNum = pThis->getFocusedNum();

    VfxFloat unit = 1.0f / (visibleCount - 1);

    VfxFloat output = unit * (visibleCount - focusedNum - cellRelPos);

    VfxFloat focusItem = pThis->getFocus();

    //VFX_TRACE(("normalizingTimingFuncCallback: cell: %d, focus: %f, t: %f, relPos: %f output: %f\n", header->cell, focusItem, t, cellRelPos, output));

    return output;
}

VfxS32 VappMusicPlayerCoverFlow3DMenu::getSubCellCount()
{
    return m_subCellCount;
}

VfxS32 VappMusicPlayerCoverFlow3DMenu::getCount()
{
    return m_totalCount;
    //VfxS32 count = m_page->getAlbumCount();
    //return count;
};

VfxS32 VappMusicPlayerCoverFlow3DMenu::getFocus()
{
    return m_focus;
}

VfxS32 VappMusicPlayerCoverFlow3DMenu::getVisibleCount()
{
    VfxU32 count = m_visibleItemCount;
    return count;
};

VfxS32 VappMusicPlayerCoverFlow3DMenu::getFocusedNum()
{
    VfxU32 count = m_focusedNum;
    return count;
}

VfxS32 VappMusicPlayerCoverFlow3DMenu::getBehindCount()
{
    VfxU32 count = getVisibleCount() - getFocusedNum();
    return count;
};

VfxS32 VappMusicPlayerCoverFlow3DMenu::getAheadCount()
{
    VfxU32 count = getFocusedNum() - 1;
    return count;
};

VcpMenuRegion VappMusicPlayerCoverFlow3DMenu::getRealContentRegion()
{
    return VcpMenuRegion(0, m_firstVisibleItem, 0, m_lastVisibleItem);

}

VfxGroup* VappMusicPlayerCoverFlow3DMenu::getCellIfPresent(VfxS32 cell, VfxS32 subcell)
{
    // if dummy cell, just return NULL
    return m_cache.getItem(Key(cell, subcell));
}

void VappMusicPlayerCoverFlow3DMenu::update()
{
    checkUpdate();
}

void VappMusicPlayerCoverFlow3DMenu::cleanAllCell()
{
    // Clear cache and sub cell item
    m_cache.clear();
    
    
    m_focus             = -1;
    m_firstVisibleItem  = 0;
    m_lastVisibleItem   = 0;

    checkUpdate();
}

VfxFloat VappMusicPlayerCoverFlow3DMenu::getScrollIndex()
{
    return m_tracker->getFilterTiming();
}


void VappMusicPlayerCoverFlow3DMenu::onTimerTick(VfxTimer *source)
{
    if (m_isScrolling)
    {
    	m_isScrolling = VFX_FALSE;
    	m_endScrolling.postEmit(this);
    }
    
    m_isSliding = VFX_FALSE;
    
    m_isTappedItemFocusing = VFX_FALSE;
}


static VfxFloat decelerationTimingFuncCallback(VfxFloat t, void *data, VfxU32 dataSize)
{
    vrt_float s;
    vrt_float *p = (vrt_float*)data;
    vrt_float vs;

    VFX_UNUSED(dataSize);

    // to prevent error when the timeline is ended, t = 1.0f must be mapped to 1.0f
    if (t == 1.0f)
    {
        return 1.0f;
    }

    t = t * p[3];
    
    vs = t * (p[0] + 0.5f * p[1] * t);

    if (p[2] == 0)
    {
        s = 0;
    }
    else
    {
        s = vs / p[2];
    }

	VFX_LOG(VFX_INFO3, VCP_SCROLLABLE_INFO_FRPARA_VIEW, (vrt_s32)(1000 * t / p[3]), (vrt_s32)(1000 * s), (vrt_s32)p[0], (vrt_s32)p[1], (vrt_s32)p[2], (vrt_s32)( 1000 * p[3]));        
    return s;
}


void VappMusicPlayerCoverFlow3DMenu::setScrollIndex(VfxFloat perc, VfxMsec animTime, VfxFloat velocity)
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_SETSCROLLINDEX, VfxS32(perc * 1000), animTime, VfxS32(velocity * 1000));

    VfxFloat preIndex = getScrollIndex();
	// Stop the timer fisrt
	m_timer->stop();

	// detect whether we need to fire scrolling event
	if (!m_isScrolling)
	{
		m_isScrolling = VFX_TRUE;
		m_beginScrolling.postEmit(this);
	}

	// If the timer value is -1, means use default value
    if (animTime == -1)
    {
        animTime = m_defaultAnimTime;
    }
    else if (animTime < 100)
    {
        animTime = 100;
    }
    else
    {
        animTime = vfxMax(animTime, 250);
    }

    // Set the animating index value
    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(animTime <= 0);
    VfxAutoAnimate::setTimingFunc(getMoveTimeFunction());
    VfxAutoAnimate::setDuration(animTime);
    m_tracker->setFilterTiming(perc);
    VfxAutoAnimate::commit();

    if (m_mainTimeline->getIsEnabled())
    {
        m_mainTimeline->setIsFromCurrent(VFX_TRUE);
    }
    else
    {
        m_mainTimeline->setFromValue(preIndex);
    }
    
    if (velocity == 0)
    {
        m_mainTimeline->setCustomTimingFunc(NULL,NULL,0);
    }
    else
    {
        VfxFloat p[4];
        p[0] = velocity;
        p[1] = 1200.0f / 800.0f * MAIN_LCD_DEVICE_HEIGHT;
        p[3] = -p[0] / p[1];  
        p[2] = p[0] * p[3] / 2.0f;
        m_mainTimeline->setCustomTimingFunc(decelerationTimingFuncCallback, p, sizeof(p));
    }
    m_mainTimeline->setToValue(perc);
    m_mainTimeline->setDuration(animTime);

    if (animTime <= 0)
    {
        // becasue when animTime <= 0, 
        // we can directly use vfx value to gain better performance
        updateContent(VFX_TRUE);
    }
    else
    {
        updateContent(VFX_FALSE);
    }

    m_mainTimeline->start();

    m_timer->setStartDelay(animTime);
	m_timer->start();
}

struct VcpWheelMenuMonitorData
{
    VfxS32 cstart;
    VfxS32 cend;
    VfxS32 wstart;
    VfxS32 wend;
    VfxS32 ahead;
    VfxS32 behind;
    VfxS32 count;
    void* self;
    VfxU32 signature;
};

void VappMusicPlayerCoverFlow3DMenu::emitContentWarning(void *arg)
{
    VfxObject *obj = VfxObject::handleToObject((VfxObjHandle)arg);

    if (obj)
    {
        VappMusicPlayerCoverFlow3DMenu *menu = VFX_OBJ_DYNAMIC_CAST(obj, VappMusicPlayerCoverFlow3DMenu);

        menu->updateContent(VFX_FALSE);
    }
}

void VappMusicPlayerCoverFlow3DMenu::emitContentError(void *arg)
{
    VfxObject *obj = VfxObject::handleToObject((VfxObjHandle)arg);

    if (obj)
    {
        VappMusicPlayerCoverFlow3DMenu *menu = VFX_OBJ_DYNAMIC_CAST(obj, VappMusicPlayerCoverFlow3DMenu);

        menu->updateContent(VFX_FALSE);
    }
}

VfxTimelineInterpolationRetEnum VappMusicPlayerCoverFlow3DMenu::indexMonitorFuncCallback(
    void *output,
    const void *fromValue,
    const void *toValue,
    VfxTypeIdEnum typeId,
    VfxFloat t, 
    void *data,
    VfxU32 dataSize
)
{
    vrt_float now, begin, end;
    
    VcpWheelMenuMonitorData *mdata = (VcpWheelMenuMonitorData*)data;
    VfxObject *obj = VfxObject::handleToObject((VfxObjHandle)mdata->signature);
    
    if (obj == NULL)
    {
        return VFX_TIMELINE_INTERPOLATION_RET_MONITOR;
    }

    VappMusicPlayerCoverFlow3DMenu *wheelMenu = VFX_OBJ_DYNAMIC_CAST(obj, VappMusicPlayerCoverFlow3DMenu);
    
    VFX_UNUSED(fromValue);
    VFX_UNUSED(toValue);
    VFX_UNUSED(typeId);
    VFX_UNUSED(t);
    VFX_UNUSED(data);
    VFX_UNUSED(dataSize);

    now = *((vrt_float*)output);

    begin = now - mdata->ahead;
    if (begin < 0)
        begin = 0;

    end = now + mdata->behind + 1;
    if (end > mdata->count)
        end = VfxFloat(mdata->count);

    // check if the view port is outside the warning content rect

    if (end > mdata->cend || begin < mdata->cstart)
    {
        // emit stop signal
        if (wheelMenu->m_isToSendError)
        {
            vrt_invoke_mmi_rpc(emitContentError, (void*)mdata->signature);
        }                

        wheelMenu->m_isToSendError = VRT_FALSE;
        return VFX_TIMELINE_INTERPOLATION_RET_MONITOR_FREEZE;
        //return VFX_TIMELINE_INTERPOLATION_RET_MONITOR;
    }
    else if (end > mdata->wend || begin < mdata->wstart)
    {
         // emit stop signal
        if (wheelMenu->m_isToSendWarning)
        {
            vrt_invoke_mmi_rpc(emitContentWarning, (void*)mdata->signature);
        }                

        wheelMenu->m_isToSendWarning = VRT_FALSE;
    }
    return VFX_TIMELINE_INTERPOLATION_RET_MONITOR;
}

void VappMusicPlayerCoverFlow3DMenu::updateMenu()
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_UPDATEMENU);

    m_mainTimeline->setIsFromCurrent(VFX_TRUE);
    m_mainTimeline->setDuration(1);
    m_mainTimeline->start();
}

void VappMusicPlayerCoverFlow3DMenu::updateContent(bool force)
{
    // Backup
    VfxS32 preFirstVisibleItem  = m_firstVisibleItem;
    VfxS32 preLastVisibleItem   = m_lastVisibleItem;

    VfxFloat index;
    if (force)
    {
        index = m_tracker->getFilterTiming();
    }
    else
    {   
        index = m_tracker->forceGetFilterTiming();
    }

    // change region
    m_firstVisibleItem = VfxS32(index) - getAheadCount();
    
    if (m_firstVisibleItem < 0)
    {
        m_firstVisibleItem = 0;
    }

    m_lastVisibleItem = VfxS32(index + 0.999f) + getBehindCount() + 1;
    if (m_lastVisibleItem > getCount())
    {
        m_lastVisibleItem = getCount();
    }

    onBeforeUpdateCell();

    int i = 0;
    for (i = preFirstVisibleItem; i < preLastVisibleItem; i++)
    {
        if (i >= m_firstVisibleItem && i < m_lastVisibleItem)
            continue;

        closeCell(i);
    }        

    for (i = m_firstVisibleItem; i < m_lastVisibleItem; i++)
    {
        for (VfxS32 j = 0; j < m_subCellCount; j++)
        {
            VfxGroup* item = m_cache.getItem(Key(i, j));

            // // create sub cell if need 
            if (item == NULL)
            {
                // Set for adding a new entry
                VfxBool isNewCreated = VFX_TRUE;
                Key key(i, j);

                m_cache.setItem(key, NULL);  
                item = createCell(i, j, isNewCreated);
                m_cache.setItem(key, item);

                VappMusicPlayerCoverFlow3DMenuCellHeader header = {0};
                header.cell = i;
                header.subCell = j;
                header.self = this;

                setCellHeader(key, &header, isNewCreated);
            }
           
            onUpdateCell(i, j, item);
        }
    }

    onAfterUpdateCell();

    // Start Monitor
    VcpWheelMenuMonitorData data;
    data.cstart = m_firstVisibleItem;
    data.cend = m_lastVisibleItem;
    data.wstart = m_firstVisibleItem;
    data.wend = m_lastVisibleItem;
    data.ahead = getAheadCount();
    data.behind = getBehindCount();
    data.count = getCount();

    data.self = this;
    data.signature = m_signature;

    // reset m_isToSendError , m_isToSendWarning
    m_isToSendError = VFX_TRUE;
    m_isToSendWarning = VFX_TRUE;

    // Set monitor
    m_monitorTl->setTarget(m_tracker);
    m_monitorTl->setTargetPropertyId(VRT_FRAME_PROPERTY_ID_FILTER_TIMING);
    m_monitorTl->setCustomInterpolateFunc(indexMonitorFuncCallback, &data, sizeof(VcpWheelMenuMonitorData));
    m_monitorTl->setDurationTime(0xFFFFFF);
    m_monitorTl->setRepeatDuration(0xFFFFFF);
    m_monitorTl->start();

    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_UPDATECONTENT, VfxS32(index*1000), m_focus, m_firstVisibleItem, m_lastVisibleItem);
}

void VappMusicPlayerCoverFlow3DMenu::setFocus(VfxS32 focus, VfxMsec animTime, VfxFloat velocity)
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_SETFOCUS, focus, animTime, VfxS32(velocity * 1000));

    VfxS32 preFocus = m_focus;
    
    if (focus < 0)
    {
        focus = 0;
    }

    if (focus >= getCount())
    {
        focus = getCount() - 1;
    }

    // Update property
    m_focus = focus;

    // Set the animating index value
    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(VFX_TRUE);
    m_tracker->setPos(VfxPoint(m_tracker->getPos().x, m_focus));
    VfxAutoAnimate::commit(); 

    setScrollIndex(VfxFloat(focus), animTime, velocity);
    
    if (preFocus != m_focus)
    {
        onFocusIndexChange(m_focus, preFocus);
    }
}

void VappMusicPlayerCoverFlow3DMenu::onViewBoundsChanged(VfxFrame *view, const VfxRect &old)
{
    checkUpdate();

    // Set the animating index value
    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(VFX_TRUE);
    //m_tracker->setBounds(getBounds());
    VfxAutoAnimate::commit(); 
}

void VappMusicPlayerCoverFlow3DMenu::setCellHeader(Key key, VappMusicPlayerCoverFlow3DMenuCellHeader* header, VfxBool isNewCreated)
{
    VFX_DEV_ASSERT(header);

    VfxGroup* group = m_cache.getItem(key);
    if (group == NULL)
    {
        return;
    }

    CDBoxItem *cdbox = m_page->findCDBoxItem(key.cell);
    VFX_DEV_ASSERT(cdbox);

    VFX_OBJ_CLOSE(cdbox->anim);
    VFX_OBJ_CLOSE(cdbox->opacityTL);

    VfxAnimation *anim;
    VFX_OBJ_CREATE(anim, VfxAnimation, group);
    VfxAssetLoader::loadAnimation(anim, group, V3D_GEN_ID__DEFAULT_3D_MUSICPLAYER_DISC_ANI_DISC_ANI_ANI);
    anim->setCustomTimingFunc(normalizingTimingFuncCallback, header, sizeof(*header));
    anim->setTimelineTime(m_mainTimeline, 1.0f, 0.0f, VFX_TIMELINE_TIME_WRAP_TYPE_NONE);
    cdbox->anim = anim;

    VfxFloatTimeline *opacity_tl;
    VFX_OBJ_CREATE(opacity_tl, VfxFloatTimeline, group);
    opacity_tl->setTarget(group);
    opacity_tl->setTargetPropertyId(VRT_NODE_PROPERTY_ID_OPACITY);
    opacity_tl->setDuration(2000);
    opacity_tl->setRepeatCount(VFX_TIMELINE_REPEAT_INFINITE);
    opacity_tl->setFromValue(0);
    opacity_tl->setToValue(1);
    opacity_tl->setCustomTimingFunc(normalizingTimingFuncCallback, header, sizeof(*header));
    opacity_tl->setCustomInterpolateFunc(opacityFunc, header, sizeof(*header));
    opacity_tl->setTimelineTime(m_mainTimeline, 1.0f, 0.0f, VFX_TIMELINE_TIME_WRAP_TYPE_NONE);
    cdbox->opacityTL = opacity_tl;
    
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_SETCELLHEADER, header->cell, isNewCreated);
}

void VappMusicPlayerCoverFlow3DMenu::onUpdate()
{
    Super::onUpdate();

    VfxS32 preCellCount = m_subCellCount;
    m_subCellCount = getSubCellCount();
    VFX_ASSERT(m_subCellCount >= 1);

    // check whether need to remove extra sub cell
    if (preCellCount > m_subCellCount)
    {
        for (VfxS32 i = getFirstVisibleIndex(); i < getLastVisibleIndex(); i++)
        {
            for (VfxS32 j = m_subCellCount; j < preCellCount; j++)
            {
                m_cache.closeItem(Key(i, j));
            }
        }
    }

    // adjust focus index
    if (getCount() > 0)
    {
        if (m_focus < 0)
        {
            m_focus = 0;
        }

        if (m_focus >= getCount())
        {
            m_focus = getCount() - 1;
        }

        setScrollIndex(VfxFloat(m_focus), m_defaultAnimTime);
    }
    else
    {
        m_focus             = -1;
        m_firstVisibleItem  = 0;
        m_lastVisibleItem   = 0;
    }
}

VfxBool VappMusicPlayerCoverFlow3DMenu::onKeyInput(VfxKeyEvent &event)
{
    return Super::onKeyInput(event);
}

VfxS32 VappMusicPlayerCoverFlow3DMenu::getFirstVisibleIndex()
{
    return m_firstVisibleItem;
}

VfxS32 VappMusicPlayerCoverFlow3DMenu::getLastVisibleIndex()
{
    return m_lastVisibleItem;
}

void VappMusicPlayerCoverFlow3DMenu::handleDragStart()
{   
    onDragStart();
}


void VappMusicPlayerCoverFlow3DMenu::handleDragEnd(VfxS32 xspeed, VfxS32 yspeed)
{
    onDragEnd(xspeed, yspeed);
}


void VappMusicPlayerCoverFlow3DMenu::handleDrag(VfxS32 xoffset, VfxS32 yoffset)
{
    onDrag(xoffset, yoffset);
}


VfxBool VappMusicPlayerCoverFlow3DMenu::handleTap(VfxPoint pt)
{
    return onTap(pt);
}

VfxBool VappMusicPlayerCoverFlow3DMenu::onTap(VfxPoint pt)
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONTAP_1);
    
    // calculate the incident ray start at user clicked pos in 3D world coordinate
    const VfxSize size = getSize();
    const VfxFloat x = (VfxFloat)pt.x;
    const VfxFloat y = (VfxFloat)pt.y;
    const VfxFloat w = (VfxFloat)size.width;
    const VfxFloat h = (VfxFloat)size.height;

    VfxWorld *world = m_page->get3DFrame()->getWorld();
    VfxCamera *camera = world->getActiveCamera();

    VfxVector3f pCamera;
    camera->getWorldPosition(pCamera);

    VfxVector3f pClickedPos = camera->unproject(VfxVector3f(
        (x * 2) / w - 1.0f,
        -((y * 2) / h - 1.0f),
        -1.0f));
    VfxVector3f vIncidentRay = pClickedPos - pCamera;

    VfxNode *pickNode = world->pick(pCamera, vIncidentRay);
    if (pickNode)
    {
        VfxS32 index = m_page->findPickedNode(pickNode);
        MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONTAP_2, index);
        
        if(index == m_focus)
        {
            if (m_isSliding || m_mainTimeline->getIsEnabled())
            {
                MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONTAP_3);
                m_isTappedItemFocusing = VFX_TRUE;
                setFocus(index, 250);                
            }
            else
            {
                MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONTAP_4);
                m_page->openCDBoxSongList(VfxU32(index));
            }
        }
        else if (index >= 0)
        {
            MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONTAP_5);
            m_isTappedItemFocusing = VFX_TRUE;
            setFocus(index, vfxMin(1000, vfxAbs(m_focus - index) * 250));
        }
        
        return VFX_TRUE;
    }

    return VFX_FALSE;
}

VfxBool VappMusicPlayerCoverFlow3DMenu::onPenInput(VfxPenEvent &event)
{
    if (m_page->isCDBoxOpened())
    {
        if (!m_page->isCDBoxOpeningAnimation())
        {
            // not in the animation

            if (event.type == VFX_PEN_EVENT_TYPE_UP)
            {
                MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONPENINPUT_1);
                
                // only handle pen up to close cd box
                m_page->closeCDBoxSongList();
            }
        }

        return VFX_TRUE;
    }

    if (event.type == VFX_PEN_EVENT_TYPE_DOWN)
    {
        m_maxMoveOffset = 0;
        handleDragStart();
        return VFX_TRUE;
    }
    else if (event.type == VFX_PEN_EVENT_TYPE_UP)
    {
        if (m_maxMoveOffset <= getTapThreshold())
        {
            // this is a tap            

            if (isTapTimeout(event.timeStamp))
            {
                m_prevTapTimeStamp = event.timeStamp;
                
                VfxPoint dowmpt = event.getRelDownPos(this);
                if (!handleTap(dowmpt))
                {
                    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONPENINPUT_2);

                    if (!m_isTappedItemFocusing)
                    {
                        // block tap if current previous tapped item is still focusing
                        handleDragEnd(0, 0);
                    }
                }
            }
            else
            {
                // ignore rapid tapping
                MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONPENINPUT_3);
                
                return VFX_TRUE;
            }
        }
        else if (event.timeStamp > event.downTimeStamp)
        {
            VfxPoint dowmpt = event.getRelDownPos(this);
            VfxPoint pt     = event.getRelPos(this);
            VfxS32   yv      = (1000 * (pt.y - dowmpt.y)) / (event.timeStamp - event.downTimeStamp);
            VfxS32   xv      = (1000 * (pt.x - dowmpt.x)) / (event.timeStamp - event.downTimeStamp);

            // the onTap event will disable
            m_isSliding = VFX_TRUE;

            MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONPENINPUT_4);
            handleDragEnd(xv, yv);
        }
        else
        {
            MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONPENINPUT_5);
            handleDragEnd(0, 0);            
        }
        return VFX_TRUE;
    }
    else if (event.type == VFX_PEN_EVENT_TYPE_ABORT)
    {
        MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONPENINPUT_6);
        handleDragEnd(0, 0);
        return VFX_TRUE;
    }
    else if (event.type == VFX_PEN_EVENT_TYPE_MOVE)
    {   
        VfxPoint dowmpt = event.getRelDownPos(this);
        VfxPoint prept  = event.getRelPrevPos(this);
        VfxPoint pt     = event.getRelPos(this);
        
        VfxS32 xoffset = VFX_ABS(pt.x - dowmpt.x);
        VfxS32 yoffset = VFX_ABS(pt.y - dowmpt.y);
        
        m_maxMoveOffset = yoffset > m_maxMoveOffset ? yoffset : m_maxMoveOffset;
        m_maxMoveOffset = xoffset > m_maxMoveOffset ? xoffset : m_maxMoveOffset;

        if (m_maxMoveOffset > getTapThreshold())
        {
            handleDrag(pt.x - prept.x, pt.y - prept.y);
        }

        return VFX_TRUE;
    }
    return Super::onPenInput(event);
}

void VappMusicPlayerCoverFlow3DMenu::closeCell(VfxS32 cell, VfxS32 subCell, VfxGroup* group)
{
    VFX_DEV_ASSERT(cell >= 0);
    VFX_DEV_ASSERT(subCell >= 0);

    onCloseCell(cell, subCell, group);

    VappMusicPlayerCtrlMediaCahce* mc = m_page->m_provider->getCtrlMediaCache();

    MediaCacheTask task = mc->getTask(VfxU32(cell));
    mc->freeImageBuffer(task.m_imageBuffer.ptr, VfxU32(cell));
}

void VappMusicPlayerCoverFlow3DMenu::closeCell(VfxS32 cell)
{
    VFX_DEV_ASSERT(cell >= 0);

    for (VfxS32 i = 0; i < m_subCellCount; i++)
    {
        m_cache.closeItem(Key(cell, i));
    }
}

void VappMusicPlayerCoverFlow3DMenu::resetCell(VfxS32 index)
{
    closeCell(index);
    update();
}

void VappMusicPlayerCoverFlow3DMenu::withdrawCell(VfxS32 index, VfxBool behindItemGoAhead)
{
}


VfxGroup* VappMusicPlayerCoverFlow3DMenu::pullOutSubCell(VfxS32 cell, VfxS32 subCell)
{
	return NULL;
}


void VappMusicPlayerCoverFlow3DMenu::pushInSubCell(VfxGroup *group, VfxS32 cell, VfxS32 subCell)
{
}


VfxGroup* VappMusicPlayerCoverFlow3DMenu::createCell(VfxS32 cell, VfxS32 subCell, VfxBool &isNewCreated)
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_CREATECELL, cell, m_focus);

    //m_page->getAlbumID(VfxU32(cell));

    CDBoxItem *cdbox = m_page->getCDBox(cell, isNewCreated);
    VFX_DEV_ASSERT(cdbox != NULL);

    if (cell >= m_focus)
    {
        cdbox->item->sendToBack();
        m_page->setBgPlaneOrder();
    }
    else
    {
        cdbox->item->bringToFront();
        m_page->setSceneTreeOrder();
    }

	// check if creating is sequential
    if (m_preCreatedCell != -1)
    {
        if (m_preCreatedCell > cell)
        {
            for (VfxS32 idx = m_preCreatedCell - 1; idx >= cell; --idx)
            {
				m_page->getAlbumID(VfxU32(idx));
            }
        }
        else if (m_preCreatedCell < cell)
        {
            for (VfxU32 idx = m_preCreatedCell + 1; idx <= cell; ++idx)
            {
                m_page->getAlbumID(VfxU32(idx));
            }
        }
    }
    m_preCreatedCell = cell;

    VfxImageSrc imgSrc;
    m_page->getAlbumImage(VfxU32(cell), imgSrc);
    m_page->setCDBoxCover(VfxU32(cell), imgSrc);

    return cdbox->item;
}

void VappMusicPlayerCoverFlow3DMenu::onCloseCell(VfxS32 cell, VfxS32 subCell, VfxGroup* group)
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_CLOSECELL, cell);
    
    m_page->releaseCDBox(cell, group);
}

void VappMusicPlayerCoverFlow3DMenu::onFocusIndexChange(VfxS32 focusItem, VfxS32 preFocusItem) 
{
    m_page->updateAlbumInfo(VfxU32(focusItem));
}

void VappMusicPlayerCoverFlow3DMenu::onDragEnd(VfxS32 xspeed, VfxS32 yspeed)
{
    if (xspeed == 0)
    {
        MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONDRAGEND_1);
        setFocus(VfxS32(getScrollIndex() + 0.5f), 250);
    }
    else if (vfxAbs(xspeed) <= 20)
    {
        MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONDRAGEND_2);
        setFocus(VfxS32(getScrollIndex()), 250);
    }
    else
    {
        VfxS32   s = xspeed > 0 ? 1 : -1;
        VfxFloat m = vfxMin(VFX_ABS(xspeed) / 333.3f, 5.0f);
        VfxMsec t = VfxS32(100*m);
        
        MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_MENU_ONDRAGEND_3, t);
        setFocus(VfxS32(getScrollIndex() - s * m + 0.5f), t);
    }
}

void VappMusicPlayerCoverFlow3DMenu::onDrag(VfxS32 xoffset, VfxS32 yoffset)
{
    VfxFloat sIdx = 0.0;
    if (xoffset > 0)
    {
        sIdx = vfxMax(getScrollIndex() - VfxFloat(xoffset) / 60, 0.0f);
    }
    else
    {
        sIdx = vfxMin(getScrollIndex() - VfxFloat(xoffset) / 60, VfxFloat(getCount() - 1));
    }

    setScrollIndex(sIdx, 0);
}

VfxBool VappMusicPlayerCoverFlow3DMenu::isTapTimeout(VfxMsec timeStamp)
{
    // used to block rapidly tapping
    return timeStamp - m_prevTapTimeStamp >= 200;
}

VfxBool VappMusicPlayerCoverFlow3DMenu::isScrolling()
{
    return m_isScrolling;
}

/***************************************************************************** 
 * VappMusicPlayerCoverFlow3DSongListPanel Implementation
 *****************************************************************************/

VFX_IMPLEMENT_CLASS("VappMusicPlayerCoverFlow3DSongListPanel", VappMusicPlayerCoverFlow3DSongListPanel, VfxControl);

void VappMusicPlayerCoverFlow3DSongListPanel::onInit()
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_SONGLISTPANEL_ONINIT);
    
    VfxControl::onInit();

    // Set focus to receive key event
    setFocused(VFX_TRUE);
    setSize(panelWidth, panelHeight);
    setPos(panelSongListPosX, panelSongListPosY);
    setHints(VFX_FRAME_HINTS_TEXTURE_HIDDEN);

    // Get parent object and provider
    VappMusicPlayerApp *app = VFX_OBJ_DYNAMIC_CAST(findRootApp(this), VappMusicPlayerApp);
    VFX_ASSERT(app);

    m_provider = app->getProvider();
    VFX_ASSERT(m_provider);

    VFX_OBJ_CREATE(m_listMenuProvider, VappMusicPlayerListMenuProvider, this);
    m_listMenuProvider->setDataProvider(m_provider);  // Set global data provider to this content provider
    m_listMenuProvider->setViewType(VIEW_TYPE_COVER_FLOW_SONG);
    
    // Create list menu title
    VfxFrame *titleBG;
    VFX_OBJ_CREATE(titleBG, VfxFrame, this);
    titleBG->setImgContent(VfxImageSrc(VCP_IMG_TITLEBAR_BACKGROUND_NORMAL));
    titleBG->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    titleBG->setPos(0, 0);
    titleBG->setSize(panelWidth, titleBarHeight);

    // Create album name text
    VfxWString titleTextString;
    m_provider->getTitle(m_albumIndex, titleTextString);
    
    VfxTextFrame *titleText;
    VFX_OBJ_CREATE(titleText, VfxTextFrame, titleBG);
    titleText->setString(titleTextString);
    titleText->setAnchor(0.0f, 0.5f);
    titleText->setSize(titleBarTextWidth, titleBarTextHeight);
    titleText->setPos(titleBarMarginX, titleBarHeight / 2 + 5);
    titleText->setAlignMode(VfxTextFrame::ALIGN_MODE_LEFT);
    VfxFontDesc font1(VFX_FONT_DESC_VF_SIZE(titleBarFontSize1), VFX_FE1_1);
    titleText->setFont(font1);
    titleText->setAutoResized(VFX_FALSE);
    titleText->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
    titleText->setColor(VFX_COLOR_WHITE);

    // Set view to cover flow song and get list content
    app->setViewType(VIEW_TYPE_COVER_FLOW_SONG, CHANGE_VIEW_MODE_ENTER, m_albumIndex);

    // Create album number text
    VfxU32 num = 0;
    num = m_listMenuProvider->getCount();
    VfxWString str;
    str.format(" %d ", num);
    str += num > 1 ? VFX_WSTR_RES(STR_ID_VAPP_MUSIC_PLAYER_UNIT_SONGS) : VFX_WSTR_RES(STR_ID_VAPP_MUSIC_PLAYER_UNIT_SONG);

    VfxTextFrame *numText;
    VFX_OBJ_CREATE(numText, VfxTextFrame, titleBG);
    numText->setString(str);
    numText->setAnchor(1.0f, 0.5f);
    numText->setPos(panelWidth - titleBarMarginX, titleBarHeight / 2 + titleBarNumTextShiftY);
    numText->setSize(titleBarNumTextWidth, titleBarNumTextHeight);
    numText->setAlignMode(VfxTextFrame::ALIGN_MODE_RIGHT);
    VfxFontDesc font2(VFX_FONT_DESC_VF_SIZE(titleBarFontSize2), VFX_FE1_1);
    numText->setFont(font2);
    numText->setAutoResized(VFX_FALSE);
    numText->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
    numText->setColor(VFX_COLOR_WHITE);

    // Create list menu
    VFX_OBJ_CREATE(m_listMenu, VappMusicPlayerListMenu, this);
    m_listMenu->setCellStyle(VCP_LIST_MENU_CELL_STYLE_MULTI_TEXT_EX);
    m_listMenu->setMenuControlMode(VCP_LIST_MENU_CONTROL_MODE_NORMAL,VFX_FALSE);
    m_listMenu->m_signalItemTapped.connect(this, &VappMusicPlayerCoverFlow3DSongListPanel::onListItemTapped);
    m_listMenu->setContentProvider(m_provider);
    m_listMenu->setPos(0, titleBarHeight);
    m_listMenu->setSize(panelWidth, panelHeight - titleBarHeight);
    m_listMenu->setItemHeight(listMenuItemHeight);
    m_listMenu->setIsOpaque(VFX_FALSE);
    m_listMenu->setSlowFactor(1.0, 1.0, 0.6);
    m_listMenu->setShadowIsDisabled(VFX_TRUE);

    m_provider->setListMenu(m_listMenu);
    m_listMenuProvider->setListMenu(m_listMenu);
    
    // List menu theme color
    VcpListMenuThemeStruct themeData = m_listMenu->getThemeData();
    themeData.normalTextColor = VRT_COLOR_MAKE(255, 255, 255, 255);
    themeData.lowlightTextColor = VRT_COLOR_MAKE(255, 150, 150, 150);
    themeData.highlightTextColor = VRT_COLOR_MAKE(255, 141, 200, 56);
    themeData.bgColor = VRT_COLOR_MAKE(255, 56, 56, 56);
    m_listMenu->setThemeData(themeData);
}

void VappMusicPlayerCoverFlow3DSongListPanel::onDeinit()
{
    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_SONGLISTPANEL_ONDEINIT);
    VfxControl::onDeinit();
}


VfxBool VappMusicPlayerCoverFlow3DSongListPanel::onKeyInput(VfxKeyEvent &event)
{
    if (event.type == VFX_KEY_EVENT_TYPE_DOWN)
    {
        switch (event.keyCode)
        {
            case VFX_KEY_CODE_BACK:
                {
                    VappMusicPlayerCoverFlow3DPage *parent = VFX_OBJ_DYNAMIC_CAST(getParent(), VappMusicPlayerCoverFlow3DPage);
                    if (parent && !parent->isCDBoxOpeningAnimation())
                    {
                        MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_SONGLISTPANEL_ONKEYINPUT_CLOSECDBOX);
                        parent->closeCDBoxSongList();
                    }
                }
                return VFX_TRUE;

            default:
                break;
        }
    }
    
    return VfxControl::onKeyInput(event);
}

VfxBool VappMusicPlayerCoverFlow3DSongListPanel::onPenInput(VfxPenEvent &event)
{
    VappMusicPlayerCoverFlow3DPage *page = VFX_OBJ_DYNAMIC_CAST(getParent(), VappMusicPlayerCoverFlow3DPage);
    if (page && page->isCDBoxOpened() && !page->isCDBoxOpeningAnimation())
    {
        return VFX_TRUE;
    }

    return VfxControl::onPenInput(event);
}

void VappMusicPlayerCoverFlow3DSongListPanel::onListItemTapped(VcpListMenu *menu, VfxU32 index)
{
    VappMusicPlayerApp *app = VFX_OBJ_DYNAMIC_CAST(findRootApp(this), VappMusicPlayerApp);
    VFX_DEV_ASSERT(app != NULL);

    if (app->blockActionInCall())
    {
        return;
    }

    MMI_TRACE(TRACE_GROUP_2, TRC_VAPP_MUSICPLY_CF_3D_SONGLISTPANEL_ONLISTITEMTAPPED, index);

    app->onListMenuItemTapped(NULL, index);

    m_listMenu->updateItem(index);

    // set the flag to go to now playing on exit cover flow
    VappMusicPlayerCoverFlow3DPage *page = VFX_OBJ_DYNAMIC_CAST(getParent(), VappMusicPlayerCoverFlow3DPage);
    if (page)
    {
        page->m_hasStartPlayback = VFX_TRUE;
    }
}

void VappMusicPlayerCoverFlow3DSongListPanel::updateListMenu(VfxS32 index)
{
    if (index == -1)
    {
        m_listMenu->updateAllItems();
    }
    else
    {
        m_listMenu->updateItem(index);
    }
}


VfxU32 VappMusicPlayerCoverFlow3DSongListPanel::getFirstSongId()
{
    VcpMenuRegion region = m_listMenu->getRealContentRegion();
    VfxU32 index = region.begin.isValid() ? region.begin.pos : 0;

    return m_listMenuProvider->getID(index);
}

void VappMusicPlayerCoverFlow3DSongListPanel::setListMenuDisabled(VfxBool isDisabled)
{
    m_listMenu->setIsDisabled(isDisabled);
}


VFX_IMPLEMENT_CLASS("CDBoxItem", CDBoxItem, VfxObject);

#endif //__COSMOS_3D_V10__
#endif //__COSMOS_MUSICPLY__ && __COSMOS_MUSICPLY_COVER_FLOW__ && __COSMOS_3D_V10__
