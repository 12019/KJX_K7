/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vapp_helloworld.cpp
 *
 * Project:
 * --------
 *  Venus
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 *  
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * Include
 *****************************************************************************/


#ifdef __cplusplus
extern "C"
{
#endif /* __CPLUSPLUS__ */

#include "USBSrvGprot.h"
#include "NwUsabSrvGprot.h"
#include "ModeSwitchSrvGprot.h"
#include "DtcntSrvGprot.h"

#ifdef __cplusplus
}
#endif /* __CPLUSPLUS__ */

#include "vapp_usb_gprot.h"

#include "vapp_dla_main.h"
#include "vfx_text_frame.h"
#include "vcp_global_popup.h"
#include "NotificationGprot.h"
#include "mmi_rp_app_cosmos_global_def.h"

VfxU16  m_DLAgentAppID;
//to record the launch parameter to determine whether the notification of launch should be called
vapp_da_app_launch_struct	*launcherRecord;
void 						*launcherArgRecord;


VFX_OBJ_IMPLEMENT_SINGLETON_CLASS(VAppDLAgentInterface);

/***************************************************************************** 
 * Function
 *****************************************************************************/

extern void onPauseSuccess (srv_da_job_struct *arg, U16 string_id);

#ifdef __MMI_OMA_DD_DOWNLOAD__
void vapp_da_oma_get_item_progress(const srv_da_job_struct* job, srv_da_item_progress_struct *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
//    U32 secs;
//    U32 progress;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_OMADL);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if(job->state == SRV_DA_JOB_STATE_PROCESSING)
    {
        switch (job_data->oma_state)
        {
            case SRV_DA_OMA_STATE_DOWNLOADING_ICON:
                info->processing_string_id = VAPP_STR_DLA_OMA_DOWNLOADING_ICON;
                break;
            case SRV_DA_OMA_STATE_SENDING_INSTALL_NOTIFICATION:
                info->processing_string_id = VAPP_STR_DLA_OMA_SEND_REPORT;
                break;
            default:
                info->processing_string_id = 0;
                break;
        }
    }
    else
    {
        info->processing_string_id = 0;
    }

}
#endif

/*****************************************************************************
 * FUNCTION
 *  vapp_da_job_on_use_file_selected
 * DESCRIPTION
 *  User selected "Use file" item. Call dispatch handler
 * PARAMETERS
 *  job     [IN] Target job
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL vapp_da_job_on_use_file_selected(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 error_id;
    srv_da_job_filestamp_enum check_result = SRV_DA_FILESTAMP_CHECK_OK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_COMPLETED);
    
    /* If the user is already allowed to use the file and try to use,
       we will not notify complete again. */
    job->notified_complete = MMI_TRUE;

    check_result = srv_da_job_check_filestamp(job, &error_id);
    
    if (check_result != SRV_DA_FILESTAMP_CHECK_OK)
    {
        srv_da_adp_popup(error_id, 0, SRV_DA_POPUP_TYPE_ERROR);

        if (check_result == SRV_DA_FILESTAMP_CHECK_FAIL)
        {
            srv_da_free_job_and_remove_screens(job);
        }
        return MMI_FALSE;
    }

    MMI_ASSERT(srv_da_job_dispatch != NULL);
    srv_da_job_dispatch(job);
    return MMI_TRUE;
}


/*****************************************************************************
* FUNCTION
*   vapp_da_util_format_time
* DESCRIPTION
*   format output string buffer according to input time
* PARAMETERS
*   buffer  [OUT]   the formated time message,
*   total_secs [IN]    time                
* RETURNS
*   void
*****************************************************************************/
void vapp_da_app_util_format_time(U16 *buffer, U32 total_secs)
{
    U32 mins, secs;

    if(!buffer)
        return;

    buffer[0] = 0;
    
    if(total_secs == 0xFFFFFFFF)
        return;

    if(total_secs == 0)
    {
        kal_wsprintf(buffer, "< 1 %w", GetString(VAPP_STR_DLA_PROMPT_SEC));
        return;
    }
    
    mins = total_secs / 60;
    secs = total_secs % 60;

    if(mins > 99)
    {
        kal_wsprintf(buffer, "> 99 %w 59 %w", GetString(VAPP_STR_DLA_PROMPT_MINS), GetString(VAPP_STR_DLA_PROMPT_SECS));
        secs = 0;
    }
    else if(mins > 1)
        kal_wsprintf(buffer, "%d %w ", mins, GetString(VAPP_STR_DLA_PROMPT_MINS));
	else if (mins != 0)
        kal_wsprintf(buffer, "%d %w ", mins, GetString(VAPP_STR_DLA_PROMPT_MIN));

    if(mins == 0 || secs != 0)
	{
		if (secs>1)
			kal_wsprintf(buffer + mmi_ucs2strlen((S8*)buffer), "%d %w", secs, GetString(VAPP_STR_DLA_PROMPT_SECS));
		else
        kal_wsprintf(buffer + mmi_ucs2strlen((S8*)buffer), "%d %w", secs, GetString(VAPP_STR_DLA_PROMPT_SEC));
    }

}


/* START of methods of VappDLAgentDownloadListControl class */
void VappDLAgentDownloadListControl:: set_text (VfxWChar *text, VfxU16 field)
{
    VfxWString    string;
	string.loadFromMem(text);
    switch (field)
    {
    case LIST_CONTROL_TEXT_FILENAME:
        this->m_text_filename->setString(string);
        break;
    case LIST_CONTROL_TEXT_SIZE:
        this->m_text_size->setString(string);
        break;
    case LIST_CONTROL_TEXT_TIME:
        this->m_text_time->setString(string);
        break;
    case LIST_CONTROL_TEXT_STATUS:
        this->m_text_status->setString(string);
        break;
    default:
        MMI_ASSERT(0);
    }
}

void VappDLAgentDownloadListControl::set_button_text(VcpButton *button, VfxWString &text)
{
    button->setText(text);
}
void VappDLAgentDownloadListControl::set_button_enable(VcpButton *button, VfxBool enable)
{
    button->setIsDisabled(!enable);
}

void VappDLAgentDownloadListControl:: set_progress (VfxFloat percentage)
{
    this->progress_bar->setProgress (percentage);
}

VfxS32 VappDLAgentDownloadListControl:: getArgID (void)
{
    return this->m_arg_id;
}

void VappDLAgentDownloadListControl:: setArgID (VfxS32 ID)
{
    this->m_arg_id = ID;
}

void VappDLAgentDownloadListControl:: onDeinit (void)
{
    m_arg_id = -1;
    VcpListMenuCellClientBaseFrame::onDeinit();
}

void VappDLAgentDownloadListControl::updateContentOfEachItem(void)
{
	VappDLAgentApp *m_dlaApp = ((VappDLAgentApp *)VfxAppLauncher::getObject(m_DLAgentAppID));
	if (m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_DOWNLOAD)
	{
	m_dlaApp->scr->m_tabbedDownload_page->m_downloadingPage->updateToolBar();
	m_dlaApp->scr->m_tabbedDownload_page->m_downloadingPage->m_downloading_list_cp->updateItemContent(NULL);
	m_dlaApp->scr->m_tabbedDownload_page->m_downloadingPage->m_download_list->updateAllItems();
	}
	else if(m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_COMPLETED)
	{
		m_dlaApp->scr->m_tabbedDownload_page->m_CompletedPage->updateToolBar();
		m_dlaApp->scr->m_tabbedDownload_page->m_CompletedPage->m_completed_list_cp->updateItemContent(NULL);
		m_dlaApp->scr->m_tabbedDownload_page->m_CompletedPage->m_completed_list->updateAllItems();
	}
}

void VappDLAgentDownloadListControl::handleLeftButtonHandler (VfxObject *sender, VfxId id)
{
    VappDLAgentApp *m_dlaApp = ((VappDLAgentApp *)VfxAppLauncher::getObject(m_DLAgentAppID));
    srv_da_job_struct *job = NULL;
    S32 prev_state;

    job = srv_da_job_get_job_by_id (m_arg_id);
    if (!job)
    {
        /* This condition can only occur when job is free at service and not updated at app */
        return;
    }

    if (m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_DOWNLOAD)
    {
        prev_state = job->state;
        if ((prev_state == SRV_DA_JOB_STATE_RESUMING) || (prev_state == SRV_DA_JOB_STATE_PROCESSING))
			return;
        if ((prev_state == SRV_DA_JOB_STATE_DOWNLOADING) || (prev_state == SRV_DA_JOB_STATE_WAITING))
        {
            job->state = SRV_DA_JOB_STATE_ABORTING;
            job->was_stopped_by_upper_layer = MMI_TRUE;
           
            srv_da_stop_selected_job(job, prev_state, MMI_TRUE, onPauseSuccess);
        }
        else if ((prev_state == SRV_DA_JOB_STATE_PAUSED) || (prev_state == SRV_DA_JOB_STATE_FAILED) || (prev_state == SRV_DA_JOB_STATE_PAUSED_WAITING))
        {            
        	#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif

            MMI_ASSERT((job->state == SRV_DA_JOB_STATE_FAILED) || (job->state == SRV_DA_JOB_STATE_PAUSED) || (job->state == SRV_DA_JOB_STATE_PAUSED_WAITING));
            MMI_ASSERT(srv_da_job_can_resume(job));

            srv_da_set_allow_to_trigger_connection(MMI_TRUE);

            /* Don't start to report immediately when user resume the download */
            job->reporting = MMI_FALSE;

            if(srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_DOWNLOADING) +
                srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_PROCESSING) >= MMI_DA_MAX_DL)
            {
                m_dlaApp->scr->createPopup(VCP_INFO_BALLOON_TYPE_FAILURE, VAPP_STR_DLA_PROMPT_EXCEED_MAX_DL);
            }
            else if (srv_da_is_in_voice_call())
            {
                mmi_frm_nmgr_balloon(
                    MMI_SCENARIO_ID_GENERAL,
                    MMI_EVENT_INFO_BALLOON,
                    MMI_NMGR_BALLOON_TYPE_INFO,
                    (WCHAR*)(VFX_WSTR_RES(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE_IN_CALL).getBuf()));
            }
            else
            {
            #if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
                //set_left_button_enable(VFX_FALSE);
                srv_da_job_resume(job);
            #endif
            }

            if (prev_state == SRV_DA_JOB_STATE_FAILED)
            {
                //VcpDLAgentNCenter::updateFailedCells();
            }
        }
    }
    else if (m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_COMPLETED)
    {
        if (!vapp_da_job_on_use_file_selected (job))
        {
            /* Updating the list in case if use item does not exists */
            vapp_da_app_launch_struct  app_launch;
            app_launch.type = SRV_DA_APP_UPDATE_DOWNLOAD;
            app_launch.arg = NULL;
            app_launch.argSize = sizeof (srv_da_update_job_event_struct);
            VAppDLAgentInterface::OnServiceCallback ((void*)&app_launch);
			VappDLAgentNCenterNew::vapp_dla_update_ncenter(NULL, 0);
        }
    }
    else
    {
        VFX_ASSERT(0);
    }
}


void VappDLAgentDownloadListControl::onCancelConfirmation(VfxObject* obj, VfxId id)
{
    VappDLAgentApp *m_dlaApp = ((VappDLAgentApp *)VfxAppLauncher::getObject(m_DLAgentAppID));
    srv_da_job_struct *job = NULL;
    if (id == VCP_CONFIRM_POPUP_BUTTON_USER_1)
    {
        job = srv_da_job_get_job_by_id (m_arg_id);
        VFX_ASSERT (job);
        
        srv_da_show_progressing_event_struct  evt;
        evt.screen_id = 0;
        evt.title_string_id = 0;
        evt.title_icon_id = 0;
        evt.message_id = STR_GLOBAL_ABORTING;
        evt.cancel_rsk = MMI_FALSE;
        evt.arg = job;
        evt.cancel_callback = NULL;
        m_dlaApp->scr->drawProgressScreen((void*)&evt);
        srv_da_curr_job_do_abort (job);
    }
}


void VappDLAgentDownloadListControl::handleRightButtonHandler (VfxObject *sender, VfxId id)
{
    srv_da_job_struct *job = NULL;
	job = srv_da_job_get_job_by_id (m_arg_id);
    if (m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_DOWNLOAD)
    {
    /*****if job status is aborting, then return*****/
		if(job->state == SRV_DA_JOB_STATE_ABORTING)
			return;		
        VcpConfirmPopup  *confirmPopup = NULL;
		createAndSetPopup(confirmPopup, VCP_POPUP_TYPE_WARNING, VCP_CONFIRM_BUTTON_SET_USER_DEFINE, VFX_WSTR_RES(VAPP_STR_DLA_DISCARD_DOWNLOADING_CONFIRM), this);
        confirmPopup->setCustomButton(VFX_WSTR_RES (VAPP_STR_DLA_DISCARD), VFX_WSTR_RES (STR_GLOBAL_CANCEL), VCP_POPUP_BUTTON_TYPE_WARNING, VCP_POPUP_BUTTON_TYPE_CANCEL);
        confirmPopup->m_signalButtonClicked.connect(this, &VappDLAgentDownloadListControl::onCancelConfirmation);
    }
    else if (m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_COMPLETED)
    {
        srv_da_free_job (job);
		updateContentOfEachItem();
        //VcpDLAgentNCenter::updateAllCells();
        //VcpDLAgentNCenter::updateCompletedCells();
		VappDLAgentNCenterNew::vapp_dla_update_ncenter(NULL, 0);
    }
}


VfxBool VappDLAgentDownloadListControl::isItemRotated(void)
{
    VappDLAgentApp *m_dlaApp = (VappDLAgentApp *) VfxAppLauncher::findApp(VAPP_DLAGENT, VFX_OBJ_CLASS_INFO(VappDLAgentApp), VFX_APP_LAUNACHER_FIND_APP_NORMAL_FLAG, 0);
    return ((VFX_SCR_ROTATE_TYPE_270 == m_dlaApp->scr->m_tabbedDownload_page->getRotate()) 
        || (VFX_SCR_ROTATE_TYPE_90 == m_dlaApp->scr->m_tabbedDownload_page->getRotate()));
}


VfxS32 VappDLAgentDownloadListControl::componentWidth(void)
{
    if (!isRotated)
    {
        return LCD_WIDTH;
    }
    else
    {
        return LCD_HEIGHT;
    }
}


VfxS32 VappDLAgentDownloadListControl::componentHeight(void)
{
    if (m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_DOWNLOAD)
    {
        if (unfolded)
        {
            return VAPP_DLA_DOWNLOAD_LIST_ITEM_UNFOLDED_HEIGHT;
        }
        else
        {
            return VAPP_DLA_DOWNLOAD_LIST_ITEM_FOLDED_HEIGHT;
        }
    }
    else
    {
        if (unfolded)
        {
            return VAPP_DLA_COMPLETED_LIST_ITEM_UNFOLDED_HEIGHT;
        }
        else
        {
            return VAPP_DLA_COMPLETED_LIST_ITEM_FOLDED_HEIGHT;
        }
    }
}

VfxS32 VappDLAgentDownloadListControl::filenameLength(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_FILENAME_EDIT_LENGTH;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_FILENAME_EDIT_LENGTH_LANDSCAPE;
    }
}


VfxS32 VappDLAgentDownloadListControl::statusDisplayLength(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_STATUS_EDIT_LENGTH;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_STATUS_EDIT_LENGTH_LANDSCAPE;
    }
}

VfxS32 VappDLAgentDownloadListControl::sizeDisplayLength(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_SIZE_EDIT_LENGTH;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_SIZE_EDIT_LENGTH_LANDSCAPE;
    }
}

VfxS32 VappDLAgentDownloadListControl::timeDisplayLength(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_TIME_EDIT_LENGTH;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_TIME_EDIT_LENGTH_LANDSCAPE;
    }
}


VfxS32 VappDLAgentDownloadListControl::topMargin(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_TOP_MARGIN;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_TOP_MARGIN_LANDSCAPE;
    }
}


VfxS32 VappDLAgentDownloadListControl::bottomMargin(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_BOTTOM_MARGIN;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_BOTTOM_MARGIN_LANDSCAPE;
    }
}


VfxS32 VappDLAgentDownloadListControl::leftMargin(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_LEFT_MARGIN;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_LEFT_MARGIN_LANDSCAPE;
    }
}


VfxS32 VappDLAgentDownloadListControl::rightMargin(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_RIGHT_MARGIN;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_RIGHT_MARGIN_LANDSCAPE;
    }
}


VfxS32 VappDLAgentDownloadListControl::buttonWidth(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_BUTTOM_WIDTH;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_BUTTOM_WIDTH_LANDSCAPE;
    }
}


VfxS32 VappDLAgentDownloadListControl::buttonLength(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_BUTTOM_LENGTH;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_BUTTOM_LENGTH_LANDSCAPE;
    }
}


VfxS32 VappDLAgentDownloadListControl::buttonDistance(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_DISTANCE_BTW_BUTTONS;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_DISTANCE_BTW_BUTTONS_LANDSCAPE;
    }
}


VfxS32 VappDLAgentDownloadListControl::progressbarwidth(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_PROGRESS_BAR_WIDTH;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_PROGRESS_BAR_WIDTH_LANDSCAPE;
    }
}


VfxS32 VappDLAgentDownloadListControl::progressbarLength(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_PROGRESS_BAR_LENGTH;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_PROGRESS_BAR_LENGTH_LANDSCAPE;
    }
}


VfxS32 VappDLAgentDownloadListControl::commonDistance(void)
{
    if (!isRotated)
    {
        return VAPP_DLA_LIST_ITEM_COMMON_DISTANCE;
    }
    else
    {
        return VAPP_DLA_LIST_ITEM_COMMON_DISTANCE_LANDSCAPE;
    }
}


void VappDLAgentDownloadListControl::resetPosition (void)
{
	VfxU32 height = VAPP_DLA_COMPLETED_LIST_ITEM_FOLDED_HEIGHT - VAPP_DLA_LIST_ITEM_FILENAME_EDIT_WIDTH;
	height = height / 2;
    isRotated = isItemRotated();
    m_frame->setBounds(VfxRect(0,0, getRect().getWidth(),componentHeight()));
    if(m_text_filename != NULL)
    {
	    m_text_filename->setPos (leftMargin(), topMargin());
        if (unfolded)
        {
            m_text_filename->setSize (progressbarLength(), VAPP_DLA_LIST_ITEM_FILENAME_EDIT_WIDTH);
        }
        else
        {
            if (m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_COMPLETED)
            {
                m_text_filename->setPos (leftMargin(), height); 
            }
            m_text_filename->setSize (filenameLength(), VAPP_DLA_LIST_ITEM_FILENAME_EDIT_WIDTH);
        }
    }

    if (m_text_status != NULL)
    {
        if (m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_COMPLETED)
        {
            m_text_status->setPos ((componentWidth() - (rightMargin() + statusDisplayLength())), height); 
        }
        else
        {
            m_text_status->setPos ((componentWidth() - (rightMargin() + statusDisplayLength())), topMargin());
        }
        m_text_status->setSize (statusDisplayLength(), VAPP_DLA_LIST_ITEM_STATUS_EDIT_WIDTH);
    }
    if (m_text_size != NULL)
    {
        m_text_size->setPos (leftMargin(), (m_text_filename->getRect().getY() + m_text_filename->getRect().getHeight() + commonDistance()));
        m_text_size->setSize (sizeDisplayLength(),VAPP_DLA_LIST_ITEM_SIZE_EDIT_WIDTH);
    }
    if (m_text_time != NULL)
    {
        m_text_time->setPos (leftMargin(), (m_text_size->getRect().getY() + m_text_size->getRect().getHeight()  + commonDistance()));
        m_text_time->setSize (timeDisplayLength(),VAPP_DLA_LIST_ITEM_TIME_EDIT_WIDTH);
    }

    
    if (progress_bar != NULL)
    {
        progress_bar->setWidth (progressbarLength());
        if (unfolded)
        {
            progress_bar->setPos (leftMargin(), 
                (m_text_time->getRect().getY() + m_text_time->getRect().getHeight()  + commonDistance()));
        }
        else
        {
            progress_bar->setPos (leftMargin(), (m_text_filename->getRect().getY() + m_text_filename->getRect().getHeight() + commonDistance()));
        }
    }

    if (m_left_button != NULL)
    {
        if (m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_COMPLETED)
        {
            m_left_button->setRect(VfxRect(
                leftMargin(), 
                (m_text_time->getRect().getY() + m_text_time->getRect().getHeight()  + commonDistance()),
                buttonLength(), 
                buttonWidth()));
        }
        else
        {
            m_left_button->setRect(VfxRect(
                leftMargin(), 
                (m_text_time->getRect().getY() + m_text_time->getRect().getHeight()  + (2 * commonDistance()) + VAPP_DLA_LIST_ITEM_PROGRESS_BAR_WIDTH),
                buttonLength(), 
                buttonWidth()));
        }
    }

    if (m_right_button != NULL)
    {
        m_right_button->setRect(VfxRect(
            (leftMargin() + buttonLength() + buttonDistance()), 
            m_left_button->getRect().getY(),
            buttonLength(),
            buttonWidth()));
    }
}


void VappDLAgentDownloadListControl::onLayoutElements(void)
{
    VcpListMenuCell *cell = getCell();
    if (!cell)
    {
        return;
    }
    if (m_text_filename)
    {
        m_text_filename->setColor(cell->getTextColor(VCP_LIST_MENU_TEXT_COLOR_NORMAL));
    }
    if (m_text_status)
    {
        m_text_status->setColor(cell->getTextColor(VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT));
    }
}



void VappDLAgentDownloadListControl::onUpdateEmphasisFocus(VfxBool isFocus)
{
    isRotated = isItemRotated();
    VcpListMenuCell *cell = getCell();
    if (isFocus)
    {
        unfolded = VFX_TRUE;
        m_text_filename->setPos (leftMargin(), topMargin());
        /* Progress bar length can be use to set filename length */
        m_text_filename->setSize (progressbarLength(), VAPP_DLA_LIST_ITEM_FILENAME_EDIT_WIDTH);
        if (!m_text_size)
        VFX_OBJ_CREATE(m_text_size, VfxTextFrame, m_frame);
        m_text_size->setColor(cell->getTextColor(VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT));
        m_text_size->setAutoResized(VFX_FALSE);
        m_text_size->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_DLA_LIST_ITEM_SIZE_EDIT_WIDTH - 2)));

        if (!m_text_time)
        VFX_OBJ_CREATE(m_text_time, VfxTextFrame, m_frame);
        m_text_time->setColor(cell->getTextColor(VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT));
        m_text_time->setAutoResized(VFX_FALSE);
        m_text_time->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_DLA_LIST_ITEM_TIME_EDIT_WIDTH - 2)));

        if (!m_left_button)
        VFX_OBJ_CREATE(m_left_button, VcpButton, this);
        m_left_button->setPlacement(VCP_BUTTON_PLACEMENT_TEXT_ONLY);
        m_left_button->setStyle (VCP_BUTTON_STYLE_DEFAULT);
        m_left_button->bringToFront();

        if (!m_right_button)
        VFX_OBJ_CREATE(m_right_button, VcpButton, this);
        m_right_button->setPlacement(VCP_BUTTON_PLACEMENT_TEXT_ONLY);
        m_right_button->setStyle (VCP_BUTTON_STYLE_RED);

        m_left_button->m_signalClicked.connect (this, &VappDLAgentDownloadListControl::handleLeftButtonHandler);
        m_right_button->m_signalClicked.connect  (this, &VappDLAgentDownloadListControl::handleRightButtonHandler);
        if (m_text_status != NULL)
        {
            VFX_OBJ_CLOSE(m_text_status);
        }
    }
    else
    {
        unfolded = VFX_FALSE;
        if (m_text_status == NULL)
        {
            VFX_OBJ_CREATE(m_text_status, VfxTextFrame, m_frame);
            m_text_status->setColor(cell->getTextColor(VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT));
            m_text_status->setAlignMode(VfxTextFrame::ALIGN_MODE_RIGHT);
            m_text_status->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_DLA_LIST_ITEM_STATUS_EDIT_WIDTH - 2)));
            m_text_status->setAutoResized(VFX_FALSE);
        }
        if (m_text_size != NULL)
        {
            VFX_OBJ_CLOSE(m_text_size);
        }
        if (m_text_time != NULL)
        {
            VFX_OBJ_CLOSE(m_text_time);
        }
        if (m_left_button != NULL)
        {
            m_left_button->m_signalClicked.disconnect (this, &VappDLAgentDownloadListControl::handleLeftButtonHandler);

            VFX_OBJ_CLOSE(m_left_button);
        }
        if (m_right_button != NULL)
        {
            m_right_button->m_signalClicked.disconnect  (this, &VappDLAgentDownloadListControl::handleRightButtonHandler);
            VFX_OBJ_CLOSE(m_right_button);
        }        
    }

    VappDLAgentMainPageContentProvider  *cp = NULL;
    VappDLAgentApp *m_dlaApp = ((VappDLAgentApp *)VfxAppLauncher::getObject(m_DLAgentAppID));
    if (m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_DOWNLOAD)
    {       
        cp = m_dlaApp->scr->m_tabbedDownload_page->m_downloadingPage->m_downloading_list_cp;
    }
    else if (m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_COMPLETED)
    {
        cp = m_dlaApp->scr->m_tabbedDownload_page->m_CompletedPage->m_completed_list_cp;
    }
    else
    {
        VFX_ASSERT(0);
    }
	resetPosition();
    srv_da_job_struct *job = srv_da_job_get_job_by_id (m_arg_id);
    VFX_ASSERT(job);
    cp->fillCustomFieldData (this, (void*)job, !unfolded);
}


void VappDLAgentDownloadListControl:: onInit (void)
{
    VcpListMenuCellClientBaseFrame::onInit();
    VcpListMenuCell *cell = getCell();

    this->isRotated = isItemRotated();
    VFX_OBJ_CREATE(m_frame, VfxFrame, this);
    m_frame->setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE, VFX_FRAME_ALIGNER_MODE_SIDE, 
        VFX_FRAME_ALIGNER_MODE_SIDE, VFX_FRAME_ALIGNER_MODE_SIDE);

    VFX_OBJ_CREATE(m_text_filename, VfxTextFrame, m_frame);
    m_text_filename->setColor(cell->getTextColor(VCP_LIST_MENU_TEXT_COLOR_NORMAL));
    m_text_filename->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_DLA_LIST_ITEM_FILENAME_EDIT_WIDTH - 2)));
    m_text_filename->setAutoResized(VFX_FALSE);
    m_text_filename->setTruncateMode (VfxTextFrame::TRUNCATE_MODE_END);

    VFX_OBJ_CREATE(m_text_status, VfxTextFrame, m_frame);
    m_text_status->setColor(cell->getTextColor(VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT));
    m_text_status->setAlignMode(VfxTextFrame::ALIGN_MODE_RIGHT);
    m_text_status->setAutoResized(VFX_FALSE);
    m_text_status->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_DLA_LIST_ITEM_SIZE_EDIT_WIDTH - 2)));

    if (m_listType == VappDLAgentMainPage::VAPP_DLA_TAB_DOWNLOAD)
    {
        VFX_OBJ_CREATE(progress_bar, VcpProgressIndicator, m_frame);
        progress_bar->setWidth (progressbarLength());
        progress_bar->setMaxProgressValue ((VfxFloat)1.0);
    }
    else
    {
        progress_bar = NULL;
    }
    unfolded = VFX_FALSE;
	resetPosition();
}

/* END of methods of VappDLAgentDownloadListControl class */


void VappDLAgentScreen::drawDownloadListPage(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_display_job_list_event_struct        *dl_list;
    VfxBool                                     reEntry = VFX_FALSE;
    VfxU16                                      tab_page_enum;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dl_list = (srv_da_display_job_list_event_struct*)arg;
	// dla_main_tab_enum and srv_da_list_type_enum have the same enum
    tab_page_enum = dl_list->list_type;
    if (m_tabbedDownload_page)
    {
        reEntry = VFX_TRUE;
    }
    if (!reEntry)
    {
	    VFX_OBJ_CREATE_EX(m_tabbedDownload_page, VappDLAgentMainPage, this, (tab_page_enum)); /* Passed hardcoded "1" for VAPP_DLA_TAB_DOWNLOAD */
        pushPage(DLA_PAGE_DOWNLOAD_LIST_PAGE, m_tabbedDownload_page);
    }
    m_tabbedDownload_page->setCurrTab (tab_page_enum);
}


/**********************************************************************************************************************************************/
/*                                          STARTING AUTHENTICATION SCREEN DRAW                                                               */
/**********************************************************************************************************************************************/

void VappDLAgentScreen::drawUserAuthPage(void *arg)
{
    VFX_OBJ_CREATE_EX(m_userAuthPage, VappDLAgentUserAuthPage, this, (arg, sizeof (srv_da_show_user_auth_event_struct)));
    this->pushPage(DLA_PAGE_USER_AUTH_PAGE, m_userAuthPage);
}


void VappDLAgentScreen::showJobDetails(void *arg)
{
    if (!m_jobDetail)
    {
        setBgColor(VFX_COLOR_TRANSPARENT);
        VFX_OBJ_CREATE_EX(m_jobDetail, VappDLAgentJobDetailPage, this, (arg));
    }
    pushPage(DLA_PAGE_JOB_DETAIL_PAGE, m_jobDetail);
}

/**********************************************************************************************************************************************/
/*                                          END AUTHENTICATION SCREEN DRAW                                                                    */
/**********************************************************************************************************************************************/




void VappDLAgentScreen::createPopup(VfxU16 balloonType, VfxU32 string_id)
{
    VcpInfoBalloon *balloon = VFX_OBJ_GET_INSTANCE(VcpInfoBalloon);
    balloon->addItem(balloonType, VFX_WSTR_RES(string_id));
}

void VappDLAgentScreen::displayPopup(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_popup_event_struct  *data = (srv_da_popup_event_struct*)arg;
    VfxU16                     balloonType = VCP_INFO_BALLOON_TYPE_SUCCESS;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (data->type)
    {
    case SRV_DA_POPUP_TYPE_MESSAGE:
        balloonType = VCP_INFO_BALLOON_TYPE_INFO;
        break;
    case SRV_DA_POPUP_TYPE_ERROR:
        balloonType = VCP_INFO_BALLOON_TYPE_FAILURE;
        break;
    case SRV_DA_POPUP_TYPE_DONE:
        balloonType = VCP_INFO_BALLOON_TYPE_SUCCESS;
        break;
    case SRV_DA_POPUP_TYPE_INFO:
        balloonType = VCP_INFO_BALLOON_TYPE_INFO;
        break;
    case SRV_DA_POPUP_TYPE_SAVED:
        balloonType = VCP_INFO_BALLOON_TYPE_SUCCESS;
        break;
    case SRV_DA_POPUP_TYPE_LONG_MESSAGE:
        balloonType = VCP_INFO_BALLOON_TYPE_SUCCESS;
        break;
    case SRV_DA_POPUP_TYPE_DRM_PROCESSING_INFO:
        balloonType = VCP_INFO_BALLOON_TYPE_PROGRESS;
        break;
    }
    createPopup (balloonType, data->string_id);
}


void VappDLAgentScreen::drawNewDownloadPage(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct                           *job;
    srv_da_normal_dl_job_struct                 *job_data;
    srv_da_setting_struct                       *setting_data;
    srv_da_show_choice_screen_event_struct      *new_dl;
    VfxU32                                      downloadSize = 0;
    VfxU16                                      temp_filename[MMI_DA_MAX_FILENAME_INPUT_LEN + 2];
    VfxU16                                      ext[SRV_FMGR_PATH_MAX_FILE_EXT_LEN + 1];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    new_dl = (srv_da_show_choice_screen_event_struct*)arg;
    job = (srv_da_job_struct*)new_dl->arg;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if (new_dl->arg_size == sizeof (srv_da_push_item_struct))
    {
        downloadSize = srv_da_push_get_download_size (job);
        srv_da_push_get_filename (job, temp_filename, ext);
        goto CREATE_PAGE;
    }

    setting_data = srv_da_get_setting_buffer();
    if (job->type == SRV_DA_JOB_TYPE_NORMAL)
    {
	#ifdef BROWSER_SUPPORT
        downloadSize = job_data->size;
        srv_da_http_get_setting(job, setting_data);
        srv_da_copy_setting(job, setting_data);
	#else
		VFX_ASSERT(0);
	#endif
    }
#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
	else if (job->type ==SRV_DA_JOB_TYPE_HTTP_DOWNLOAD)
	{
		downloadSize = job_data->size;
        srv_da_http_dl_get_setting(job, setting_data);
        srv_da_copy_setting(job, setting_data);
	}
#endif
#ifdef __MMI_OMA_DD_DOWNLOAD__
    else if (job->type == SRV_DA_JOB_TYPE_OMADL)
    {
        downloadSize = ((srv_da_omadl_job_struct*)job_data)->size;
        srv_da_oma_get_setting(job, setting_data);
        srv_da_copy_setting(job, setting_data);
    }
#endif    
    if (job->type == SRV_DA_JOB_TYPE_NORMAL || job->type == SRV_DA_JOB_TYPE_HTTP_DOWNLOAD)
    {
        if (!setting_data->default_filename && setting_data->filename[0])
        {
            srv_da_extract_filepath(setting_data->filename, temp_filename, ext);
        }
        else if (job_data->filepath!= NULL && job_data->filepath[0] != L'\0')
        {
            srv_da_extract_filepath(job_data->filepath, temp_filename, ext);
        }
        else
        {
            srv_da_extract_filename_from_url(job_data->url_ptr, temp_filename, ext);
        }
    }
#ifdef __MMI_OMA_DD_DOWNLOAD__
    else if (job->type == SRV_DA_JOB_TYPE_OMADL)
    {
        srv_da_oma_decide_default_filename (job, setting_data, temp_filename, ext);
    }
#endif
#ifdef MMI_DLA_MRE_SUPPORT
    else if (job->type == SRV_DA_JOB_TYPE_MREDL)
    {
        downloadSize = srv_da_mre_get_download_size (job);
        srv_da_mre_decide_default_filename (job, temp_filename, ext);
    }
#endif /* MMI_DLA_MRE_SUPPORT */
    else
    {
        VFX_ASSERT(0);
    }

CREATE_PAGE:
    VFX_OBJ_CREATE_EX(m_new_download_page, VappDLAgentNewDownloadPage, this, (new_dl->arg, new_dl->arg_size));

	this->pushPageHandler(DLA_PAGE_NEW_DOWNLOAD_PAGE, m_new_download_page);
	 
    m_new_download_page->setDownloadSize (downloadSize);
#ifndef __COSMOS_NO_USER_DRIVE__
    m_new_download_page->set_default_location (m_new_download_page->m_user_prefered_drive);
#endif
    m_new_download_page->set_default_filename (temp_filename);
    /* Started setting the required callbacks */
    m_new_download_page->setDownloadConfirmCallback (new_dl->lsk_hdlr);
    m_new_download_page->setDownloadCancelCallback (new_dl->rsk_hdlr);
    if (ext[0] != L'\0')
    {
        m_new_download_page->m_ext = VFX_WSTR_MEM (ext);
    }    
    m_new_download_page->createDescription();


	//this->pushPage(DLA_PAGE_NEW_DOWNLOAD_PAGE, m_new_download_page);

	//
	
}

void VappDLAgentScreen::closeProgressScreen(void *arg)
{
    if (m_progress_popup != NULL)
    {
        //m_progress_popup->hide(VFX_TRUE);
        VFX_OBJ_CLOSE(m_progress_popup);
        //m_progress_popup = NULL;
    }
	  if(m_popupArg)
	  {
		  VFX_FREE_MEM (m_popupArg);
		  m_popupArg = NULL;
	  }
    if (getTopPageId() == VFX_ID_NULL)
    {
        VfxAppLauncher::terminate(m_DLAgentAppID);
    }
    else
    {
    	  setBgColor(VFX_COLOR_RES(CLR_COSMOS_BG_MAIN));
    }
}

void VappDLAgentScreen::onProcessingCanceled(VfxObject* obj, VfxFloat curr_progress)
{
    m_progress_popup->hide(VFX_TRUE);
	if(m_popupArg &&((srv_da_show_progressing_event_struct*)m_popupArg)->cancel_callback)
        ((srv_da_show_progressing_event_struct*)m_popupArg)->cancel_callback (((srv_da_show_progressing_event_struct*)m_popupArg)->arg, MMI_FALSE);
    closeProgressScreen(NULL);
}


void VappDLAgentScreen::drawProgressScreen(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_show_progressing_event_struct  *data = (srv_da_show_progressing_event_struct*)arg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(m_progress_popup)
    {
		return;
	}
    setBgColor(VFX_COLOR_TRANSPARENT);
	if(!m_progress_popup)
	{
		VFX_ALLOC_MEM(m_popupArg, sizeof(srv_da_show_progressing_event_struct), this);
		memcpy (m_popupArg, arg, sizeof(srv_da_show_progressing_event_struct));
        VFX_OBJ_CREATE(m_progress_popup, VcpIndicatorPopup, this);
	}
    if (data->cancel_rsk)
    {
        m_progress_popup->setInfoType (VCP_INDICATOR_POPUP_STYLE_ACTIVITY_WITH_CANCEL_BUTTON);
    }
    else
    {
        m_progress_popup->setInfoType (VCP_INDICATOR_POPUP_STYLE_ACTIVITY);
    }
    m_progress_popup->setText (VFX_WSTR_RES(data->message_id));
    m_progress_popup->setAutoDestory(VFX_FALSE);
    m_progress_popup->show(VFX_TRUE);
    m_progress_popup->m_signalCanceled.connect(this, &VappDLAgentScreen::onProcessingCanceled);
}

void VappDLAgentScreen::onQueryRotateEx(VfxScreenRotateParam &param)
{
	if(!(param.rotateTo == VFX_SCR_ROTATE_TYPE_0 || param.rotateTo == VFX_SCR_ROTATE_TYPE_270 || param.rotateTo == VFX_SCR_ROTATE_TYPE_90)) 
		param.rotateTo = VFX_SCR_ROTATE_TYPE_NORMAL;
}

void VappDLAgentScreen::onDeinit()
{
    if (m_progress_popup)
    {
        if (m_popupArg != NULL)
        {
			if(((srv_da_show_progressing_event_struct*)m_popupArg)->cancel_callback != NULL)
                ((srv_da_show_progressing_event_struct*)m_popupArg)->cancel_callback (((srv_da_show_progressing_event_struct*)m_popupArg)->arg, MMI_FALSE);
            VFX_FREE_MEM (m_popupArg);
        }
    }
    VFX_FREE_MEM (m_screenArg.arg);
    m_popupArg = NULL;
    VfxMainScr::onDeinit();
}

void VappDLAgentScreen::onServiceEventHandler(vapp_da_app_launch_struct *arg)
{
	switch(arg->type)
    {
    case SRV_DA_APP_LAUNCH_NEW_DOWNLOAD:
	        drawNewDownloadPage (arg->arg);
        break;
    case SRV_DA_APP_LAUNCH_DOWNLOADING_LIST:
    case SRV_DA_APP_LAUNCH_COMPLETED_LIST:
	        drawDownloadListPage(arg->arg);
        break;
    case SRV_DA_APP_LAUNCH_PROGRESSING:
	        drawProgressScreen(arg->arg);
        break;
    case SRV_DA_APP_CLOSE_PROGRESSING:
	        closeProgressScreen(arg->arg);
        break;
    case SRV_DA_APP_LAUNCH_POPUP:
	        displayPopup (arg->arg);
        break;
    case SRV_DA_APP_LAUNCH_AUTH_SCREEN:
	        drawUserAuthPage (arg->arg);
        break;
	    case SRV_DA_APP_UPDATE_NCENTER:
	        //VcpDLAgentNCenter::updateAllCells();
            //VappDLAgentNCenterNew::vapp_dla_update_ncenter(NULL, 0);
        break;
    case SRV_DA_APP_LAUNCH_DISPLAY_JOB_DETAIL:
	        showJobDetails (arg->arg);
        break;
    default:
        /* error */
        break;
    }
    //VcpDLAgentNCenter::updateAllCells();
    VappDLAgentNCenterNew::vapp_dla_update_ncenter(NULL, 0);
}

void VappDLAgentScreen::onInit()
{
	VfxMainScr::onInit();
}

void VappDLAgentScreen::on1stReady()
{
    VfxMainScr::on1stReady();
    VfxKeypad::registerHandler(VFX_KEY_CODE_SPECIAL_ALL, this);

	//each page will have a pointer which points to m_screenArg->arg, so pages has no need to have a copy
    vapp_da_app_launch_struct  *screen_arg = (vapp_da_app_launch_struct*)&m_screenArg;
    onServiceEventHandler(screen_arg);
}



void VappDLAgentScreen::serviceEventHandler (void *param)
{
    vapp_da_app_launch_struct  *arg = (vapp_da_app_launch_struct*)param;
    VappDLAgentApp *m_dlaApp = ((VappDLAgentApp *)VfxAppLauncher::getObject(m_DLAgentAppID));

    if (arg->type == SRV_DA_APP_UPDATE_DOWNLOAD)
        {
            if (m_dlaApp->scr->m_tabbedDownload_page != NULL)
            {
                if (m_dlaApp->scr->m_tabbedDownload_page->m_downloadingPage != NULL)
                {
                    if (m_dlaApp->scr->m_tabbedDownload_page->m_downloadingPage->m_download_list != NULL)
                    {
                        m_dlaApp->scr->m_tabbedDownload_page->m_downloadingPage->m_downloading_list_cp->updateItemContent((void*)arg->arg);

                        if (arg->arg != NULL)
                        {
                            if(((srv_da_job_struct*)arg->arg)->state == SRV_DA_JOB_STATE_COMPLETED)
                            {
                                m_dlaApp->scr->m_tabbedDownload_page->m_downloadingPage->m_downloading_list_cp->UpdateDisplayedList();
                            }
                        }
                        m_dlaApp->scr->m_tabbedDownload_page->m_downloadingPage->updateToolBar();

                        if (arg->arg != NULL)
                        {
                            if ((((srv_da_job_struct*)arg->arg)->state == SRV_DA_JOB_STATE_ABORTED) ||
                                (((srv_da_job_struct*)arg->arg)->state == SRV_DA_JOB_STATE_COMPLETED))
                            {
                                m_dlaApp->scr->m_tabbedDownload_page->m_downloadingPage->m_download_list->resetAllItems();
                            }
                            else
                            {
                                m_dlaApp->scr->m_tabbedDownload_page->m_downloadingPage->m_download_list->updateAllItems();
                            }
                        }
                        else
                        {
                            m_dlaApp->scr->m_tabbedDownload_page->m_downloadingPage->m_download_list->updateAllItems();
                        }
                    }
                }
                if (m_dlaApp->scr->m_tabbedDownload_page->m_CompletedPage != NULL)
                {
                    if (m_dlaApp->scr->m_tabbedDownload_page->m_CompletedPage->m_completed_list != NULL)
                    {
                        m_dlaApp->scr->m_tabbedDownload_page->m_CompletedPage->m_completed_list_cp->updateItemContent((void*)arg->arg);
                        if (arg->arg != NULL)
                        {
                            if(((srv_da_job_struct*)arg->arg)->state == SRV_DA_JOB_STATE_COMPLETED)
                            {
                                //reset all items with folded state when a new complete job comes
								m_dlaApp->scr->m_tabbedDownload_page->m_CompletedPage->m_completed_list->resetAllItems();
                            }
                        }
                        m_dlaApp->scr->m_tabbedDownload_page->m_CompletedPage->updateToolBar();
                        m_dlaApp->scr->m_tabbedDownload_page->m_CompletedPage->m_completed_list->updateAllItems();
                    }
                }
            }
            if (m_dlaApp->scr->m_jobDetail)
            {
                m_dlaApp->scr->m_jobDetail->updateStatus((void*)arg->arg);
            }
        }
    else
		//m_dlaApp->scr->onServiceEventHandler(arg);
		onServiceEventHandler(arg);
}





VFX_IMPLEMENT_CLASS("VappDLAgentApp", VappDLAgentApp, VfxApp);

void VappDLAgentApp::onRun(void *args, VfxU32 argSize)
{
	vapp_da_app_launch_struct  *appLauncher = (vapp_da_app_launch_struct*)args;
    VfxApp::onRun(args, argSize);    
    // create and display main screen
    VFX_OBJ_CREATE_EX(scr, VappDLAgentScreen, this, (args, sizeof (vapp_da_app_launch_struct)));
	scr->m_screenArg.type = appLauncher->type;    
    scr->m_screenArg.argSize = appLauncher->argSize;
    VFX_ALLOC_MEM(scr->m_screenArg.arg, appLauncher->argSize, this);	
	ASSERT(scr->m_screenArg.arg != NULL);
	memcpy (scr->m_screenArg.arg, appLauncher->arg, appLauncher->argSize);
	free_ctrl_buffer(appLauncher->arg);
	m_DLAgentAppID = getGroupId();
	kal_prompt_trace(MOD_MMI,"[VAPP_DLA]onrun success m_DLAgentAppID = %f", m_DLAgentAppID);
	launcherArgRecord = NULL;
	#ifdef __MMI_ASM_OOM_AUTO_KILL__
    mmi_frm_asm_set_app_priority(VAPP_BROWSER, 128);
	#endif
    ((VAppDLAgentInterface *)VFX_OBJ_GET_INSTANCE(VAppDLAgentInterface))->m_dispatchCallback.connect(this->scr, &VappDLAgentScreen::serviceEventHandler);
    scr->show();
}

void VappDLAgentApp::onDeinit(void)
{
    //VFX_FREE_MEM (scr->m_screenArg.arg);
	m_DLAgentAppID = 0;
    VfxApp::onDeinit();
}


/*****************************************************************************
 * FUNCTION
 *  vapp_da_app_launch
 * DESCRIPTION
 *  This func is used for creating a instance of Download agent service for 
 * downloading.
 * PARAMETERS
 *  void          
 * RETURNS
 *  void
 *****************************************************************************/


void vapp_dla_app_launch_callback (VfxAppLauncherResultEnum result, void *userData)
{
	if(VFX_APP_LAUNCHER_RESULT_CANCEL == result)
	{
        if(launcherRecord->type == SRV_DA_APP_LAUNCH_NEW_DOWNLOAD)
        {
			srv_da_show_choice_screen_event_struct *evt = (srv_da_show_choice_screen_event_struct *)(launcherRecord->arg);
            evt->rsk_hdlr(evt->arg);
		}
	}
	free_ctrl_buffer(launcherRecord);
	launcherRecord = NULL;
}


extern "C" MMI_BOOL vapp_da_notify_app_launch(mmi_scenario_id scen_id, void *arg)
{
	vapp_da_app_launch_struct  *launcher = (vapp_da_app_launch_struct *)arg;
    if(launcher->type == SRV_DA_APP_LAUNCH_DISPLAY_JOB_DETAIL)
    {
        srv_da_display_job_detail_event_struct *evt = (srv_da_display_job_detail_event_struct *)launcher->arg;
		srv_da_job_struct *job = (srv_da_job_struct *)(evt->job);
		if(!srv_da_does_job_exist(job))
			return MMI_TRUE;
	}
	#ifdef __MMI_ASM_OOM_AUTO_KILL__
    mmi_frm_asm_set_app_priority(VAPP_BROWSER, 0);
	#endif
    VfxAppLauncherParam launchParam(VAPP_DLAGENT, VFX_OBJ_CLASS_INFO(VappDLAgentApp), GRP_ID_ROOT);
	launchParam.setArgument(arg, sizeof (vapp_da_app_launch_struct));
    launchParam.setLauncherResultCb(vapp_dla_app_launch_callback, NULL);
    VfxAppLauncher::launchEx(launchParam);
	return MMI_TRUE;
}

extern "C" void vapp_da_app_launch(void *arg)
{
	ASSERT(arg != NULL);
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    vapp_da_app_launch_struct  *appLauncher = (vapp_da_app_launch_struct*)arg;
	vapp_da_app_launch_struct  *launcher = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* TODO: check for re-enterance cases */
#ifdef __MMI_USB_SUPPORT__
		if (srv_usb_is_in_mass_storage_mode())
		{
			vapp_usb_unavailable_popup(0);
			return;
		}
#endif /* __MMI_USB_SUPPORT__ */

	if (!srv_mode_switch_is_network_service_available()
		&& appLauncher->type != SRV_DA_APP_LAUNCH_NEW_DOWNLOAD
	)
	{
		//__OP01__ is for CMCC compile option
		//WiFi still can't be turned on in flight mode in CMCC project
#ifndef __OP01__
		if(srv_dtcnt_wlan_status() == SRV_DTCNT_WLAN_STATUS_INACTIVE)
		{
#endif
		mmi_frm_nmgr_balloon(
			MMI_SCENARIO_ID_GENERAL,
			MMI_EVENT_INFO_BALLOON,
			MMI_NMGR_BALLOON_TYPE_FAILURE,
			(WCHAR*)(VFX_WSTR_RES(VAPP_STR_DLA_FLIGHT_MODE_ACTIVE).getBuf()));
		return;
#ifndef __OP01__
		}
#endif
	}
	if(launcherRecord != NULL)
	{
		mmi_frm_nmgr_cancel_deferred_scenario(MMI_SCENARIO_ID_DEFAULT, vapp_da_notify_app_launch, (void *)launcherRecord);
		free_ctrl_buffer(launcherRecord);
		launcherRecord = NULL;
	}
		
	if(launcherArgRecord != NULL)
	{
		free_ctrl_buffer(launcherArgRecord);
		launcherArgRecord = NULL;
	}

	launcher = (vapp_da_app_launch_struct*)get_ctrl_buffer(sizeof(vapp_da_app_launch_struct));
	memcpy(launcher, appLauncher, sizeof(vapp_da_app_launch_struct));
	launcher->arg = (void *)get_ctrl_buffer(launcher->argSize);
	memcpy(launcher->arg, appLauncher->arg, launcher->argSize);
	launcherRecord = launcher;
	launcherArgRecord = launcher->arg;
	mmi_frm_nmgr_notify_by_app(MMI_SCENARIO_ID_DEFAULT,
		                       MMI_EVENT_DEFAULT,
		                       vapp_da_notify_app_launch,
		                       (void *)launcher);
}


extern "C"  MMI_ID vapp_dla_app_launch_ext(void* param, U32 param_size)
{
#ifdef __MMI_USB_SUPPORT__
    if (srv_usb_is_in_mass_storage_mode())
    {
        vapp_usb_unavailable_popup(0);
        return MMI_RET_OK;
    }
#endif /* __MMI_USB_SUPPORT__ */
	    /* check if any network is available or not */
    if (!srv_mode_switch_is_network_service_available())
    {
		
#ifndef __OP01__
		if(srv_dtcnt_wlan_status() == SRV_DTCNT_WLAN_STATUS_INACTIVE)
		{
#endif
        mmi_frm_nmgr_balloon(
            MMI_SCENARIO_ID_GENERAL,
            MMI_EVENT_INFO_BALLOON,
            MMI_NMGR_BALLOON_TYPE_FAILURE,
            (WCHAR*)(VFX_WSTR_RES(VAPP_STR_DLA_FLIGHT_MODE_ACTIVE).getBuf()));
        return MMI_RET_OK;
#ifndef __OP01__
		}
#endif
    }
    vapp_da_app_launch_struct  app_launch;
    srv_da_display_job_list_event_struct  evt;
    evt.job = NULL;
    app_launch.type = SRV_DA_APP_LAUNCH_DOWNLOADING_LIST;    
    app_launch.arg = (void*)&evt;    
    if (m_DLAgentAppID)
    {
        VAppDLAgentInterface::OnServiceCallback ((void*)&app_launch);
        return MMI_RET_OK;
    }
    app_launch.argSize = sizeof (srv_da_display_job_list_event_struct);
	#ifdef __MMI_ASM_OOM_AUTO_KILL__
    mmi_frm_asm_set_app_priority(VAPP_BROWSER, 0);
	#endif
    vapp_da_app_launch ((void*)&app_launch);
	return MMI_RET_OK;
}

extern "C"  mmi_ret vapp_dla_app_launch_proc(mmi_event_struct *param)
{
	return MMI_RET_DONT_CARE;
}
