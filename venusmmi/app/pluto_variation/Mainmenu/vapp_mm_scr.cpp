/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  
 *
 * Project:
 * --------
 *  Venus
 *
 * Description:
 * ------------
 *  Internal UI componets of home screen
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * Include
 *****************************************************************************/
#include "MMI_features.h"

#include "vapp_mm_scr.h"
#include "vcp_page_menu_util.h"
#include "vcp_status_icon_bar.h"

#include "vrt_datatype.h"
#include "vfx_cpp_base.h"
#include "vfx_datatype.h"
#include "vcp_matrix.h"
#include "vfx_string.h"
#include "vfx_rect_frame.h"
#include "vcp_app_scr.h"
#include "vfx_app_cat_scr.h"
#include "vfx_sys_memory.h"
#include "vfx_object.h"
#include "vfx_basic_type.h"
#include "vrt_system.h"
#include "GUI/vadp_p2v_theme_info.h"
#include "vcp_softkey.h"
#include "vcp_shortcut.h"
#include "vcp_title_bar.h"
#include "vfx_signal.h"
#include "vfx_input_event.h"
#include "vfx_keypad.h"
#include "vfx_auto_animate.h"
#include "vfx_async_signal.h"
#include "vcp_normal_mode_menu.h"
#include "vcp_fancy_mode_menu.h"
#include "mmi_rp_app_mainmenu_def.h"
#include "vcp_option_menu.h"
#include "vfx_frame.h"
#include "vfx_image_src.h"
#include "vfx_primitive_frame.h"
#include "vcp_page_menu_util.h"
#ifdef __cplusplus
extern "C"
#endif
{
#include "kal_general_types.h"	
#include "mmi_rp_app_mainmenu_def.h"
#include "wgui_categories_list.h"
#include "kal_public_api.h"
#include "kal_general_types.h"

#ifdef __MMI_SCREEN_SWITCH_EFFECT__
#include "gui_effect_oem.h"
    extern void gui_screen_switch_effect_setup_MM(void);
#endif
    
    extern void (*MMI_main_menu_lsk_handler) (void);
    extern void (*MMI_main_menu_rsk_handler) (void);
	extern void vadp_v2p_3d_main_menu_write_record(VfxU8* menu_order);
#ifdef __cplusplus
}
#endif
#ifdef __MMI_VUI_MAINMENU__
/***************************************************************************** 
 * Define
 *****************************************************************************/

/***************************************************************************** 
 * Global Function
 *****************************************************************************/
VfxBool VappMmScr::s_isLeaveScreenByUser = VFX_FALSE;

VappMmScr::VappMmScr(VfxU16* string_id, VfxU16* iconId, VfxS32 highlight_id, VfxU8* menuOrder, VfxU8 Style):
    m_matrix(NULL),
    m_softkeybar(NULL),
    m_titleFrame(NULL),
    m_theme(NULL),
    m_shortcut(NULL)
{
    for (VfxU32 i = 0; i < VcpSimpleMatrix::TOTAL_ITEMS; i++)
    {
        m_stringID[i] = string_id[i];
        m_iconID[i] = iconId[i];
        m_menuOrder[i] = menuOrder[i];
    }
    m_highlightID = highlight_id;
    m_highlightEffect = Style;
}

void VappMmScr::onInit()
{
    vrt_size_struct main_screen_size;
    VfxColorTypeEnum main_screen_color_format;
#if defined (VAPP_MM_SHOW_STATUS_ICON_BAR)
    VcpStatusIconBar *status_icon_bar;    
#endif
    VfxU32 i, j, k = 0;
	VfxImageSrc p[VcpSimpleMatrix::TOTAL_ITEMS];
    VfxWString text[VcpSimpleMatrix::TOTAL_ITEMS];
    VfxRectFrame *bg;
    
    VcpAppScr::onInit();

    // Setup major child components
    VFX_OBJ_CREATE(bg, VfxRectFrame, this);
    bg->setPos(VfxPoint(0, 0));
    vrt_sys_get_main_screen_info(
        &main_screen_size, 
        &main_screen_color_format);
    bg->setBounds(VfxRect(VFX_POINT_ZERO, main_screen_size));
#if defined (VAPP_MM_SHOW_STATUS_ICON_BAR)
    VFX_OBJ_CREATE(status_icon_bar, VcpStatusIconBar, this);
#endif
    VFX_OBJ_CREATE(m_theme, VadpTheme, this);	
    VFX_OBJ_CREATE(m_matrix, VcpSimpleMatrix, this);
    VFX_OBJ_CREATE(m_softkeybar, VcpSoftkey, this);	
    VFX_OBJ_CREATE(m_shortcut, VcpShortcut, this);
#ifdef VCP_SIMPLE_MATRIX_WITH_TITLE
    VFX_OBJ_CREATE(m_titleFrame, VcpPlutoTitleBar, this);
#endif
    
    vrt_sys_get_main_screen_info(
        &main_screen_size, 
        &main_screen_color_format);
    m_softkeybar->setPos(VfxPoint(0, main_screen_size.height - SOFTKEY_HEIGHT));
    m_matrix->setPos(VfxPoint(0, STATUS_ICON_BAR_HEIGHT + TITLE_HEIGHT));
    main_screen_size.height -= STATUS_ICON_BAR_HEIGHT + SOFTKEY_HEIGHT + TITLE_HEIGHT;
    m_matrix->setBounds(VfxRect(VFX_POINT_ZERO, main_screen_size));
    
    m_softkeybar->getCallback(VCP_SOFTKEY_LSK).connect(this, &VappMmScr::onEventLsk);
    m_softkeybar->getCallback(VCP_SOFTKEY_RSK).connect(this, &VappMmScr::onEventRsk);
    //m_softkeybar->hideSoftkey(VCP_SOFTKEY_CSK);
    m_softkeybar->getCallback(VCP_SOFTKEY_CSK).connect(this, &VappMmScr::onEventLsk);
    m_softkeyState = VCP_MATRIX_SOFTKEY_ENABLED;
    
    setIsOpaque(VFX_TRUE);
    
    bg->setFilledArea(m_theme->GetFiller(VadpTheme::MAIN_MENU_BKG_FILLER));
    bg->setIsCached(VFX_TRUE);
    bg->setIsOpaque(VFX_TRUE);
    // Set opaque background color because VRT can use the information for optimization
    bg->setBgColor(VFX_COLOR_BLACK);    
    
    m_shortcut->m_input.connect(m_matrix, &VcpSimpleMatrix::onEventinput);
    m_shortcut->m_keydown.connect(m_matrix, &VcpSimpleMatrix::onStopDrag);
    
#ifdef VCP_SIMPLE_MATRIX_WITH_TITLE
    //m_titleFrame->setFont(s_font);
    m_titleFrame->setPos(VfxPoint(0, STATUS_ICON_BAR_HEIGHT));
    m_titleFrame->setBounds(VfxRect(VFX_POINT_ZERO, 
        VfxSize(main_screen_size.width, TITLE_HEIGHT)));
    //m_titleFrame->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
    //m_titleFrame->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
    m_matrix->m_signalTitleChanged.connect(this, &VappMmScr::onTitleChanged);
    m_matrix->m_signalTitleChangedNoRedraw.connect(this, &VappMmScr::onTitleChangedNoRedraw);
#if defined(VAPP_MM_SHOW_INTEGRATED_TITLE)
    m_titleFrame->enableIntegrateTitle(VFX_TRUE);
#endif
#endif /* VCP_SIMPLE_MATRIX_WITH_TITLE */
    
    // Setup key handler
    
    VfxKeypad::registerHandler(VFX_KEY_CODE_SPECIAL_ALL_ARROW, m_matrix);
    VfxKeypad::registerHandler(VFX_KEY_CODE_VOL_UP, m_matrix);
    VfxKeypad::registerHandler(VFX_KEY_CODE_VOL_DOWN, m_matrix);
    //VfxKeypad::registerHandler(VFX_KEY_CODE_ENTER, m_matrix);
    VfxKeypad::registerHandler(VFX_KEY_CODE_SPECIAL_ALL_NUMBER, m_shortcut);
    VfxKeypad::registerHandler(VFX_KEY_CODE_STAR, m_shortcut);
    VfxKeypad::registerHandler(VFX_KEY_CODE_POUND, m_shortcut);

    // Setup matrix
    
    for (i = 0; i < VcpSimpleMatrix::TOTAL_ITEMS; i++)
    {
        m_matrix->m_menuOrder[i] = m_menuOrder[i];
        m_matrix->m_menuPreOrder[i] = m_menuOrder[i];
    }
    m_matrix->setRowsColumns(MAX_ROWS, MAX_COLUMNS);
    if (m_highlightID == -1)
    {
        m_matrix->changeCurrentHighlightIndex(((MAX_ROWS / 2 + (MAX_ROWS % 2) - 1) * MAX_COLUMNS) + MAX_COLUMNS / 2 + (MAX_COLUMNS % 2) - 1);
    }
    else
    {
        m_matrix->changeCurrentHighlightIndex(m_highlightID);
    }
    
    for (i = 0; i < MAX_ROWS; i++)
    {
        for (j = 0; j < MAX_COLUMNS; j++)
        {
			p[k] = VfxImageSrc(m_iconID[k]);
            m_matrix->setItemImage(i, j, p[k]);
            
            text[k] = VFX_WSTR_RES(m_stringID[k]);
            m_matrix->setItemString(i, j, text[k]);
            k++; 
        }
    }
    m_matrix->m_highlightEffect = m_highlightEffect;

    m_matrix->m_signalLSK.connect(this, &VappMmScr::onEventLsk);
    m_matrix->m_signalSoftkeyStateChanged.connect(this, &VappMmScr::onSoftkeyStateChanged);
}


void VappMmScr::onDeinit()
{
    VcpAppScr::onDeinit();

    s_isLeaveScreenByUser = VFX_FALSE;        
}


VfxBool VappMmScr::onEntryEffectIsDisabled()
{
    if (VcpAppScr::onEntryEffectIsDisabled())
    {
        return VFX_TRUE;
    }
#ifdef MT6225 
    /* Not supported on MT6225 */    
    return VFX_TRUE;
#else /* MT6225 */
    if (!m_isBackFromHistory /* From Idle to Main Menu */ || 
        s_isLeaveScreenByUser /* Go back history from sub menu */)
    {
        return VFX_FALSE;
    }
    else
    {
        return VFX_TRUE;
    }
#endif /* MT6225 */
}


void VappMmScr::onEntryEffectInit()
{
    VcpAppScr::onEntryEffectInit();
    m_matrix->initEntryAnimation();

    // No auto animation 
    VfxPoint pos = m_softkeybar->getPos();
    pos.y += SOFTKEY_HEIGHT;
    m_softkeybar->setPos(pos);

    // Enable auto animation 
    m_softkeybar->setAutoAnimate(VFX_TRUE);    
}


void VappMmScr::onEntryEffectStart()
{
    VcpAppScr::onEntryEffectStart();
    m_matrix->startEntryAnimation();
    
    VfxAutoAnimate::initAnimateBegin();
    VfxAutoAnimate::begin(); 
    VfxAutoAnimate::setDuration(VcpSimpleMatrix::ENTRY_ANIMATION_INTERVAL + VcpSimpleMatrix::ENTRY_ANIMATION_INTERVAL2);
    VfxPoint pos = m_softkeybar->getPos();
    pos.y -= SOFTKEY_HEIGHT;
    m_softkeybar->setPos(pos);    
    VfxAutoAnimate::commit();    
    VfxAutoAnimate::initAnimateEnd();
}


void VappMmScr::onSoftkeyStateChanged(VcpMatrixSoftkeyState softkeyState)
{
    if (m_softkeyState != softkeyState)
    {
        if (m_softkeyState == VCP_MATRIX_SOFTKEY_DISABLED)
        {
            m_softkeybar->disableSoftkey(VFX_FALSE);
        }
        else if (softkeyState == VCP_MATRIX_SOFTKEY_DISABLED)
        {
            m_softkeybar->disableSoftkey(VFX_TRUE);
        }
    }
    m_softkeyState = softkeyState;
}


void VappMmScr::onEventLsk(VcpSoftkeyEventEnum event_type)
{
    if (event_type == VCP_SOFTKEY_UP && MMI_main_menu_lsk_handler)
    {
        switch (m_softkeyState)
        {
        case VCP_MATRIX_SOFTKEY_ENABLED:
            m_softkeybar->disableSoftkey(VFX_TRUE); // avoid click the softkey twice before async vfxPostInvoke() is executed
            m_softkeyState = VCP_MATRIX_SOFTKEY_DISABLED;
            vfxPostInvoke(this, &VappMmScr::handleLsk);
            break;

        case VCP_MATRIX_SOFTKEY_RESET:
            m_matrix->resetNormal();
            break;

        case VCP_MATRIX_SOFTKEY_DISABLED:
            /* FALLTHROUGH no break */
        default: 
            VFX_ASSERT(0);
            break;
        }
    }
}

void VappMmScr::onEventRsk(VcpSoftkeyEventEnum event_type)
{
    if (event_type == VCP_SOFTKEY_UP && MMI_main_menu_rsk_handler)
    {
        switch (m_softkeyState)
        {
        case VCP_MATRIX_SOFTKEY_ENABLED:
            m_softkeybar->disableSoftkey(VFX_TRUE); // avoid click the softkey twice before async vfxPostInvoke() is executed
            m_softkeyState = VCP_MATRIX_SOFTKEY_DISABLED;
            vfxPostInvoke(this, &VappMmScr::handleRsk);
            break;

        case VCP_MATRIX_SOFTKEY_RESET:
            m_matrix->resetNormalAndRestore();
            break;
            
        case VCP_MATRIX_SOFTKEY_DISABLED:
            /* FALLTHROUGH no break */
        default: 
            VFX_ASSERT(0);
            break;
        }
    }
}

void VappMmScr::handleLsk(void *data)
{
    VFX_UNUSED(data);
    
#ifdef __MMI_SCREEN_SWITCH_EFFECT__
#ifdef __PLUTO_3D_V10__
    if (m_matrix->m_highlightIndex / 3 == 0)
    {
        gui_sse_setup_scenario(GUI_SSE_SCENARIO_COSMOS_3D_TRIANGLE_ENTER);
    }
    else if (m_matrix->m_highlightIndex / 3 == 1) 
    {
        gui_sse_setup_scenario(GUI_SSE_SCENARIO_COSMOS_3D_CUBE_ENTER);
    }
    else if (m_matrix->m_highlightIndex / 3 == 2) 
    {
        gui_sse_setup_scenario(GUI_SSE_SCENARIO_COSMOS_3D_BRICK_ENTER);
    }
    else 
    {
        gui_sse_setup_scenario(GUI_SSE_SCENARIO_COSMOS_3D_TWIST_ENTER);
    }
#else
    gui_screen_switch_effect_setup_MM();
#endif
#endif

	m_matrix->blockEventInput();
    MMI_main_menu_lsk_handler(); /* VappMmScr::onDeinit() should be invoked here */

    s_isLeaveScreenByUser = VFX_TRUE;    
}

void VappMmScr::handleRsk(void *data)
{
    VFX_UNUSED(data);
    m_matrix->blockEventInput();
    MMI_main_menu_rsk_handler(); /* VappMmScr::onDeinit() should be invoked here */

    s_isLeaveScreenByUser = VFX_TRUE;    
}


void VappMmScr::onTitleChanged(const VfxWString &string)
{
#ifdef VCP_SIMPLE_MATRIX_WITH_TITLE
    if (m_titleFrame->isValid())
    {
        m_titleFrame->changeText(string);
    }
#else
    VFX_UNUSED(string);
#endif
}

void VappMmScr::onTitleChangedNoRedraw(const VfxWString &string)
{
#ifdef VCP_SIMPLE_MATRIX_WITH_TITLE
    if (m_titleFrame->isValid())
    {
        m_titleFrame->changeTextWithNotUpdate(string);
    }
#else
    VFX_UNUSED(string);
#endif
}
#endif /* __MMI_VUI_MAINMENU__*/

#ifdef __MMI_VUI_3D_MAINMENU__
/***************************************************************************** 
 * Define
 *****************************************************************************/
#include "mmi_rp_all_defs.h"
/***************************************************************************** 
 * Global Function
 *****************************************************************************/
void Vapp3DMmScr::CreateNormalMode()
{
	vrt_size_struct main_screen_size;
	VfxColorTypeEnum main_screen_color_format;

	vrt_sys_get_main_screen_info(
        &main_screen_size, 
        &main_screen_color_format);

	VFX_OBJ_CREATE(m_normal, VcpNormalModeMenu, this);
	VFX_OBJ_CREATE(m_normalBuilder, VcpNormalModeMenuBuilder, this);

    m_normalBuilder->setAllAppData(m_entry, m_items);
	m_normalBuilder->setAppOrderData(m_order, VAPP_3D_MAINMENU_ORDER_SIZE);
    m_normalBuilder->loadMenu(m_normal);

	m_normal->setPos(VfxPoint(0, STATUS_ICON_BAR_HEIGHT));
	main_screen_size.height -= STATUS_ICON_BAR_HEIGHT + SOFTKEY_HEIGHT;
    VcpPageMenuLayout layout = m_normal->getMenuLayout();
    layout.cellStartY = NORMAL_OFFSET_Y;
    m_normal->setMenuLayout(layout);
    m_normal->setBounds(VfxRect(VFX_POINT_ZERO, main_screen_size));
	m_normal->setCurrentPageIndex(m_curr_page, VFX_FALSE);
	m_normal->m_appClicked.connect(this, &Vapp3DMmScr::onAppClicked);
	m_normal->m_organizationChanged.connect(this, &Vapp3DMmScr::onOrganizationChanged);
	m_normal->m_pageChanged.connect(this, &Vapp3DMmScr::onPageChanged);
}

#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
void Vapp3DMmScr::CreateFancyMode()
{
	vrt_size_struct main_screen_size;
	VfxColorTypeEnum main_screen_color_format;

	vrt_sys_get_main_screen_info(
        &main_screen_size, 
        &main_screen_color_format);


	VFX_OBJ_CREATE(m_fancy, VcpFancyModeMenu, this);
    m_fancy->setPos(VfxPoint(0, STATUS_ICON_BAR_HEIGHT));
    main_screen_size.height -= STATUS_ICON_BAR_HEIGHT + SOFTKEY_HEIGHT;
    m_fancy->setBounds(VfxRect(VFX_POINT_ZERO, main_screen_size));
    m_fancy->setAllAppData(m_entry, m_items);
	m_fancy->m_appClicked.connect(this, &Vapp3DMmScr::onAppClicked);
}

void Vapp3DMmScr::EnterFancyMode(VfxU8 style, VfxBool IsAnim)
{
	VcpFancyModeMenuType fancy_style = VCP_FANCY_MODE_MENU_NULL;

	if(!IsAnim)
	{
		m_fancy->setFocus(m_focus);
	}	
	switch(style)
	{
		case TWIST_STYLE:
			fancy_style = VCP_FANCY_MODE_MENU_TORNADO;
			break;
		case SPACE_STYLE:
			fancy_style = VCP_FANCY_MODE_MENU_SPACE_BEAM;
			break;
		default:
			break;
	}

	m_fancy->enter(fancy_style, m_order, VAPP_3D_MAINMENU_ORDER_SIZE, 10, m_curr_index, IsAnim);
}
void Vapp3DMmScr::onFancyModeLeave(void)
{
	//VfxImage *LskImg;
	//VFX_OBJ_CREATE(LskImg, VfxImage, this);

	VFX_OBJ_CLOSE(m_fancy);
	CreateNormalMode();
	m_normal->setHidden(VFX_FALSE);
	m_mode = NORMAL_MODE;
	// softkey
	//LskImg->setResId(MAIN_MENU_3D_NORMAL_SOTKEY_ICON);
	m_softkeybar->setSoftkey(VCP_SOFTKEY_LSK, VFX_WSTR_NULL, VfxImageSrc(MAIN_MENU_3D_NORMAL_SOTKEY_ICON));
	m_softkeybar->hideSoftkey(VCP_SOFTKEY_CSK);

	Isblocking = VFX_FALSE;
}

void Vapp3DMmScr::CloseFancyMode(VfxU8 style)
{
	Isblocking = VFX_TRUE;
	m_fancy->m_signalLeaveFinished.connect(this, &Vapp3DMmScr::onFancyModeLeave);
	m_fancy->leave();

}

void Vapp3DMmScr::onFancyModeFinish(void)
{
	//VfxImage *LskImg, *CskImg;
	//VFX_OBJ_CREATE(LskImg, VfxImage, this);
	//VFX_OBJ_CREATE(CskImg, VfxImage, this);

	Isblocking = VFX_FALSE;
	//LskImg->setResId(MAIN_MENU_3D_FANCY_SOTKEY_ICON);
	m_softkeybar->setSoftkey(VCP_SOFTKEY_LSK, VFX_WSTR_NULL, VfxImageSrc(MAIN_MENU_3D_FANCY_SOTKEY_ICON));
	//CskImg->setResId(MAIN_MENU_3D_SETTING_SOFKTY_ICON);
	m_softkeybar->setSoftkey(VCP_SOFTKEY_CSK, VFX_WSTR_NULL, VfxImageSrc(MAIN_MENU_3D_SETTING_SOFKTY_ICON));
	m_softkeybar->unhideSoftkey(VCP_SOFTKEY_CSK);
}
#endif /* __MMI_VUI_3D_MAINMENU_FANCY__ */

void Vapp3DMmScr::writeMenuOrder(void)
{
	VfxU8 nvram_buf[NVRAM_EF_VENUS_3D_MM_SIZE];

    for (VfxU16 i = 0; i < NVRAM_EF_VENUS_3D_MM_SIZE; i++)
    {
		if(m_order[i] == 0xFFFFFFFF)
		{
			nvram_buf[i] = 0xFF;
		}
		else
		{
			nvram_buf[i] = m_order[i];
		}
    }
	vadp_v2p_3d_main_menu_write_record(nvram_buf);
}

void Vapp3DMmScr::handleLsk(void *data)
{
	//VfxImage *LskImg, *CskImg;
	//VFX_OBJ_CREATE(LskImg, VfxImage, this);
	//VFX_OBJ_CREATE(CskImg, VfxImage, this);

	VFX_UNUSED(data);
	switch(m_mode)
	{
		case NORMAL_MODE:
			if(m_organizer)
			{
				m_normal->leaveOrganizationMode();
                m_normalBuilder->saveMenu(m_normal);
				writeMenuOrder();
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
				m_softkeybar->setSoftkey(VCP_SOFTKEY_LSK, VFX_WSTR_NULL, VfxImageSrc(MAIN_MENU_3D_NORMAL_SOTKEY_ICON));
#else
				m_softkeybar->setSoftkey(VCP_SOFTKEY_LSK, VFX_WSTR_NULL, VfxImageSrc(0));
#endif
				//m_softkeybar->setSoftkey(VCP_SOFTKEY_LSK, VFX_WSTR_NULL, VfxImageSrc(MAIN_MENU_3D_NORMAL_SOTKEY_ICON));
				m_organizer = VFX_FALSE;
			}
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
			else
			{
				m_curr_index = m_normal->getCurrentAppIndex();
				m_curr_page = m_normal->getCurrentPageIndex();
				VFX_OBJ_CLOSE(m_normal);
                VFX_OBJ_CLOSE(m_normalBuilder);
				CreateFancyMode();
				EnterFancyMode(m_style, VFX_TRUE);
				m_fancy->m_signalEnterFinished.connect(this, &Vapp3DMmScr::onFancyModeFinish);
				m_mode = FANCY_MODE;
				Isblocking = VFX_TRUE;
			}
#endif
			break;
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
		case FANCY_MODE:
			CloseFancyMode(m_style);
			break;
#endif
		default:
				break;

	}
}

void Vapp3DMmScr::onEventLsk(VcpSoftkeyEventEnum event_type)
{
	if(Isblocking)
		return;
    if (event_type == VCP_SOFTKEY_UP)
    {
		vfxPostInvoke(this, &Vapp3DMmScr::handleLsk);
	}
}

void Vapp3DMmScr::handleRsk(void *data)
{
	VFX_UNUSED(data);
	if((m_organizer)&&(m_mode == NORMAL_MODE))
	{
		m_normal->leaveOrganizationMode();
        m_normalBuilder->loadMenu(m_normal);
		m_organizer = VFX_FALSE;
		//VfxImage *LskImg;
		VfxResId imageId;
		
		//VFX_OBJ_CREATE(LskImg, VfxImage, this);
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
		imageId = MAIN_MENU_3D_NORMAL_SOTKEY_ICON;
		//LskImg->setResId(MAIN_MENU_3D_NORMAL_SOTKEY_ICON);
#else
		imageId = 0;
		//LskImg->setResId(0);
#endif
		m_softkeybar->setSoftkey(VCP_SOFTKEY_LSK, VFX_WSTR_NULL, VfxImageSrc(imageId));
	}
	else if(MMI_main_menu_rsk_handler)
		MMI_main_menu_rsk_handler();
}

void Vapp3DMmScr::onEventRsk(VcpSoftkeyEventEnum event_type)
{
	if(Isblocking)
		return;
    if (event_type == VCP_SOFTKEY_UP)
    {
		vfxPostInvoke(this, &Vapp3DMmScr::handleRsk);

    }
}
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
void Vapp3DMmScr::onEventCsk(VcpSoftkeyEventEnum event_type)
{
	if(Isblocking)
		return;
    if (event_type == VCP_SOFTKEY_UP)
    {
		if(m_mode == FANCY_MODE)
		{
			CreateOptionList();
		}
    }
}
#endif
void Vapp3DMmScr::onAppClicked(VfxS32 index)
{
	 FuncPtr launch = m_launch[index];

	 if(launch != NULL)
     {
#ifdef __MMI_SCREEN_SWITCH_EFFECT__
		gui_screen_switch_effect_setup_MM();
#endif
		 launch();
     }
}
void Vapp3DMmScr::onPageChanged(VfxS32 index)
{
	m_curr_page = index;
}
void Vapp3DMmScr::onOrganizationChanged(VfxBool isOrganization)
{

	if(isOrganization)
	{
	    m_organizer = VFX_TRUE;
		//VfxImage *LskImg;
		//VFX_OBJ_CREATE(LskImg, VfxImage, this);
		//LskImg->setResId(MAIN_MENU_3D_ORGANIZER_SOTKEY_ICON);
		m_softkeybar->setSoftkey(VCP_SOFTKEY_LSK, VFX_WSTR_NULL, VfxImageSrc(MAIN_MENU_3D_ORGANIZER_SOTKEY_ICON));
	}
}

void Vapp3DMmScr::onInit()
{
	vrt_size_struct main_screen_size;
	VfxColorTypeEnum main_screen_color_format;
	VcpStatusIconBar *status_icon_bar;
	//VfxImageFrame *softkeyBkg;
	//VfxImage *LskImg, *RskImg, *CskImg;
	VfxResId LskImg, RskImg, CskImg;

	VcpAppScr::onInit();
	vrt_sys_get_main_screen_info(
        &main_screen_size, 
        &main_screen_color_format);

    setBgColor(VFX_COLOR_TRANSPARENT);
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
	VFX_ALLOC_MEM(m_menuItems, sizeof(VcpOptionMenuItem*) * 2, this);
#endif
// background
    VFX_OBJ_CREATE(m_bg, VfxFrame, this);
    m_bg->setImgContent(VfxImageSrc(MAIN_MENU_3D_BG_IMG));
    vcpPageMenuApplyFrameRenderHints(m_bg);
	m_bg->setPos(VfxPoint(0, 0));
    m_bg->setBounds(VfxRect(VFX_POINT_ZERO, main_screen_size));
    m_bg->setOpaqueMode(VFX_FRAME_OPAQUE_MODE_FULLY_OPAQUE);

// status icon bar
	VFX_OBJ_CREATE(status_icon_bar, VcpStatusIconBar, this);
    vcpPageMenuApplyFrameRenderHints(status_icon_bar);

// softkey
	VFX_OBJ_CREATE(m_softkeybar, VcpSoftkey, this);
	m_softkeybar->setPos(VfxPoint(0, main_screen_size.height - SOFTKEY_HEIGHT));
	m_softkeybar->setBounds(VfxRect(0, 0, main_screen_size.width, SOFTKEY_HEIGHT));
    m_softkeybar->getCallback(VCP_SOFTKEY_LSK).connect(this, &Vapp3DMmScr::onEventLsk);
    m_softkeybar->getCallback(VCP_SOFTKEY_RSK).connect(this, &Vapp3DMmScr::onEventRsk);
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
    m_softkeybar->getCallback(VCP_SOFTKEY_CSK).connect(this, &Vapp3DMmScr::onEventCsk);
#endif
// 3D main menu

	//VFX_OBJ_CREATE(LskImg, VfxImage, m_softkeybar);
	//VFX_OBJ_CREATE(RskImg, VfxImage, m_softkeybar);
	//VFX_OBJ_CREATE(CskImg, VfxImage, m_softkeybar);
	RskImg = MAIN_MENU_3D_CANCEL_SOTKEY_ICON;
#ifndef __MMI_VUI_3D_MAINMENU_FANCY__
	m_mode = NORMAL_MODE;
#endif
	if(m_mode == NORMAL_MODE)
	{
		CreateNormalMode();
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
		LskImg = MAIN_MENU_3D_NORMAL_SOTKEY_ICON;
#else
		LskImg= 0
#endif
	}
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
	if(m_mode == FANCY_MODE)
	{
		CreateFancyMode();
		EnterFancyMode(m_style, VFX_FALSE);
		//LskImg->setResId(MAIN_MENU_3D_FANCY_SOTKEY_ICON);
		LskImg = MAIN_MENU_3D_FANCY_SOTKEY_ICON;
		CskImg = MAIN_MENU_3D_SETTING_SOFKTY_ICON;
		m_softkeybar->setSoftkey(VCP_SOFTKEY_CSK, VFX_WSTR_NULL, VfxImageSrc(CskImg));

	}
#endif

	m_softkeybar->setSoftkey(VCP_SOFTKEY_LSK, VFX_WSTR_NULL, VfxImageSrc(LskImg));
	m_softkeybar->setSoftkey(VCP_SOFTKEY_RSK, VFX_WSTR_NULL, VfxImageSrc(RskImg));
	
	m_softkeybar->setSoftkeyWidth(VCP_SOFTKEY_LSK, SOFTKEY_WIDTH);
	m_softkeybar->setSoftkeyWidth(VCP_SOFTKEY_RSK, SOFTKEY_WIDTH);
	m_softkeybar->setSoftkeyWidth(VCP_SOFTKEY_CSK, SOFTKEY_WIDTH);

	VfxImageFrame *softkeyBkg;
    VFX_OBJ_CREATE(softkeyBkg, VfxImageFrame, m_softkeybar);
    softkeyBkg->setIsCached(VFX_TRUE);
	softkeyBkg->setResId(MAIN_MENU_3D_SOTKEY_BAR_BG);
	softkeyBkg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
	softkeyBkg->setPos(VfxPoint(0, 0));
	softkeyBkg->setBounds(VfxRect(0, 0, main_screen_size.width, SOFTKEY_HEIGHT));
	m_softkeybar->setSoftkeyBarBackground(softkeyBkg);

	VfxKeypad::registerHandler(VFX_KEY_CODE_SPECIAL_ALL_ARROW, this);

}

VfxBool Vapp3DMmScr::onKeyInput(VfxKeyEvent &event)
{
	VfxS32 page_count;

	if((m_mode == FANCY_MODE) || (m_organizer) || (Isblocking))
		return VFX_FALSE;
	if ((event.type == VFX_KEY_EVENT_TYPE_DOWN) || (event.type == VFX_KEY_EVENT_TYPE_REPEAT))
	{
		switch (event.keyCode)
		{
			case VFX_KEY_CODE_ARROW_LEFT:
					//m_curr_page
					page_count = m_normal->getPageCount();
					m_curr_page --;
					if(m_curr_page < 0)
					{
						m_curr_page = page_count - 1;
					    m_normal->setCurrentPageIndex(m_curr_page, VFX_FALSE);
					}
					else
					{
						m_normal->setCurrentPageIndex(m_curr_page, VFX_TRUE);
					}
					return VFX_TRUE;
					break;
			case VFX_KEY_CODE_ARROW_RIGHT:
					page_count = m_normal->getPageCount();
					m_curr_page ++;
					if(m_curr_page > (page_count - 1))
					{
						m_curr_page = 0;
					    m_normal->setCurrentPageIndex(m_curr_page, VFX_FALSE);
					}
					else
					{
						m_normal->setCurrentPageIndex(m_curr_page, VFX_TRUE);
					}
					return VFX_TRUE;
					break;
			default:
				return VFX_FALSE;
					break;

		}
	}
	return VFX_FALSE;
}
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
void Vapp3DMmScr::onCandidateListSel(VcpOptionMenu *sender, VcpOptionMenu::VcpOptionMenuEventEnum evt, VcpOptionMenuItem *item)
{

	if (sender == m_fancyList)
	{
		 if (evt == VcpOptionMenu::VCP_OPTION_MENU_EVENT_ITEM_SELECTED)
		 {
			if((m_menuItems[0] == item) && (m_style == SPACE_STYLE))
			{
				m_style = TWIST_STYLE;
				IsChanged = VFX_TRUE;
			}
			else if((m_menuItems[1] == item) && (m_style == TWIST_STYLE))
			{
				m_style = SPACE_STYLE;
				IsChanged = VFX_TRUE;
			}
		 }
		 else if (evt == VcpOptionMenu::VCP_OPTION_MENU_EVENT_MENU_CLOSE)
		 {
            //freeMemory(m_menuItems);
            m_fancyList = NULL;
			if(IsChanged)
			{
				VFX_OBJ_CLOSE(m_fancy);
				m_focus = -1; // switch fancy mode. fancy all reset.
				CreateFancyMode();
				EnterFancyMode(m_style, VFX_FALSE);
				m_fancy->setHidden(VFX_FALSE);
			}
			IsChanged = VFX_FALSE;
         }
	}
}

void Vapp3DMmScr::CreateOptionList()
{
	VfxBool TwistState = VFX_FALSE;
	VfxBool SpaceState = VFX_FALSE;

	VFX_OBJ_CREATE(m_fancyList, VcpOptionMenu, this);
	m_fancyList->setTitle(VFX_WSTR_RES(MAIN_MENU_FANCY_SETTINGS));
    m_fancyList->setIsAutoClose(VFX_TRUE);
    m_fancyList->setIsAutoCancel(VFX_TRUE);
	m_fancyList->m_signalMenuCallback.connect(this, &Vapp3DMmScr::onCandidateListSel);

	if(m_style == TWIST_STYLE)
	{
		TwistState = VFX_TRUE;
	}
	if(m_style == SPACE_STYLE)
	{
		SpaceState = VFX_TRUE;
	}
	m_menuItems[0] = m_fancyList->createRadioMenuItem(
                            0,
                            VFX_WSTR_RES(MAIN_MENU_TORNADO),
							TwistState);					
    m_fancyList->appendItem(NULL, m_menuItems[0]);
    m_menuItems[1] = m_fancyList->createRadioMenuItem(
                            1,
                            VFX_WSTR_RES(MAIN_MENU_SPACE_BEAM),
							SpaceState);
    m_fancyList->appendItem(NULL, m_menuItems[1]);

	m_fancyList->showMenu();

}
#endif /* __MMI_VUI_3D_MAINMENU_FANCY__ */

Vapp3DMmScr::Vapp3DMmScr(VfxU16 n_items, AppEntry *app_info, FuncPtr *launch_table, VfxU8 *order, VfxS32 curr_page, VfxU8 mode, VfxU8 style, VfxU8 index, VfxS32 focus)
{
	m_items = n_items;
	m_curr_page = curr_page;
	m_mode = mode;
	m_style = style;
	m_organizer = VFX_FALSE;
	m_curr_index = 0;
	m_normal = NULL;
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
	m_fancyList = NULL;
	m_menuItems= NULL;
	m_fancy = NULL;
#endif
	IsChanged = VFX_FALSE;
	m_curr_index = index;
	m_focus = focus;
	Isblocking = VFX_FALSE;

	for(int i = 0; i<n_items; i++)
	{
		m_entry[i] = app_info[i];
		m_launch[i] = launch_table[i];
	}
	for(int j = 0; j<VAPP_3D_MAINMENU_ORDER_SIZE; j++)
	{
		if(order[j] == 0xFF)
		{
			m_order[j] = 0xFFFFFFFF;
		}
		else
		{
			m_order[j] = (VfxS32)order[j];
		}
	}

}

void Vapp3DMmScr::onDeinit()
{
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
	VFX_FREE_MEM(m_menuItems);
#endif
    VcpAppScr::onDeinit();
    
}

VfxS32 Vapp3DMmScr::getCurrentPageIndex()
{
	if(m_normal != NULL)
	{
		return m_normal->getCurrentPageIndex();
	}
	else
	{
		return m_curr_page;   // m_normal maybe close
	}
}
VfxU8 Vapp3DMmScr::getCurrentAppIndex()
{
	return m_curr_index;
}
VfxS32 Vapp3DMmScr::getCurrentFocusIndex()
{
#ifdef __MMI_VUI_3D_MAINMENU_FANCY__
	if(m_fancy != NULL)
	{
		return m_fancy->getFocus();
	}
#endif
	return m_focus;
}
void Vapp3DMmScr::leaveOrganizationMode(VfxBool saveChanges)
{
	if(m_organizer)
	{
		m_normal->leaveOrganizationMode();
        if (saveChanges)
        {
            m_normalBuilder->saveMenu(m_normal);
        }
        else
        {
            m_normalBuilder->loadMenu(m_normal);
        }
	}
}
#endif
