/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2011
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *  vapp_widget_key_musicplayer.cpp
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "MMI_features.h"

#if defined(__MMI_VUI_WIDGET_KEY_MUSIC_PLAYER__)
#include "vapp_widget_key_musicplayer.h"
#include "vfx_cpp_base.h"
#include "vfx_object.h"
#include "vfx_sys_memory.h" 
#include "vfx_class_info.h"
#include "vfx_control.h"
#include "vfx_datatype.h"
#include "vfx_input_event.h"
#include "vfx_primitive_frame.h"
#include "vfx_basic_type.h"
#include "vfx_signal.h"
#include "vfx_frame.h"  
#include "vfx_draw_context.h"
#include "vrt_system.h"
#include "../app/common/widget/vapp_widget_def.h"
#include "vfx_string.h"
#include "vfx_timer.h"
#include "vfx_weak_ptr.h"
#include "vfx_renderer.h"
#include "vrt_canvas.h"
#include "vrt_datatype.h"
#include "vfx_system.h"
#include "vapp_widget_native_factory.h"


/* Pluto MMI headers: */
#ifdef __cplusplus
extern "C" 
{
#endif
#include "ConnectivityResDef.h"
#ifdef __MMI_USB_SUPPORT__
 #include "USBSrvGProt.h"
#endif
#include "gui_touch_feedback.h"
#include "gui_typedef.h"
#if !defined(__COSMOS_MMI__)
#include "mmi_rp_app_usbmmi_def.h"
#endif
#include "mmi_rp_app_venus_key_wg_musicplayer_def.h"
#if defined(__PLST_SERVICE_DB_SUPPORT__)
#include "mmi_rp_srv_plst_def.h"
#endif
#include "MMIDataType.h"
#include "kal_trace.h"
#include "GlobalResDef.h"
#include "MediaPlayerGProt.h"
#include "MediaPlayerEnumDef.h"
#include "MediaAppWidgetDef.h"
#include "AudioPlayerProt.h"
#include "mdi_datatype.h"
#include "mdi_audio.h"
#include "med_api.h"
#include "meta_tag_api.h"
#include "kal_general_types.h"
#include "mmi_common_app_trc.h"
#include "vapp_widget_key_musicplayer_def.h"
#include "PixcomFontEngine.h"

enum
{
    BUT_PLAY,
    BUT_PREV,
    BUT_NEXT
};

typedef struct
{
	U8 *working_buf_ptr;
    U8 *artwork_image_ptr;
    U8 *g_wg_photo_ptr;
    U8 *g_wg_photo_ptr2;
    U8 *g_active_photo_ptr;
    U8 *filepath; 	
}mmi_keylauncher_widget_music_player;

/*
typedef struct
{
    U32 size;
    U8  mime_type;
} mmi_keylaucher_details_artwork_struct;
*/

mmi_keylauncher_widget_music_player  g_kl_wg_mp;
mmi_keylauncher_widget_music_player  *g_kl_wg_musicplayer = &g_kl_wg_mp;
//mmi_keylaucher_details_artwork_struct  details;
U32 meta_parser_hdlr = 0;


/*
 * Add by Meta parser async interface MMI part
 * ----------- begin ----------
 */
#if defined(__META_DATA_PARSE_API__)

#include "mmi_frm_events_gprot.h"
#include "med_v_struct.h"
#include "meta_tag_parser.h"

#define META_MAX_SEQ_ID 20 

extern kal_eventgrpid meta_tag_event;
extern kal_bool meta_parser_cancel_flag; 
static U32 (*meta_parser_async_callback)(void *user_data,meta_tag_async_type_enum type, U8 result, U32 param);
static void* meta_user_data;
static U32 meta_seq_id;

U32 meta_parser_get_new_seq_id()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (META_MAX_SEQ_ID == meta_seq_id)
    {
        meta_seq_id = 0;
    }
    else
    {
        meta_seq_id++;
    }
    META_TAG_MSG_TRACE(FILE_ID_META_SEQ_ID, meta_seq_id);
    return meta_seq_id;
}


U8 meta_parser_create_async(void* user_data, U8* buffer, U32 buffersize, U32 *handle,
                            U32 (*callback)(void* userdata, meta_tag_async_type_enum type, U8 result, U32 param))
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    META_TAG_MSG_TRACE(FILE_ID_META_TAG_API_ASYNC, meta_parser_cancel_flag);

    meta_parser_cancel_flag = KAL_FALSE;

    if (NULL == callback)
    {
        return META_TAG_ERR_INPUT_PARAM;
    }
    ret = meta_parser_create(buffer, buffersize, handle);
    if (META_TAG_ERR_NONE == ret)
    {
        meta_parser_async_callback = callback;
        meta_user_data = user_data;
        if (!meta_tag_event)
        {
        meta_tag_event = kal_create_event_group("meta_evt");
    }
    }
    return ret;
}


U8 meta_parser_release_async(U32 metaID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    META_TAG_MSG_TRACE(FILE_ID_META_TAG_API_ASYNC, meta_parser_cancel_flag);
    META_TAG_MSG_TRACE(FILE_ID_META_TAG_API_ASYNC, metaID);
    
    meta_parser_async_callback = NULL;
    //if (!meta_tag_event)
    //{
    //    kal_delete_eventgrp(meta_tag_event);
    //    meta_tag_event = 0;
    //}
    return meta_parser_release(metaID);
}


void meta_parser_file_parse_callback_hdlr(void *msg_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    meta_tag_async_info_struct info;
    media_meta_tag_parse_cnf_struct *rsp_p = (media_meta_tag_parse_cnf_struct*)msg_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    META_TAG_MSG_TRACE(FILE_ID_META_TAG_API_ASYNC, rsp_p->type);
    META_TAG_MSG_TRACE(FILE_ID_META_SEQ_ID, rsp_p->seqID);
    if (meta_seq_id != rsp_p->seqID)
    {
        META_TAG_ERR_TRACE(FILE_ID_META_SEQ_ID, meta_seq_id);
        return;
    }
    
    if (META_TAG_ASYNC_TYPE_PARSE == rsp_p->type)
    {
        //already cancel
        if (meta_parser_cancel_flag)
        {
            return;
        }
        if (NULL != meta_parser_async_callback)
        {
            info.audio_info = rsp_p->audio_info;
            info.music_info = rsp_p->music_info;
            info.cover_info = rsp_p->cover_info;
            info.has_image  = rsp_p->has_image;
            if (meta_parser_async_callback)
            {
                meta_parser_async_callback(
                                    meta_user_data, 
                                    (meta_tag_async_type_enum)rsp_p->type, 
                                    (U8)rsp_p->result, 
                                    (U32)&info);
            }
        }
    }
    else
    {
        //ASSERT(meta_parser_cancel_flag);
        if (!meta_parser_cancel_flag)
        {
            META_TAG_ERR_TRACE(FILE_ID_META_TAG_API_ASYNC, meta_parser_cancel_flag);
            return;
        }
        meta_parser_cancel_flag = KAL_FALSE;
        if (meta_parser_async_callback)
        {
            meta_parser_async_callback(
                                meta_user_data, 
                                (meta_tag_async_type_enum)rsp_p->type, 
                                (U8)rsp_p->result, 
                                NULL);
        }
    }
}


U8 meta_parser_file_parse_async(U32 metaID, U16 *filepath, U32 bufSize, U8 *imgBuf)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_meta_tag_parse_req_struct *req_p = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    META_TAG_MSG_TRACE(FILE_ID_META_TAG_API_ASYNC, metaID);
    if (meta_parser_cancel_flag)
    {
        META_TAG_ERR_TRACE(FILE_ID_META_TAG_API_ASYNC, meta_parser_cancel_flag);
        return META_TAG_ERR_HAS_CANELED;
    }
    
    SetProtocolEventHandler(meta_parser_file_parse_callback_hdlr, MSG_ID_MEDIA_META_PARSE_CNF);

    req_p = (media_meta_tag_parse_req_struct*) 
                construct_local_para(sizeof(media_meta_tag_parse_req_struct), TD_CTRL);
    req_p->seqID      = meta_parser_get_new_seq_id();
    req_p->metaID     = metaID;
    req_p->type       = META_TAG_ASYNC_TYPE_PARSE;
    req_p->imgBufSize = bufSize;
    req_p->imgBuf     = imgBuf;
    req_p->filePath   = filepath;
        
    meta_parser_send_ilm(MOD_MED_V, MSG_ID_MEDIA_META_PARSE_REQ, req_p);
    
    META_WAIT_EVENT(META_TAG_EVT_PARSE); 

    return META_TAG_ERR_NONE;
}

U8 meta_parser_file_cancel_async(U32 metaID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_meta_tag_parse_req_struct *req_p = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    META_TAG_MSG_TRACE(FILE_ID_META_TAG_API_ASYNC, metaID);

    if (meta_parser_cancel_flag)
    {
        META_TAG_ERR_TRACE(FILE_ID_META_TAG_API_ASYNC, meta_parser_cancel_flag);
        return META_TAG_ERR_HAS_CANELED;
    }
    meta_parser_cancel_flag = KAL_TRUE;

    SetProtocolEventHandler(meta_parser_file_parse_callback_hdlr, MSG_ID_MEDIA_META_PARSE_CNF);
    
    req_p = (media_meta_tag_parse_req_struct*) 
                construct_local_para(sizeof(media_meta_tag_parse_req_struct), TD_CTRL);
    req_p->seqID = meta_parser_get_new_seq_id();
    req_p->type  = META_TAG_ASYNC_TYPE_CANCEL;

    meta_parser_send_ilm(MOD_MED_V, MSG_ID_MEDIA_META_PARSE_REQ, req_p);

    META_WAIT_EVENT(META_TAG_EVT_CANCEL);

    return META_TAG_ERR_NONE;
}

#endif
/*
 * Add by Meta parser async interface MMI part
 * ----------- end ----------
 */


void mmi_kl_widget_musicplayer_init(void)
{
    g_kl_wg_musicplayer->working_buf_ptr = NULL;
    g_kl_wg_musicplayer->artwork_image_ptr = NULL;
    g_kl_wg_musicplayer->g_wg_photo_ptr = NULL;
    g_kl_wg_musicplayer->g_wg_photo_ptr2 = NULL;
    g_kl_wg_musicplayer->filepath = NULL;

/*     media_get_ext_buffer(stack_get_active_module_id(), (void **)&g_kl_wg_musicplayer->working_buf_ptr, KL_WG_MP_MEMORY_SIZE);
    ASSERT(g_kl_wg_musicplayer->working_buf_ptr != NULL);
      g_kl_wg_musicplayer->artwork_image_ptr = g_kl_wg_musicplayer->working_buf_ptr;
    g_kl_wg_musicplayer->g_wg_photo_ptr = g_kl_wg_musicplayer->working_buf_ptr + KL_WG_ARTWORK_MEMORY_SIZE;
    g_kl_wg_musicplayer->g_wg_photo_ptr2 = g_kl_wg_musicplayer->g_wg_photo_ptr + KL_WG_ARTWORK_MEMORY_SIZE;
    g_kl_wg_musicplayer->filepath =  g_kl_wg_musicplayer->g_wg_photo_ptr2 + KL_WG_ARTWORK_MEMORY_SIZE;*/
     media_get_ext_buffer(stack_get_active_module_id(), (void **)&g_kl_wg_musicplayer->artwork_image_ptr, KL_WG_ARTWORK_MEMORY_SIZE);
     media_get_ext_buffer(stack_get_active_module_id(), (void **)&g_kl_wg_musicplayer->g_wg_photo_ptr, KL_WG_MP_PASER_DATA_SIZE);
     media_get_ext_buffer(stack_get_active_module_id(), (void **)&g_kl_wg_musicplayer->g_wg_photo_ptr2, KL_WG_MP_PASER_HDL_SIZE);
     media_get_ext_buffer(stack_get_active_module_id(), (void **)&g_kl_wg_musicplayer->filepath, 520); 
}


void mmi_kl_widget_musicplayer_deinit(void)
{
    /*
    if (g_kl_wg_musicplayer->working_buf_ptr)
    {
        media_free_ext_buffer(MOD_MMI, (void **)&g_kl_wg_musicplayer->working_buf_ptr);
    }
    g_kl_wg_musicplayer->working_buf_ptr = NULL;
    g_kl_wg_musicplayer->artwork_image_ptr = NULL;
    g_kl_wg_musicplayer->g_wg_photo_ptr = NULL;
    g_kl_wg_musicplayer->g_wg_photo_ptr2 = NULL;
    g_kl_wg_musicplayer->filepath = NULL;*/

    if (g_kl_wg_musicplayer->artwork_image_ptr)
    {
        media_free_ext_buffer(MOD_MMI, (void **)&g_kl_wg_musicplayer->artwork_image_ptr);
        g_kl_wg_musicplayer->artwork_image_ptr = NULL;
    }
        if (g_kl_wg_musicplayer->g_wg_photo_ptr)
    {
        media_free_ext_buffer(MOD_MMI, (void **)&g_kl_wg_musicplayer->g_wg_photo_ptr);
        g_kl_wg_musicplayer->g_wg_photo_ptr = NULL;
    }
            if (g_kl_wg_musicplayer->g_wg_photo_ptr2)
    {
        media_free_ext_buffer(MOD_MMI, (void **)&g_kl_wg_musicplayer->g_wg_photo_ptr2);
        g_kl_wg_musicplayer->g_wg_photo_ptr2 = NULL;
    }
     if (g_kl_wg_musicplayer->filepath)
    {
        media_free_ext_buffer(MOD_MMI, (void **)&g_kl_wg_musicplayer->filepath);
        g_kl_wg_musicplayer->filepath = NULL;
    }
}



void mmi_kl_widget_musicplayer_launch_app(void)
{
#if defined(__MMI_AUDIO_PLAYER__)
    mmi_audply_entry_main();
#else if defined(__MMI_MEDIA_PLAYER__)
    mmi_medply_app_pre_entry();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_kl_widget_musicplayer_state_transform
 * DESCRIPTION
 *  Map application state to widget state
 * PARAMETERS
 *  audio_player_state      [IN]        Application state
 * RETURNS
 *  widget state            Widget state
 *****************************************************************************/
U8 mmi_kl_widget_musicplayer_state_transform(U8 audio_player_state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined __MMI_MEDIA_PLAYER__
    mmi_medply_widget_state_enum media_player_state = (mmi_medply_widget_state_enum)audio_player_state;
    switch(media_player_state)
    {
        case MEDPLY_WIDGET_STATE_IDLE:
        {
            return VAPP_WIDGET_AUDPLAYER_STATE_INIT;
        }

        case MEDPLY_WIDGET_STATE_PLAY:
        {
            return VAPP_WIDGET_AUDPLAYER_STATE_PLAY;
        }

        case MEDPLY_WIDGET_STATE_PROCESSING:
        {
            return VAPP_WIDGET_AUDPLAYER_STATE_PROCESS;
        }
        
        default:
        {
            ASSERT(0);
        }
    }
#elif defined __MMI_AUDIO_PLAYER__
    switch(audio_player_state)
    {
        case AUDPLY_AIDGET_STATE_IDLE:
        {
            return VAPP_WIDGET_AUDPLAYER_STATE_INIT;
        }
        case AUDPLY_AIDGET_STATE_PLAY:
        {
            return VAPP_WIDGET_AUDPLAYER_STATE_PLAY;
        }
        case AUDPLY_AIDGET_STATE_PROCESS:
        {
            return VAPP_WIDGET_AUDPLAYER_STATE_PROCESS;
        }
        default:
        {
            ASSERT(0);
        }
    }
#endif

    return VAPP_WIDGET_AUDPLAYER_STATE_INIT;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_kl_widget_musicplayer_get_info
 * DESCRIPTION
 *  Get information
 * PARAMETERS
 *  info_type       [IN]        Information type
 *  result_ptr      [OUT]       Result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_kl_widget_musicplayer_get_info(VappWidgetAudplayerGetInfoEnum info_type, void* result_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
#if defined __MMI_MEDIA_PLAYER__
    switch(info_type)
    {
        case VAPP_WIDGET_AUDPLAYER_INFO_STATE:
        {
            /*U8*/
            U8 state;
            mmi_medply_widget_get_value(MMI_WIDGET_PLAYER_CUR_STATE, &state);
            *((U8*)result_ptr) = mmi_kl_widget_musicplayer_state_transform(state);
            break;
        }

        case VAPP_WIDGET_AUDPLAYER_INFO_TITLE:
        {
            /*assign title string to result_ptr, max lengh MEDPLY_MAX_FILE_LEN*/
            mmi_medply_widget_get_value(MMI_WIDGET_PLAYER_FILENAME, result_ptr);
            break;
        }
        case VAPP_WIDGET_AUDPLAYER_INFO_FILEPATH:
        {
            mmi_medply_widget_get_value(MMI_WIDGET_PLAYER_FULLPATH, result_ptr);
            break;
        }
        case VAPP_WIDGET_AUDPLAYER_INFO_DURATION:
        {
            /*U64*/
            mmi_medply_widget_get_value(MMI_WIDGET_PLAYER_TOTAL_DURATION, result_ptr);
            break;
        }

        case VAPP_WIDGET_AUDPLAYER_INFO_CURR_TIME:
        {
            /*U64*/
            mmi_medply_widget_get_value(MMI_WIDGET_PLAYER_CUR_TIME, result_ptr);
            break;
        }

        case VAPP_WIDGET_AUDPLAYER_INFO_PAUSE_DISABLE:
        {
            /* MMI_BOOL */
            MMI_BOOL temp;
            mmi_medply_widget_get_value(MMI_WIDGET_PLAYER_IS_PAUSE_DISABLED, &temp);

            *(VfxS32*)result_ptr = temp ? TRUE : FALSE;
            break;
        }
        
        case VAPP_WIDGET_AUDPLAYER_INFO_ARTIST:
            UI_character_type filename[2];
            U8** filename_p ;
            filename[0] = '\0';
            filename[1] = '\0';
            filename_p = (U8**) result_ptr;
            mmi_ucs2cpy((CHAR*)filename_p , (CHAR*)filename);   
            break;
        default:
            ASSERT(0);
    }
#elif defined __MMI_AUDIO_PLAYER__
    switch(info_type)
    {
        case VAPP_WIDGET_AUDPLAYER_INFO_STATE:
        {
            /*U8*/
            U8 state;
            mmi_audply_widget_get_value(MMI_WIDGET_PLAYER_CUR_STATE, &state);
            *((U8*)result_ptr) = mmi_kl_widget_musicplayer_state_transform(state);
            break;
        }

        case VAPP_WIDGET_AUDPLAYER_INFO_TITLE:
        {
            /*assign title string to result_ptr, max lengh MEDPLY_MAX_FILE_LEN*/
            mmi_audply_widget_get_value(MMI_WIDGET_PLAYER_FILENAME, result_ptr);
            break;
        }
        case VAPP_WIDGET_AUDPLAYER_INFO_FILEPATH:
        {
            mmi_audply_widget_get_value(MMI_WIDGET_PLAYER_FULLPATH, result_ptr);
            break;
        }

        case VAPP_WIDGET_AUDPLAYER_INFO_DURATION:
        {
            /*U64*/
            mmi_audply_widget_get_value(MMI_WIDGET_PLAYER_TOTAL_DURATION, result_ptr);
            break;
        }

        case VAPP_WIDGET_AUDPLAYER_INFO_CURR_TIME:
        {
            /*U64*/
            mmi_audply_widget_get_value(MMI_WIDGET_PLAYER_CUR_TIME, result_ptr);
            break;
        }

        case VAPP_WIDGET_AUDPLAYER_INFO_PAUSE_DISABLE:
        {
            *(VfxS32*)result_ptr = FALSE;
            break;
        }            
        case VAPP_WIDGET_AUDPLAYER_INFO_ARTIST:
            UI_character_type filename[2];
            U8** filename_p ;
            filename[0] = '\0';
            filename[1] = '\0';
            filename_p = (U8**) result_ptr;
            mmi_ucs2cpy((CHAR*)filename_p , (CHAR*)filename);   
            break;
        default:
            ASSERT(0);
    }
#endif
}


#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

MMI_BOOL mmi_kl_widget_musicplayer_draw_artwork_to_buff(meta_tag_async_info_struct *details)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w, h, x, y, resize_w, resize_h = 0 ; 
    GDI_RESULT  ret;
    gdi_handle src_layer;
    U8  gdi_img_type;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    memset(g_kl_wg_musicplayer->artwork_image_ptr, 0, KL_WG_ARTWORK_MEMORY_SIZE);
    if(details->cover_info == NULL)
    {
        return MMI_FALSE;
    }
    switch(details->cover_info->mime_type)
    {
        case META_TAG_IMG_PNG :     gdi_img_type = GDI_IMAGE_TYPE_PNG; break;
        case META_TAG_IMG_JPG:      gdi_img_type = GDI_IMAGE_TYPE_JPG; break;
        case META_TAG_IMG_JPEG:     gdi_img_type = GDI_IMAGE_TYPE_JPG; break;
        case META_TAG_IMG_GIF:      gdi_img_type = GDI_IMAGE_TYPE_GIF; break;
        case META_TAG_IMG_BMP:      gdi_img_type = GDI_IMAGE_TYPE_BMP; break;

        default:                    return  MMI_FALSE;
    }

    ret = gdi_image_get_dimension_mem(gdi_img_type, g_kl_wg_musicplayer->g_wg_photo_ptr, details-> cover_info->data_size,
        &w, &h);
    if (GDI_SUCCEED != ret)
    {
        return  MMI_FALSE;
    }
    /*To get image fit size and offset*/
    gdi_image_util_fit_bbox(KL_WG_COVER_WIDTH, KL_WG_COVER_HEIGHT,
        w, h, &x, & y, &resize_w, &resize_h);    
    if(ret == GDI_SUCCEED)

   {
           gdi_layer_create_using_outside_memory(
               0,
               0,
               KL_WG_COVER_WIDTH,
               KL_WG_COVER_HEIGHT,
               &src_layer,
               g_kl_wg_musicplayer->artwork_image_ptr,
               KL_WG_COVER_WIDTH * KL_WG_COVER_HEIGHT* (GDI_MAINLCD_BIT_PER_PIXEL / 8));   
               gdi_layer_push_and_set_active(src_layer);
               #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif
           {
               gdi_image_util_fit_bbox(KL_WG_COVER_WIDTH, KL_WG_COVER_HEIGHT,w, h, &x, & y, &resize_w, &resize_h);
               ret = gdi_image_draw_resized_mem(x, y, resize_w,resize_h, g_kl_wg_musicplayer->g_wg_photo_ptr, gdi_img_type,details-> cover_info->data_size);
           }
           if (ret == GDI_SUCCEED)
           {
               gdi_layer_free(src_layer);
               gdi_layer_pop_and_restore_active();
           }
           else
           {
               gdi_layer_free(src_layer);
               gdi_layer_pop_and_restore_active();
           }
       }

    if (GDI_SUCCEED != ret)
    {
        return  MMI_FALSE;
    }
    return  MMI_TRUE;
}


void mmi_kl_widget_musicplayer_get_artwork_mem(void** covermem,  meta_tag_async_info_struct *detail, S32 width, S32 height)
{
     S32 ret = KAL_TRUE;
#ifdef __PLST_SERVICE_DB_SUPPORT__
    U32 buffer_size = KL_WG_ARTWORK_MEMORY_SIZE;
    S32 w, h;
    gdi_handle tmp_layer;

   // mmi_medply_plst_get_artist_name(str, 10);
    memset(g_kl_wg_musicplayer->artwork_image_ptr, 0, KL_WG_ARTWORK_MEMORY_SIZE);
    ret = mmi_medply_plst_get_current_artwork_ex(g_kl_wg_musicplayer->g_wg_photo_ptr, &buffer_size);
    
    if (buffer_size > 0 && !ret )
    {
        ret = gdi_image_get_dimension_mem(
                GDI_IMAGE_TYPE_JPG,
                g_kl_wg_musicplayer->g_wg_photo_ptr,
                (S32)buffer_size,
                &w,
                &h);

        if (ret == GDI_SUCCEED)
        {
            S32 real_offset_x, real_offset_y, real_width, real_height;

            gdi_util_fit_box(
                GDI_UTIL_MODE_NO_RESIZE_OR_LONG_SIDE_FIT, 
                width, 
                height, 
                w, 
                h,
                &real_offset_x,
                &real_offset_y,
                &real_width,
                &real_height);


            gdi_layer_create_using_outside_memory(
                0,
                0,
                width,
                height,
                &tmp_layer,
                g_kl_wg_musicplayer->artwork_image_ptr,
                KL_WG_ARTWORK_MEMORY_SIZE);

            gdi_layer_push_and_set_active(tmp_layer);
            gdi_push_and_set_alpha_blending_source_layer(tmp_layer);
            gdi_layer_clear(GDI_COLOR_BLACK);
            gdi_layer_set_source_key(TRUE,GDI_COLOR_TRANSPARENT);
            gdi_image_draw_resized_mem(real_offset_x,real_offset_y,real_width,real_height,g_kl_wg_musicplayer->g_wg_photo_ptr,GDI_IMAGE_TYPE_JPG,buffer_size);
            gdi_pop_and_restore_alpha_blending_source_layer();
            gdi_layer_pop_and_restore_active();
            gdi_layer_free(tmp_layer); 
            *covermem = &g_kl_wg_musicplayer->artwork_image_ptr[0];
		}
        else
        {
            *covermem = NULL;
        }
    }
    else
    {
         *covermem = NULL;
    }
  
#else
   // ret = mmi_kl_widget_musicplayer_parser_artwork();
    if(ret)
    {
        ret = mmi_kl_widget_musicplayer_draw_artwork_to_buff(detail);
    }

    if(!ret)
    {
        *covermem = NULL;
    }
    else
    {
        *covermem = &g_kl_wg_musicplayer->artwork_image_ptr[0];
    }
#endif
}

/*****************************************************************************
 * FUNCTION
 *  mmi_kl_widget_musicplayer_is_ready
 * DESCRIPTION
 *  Check if the playlist is ready. 
 * PARAMETERS
 *  void
 * RETURNS
 *  result      ready or not      
 *****************************************************************************/
VfxU32 mmi_kl_widget_musicplayer_is_ready()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_TRUE;    
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined __MMI_MEDIA_PLAYER__
    result = mmi_medply_widget_is_plst_ready();
#elif defined __MMI_AUDIO_PLAYER__
    result = mmi_audply_is_ready_to_play();
#endif
    return (VfxU32)result;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_kl_widget_musicplayer_is_play_continue
 * DESCRIPTION
 *  Check if the file is play. 
 * PARAMETERS
 *  void
 * RETURNS
 *  result      ready or not      
 *****************************************************************************/
VfxU32 mmi_kl_widget_musicplayer_is_play_continue()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_TRUE;    
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined __MMI_MEDIA_PLAYER__
    result = mmi_medply_is_play_continue();
#elif defined __MMI_AUDIO_PLAYER__
    result = mmi_audply_show_play_bttn();
#endif
    return (VfxU32)result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_kl_widget_musicplayer_is_ready
 * DESCRIPTION
 *  Check if the playlist is ready. 
 * PARAMETERS
 *  void
 * RETURNS
 *  result      ready or not      
 *****************************************************************************/
VfxU32 mmi_kl_widget_musicplayer_play_media_is_audio()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_TRUE;    
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined __MMI_MEDIA_PLAYER__
    result = mmi_medply_widget_is_audio_file();
#endif
    return (VfxU32)result;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_kl_widget_musicplayer_register_callback
 * DESCRIPTION
 *  Register callback function.
 * PARAMETERS
 *  userdata        [IN]    C++ this pointer
 *  callback        [IN]    Callback function
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_kl_widget_musicplayer_register_callback(void* userdata, void(*callback)(void*, VfxU32, void*))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined __MMI_MEDIA_PLAYER__
    mmi_medply_widget_register_callbacks(userdata, (void(*)(void*, mmi_widget_player_callback_enum, void*))callback);
#elif defined __MMI_AUDIO_PLAYER__
    mmi_audply_widget_register_callback(userdata, (void(*)(void*, mmi_widget_player_callback_enum, void*))callback);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_kl_widget_musicplayer_deregister_callback
 * DESCRIPTION
 *  De-register callback function.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_kl_widget_musicplayer_deregister_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined __MMI_MEDIA_PLAYER__
    mmi_medply_widget_register_callbacks(NULL,(void(*)(void*, mmi_widget_player_callback_enum, void*))NULL);
#elif defined __MMI_AUDIO_PLAYER__
    mmi_audply_widget_register_callback(NULL, (void(*)(void*, mmi_widget_player_callback_enum, void*))NULL);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_kl_widget_musicplayer_button_process
 * DESCRIPTION
 *  Map widget button actions to application relative functions.
 * PARAMETERS
 *  button_type     [IN]        Widget button type
 *  pen_event       [IN]        Widget pen event
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_kl_widget_musicplayer_button_process(VappWidgetButtonTypeEnum button_type, VfxPenEvent pen_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_widget_player_button_enum button = (mmi_widget_player_button_enum)0;
    mmi_widget_player_key_event_enum event = (mmi_widget_player_key_event_enum)0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   // MMI_TRACE(MMI_MEDIA_TRC_G2_APP, VADP_AUDPLY_BUTTON_PRECESS, button_type, pen_event);
    
    switch(button_type)
    {
        case VAPP_WIDGET_BUTTON_PLAY:
        case VAPP_WIDGET_BUTTON_PAUSE:
        {
            button = MMI_WIDGET_PLAYER_PLAY_PAUSE;
            break;
        }

        case VAPP_WIDGET_BUTTON_STOP:
        {
            button = MMI_WIDGET_PLAYER_STOP;
            break;
        }
            
        case VAPP_WIDGET_BUTTON_PREV:
        {
            button = MMI_WIDGET_PLAYER_PREV;
            break;
        }

        case VAPP_WIDGET_BUTTON_NEXT:
        {
            button = MMI_WIDGET_PLAYER_NEXT;
            break;
        }
            
        default:
            ASSERT(0);
    }

    switch(pen_event.type)
    {
        case VFX_PEN_EVENT_TYPE_DOWN:
        {
            event = MMI_WIDGET_PLAYER_KEY_DOWN;
            break;  
        }

          case VFX_PEN_EVENT_TYPE_UP:
          {
              event = MMI_WIDGET_PLAYER_KEY_UP;
              break;    
          }

          case VFX_PEN_EVENT_TYPE_ABORT:
          {
              event = MMI_WIDGET_PLAYER_KEY_CANCELED;
              break;    
          }

          default:
            ASSERT(0);
    }

    if (button == MMI_WIDGET_PLAYER_PLAY_PAUSE && event == MMI_WIDGET_PLAYER_KEY_UP)
    {
    #if defined __MMI_MEDIA_PLAYER__
        mdi_audio_set_background_handler(MDI_BACKGROUND_APP_MEDPLY, (mdi_bg_callback)mmi_medply_background_callback_hdlr, NULL);
        mdi_audio_clear_other_background_handler(MDI_BACKGROUND_APP_MEDPLY);
    #endif    
    }
#if defined __MMI_MEDIA_PLAYER__
    mmi_medply_widget_button_action(button,event);
#elif defined __MMI_AUDIO_PLAYER__
    mmi_audply_widget_button_action(button, event);
#endif

}


kal_bool mmi_kl_widget_musicplayer_get_artist_name(void* result_ptr, meta_tag_async_info_struct* details)
{
    if(details->music_info != NULL)
    {
        if (details->music_info->txt_frame[META_TAG_FRAME_ARTIST].data_size > 0 &&
           (details->music_info->txt_frame[META_TAG_FRAME_ARTIST].data_size >> 1) <= META_TAG_FRAME_MAX_LEN)
        {
            U16** artist ;

            artist = (U16**) result_ptr;

            mmi_ucs2ncpy((CHAR*)artist, 
                   (const CHAR*)details->music_info->txt_frame[META_TAG_FRAME_ARTIST].data,
                   details->music_info->txt_frame[META_TAG_FRAME_ARTIST].data_size >> 1);

            return KAL_TRUE;
        }
    }
    return KAL_FALSE;
}

kal_bool mmi_kl_widget_musicplayer_start_parser(void* userdata, VfxU32 (*callback)(void* user_data, VfxU8, VfxU8, VfxU32))
{    
    U8 meta_parser_ret = 0; 
    mmi_kl_widget_musicplayer_get_info(VAPP_WIDGET_AUDPLAYER_INFO_FILEPATH, g_kl_wg_musicplayer->filepath);

    if(g_kl_wg_musicplayer->g_wg_photo_ptr != NULL)
    {
        memset(g_kl_wg_musicplayer->g_wg_photo_ptr, 0, KL_WG_MP_PASER_DATA_SIZE);
        memset(g_kl_wg_musicplayer->g_wg_photo_ptr2, 0, KL_WG_MP_PASER_HDL_SIZE);
        meta_parser_ret = meta_parser_create_async(userdata, g_kl_wg_musicplayer->g_wg_photo_ptr2, 
                                 KL_WG_MP_PASER_HDL_SIZE, 
                                 &meta_parser_hdlr, (kal_uint32(*)(void*, meta_tag_async_type_enum, kal_uint8,kal_uint32))callback);
        if(meta_parser_ret == META_TAG_ERR_NONE)
        {
           meta_parser_ret = meta_parser_file_parse_async(meta_parser_hdlr, (kal_uint16*)g_kl_wg_musicplayer->filepath, 
                KL_WG_MP_PASER_DATA_SIZE, g_kl_wg_musicplayer->g_wg_photo_ptr);
        }
        
        if(meta_parser_ret != META_TAG_ERR_NONE)
        {
            return KAL_FALSE;
        }
        else
        {
            return KAL_TRUE;
        }
    }
    else
    {
        return KAL_FALSE;
    }
}


kal_bool mmi_kl_widget_musicplayer_stop_parser(void* userdata, void(*callback)(void*, VfxU8, VfxU8, VfxU32))
{  
    U8 meta_parser_ret = 0;  

     meta_parser_ret = meta_parser_release_async(meta_parser_hdlr);
     if(meta_parser_ret != META_TAG_ERR_NONE)
     {
         return KAL_FALSE;
     }
     else
     {
         return KAL_TRUE;
     }
}


kal_bool mmi_kl_widget_musicplayer_cancel_file_parser(VfxU8 *ret)
{
    U8 meta_parser_ret = 0;  

    meta_parser_ret = meta_parser_file_cancel_async(meta_parser_hdlr);
    if(meta_parser_ret != META_TAG_ERR_NONE)
    {
        return KAL_FALSE;
    }
    else
    {
        return KAL_TRUE;
    }
}



#ifdef __cplusplus
}
#endif



/*****************************************************************************
 * Class VappWidgetKeyMusicPlayerButton
 *****************************************************************************/
VappWidgetKeyMusicPlayerButton::VappWidgetKeyMusicPlayerButton(): m_image(NULL), m_imageId(0)
{

}

VappWidgetKeyMusicPlayerButton::~VappWidgetKeyMusicPlayerButton()
{

}

void VappWidgetKeyMusicPlayerButton::onInit()
{
    VfxControl::onInit();

    VFX_OBJ_CREATE(m_image, VfxImageFrame, this);
}

void VappWidgetKeyMusicPlayerButton::onDeinit()
{
    VfxControl::onDeinit();
}


VfxBool VappWidgetKeyMusicPlayerButton::isContains(VfxPoint pos, VfxU8 type)
{
    VfxBool ret = VFX_FALSE;
#ifdef __MMI_MAINLCD_320X240__
    if(type == BUT_PREV)
    {
        vrt_s32 xInRect = pos.x - VAPP_WG_KEY_MUSIC_PLAYER_PREV_X;
        vrt_s32 yInRect = pos.y - VAPP_WG_KEY_MUSIC_PLAYER_PREV_Y;

        ret = xInRect >= 0 && xInRect < VAPP_WG_KEY_MUSIC_PLAYER_PICK_WIDTH&& 
              yInRect >= 0 && yInRect < VAPP_WG_KEY_MUSIC_PLAYER_PICK_HEIGHT ;
    }
    else if(type == BUT_NEXT)
    {
        vrt_s32 xInRect = pos.x - VAPP_WG_KEY_MUSIC_PLAYER_NEXT_X;
        vrt_s32 yInRect = pos.y - VAPP_WG_KEY_MUSIC_PLAYER_NEXT_Y;

        ret = xInRect >= 0 && xInRect < VAPP_WG_KEY_MUSIC_PLAYER_PICK_WIDTH && 
              yInRect >= 0 && yInRect < VAPP_WG_KEY_MUSIC_PLAYER_PICK_HEIGHT ;
    }
    else
#endif
    if(type == BUT_PLAY)
    {
        vrt_s32 xInRect = pos.x - VAPP_WG_KEY_MUSIC_PLAYER_START_X;
        vrt_s32 yInRect = pos.y - VAPP_WG_KEY_MUSIC_PLAYER_START_Y;
    
        ret = xInRect >= 0 && xInRect < VAPP_WG_KEY_MUSIC_PLAYER_START_WIDTH && 
        yInRect >= 0 && yInRect < VAPP_WG_KEY_MUSIC_PLAYER_START_HEIGHT ;
    }
    return ret;
}


void VappWidgetKeyMusicPlayerButton::setImage(VfxS32 imageid)
{
    if(m_image->getResId() != imageid)
    {
        m_image->setResId(imageid);
    }
    setBounds(m_image->getBounds()); 
}

void VappWidgetKeyMusicPlayerButton::setDisplay(VfxBool isDisplay)
{
    if(isDisplay)
    {
        setHidden(VFX_FALSE);
    }
    else
    {
        setHidden(VFX_TRUE);
    }

}

/*****************************************************************************
 * Class VappWidgetKeyMusicPlayerCover
 *****************************************************************************/
VappWidgetKeyMusicPlayerCover::VappWidgetKeyMusicPlayerCover():
m_CoverActive(NULL), 
m_CoverIdle(NULL),
m_DefaultImg(NULL),
m_WaitingIcon(NULL),
m_IsTimerStart(VFX_FALSE),
is_DefaultSet(VFX_FALSE),
m_IsUp(VFX_FALSE),
m_IsParserStart (VFX_FALSE),
m_IsWaiting(VFX_FALSE),
m_IsCancelStart(VFX_FALSE),
m_IsWaitingSwitch(VFX_FALSE)
{
    m_pointTimeline[0] = NULL;
    m_pointTimeline[1] = NULL;
}

VappWidgetKeyMusicPlayerCover::~VappWidgetKeyMusicPlayerCover()
{

}

void VappWidgetKeyMusicPlayerCover::onInit()
{
    VfxFrame::onInit();
    VfxRect size;
    setFocused(VFX_TRUE);
    mmi_kl_widget_musicplayer_init();
    m_Switch = 0;

    VFX_OBJ_CREATE(m_DefaultImg, VfxImageFrame, this);
    VFX_OBJ_CREATE(m_CoverActive, VfxImageFrame, this);
    VFX_OBJ_CREATE(m_CoverIdle, VfxImageFrame, this);

   // m_DefaultImg->setResId(VAPP_KL_WG_MUSIC_PLAYER_BACKGROUND_BG);
   // setBounds(m_DefaultImg->getBounds());
    //m_DefaultImg->setResId(VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_IMG);
   // m_DefaultImg->setPos(VAPP_WG_KEY_MUSIC_PLAYER_CD_X - 3, VAPP_WG_KEY_MUSIC_PLAYER_CD_Y); 
    //m_CoverActive->setResId(VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_IMG);
   // m_CoverActive->setPos(6, 6); 
    m_CoverIdle->setPos(0, 0); 
    if(mmi_kl_widget_musicplayer_play_media_is_audio() || !mmi_kl_widget_musicplayer_is_ready())
    {
        m_CoverActive->setResId(VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_IMG);
        m_CoverActive->setPos(0, 0); 
        m_CoverActive->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    }
    else
    {
        m_CoverActive->setResId(VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_VIDIO_IMG);
        m_CoverActive->setPos(VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_X, VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_Y);   
        m_CoverActive->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_TOP);
    }
    m_CoverActive->setBounds(0,0,VAPP_WG_KEY_MUSIC_PLAYER_COVER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);


    if(mmi_kl_widget_musicplayer_is_ready() && mmi_kl_widget_musicplayer_play_media_is_audio())
    {
        stopWaiting();
       	VFX_OBJ_CREATE(m_WaitingIcon, VcpWaitingIcon, m_CoverActive);
        startWaiting();
    }
    VFX_OBJ_CREATE(m_TimerParser, VfxTimer, this);    
    m_TimerParser->m_signalTick.connect(this, &VappWidgetKeyMusicPlayerCover::OnPaserTimerClick);
}


void VappWidgetKeyMusicPlayerCover::onDeinit()
{    
    m_Switch = 0;
    onAutoEffectCancel();
    m_IsWaiting = VFX_FALSE;
    onStopTimer();
    if(m_IsParserStart)
    {
        VfxU8 ret;
        mmi_kl_widget_musicplayer_cancel_file_parser(&ret);
        mmi_kl_widget_musicplayer_stop_parser(this, NULL);
    }
    else if(m_IsCancelStart)
    {
        mmi_kl_widget_musicplayer_stop_parser(this, NULL);
    }
    m_TimerParser->m_signalTick.disconnect(this, &VappWidgetKeyMusicPlayerCover::OnPaserTimerClick);
    if(m_pointTimeline[0])
    {
        m_pointTimeline[0]->m_signalStopped.disconnect(this, &VappWidgetKeyMusicPlayerCover::switchAutoEffectDone);
    }
    mmi_kl_widget_musicplayer_deinit();
    setFocused(VFX_FALSE);
    VfxFrame::onDeinit();
}


void VappWidgetKeyMusicPlayerCover::retsetWaitingState(void)
{
    m_IsWaiting = VFX_FALSE;
}

void VappWidgetKeyMusicPlayerCover::setSwitchInfo(VfxU8 type)
{
    if(!m_IsWaitingSwitch)
    {
        m_Switch = type;
        if(type != 0)
        {
            m_IsWaitingSwitch = VFX_TRUE;
        }
    }
}

void VappWidgetKeyMusicPlayerCover::setParentInfo(void * parent_info)
{
    m_Parent = parent_info;
}

void VappWidgetKeyMusicPlayerCover::setAnimaDirection(VfxBool is_up)
{
    m_IsUp = is_up;
}


void VappWidgetKeyMusicPlayerCover::stopWaiting(void)
{
    if (m_WaitingIcon)
    {
        m_WaitingIcon->stop();
        VFX_OBJ_CLOSE(m_WaitingIcon);
    }
}

void VappWidgetKeyMusicPlayerCover::startWaiting(void)
{
    m_WaitingIcon->setAnchor(0.5f, 0.5f);
    m_WaitingIcon->setPos(VAPP_WG_KEY_MUSIC_PLAYER_COVER_WIDTH/2 + VAPP_WG_KEY_MUSIC_PLAYER_LOADING_OFFSET_X, 
                                            VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT/2+ VAPP_WG_KEY_MUSIC_PLAYER_LOADING_OFFSET_Y);
      
    m_WaitingIcon->setSize(VAPP_WG_KEY_MUSIC_PLAYER_LOADING_WIDTH, 
                      VAPP_WG_KEY_MUSIC_PLAYER_LOADING_HEIGHT);
    m_WaitingIcon->start();
    m_WaitingIcon->bringToFront();
}

void VappWidgetKeyMusicPlayerCover::setAutoSwitch(void)
{
    onStopTimer();
    if(m_Switch)
    {    
        m_Switch = 0;
        m_IsWaitingSwitch = VFX_FALSE;
        getCovermem();
        return;
    } 
    if(m_IsParserStart)
    {
        VfxU8 ret;
        if(!m_IsCancelStart)
        {
            VFX_TRACE(("\nYaling cancenl Parser in setAutoSwitch\n"));

            mmi_kl_widget_musicplayer_cancel_file_parser(&ret); 
            m_IsCancelStart = VFX_TRUE;
            m_IsWaiting = VFX_TRUE;
            onStartTimer();
        }
        else
        {           
           m_IsWaiting = MMI_TRUE;
           onStartTimer();
        }
    }

    if(m_pointTimeline[0] || m_pointTimeline[1])
    {
        return;
    }
    if(mmi_kl_widget_musicplayer_play_media_is_audio())
    {
        stopWaiting();
    	
        m_CoverIdle->setResId(VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_IMG);
        m_CoverIdle->setPos(VfxPoint(0,0)); 
        m_CoverIdle->setBounds(0,0,VAPP_WG_KEY_MUSIC_PLAYER_COVER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
        m_CoverIdle->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);

       	VFX_OBJ_CREATE(m_WaitingIcon, VcpWaitingIcon, m_CoverIdle);
        startWaiting();
    }
    else
    {
        m_CoverIdle->setResId(VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_VIDIO_IMG);
        m_CoverIdle->setPos(VfxPoint(VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_X, VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_Y));      
        m_CoverIdle->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_TOP);     
        m_CoverIdle->setBounds(0,0,VAPP_WG_KEY_MUSIC_PLAYER_COVER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
    }  

    if(m_IsUp)
    {
        switchAutoEffect(VFX_TRUE, VFX_FALSE);    
    }
    else
    {
        switchAutoEffect(VFX_FALSE, VFX_FALSE);
    }
}


VfxBool VappWidgetKeyMusicPlayerCover::isContains(VfxPoint pos)
{
    vrt_s32 xInRect = pos.x - VAPP_WG_KEY_MUSIC_PLAYER_CD_X;
    vrt_s32 yInRect = pos.y - VAPP_WG_KEY_MUSIC_PLAYER_CD_Y;
    
    return xInRect >= 0 && xInRect < VAPP_WG_KEY_MUSIC_PLAYER_COVER_WIDTH && 
        yInRect >= 0 && yInRect < VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT ;
}


void VappWidgetKeyMusicPlayerCover::onStartTimer(void)
{
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_GET_COVER_START, m_IsTimerStart);
    if(!m_IsTimerStart && m_IsWaiting)
    {        
        m_TimerParser->setStartDelay(150);
        m_TimerParser->start();
        m_IsTimerStart = VFX_TRUE;     
    }
}


void VappWidgetKeyMusicPlayerCover::onStopTimer(void)
{
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_GET_COVER_STOP, m_IsTimerStart);
    if(m_IsTimerStart&& m_IsWaiting)
    {        
        m_TimerParser->stop();
        m_IsWaiting = MMI_FALSE;
        m_IsTimerStart = VFX_FALSE;        
    }   
}

void VappWidgetKeyMusicPlayerCover::getCovermem(void)
{
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_GET_COVER_START, 8);
    onStopTimer();
    if(g_kl_wg_musicplayer->artwork_image_ptr == NULL)
    {
	return;
    }
    if(!mmi_kl_widget_musicplayer_play_media_is_audio())
    {        
        m_CoverActive->setResId(VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_VIDIO_IMG);
     //   m_CoverActive->setPos(VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_X, VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_Y);	
        m_CoverActive->setBounds(0,0,VAPP_WG_KEY_MUSIC_PLAYER_COVER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
        m_CoverActive->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_TOP);
        return;
    }    
    if(!m_IsParserStart)
    {        
        m_IsWaiting = VFX_FALSE;
        if(mmi_kl_widget_musicplayer_start_parser(this, VappWidgetKeyMusicPlayerCover::parserCallback))
        {
            m_IsParserStart = VFX_TRUE;
        }
        else
        {
            mmi_kl_widget_musicplayer_stop_parser(this, NULL);
        }
    }
    else
    {
        VfxU8 ret;
        if(!m_IsCancelStart)
        {
            mmi_kl_widget_musicplayer_cancel_file_parser(&ret); 
            m_IsCancelStart = VFX_TRUE;               
            m_IsWaiting = VFX_TRUE;
            onStartTimer();
        }
        else
        {
           m_IsWaiting = MMI_TRUE;
           onStartTimer();
        }
    }  
}


void VappWidgetKeyMusicPlayerCover::setAlbumPhoto(VfxImageBuffer &imagebuff)
{
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_SET_IMG_BUFF1);
    m_CoverActive->setPos(VfxPoint(0, 0));
    m_CoverActive->setImgContent(VfxImageSrc(imagebuff));
    m_CoverActive->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_CENTER);        
    m_CoverActive->setBounds(0,0,KL_WG_COVER_WIDTH,KL_WG_COVER_HEIGHT);
    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    renderer->mustShowNextFrame();  
}


VfxU32 VappWidgetKeyMusicPlayerCover::parserCallback(void* user_data, VfxU8 type, VfxU8 result, VfxU32 param)
{
    VappWidgetKeyMusicPlayerCover *this_ptr = (VappWidgetKeyMusicPlayerCover*)user_data;

    if(type == META_TAG_ASYNC_TYPE_PARSE)
    {
        if(result == META_TAG_ERR_NONE)
        {
            meta_tag_async_info_struct *detail = (meta_tag_async_info_struct*)param;
            this_ptr->OnPaserBack(detail);
            mmi_kl_widget_musicplayer_stop_parser(user_data, NULL);
            this_ptr->m_IsParserStart = VFX_FALSE;
        }
        else
        {
            mmi_kl_widget_musicplayer_stop_parser(user_data, NULL);
            this_ptr->stopWaiting();
            this_ptr->m_IsParserStart = VFX_FALSE;
        }
    }
    else if(type == META_TAG_ASYNC_TYPE_CANCEL)
    {
        mmi_kl_widget_musicplayer_stop_parser(user_data, NULL);
        this_ptr->stopWaiting();
        this_ptr->m_IsCancelStart = VFX_FALSE;
        this_ptr->m_IsParserStart = VFX_FALSE;
        if(this_ptr->m_IsWaiting)
        {
            this_ptr->onStartTimer();
        }
    }
    else
    {
         this_ptr->stopWaiting();
         this_ptr->m_IsParserStart = VFX_FALSE;
    }
    return VFX_FALSE;
}


void VappWidgetKeyMusicPlayerCover::OnPaserTimerClick(VfxTimer *source)
{
    VFX_UNUSED(source);
    getCovermem();
}

void VappWidgetKeyMusicPlayerCover::OnPaserBack(meta_tag_async_info_struct *detail)
{
    VfxImageBuffer imageBuf;
    VfxU8 * tmpImageBuf;   
    /* udpate artist name */
     if(m_pointTimeline[0] || m_pointTimeline[1])
    {
        VFX_TRACE(("\n yaling return in OnPaserBack"));
        return;
    }
    if(detail->music_info != NULL)
    {
        VfxBool ret = VFX_FALSE;
        VappWidgetKeyMusicPlayerPanel *par_ptr = (VappWidgetKeyMusicPlayerPanel*)m_Parent;

        ret = mmi_kl_widget_musicplayer_get_artist_name(par_ptr->m_ArtistName, detail);

        if(ret) 
        {
            par_ptr->m_IsRescrollText = VFX_TRUE;
            par_ptr->nameFadeOut();            
            par_ptr->updateDisplay();
            par_ptr->nameFadeIn();
            VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
            renderer->mustShowNextFrame();        
        }        
    }

    VFX_OBJ_GET_INSTANCE(VfxRenderer)->suspendUntilCommit();
    mmi_kl_widget_musicplayer_get_artwork_mem((void**)&tmpImageBuf, detail, KL_WG_COVER_WIDTH,KL_WG_COVER_HEIGHT);
    stopWaiting();
    if (tmpImageBuf != NULL)
    {
        VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_SET_IMG_BUFF);
        imageBuf.ptr = (VfxU8*)tmpImageBuf;
        imageBuf.pitchBytes = KL_WG_COVER_WIDTH * 2;
        imageBuf.width = KL_WG_COVER_WIDTH;
        imageBuf.height = KL_WG_COVER_HEIGHT;

        imageBuf.colorFormat = VRT_COLOR_TYPE_RGB565;
        setAlbumPhoto(imageBuf);
    }
    else
    {
        if(mmi_kl_widget_musicplayer_play_media_is_audio() || !mmi_kl_widget_musicplayer_is_ready())
        {
            m_CoverActive->setResId(VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_IMG);
           // m_CoverActive->setPos(0, 0); 
	    m_CoverActive->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
        }
        else
        {
            m_CoverActive->setResId(VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_VIDIO_IMG);
          //  m_CoverActive->setPos(VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_X, VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_Y);
	    m_CoverActive->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_TOP);
        }
        m_CoverActive->setBounds(0,0,VAPP_WG_KEY_MUSIC_PLAYER_COVER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
    }
}


void VappWidgetKeyMusicPlayerCover::switchAutoEffectDone(VfxBaseTimeline * timeline,VfxBool isComplete)
{
    VFX_LOG(VFX_INFO2,TRC_VAPP_KEY_WG_MUSIC_PLAYER_AUTOEFFECTDOWN, isComplete);
    stopWaiting();

    if (isComplete)
    {        
        VfxImageFrame *tempframe;
        tempframe = m_CoverIdle;
        m_CoverIdle = m_CoverActive;
        m_CoverActive = tempframe;
        m_CoverIdle->setNull();
    }
    else
    {
        VfxImageFrame *tempframe;
        tempframe = m_CoverIdle;
        m_CoverIdle = m_CoverActive;
        m_CoverActive = tempframe;
        m_CoverIdle->setNull();  
    }
    m_CoverActive->bringToFront();
    m_pointTimeline[0]->m_signalStopped.disconnect(this, &VappWidgetKeyMusicPlayerCover::switchAutoEffectDone);
    VFX_OBJ_CLOSE(m_pointTimeline[0]);
    VFX_OBJ_CLOSE(m_pointTimeline[1]);    
    if(m_Switch)
    {
        VappWidgetKeyMusicPlayerPanel *par_ptr = (VappWidgetKeyMusicPlayerPanel*)m_Parent;
        par_ptr->switchSong(m_Switch);
    }
    m_IsWaitingSwitch = VFX_FALSE;
    getCovermem();
}

VfxBool VappWidgetKeyMusicPlayerCover::switchState(void)
{
    if(m_pointTimeline[0] || m_pointTimeline[1])
    {
        return VFX_TRUE;
    }
    else
    {
        return VFX_FALSE;
    }
}

void VappWidgetKeyMusicPlayerCover::switchAutoEffect(VfxBool is_up, VfxBool is_Current)
{
    VfxMsec duration = 150;
    VfxPoint tempPoint;
    VfxS32  posx = VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_X;
    VfxS32 posy = VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_Y;

    if(mmi_kl_widget_musicplayer_play_media_is_audio() || !mmi_kl_widget_musicplayer_is_ready())
    {
        posx = 0;
        posy = 0;
    }


    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_AUTO_EFFECT, is_up, is_Current);
    if(is_up)
    {
        tempPoint = VfxPoint(posx, VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
    }
    else 
    {
        tempPoint = VfxPoint(posx, -VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
    }
    //if(!is_Current)
    {
        if (m_pointTimeline[0] == NULL)
       {
           VFX_OBJ_CREATE(m_pointTimeline[0], VfxPointTimeline, this);
           m_pointTimeline[0]->m_signalStopped.connect(this, &VappWidgetKeyMusicPlayerCover::switchAutoEffectDone);
       }

        m_pointTimeline[0]->setTarget(m_CoverActive);
        m_pointTimeline[0]->setTargetPropertyId(VRT_FRAME_PROPERTY_ID_POS);
        m_pointTimeline[0]->setDurationTime(duration);
        m_pointTimeline[0]->setRepeatCount(1);
        m_pointTimeline[0]->setFromValue(m_CoverActive->getPos());
        m_pointTimeline[0]->setToValue(tempPoint);
        m_pointTimeline[0]->setTimingFunc(VFX_TIMING_FUNC_ID_EASE_OUT);
        m_pointTimeline[0]->start();

        m_CoverActive->setPos(tempPoint);
    }
    
    if(!is_Current)
    {
        if(is_up)
        {
            tempPoint = VfxPoint(m_CoverIdle->getPos().x , m_CoverIdle->getPos().y - VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
        }
        else
        {
            tempPoint = VfxPoint(m_CoverIdle->getPos().x , m_CoverIdle->getPos().y + VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
        }
    }
    else
    {
         if(is_up)
        {
            tempPoint = VfxPoint(m_CoverIdle->getPos().x , m_CoverIdle->getPos().y);
        }
        else
        {
            tempPoint = VfxPoint(m_CoverIdle->getPos().x , m_CoverIdle->getPos().y);
        }   
    }
    
    if (m_pointTimeline[1] == NULL)
    {
        VFX_OBJ_CREATE(m_pointTimeline[1], VfxPointTimeline, this);
    }
    m_pointTimeline[1]->setTarget(m_CoverIdle);
    m_pointTimeline[1]->setTargetPropertyId(VRT_FRAME_PROPERTY_ID_POS);
    m_pointTimeline[1]->setDurationTime(duration);
    m_pointTimeline[1]->setRepeatCount(1);
    m_pointTimeline[1]->setFromValue(tempPoint);

    if(!is_Current)
    {
        m_pointTimeline[1]->setToValue(m_CoverIdle->getPos());
    }
    else
    {
        m_pointTimeline[1]->setToValue(VfxPoint(posx,posy));
    }
    m_pointTimeline[1]->setTimingFunc(VFX_TIMING_FUNC_ID_EASE_OUT);
    m_pointTimeline[1]->start();
    m_CoverIdle->setPos(posx, posy);  
}

 
void VappWidgetKeyMusicPlayerCover::onAutoEffectCancel(void)
{
    if (m_pointTimeline[0])
    {
        m_pointTimeline[0]->stop();
    }
    if (m_pointTimeline[1])
    {
        m_pointTimeline[1]->stop();
    }
    if(m_Switch)
    {
        VappWidgetKeyMusicPlayerPanel *par_ptr = (VappWidgetKeyMusicPlayerPanel*)m_Parent;
        par_ptr->switchSong(m_Switch); 
    } 
    m_IsWaitingSwitch = VFX_FALSE;
    stopWaiting();
}


void VappWidgetKeyMusicPlayerCover::setDragSmart(VfxSize size, VfxPoint pos)
{
    VFX_TRACE(("\nYaling size.height = %d\n", size.height));

    VfxS32  posx = VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_X;
    VfxS32 posy = VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_Y;
    VfxS32  defaultimage = VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_VIDIO_IMG;

    if(mmi_kl_widget_musicplayer_play_media_is_audio() || !mmi_kl_widget_musicplayer_is_ready())
    {
        posx = 0;
        posy = 0;
        defaultimage = VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_IMG;
    }

    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_SET_DRAG, size.height);
    if(m_pointTimeline[0] || m_pointTimeline[1])
    {
        return;
    }

   // if(!is_DefaultSet)
    {
        stopWaiting();
    
        if(mmi_kl_widget_musicplayer_play_media_is_audio() || !mmi_kl_widget_musicplayer_is_ready())
        {
       	    VFX_OBJ_CREATE(m_WaitingIcon, VcpWaitingIcon, m_CoverIdle);
            startWaiting();
        }
    }
    if(size.height < 0) /* move up */
    { 
        VFX_TRACE(("\nYaling move up\n"));
        if(!is_DefaultSet)
        {
            is_DefaultSet = VFX_TRUE;
            m_CoverIdle->setResId(defaultimage); 
            if(mmi_kl_widget_musicplayer_play_media_is_audio() || !mmi_kl_widget_musicplayer_is_ready())
            {
                m_CoverIdle->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
            }
            else
            {
                m_CoverIdle->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_TOP);
            }
            m_CoverIdle->setBounds(0,0,VAPP_WG_KEY_MUSIC_PLAYER_COVER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
            m_CoverActive->bringToFront();
        }
        m_CoverActive->setPos(posx, size.height );
        m_CoverIdle->setPos(posx, VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT +size.height);
    }
    else if(size.height > 0)/* move down */
    {
        VFX_TRACE(("\nYaling move down\n"));
        m_CoverActive->setPos(posx, size.height);
        if(!is_DefaultSet)
        {
            is_DefaultSet = VFX_TRUE;
            m_CoverIdle->setResId(defaultimage);
            if(mmi_kl_widget_musicplayer_play_media_is_audio() || !mmi_kl_widget_musicplayer_is_ready())
            {
                m_CoverIdle->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
            }
            else
            {
                m_CoverIdle->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_TOP);
            }
            m_CoverIdle->setBounds(0,0,VAPP_WG_KEY_MUSIC_PLAYER_COVER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
            m_CoverActive->bringToFront();
        }          
        m_CoverIdle->setPos(posx, size.height - VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
    }
    else
    {
        is_DefaultSet = VFX_FALSE;
        m_CoverIdle->setPos(posx, VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
        m_CoverActive->setPos(posx, posy);
    }
}


void VappWidgetKeyMusicPlayerCover::setDragSmartDone(VfxSize size, VfxPoint pos)
{ 
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_DRAG_DONE, size.height);   
    if(m_pointTimeline[0] || m_pointTimeline[1])
    {
        return;
    }
    
    if(!is_DefaultSet)
    {
        is_DefaultSet = VFX_TRUE;
        if(mmi_kl_widget_musicplayer_play_media_is_audio() || !mmi_kl_widget_musicplayer_is_ready())
        {
            m_CoverActive->setResId(VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_IMG); 
            m_CoverActive->setPos(0, 0);
            m_CoverActive->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
        }
        else
        {
            m_CoverActive->setResId(VAPP_KL_WG_MUSIC_PLAYER_DEFAULT_VIDIO_IMG); 
            m_CoverActive->setPos(VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_X, VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_Y);                                
            m_CoverActive->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_TOP);
        }
        m_CoverActive->setBounds(0,0,VAPP_WG_KEY_MUSIC_PLAYER_COVER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
        m_CoverActive->bringToFront();

        stopWaiting();
        if(mmi_kl_widget_musicplayer_play_media_is_audio() || !mmi_kl_widget_musicplayer_is_ready())
        {
            VFX_OBJ_CREATE(m_WaitingIcon, VcpWaitingIcon, m_CoverActive);
            startWaiting();
            getCovermem();
        }
    }
    else if(size.height < 0) /* move up */
    {
        VFX_TRACE(("\nYaling drag done move up\n"));
        switchAutoEffect(VFX_FALSE, VFX_TRUE);
    }
    else /* move down */
    {
        VFX_TRACE(("\nYaling drag done move down\n"));
        switchAutoEffect(VFX_TRUE, VFX_TRUE);
    }    
    is_DefaultSet = VFX_FALSE;
}


void VappWidgetKeyMusicPlayerCover::cancelDragSmart(VfxPoint pos)
{
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_DRAG_CANCEL);

    is_DefaultSet = VFX_FALSE;
    if(mmi_kl_widget_musicplayer_play_media_is_audio() || !mmi_kl_widget_musicplayer_is_ready())
    {
        m_CoverActive->setPos(0,0);
    }
    else
    {
        m_CoverActive->setPos(VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_X, VAPP_WG_KEY_MUSIC_PLAYER_VIDEO_Y);
    }
    m_CoverIdle->setNull();
}


/*****************************************************************************
 * Class VappWidgetKeyMusicPlayerProgress
 *****************************************************************************/
VappWidgetKeyMusicPlayerProgress::VappWidgetKeyMusicPlayerProgress():
    m_ProgressFg(NULL),m_ProgressFgP(NULL),m_Ratio(0),  m_ImageFg(0)   
{

}

VappWidgetKeyMusicPlayerProgress::~VappWidgetKeyMusicPlayerProgress()
{

}

void VappWidgetKeyMusicPlayerProgress::onInit()
{
    VfxFrame::onInit();
    VFX_OBJ_CREATE(m_ProgressBg, VfxImageFrame, this);
    
    setBounds(
        0, 
        0, 
        VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_WIDTH,
        VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_HEIGHT);
    m_ProgressBg->setResId(VAPP_KL_WG_MUSIC_PLAYER_PROGRESS_BG);
    m_ProgressBg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    m_ProgressBg->setSize(VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_HEIGHT);
    m_ProgressBg->setPos(0,0);

    VFX_OBJ_CREATE(m_ProgressFgP, VfxImageFrame, this );
    m_ProgressFgP->setPos(0,0);
    m_ProgressFgP->setBounds(0,0,0,0);

    VFX_OBJ_CREATE(m_ProgressFg, VfxImageFrame, m_ProgressFgP );
    m_ProgressFg->setResId(VAPP_KL_WG_MUSIC_PLAYER_PROGRESS_FG);
    m_ProgressFg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);   
    m_ProgressFg->setSize(VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_WIDTH,VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_HEIGHT);
    m_ProgressFg->setPos(0,0);
}

void VappWidgetKeyMusicPlayerProgress::onDeinit()
{
    VfxFrame::onDeinit();
}

void VappWidgetKeyMusicPlayerProgress::setImage(VfxS32 m_Image1, VfxS32 m_Image2)
{
    m_ImageFg = m_Image1;
    m_ImageBg = m_Image2;
}

void VappWidgetKeyMusicPlayerProgress::setRatio(VfxS32 ratio)
{
    m_Ratio = ratio;
    invalidate();

    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_SETRATIO, ratio);
    VfxS32 progress_width;
    VfxRect rect;
    m_ProgressFg->setResId(VAPP_KL_WG_MUSIC_PLAYER_PROGRESS_FG);
    progress_width = (VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_WIDTH * m_Ratio)/100;

    if(m_Ratio != 100)
    {
        if(mmi_fe_is_r2l_state())
        {
            m_ProgressFgP->setPos(VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_WIDTH - progress_width, 0);
            m_ProgressFgP->setBounds(VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_WIDTH - progress_width, 0, progress_width, VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_HEIGHT);    
        }
        else
        {
            m_ProgressFgP->setBounds(0, 0, progress_width, VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_HEIGHT);    
        }
    }
    else
    {
        m_ProgressFgP->setBounds(0,0,VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_WIDTH,VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_HEIGHT);
    }
    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    renderer->mustShowNextFrame();        
}

VfxS32 VappWidgetKeyMusicPlayerProgress::getRatio(void) const
{
    return m_Ratio;
}


/*****************************************************************************
 * Class VappWidgetKeyMusicPlayerPanel
 *****************************************************************************/
VappWidgetKeyMusicPlayerPanel::VappWidgetKeyMusicPlayerPanel():
m_Album(NULL),
m_PlayButton(NULL),
m_PrevButton(NULL),
m_NextButton(NULL),
m_MarqueeText(NULL),
m_Prog(NULL),
m_LongPressTimer(NULL),
m_Timer(0),
m_Duration(0),
m_CurrentTime(0),
m_IsReady(VFX_FALSE),
m_IsTimerStart(VFX_FALSE),
m_IsLongPressTimerStart(VFX_FALSE),
m_IsPickPrev(VFX_FALSE),
m_IsPickNext(VFX_FALSE),
m_IsDownGetFirst(VFX_FALSE),
m_State(STATE_INIT),
m_IsSwitchSong(VFX_FALSE),
m_IsSwitchState(VFX_FALSE),
m_IsRescrollText(VFX_FALSE),
m_IsLaunchApp(VFX_FALSE),
m_IsPenEventCancel(VFX_FALSE),
m_IsPrevPressing(VFX_FALSE),
m_IsNextPressing(VFX_FALSE),
m_IsPowerPressing(VFX_FALSE)
{

}


VappWidgetKeyMusicPlayerPanel::~VappWidgetKeyMusicPlayerPanel()
{

}

void VappWidgetKeyMusicPlayerPanel::onInit()
{
    VfxControl::onInit();

    VfxPoint point;
    VfxRect  size1,size2;
    setBounds(0, 0, VAPP_WG_KEY_MUSIC_PLAYER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_HEIGHT);

    VFX_OBJ_CREATE(m_ImageClassBg, VfxImageFrame, this);
    m_ImageClassBg->setResId(VAPP_KL_WG_MUSIC_PLAYER_BACKGROUND_BG);
    m_ImageClassBg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    m_ImageClassBg->setSize(VAPP_WG_KEY_MUSIC_PLAYER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_HEIGHT);
    m_ImageClassBg->setBounds(0, 0, VAPP_WG_KEY_MUSIC_PLAYER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_HEIGHT);
    m_ImageClassBg->setPos(0,0);
    /* Cover */   
    VFX_OBJ_CREATE(m_Album, VappWidgetKeyMusicPlayerCover, this);
    m_Album->setPos(VAPP_WG_KEY_MUSIC_PLAYER_CD_X,VAPP_WG_KEY_MUSIC_PLAYER_CD_Y);
    m_Album->setBounds(0,0,VAPP_WG_KEY_MUSIC_PLAYER_COVER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_COVER_HEIGHT);
    m_Album->setParentInfo(this);
    /* play button */
    VFX_OBJ_CREATE(m_PlayButton, VappWidgetKeyMusicPlayerButton, this);
    m_PlayButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PLAY);    
    m_PlayButton->setPos(VAPP_WG_KEY_MUSIC_PLAYER_START_X, VAPP_WG_KEY_MUSIC_PLAYER_START_Y);

    #ifdef __MMI_MAINLCD_320X240__
    /* prev/ next button */
    VFX_OBJ_CREATE(m_PrevButton, VappWidgetKeyMusicPlayerButton, this);
    m_PrevButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_PREV);    
    m_PrevButton->setPos(VAPP_WG_KEY_MUSIC_PLAYER_PREV_X, VAPP_WG_KEY_MUSIC_PLAYER_PREV_Y);
   
    VFX_OBJ_CREATE(m_NextButton, VappWidgetKeyMusicPlayerButton, this);
    m_NextButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_NEXT);    
    m_NextButton->setPos(VAPP_WG_KEY_MUSIC_PLAYER_NEXT_X, VAPP_WG_KEY_MUSIC_PLAYER_NEXT_Y);
    #endif
    /* progress bar */
    VFX_OBJ_CREATE(m_Prog, VappWidgetKeyMusicPlayerProgress, this);
    m_Prog->setImage(VAPP_KL_WG_MUSIC_PLAYER_PROGRESS_FG, VAPP_KL_WG_MUSIC_PLAYER_PROGRESS_BG);
    m_Prog->setPos(VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_X,VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_Y);
    m_Prog->setRatio(0);
    
    /* title */
    VFX_OBJ_CREATE(m_NameBg, VfxImageFrame, this);
    m_NameBg->setResId(VAPP_KL_WG_MUSIC_PLAYER_SONG_INFO);
    m_NameBg->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    m_NameBg->setPos(VAPP_WG_KEY_MUSIC_PLAYER_NAME_BG_X, VAPP_WG_KEY_MUSIC_PLAYER_NAME_BG_Y);
    m_NameBg->setSize(VAPP_WG_KEY_MUSIC_PLAYER_NAME_BG_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_NAME_BG_HEIGHT);

    VFX_OBJ_CREATE(m_MarqueeText, VcpMarquee, this);

    m_MarqueeText->setPos(VfxPoint(VAPP_WG_KEY_MUSIC_PLAYER_NAME_X, VAPP_WG_KEY_MUSIC_PLAYER_NAME_Y));
    m_MarqueeText->setBounds(VfxRect(       0, 
                                            0, 
                                            VAPP_WG_KEY_MUSIC_PLAYER_NAME_WIDTH, 
                                            VAPP_WG_KEY_MUSIC_PLAYER_NAME_HEIGHT));
    m_MarqueeText->setHalign(VcpMarquee::HALIGN_CENTER);
    m_MarqueeText->setValign(VcpMarquee::VALIGN_TOP);
    m_MarqueeText->setSpeed(VcpMarquee::DEFAULT_SPEED / 3);
    m_IsRescrollText = VFX_TRUE;

    /* Duration and play Time */
    VFX_OBJ_CREATE(m_DuraTime, VfxTextFrame, m_Prog);
    VFX_OBJ_CREATE(m_PlayTime, VfxTextFrame, m_Prog);
    //m_DuraTime->setPos(VAPP_WG_KEY_MUSIC_PLAYER_TIME_X + 160, VAPP_WG_KEY_MUSIC_PLAYER_TIME_Y);
    if (mmi_fe_is_r2l_state())
    {
        m_PlayTime->setPos(VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_WIDTH - VAPP_WG_KEY_MUSIC_PLAYER_TIME_X, VAPP_WG_KEY_MUSIC_PLAYER_TIME_Y);
        m_DuraTime->setPos(VAPP_WG_KEY_MUSIC_PLAYER_TIME_X, VAPP_WG_KEY_MUSIC_PLAYER_TIME_Y);
    }
    else
    {    
        m_PlayTime->setPos(VAPP_WG_KEY_MUSIC_PLAYER_TIME_X, VAPP_WG_KEY_MUSIC_PLAYER_TIME_Y);	
    }   
    m_DuraTime->setFullLineHeightMode(VFX_FALSE);
    m_PlayTime->setFullLineHeightMode(VFX_FALSE);
    
    /* Timer */
    VFX_OBJ_CREATE(m_Timer, VfxTimer, this);
    VFX_OBJ_CREATE(m_LongPressTimer, VfxTimer, this);
    m_Timer->m_signalTick.connect(this, &VappWidgetKeyMusicPlayerPanel::onTimerClick);
    m_LongPressTimer->m_signalTick.connect(this, &VappWidgetKeyMusicPlayerPanel::onLongPTClick);
    
    mmi_kl_widget_musicplayer_register_callback((void*)this, playerCallback);
    getState();
    m_IsReady = mmi_kl_widget_musicplayer_is_ready() != 0 ? VFX_TRUE : VFX_FALSE;

    if (m_IsReady)
    {       
        setCurProgress();
        m_Album->getCovermem();
        getArtistname();
    }
    else
    {
        m_Prog->setRatio(0);
    }
    updateDisplay();   
}


void VappWidgetKeyMusicPlayerPanel::onDeinit()
{
    stopLPTimer();
    stopCurTimer();
    m_Timer->m_signalTick.disconnect(this, &VappWidgetKeyMusicPlayerPanel::onTimerClick);
    m_LongPressTimer->m_signalTick.disconnect(this, &VappWidgetKeyMusicPlayerPanel::onLongPTClick);
    mmi_kl_widget_musicplayer_deregister_callback();
    VfxControl::onDeinit();
}


void VappWidgetKeyMusicPlayerPanel::getTimeString(VfxU64 msec, VfxWChar *timeStr,VfxU32 maxLength) const
{
    VfxS64 totol_secs = (msec + 500) / 1000;
    VfxS32 hour;
    VfxS32 hour_remain;
    VfxS32 min;
    VfxS32 sec;

    #define STRING_LENGTH_MAX (10)
    VfxChar *temp;    
    VfxU32 wtemp_length;    
    VfxChar temp_string[STRING_LENGTH_MAX];
    VfxWChar temp_wstring[STRING_LENGTH_MAX];
    VfxChar seperator;

    seperator = ':';
   
    hour = totol_secs / 3600;
    hour_remain = totol_secs % 3600;
    min = hour_remain / 60;
    sec = hour_remain % 60; 

    temp = &temp_string[0];

    if(hour >= 100)
    {
        sprintf(temp, "99:59:59");
        *(temp + 8) = '\0';
    }
    else
    {
        if (hour > 0)
        {
            sprintf(temp, "%02d%c%02d%c%02d", hour, seperator, min, seperator, sec);
            *(temp + 8) = '\0';
        }
        else
        {
            if(m_Duration != msec)
            {
                #ifdef __MMI_MEDIA_PLAYER__
                VfxS64 temp_hour = (m_Duration + 500) / 1000/3600;
                #else
                VfxS64 temp_hour = m_Duration / 1000/3600;
                #endif 

                if(temp_hour > 0)
                {
                    sprintf(temp, "%02d%c%02d%c%02d", 0, seperator, min, seperator, sec);
                    *(temp + 8) = '\0';   
                }
	        else
                {
                    sprintf(temp, "%02d%c%02d",  min, seperator, sec);
                    *(temp + 5) = '\0';
                }
            }
            else
            {
                sprintf(temp, "%02d%c%02d",  min, seperator, sec);
                *(temp + 5) = '\0';
            }
        }
    }

    wtemp_length = vfx_sys_strlen(temp_string);
    VFX_ASSERT(wtemp_length<STRING_LENGTH_MAX);
    mmi_asc_n_to_ucs2((CHAR*)temp_wstring, (CHAR*)temp_string, wtemp_length + 1);

    if (maxLength < wtemp_length)
    {
        return;
    }

    vfx_sys_wcscpy(timeStr, temp_wstring);

}


void VappWidgetKeyMusicPlayerPanel::startLPTimer(void)
{
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_STARTLCT, m_IsLongPressTimerStart);

    if(!m_IsLongPressTimerStart)
    {
        m_LongPressTimer->setStartDelay(100);
        m_LongPressTimer->start();

        m_IsLongPressTimerStart = VFX_TRUE;
    }
}

void VappWidgetKeyMusicPlayerPanel::stopLPTimer(void)
{
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_STOPLCT, m_IsLongPressTimerStart);
    if(m_IsLongPressTimerStart)
    {
        m_LongPressTimer->stop();

        m_IsLongPressTimerStart = VFX_FALSE;
    }
}

void VappWidgetKeyMusicPlayerPanel::onLongPTClick(VfxTimer * timer)
{
    VFX_UNUSED(timer);
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_LTIMERTICK, m_IsPickNext, m_IsPickPrev, m_IsLongPressTimerStart);

    VfxKeyEvent  event;
    event.type = VFX_KEY_EVENT_TYPE_DOWN;
    if(m_IsPickNext)
    {
        switchNext(event);
        event.type = VFX_KEY_EVENT_TYPE_UP;
        switchNext(event);
    }
    else if(m_IsPickPrev)
    {
        switchPrev(event);
        event.type = VFX_KEY_EVENT_TYPE_UP;
        switchPrev(event);
    }
    if(m_IsLongPressTimerStart && (m_IsPickNext || m_IsPickPrev))
    {
        m_LongPressTimer->setStartDelay(100);
        m_LongPressTimer->start();
    }
}

void VappWidgetKeyMusicPlayerPanel::setCurProgress(void)
{
    VfxObjWeakPtr this_ptr = this;
   
    if(m_Prog == NULL)
    {
        return;
    }

    VfxS32 ratio;
    VfxU64 duration = m_Duration;
    
    getDuration();
    getPlaytime();

    if(m_Duration)
    {
        ratio = (m_CurrentTime * 100/m_Duration);
        m_Prog->setRatio(ratio);
    }
    else
    {
        m_Prog->setRatio(0);
    }

    VfxWChar str_buf[10];
    if(duration != m_Duration)
    {
        VfxU32 width;
        getTimeString(m_Duration,str_buf,10);
        m_DuraTime->setString(VFX_WSTR_MEM(str_buf));
        width = m_DuraTime->getMeasureBounds().size.width;
        if(mmi_fe_is_r2l_state())
        {
            m_DuraTime->setPos(VAPP_WG_KEY_MUSIC_PLAYER_TIME_X, VAPP_WG_KEY_MUSIC_PLAYER_TIME_Y);
        }
        else
        {
            m_DuraTime->setPos(VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_WIDTH - width - VAPP_WG_KEY_MUSIC_PLAYER_TIME_X, VAPP_WG_KEY_MUSIC_PLAYER_TIME_Y);
        }
       
    }
    getTimeString(m_CurrentTime,str_buf,10);
    m_PlayTime->setString(VFX_WSTR_MEM(str_buf));
    if(mmi_fe_is_r2l_state())
    {  
        VfxU32 width;
        width = m_PlayTime->getMeasureBounds().size.width;
        m_PlayTime->setPos(VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_WIDTH - VAPP_WG_KEY_MUSIC_PLAYER_TIME_X - width,VAPP_WG_KEY_MUSIC_PLAYER_TIME_Y);   
    }  
}

void VappWidgetKeyMusicPlayerPanel::onTimerClick(VfxTimer *timer)
{
    VFX_UNUSED(timer);
    setCurProgress();
}

void VappWidgetKeyMusicPlayerPanel::startCurTimer(void)
{
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_STARTCT, m_IsTimerStart);
    if(!m_IsTimerStart)
    {
        m_Timer->setStartDelay(100);
        m_Timer->setDuration(100);
        m_Timer->start();

        m_IsTimerStart = VFX_TRUE;
    }
}

void VappWidgetKeyMusicPlayerPanel::stopCurTimer(void)
{
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_STOPCT, m_IsTimerStart);
    if(m_IsTimerStart)
    {
        m_Timer->stop();

        m_IsTimerStart = VFX_FALSE;
    }
}


void VappWidgetKeyMusicPlayerPanel::onStatusChanged(void * result)
{
    VFX_UNUSED(result);
    getState();

    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    renderer->mustShowNextFrame();
    setCurProgress();
    updateDisplay();        
}

void VappWidgetKeyMusicPlayerPanel::onMediaChanged(void * result)
{
    VFX_UNUSED(result);
    getState();
    m_Prog->setRatio(0);
    
    m_IsRescrollText = VFX_TRUE;
    if(m_IsSwitchSong)
    {          
        m_Album->cancelDragSmart(VfxPoint(0,0));
    }
    m_IsPenEventCancel = VFX_TRUE;
    m_IsSwitchSong = VFX_FALSE;
    m_IsSwitchState = VFX_FALSE;
    getArtistname();  
    m_Album->onStopTimer();
    //m_Album->retsetWaitingState(); 
    m_Album->setAutoSwitch();
    
    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    renderer->mustShowNextFrame();       
    updateDisplay();
}

void VappWidgetKeyMusicPlayerPanel::onPlayend(void * result)
{
    
    VFX_UNUSED(result);
    getState();
    m_Prog->setRatio(100);

    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    renderer->mustShowNextFrame();
        
    updateDisplay();    
}

void VappWidgetKeyMusicPlayerPanel::onResetTime(void * result)
{
    VFX_UNUSED(result);
    getState();
    m_Prog->setRatio(0);

    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    renderer->mustShowNextFrame();
        
    updateDisplay();    
}

void VappWidgetKeyMusicPlayerPanel::playerCallback(void *user_data, VfxU32 type, void *result)
{
    VappWidgetKeyMusicPlayerPanel *this_ptr = (VappWidgetKeyMusicPlayerPanel*)user_data;

    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_CALLBACK, type, result);
    if(type == MMI_WIDGET_PLAYER_STATUS_CHANGE_CALLBACK)
    {
        this_ptr->onStatusChanged(result);
    }
    else if(type == MMI_WIDGET_PLAYER_MEDIA_CHANGE_CALLBACK)
    {
        this_ptr->onMediaChanged(result);
    }
    else if(type == MMI_WIDTET_PLAYER_RESET_TIME_CALLBACK)
    {
        this_ptr->onResetTime(result);
    }
    else if(type == MMI_WIDGET_PLAYER_PLAY_END_CALLBACK)
    {
        this_ptr->onPlayend(result);
    }
}

void VappWidgetKeyMusicPlayerPanel::onPlayDown(VfxPenEvent &event)
{
	event.type = VFX_PEN_EVENT_TYPE_DOWN;
    mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_PLAY, event);
}

void VappWidgetKeyMusicPlayerPanel::onPlayUp(VfxPenEvent &event)
{
		event.type = VFX_PEN_EVENT_TYPE_UP;
    mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_PLAY, event);
}

void VappWidgetKeyMusicPlayerPanel::onPauseDown(VfxPenEvent &event)
{
    VfxBool is_pause_disable;
    VfxS32 result = 0;

    mmi_kl_widget_musicplayer_get_info(VAPP_WIDGET_AUDPLAYER_INFO_PAUSE_DISABLE, (void*)&result);
    is_pause_disable = result ? VFX_TRUE : VFX_FALSE;
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_PAUSEDOWN, event.type, is_pause_disable);
    	event.type = VFX_PEN_EVENT_TYPE_DOWN;
    if(is_pause_disable)
    {
        mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_STOP, event);
    }
    else
    {
        mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_PAUSE, event);
    }
}

void VappWidgetKeyMusicPlayerPanel::onPauseUp(VfxPenEvent &event)
{
    VfxBool is_pause_disable;
    VfxS32 result = 0;

    mmi_kl_widget_musicplayer_get_info(VAPP_WIDGET_AUDPLAYER_INFO_PAUSE_DISABLE, (void*)&result);
    is_pause_disable = result ? VFX_TRUE : VFX_FALSE;
    
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_PAUSEUP, event.type, is_pause_disable);
    
    	event.type = VFX_PEN_EVENT_TYPE_UP;
    if(is_pause_disable)
    {
        mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_STOP, event);
    }
    else
    {
        mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_PAUSE, event);
    }
}

void VappWidgetKeyMusicPlayerPanel::updateDisplay(void)
{
    VfxWString temp_title;
    VfxWString temp_title1, temp_title2;
    
    VfxObjWeakPtr this_ptr = this;
    if (this_ptr == NULL)
    {
        return;
    }    

    
#ifdef __USB_IN_NORMAL_MODE__
    if (srv_usb_is_in_mass_storage_mode())
    {
        m_IsReady = VFX_FALSE;
        m_State = STATE_INIT;
    #if !defined(__COSMOS_MMI__)
      //  temp_title = VFX_WSTR_RES(STR_GLOBAL_NOT_AVAILABLE_IN_MASS_STORAGE_MODE);
    #endif
    }
#endif /* __USB_IN_NORMAL_MODE__ */

    getState();
    if(m_State == STATE_INIT)
    {
        if(m_IsReady)
        {
            if(mmi_kl_widget_musicplayer_is_play_continue())
            {
                m_PlayButton->setDisplay(VFX_FALSE);
            }
            else
            {
                m_PlayButton->setDisplay(VFX_TRUE);
            }
            #ifdef __MMI_MAINLCD_320X240__
            if(m_IsPrevPressing)
            {
                m_PrevButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_PREV_SELECT);
            }
            else
            {
                m_PrevButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_PREV);
            }

            if(m_IsNextPressing)
            {
                  m_NextButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_NEXT_SELECT);
            }
            else
            {
                 m_NextButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_NEXT);
            }
           #endif
        }
        else
        {
            m_PlayButton->setDisplay(VFX_FALSE);
            #ifdef __MMI_MAINLCD_320X240__
            m_PrevButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_PREV_DIS);
            m_NextButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_NEXT_DIS);
            #endif
            m_Prog->setRatio(0);
        }
        stopCurTimer();
    }
    else if(m_State == STATE_PLAY)
    {
        m_PlayButton->setDisplay(VFX_FALSE);
         #ifdef __MMI_MAINLCD_320X240__
            if(m_IsPrevPressing)
            {
                m_PrevButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_PREV_SELECT);
            }
            else
            {
                m_PrevButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_PREV);
            }

            if(m_IsNextPressing)
            {
                  m_NextButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_NEXT_SELECT);
            }
            else
            {
                 m_NextButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_NEXT);
            }
           #endif
        startCurTimer();
    }
    else if(m_State == STATE_PROCESS)
    {
        if(mmi_kl_widget_musicplayer_is_play_continue())
        {
            m_PlayButton->setDisplay(VFX_FALSE);
        }
        else
        {
            m_PlayButton->setDisplay(VFX_TRUE);
        }
         #ifdef __MMI_MAINLCD_320X240__
            if(m_IsPrevPressing)
            {
                m_PrevButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_PREV_SELECT);
            }
            else
            {
                m_PrevButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_PREV);
            }

            if(m_IsNextPressing)
            {
                  m_NextButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_NEXT_SELECT);
            }
            else
            {
                 m_NextButton->setImage(VAPP_KL_WG_MUSIC_PLAYER_PICK_NEXT);
            }
           #endif
        stopCurTimer();
    }

    S32 width;
    if(!m_IsReady)
    {
        temp_title = VFX_WSTR_RES(VAPP_WG_KEY_STR_MUSIC_PLAYER_NO_SONGS);
    }
    else
    {        
        temp_title = VFX_WSTR_MEM((const U16*)m_ArtistName);        
    }

    if(!temp_title.isEmpty() && m_IsReady)
    {        
        temp_title1 = VFX_WSTR(" - ");
        temp_title +=temp_title1;
    }
    else
    {
        if(mmi_kl_widget_musicplayer_play_media_is_audio()&& m_IsReady)
        {
            #ifdef __PLST_SERVICE_DB_SUPPORT__
            temp_title = VFX_WSTR_RES(STR_ID_SRV_PLST_UNKNOWN_ARTIST);
            temp_title1 = VFX_WSTR(" - ");
            temp_title +=temp_title1;      
            #else
            temp_title.setEmpty();
            #endif
        }
        else
        {
        temp_title.setEmpty();
        }
    }
    
    if(!m_IsReady)
    {
        temp_title2 = VFX_WSTR_RES(VAPP_WG_KEY_STR_MUSIC_PLAYER_NO_SONGS);
    }
    else
    {
        temp_title2 = VFX_WSTR_MEM((const U16*)getFilename());
    }

    if(temp_title.isEmpty())
    {
        temp_title = temp_title2;
    }
    else
    {
        temp_title += temp_title2;
    }
    
    if(m_IsRescrollText)
    {
        nameFadeIn();
        m_MarqueeText->setMovableFrame(temp_title,  VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_WG_KEY_MUSIC_PLAYER_NAME_FONT)));
        m_MarqueeText->stopScroll();
        m_MarqueeText->setStartDelay(500);
        m_MarqueeText->startScroll();
        if (m_IsRescrollText)
        {
            m_IsRescrollText = VFX_FALSE;
        }
    }

    if(m_IsReady)
    {
        getDuration();
        getPlaytime();
    }
    else
    {
        m_Duration = 0;
        m_CurrentTime = 0;
    }
    VfxWChar str_buf[10];  

    getTimeString(m_Duration,str_buf,10);
    m_DuraTime->setString(VFX_WSTR_MEM(str_buf));
    m_DuraTime->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_WG_KEY_MUSIC_PLAYER_TIME_FONT)));
    width =   m_DuraTime->getMeasureBounds().size.width;

    if(mmi_fe_is_r2l_state())
    {
        m_DuraTime->setPos(VAPP_WG_KEY_MUSIC_PLAYER_TIME_X, VAPP_WG_KEY_MUSIC_PLAYER_TIME_Y);
    }
    else
    {
        m_DuraTime->setPos(VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_WIDTH - width - VAPP_WG_KEY_MUSIC_PLAYER_TIME_X, VAPP_WG_KEY_MUSIC_PLAYER_TIME_Y);
    }
    getTimeString(m_CurrentTime,str_buf,10);
    m_PlayTime->setString(VFX_WSTR_MEM(str_buf));
    m_PlayTime->setFont(VfxFontDesc(VFX_FONT_DESC_VF_SIZE(VAPP_WG_KEY_MUSIC_PLAYER_TIME_FONT)));
    if(mmi_fe_is_r2l_state())
    {   
        width =   m_PlayTime->getMeasureBounds().size.width;
        m_PlayTime->setPos(VAPP_WG_KEY_MUSIC_PLAYER_PROGRESS_BG_WIDTH - VAPP_WG_KEY_MUSIC_PLAYER_TIME_X - width,VAPP_WG_KEY_MUSIC_PLAYER_TIME_Y);   
    }
}

void VappWidgetKeyMusicPlayerPanel::nameFadeOut(void)
{
    m_MarqueeText->setAutoAnimate(VFX_FALSE);
    m_MarqueeText->setOpacity(0.0f);
}
 
void VappWidgetKeyMusicPlayerPanel::nameFadeIn(void)
{
    m_MarqueeText->setAutoAnimate(VFX_TRUE);   
    m_MarqueeText->setOpacity(1.0f);    
}

void VappWidgetKeyMusicPlayerPanel::switchPrev(VfxKeyEvent & event)
{
    VfxObjWeakPtr this_ptr = this;

    m_Album->setAnimaDirection(VFX_TRUE);

    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_SWITCH_PREV, event.type);

    VfxPenEvent event_pen;		
    if(event.type == VFX_KEY_EVENT_TYPE_DOWN)
    {
    		event_pen.type = VFX_PEN_EVENT_TYPE_DOWN;
        mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_PREV, event_pen);
    }
    else if(event.type == VFX_KEY_EVENT_TYPE_UP)
    {
        event_pen.type = VFX_PEN_EVENT_TYPE_UP;
        mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_PREV, event_pen);
    }
    onButtonUp(this_ptr);
}

void VappWidgetKeyMusicPlayerPanel::switchNext(VfxKeyEvent & event)
{
    VFX_TRACE(("\nyaling switch next\n"));

    VfxObjWeakPtr this_ptr = this;
    m_Album->setAnimaDirection(VFX_FALSE);

    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_SWITCH_NEXT, event.type);
    VfxPenEvent event_pen;	
    if(event.type == VFX_KEY_EVENT_TYPE_DOWN)
    {
    	  event_pen.type = VFX_PEN_EVENT_TYPE_DOWN;
        mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_NEXT, event_pen);
    }
    else if(event.type == VFX_KEY_EVENT_TYPE_UP)
    {
    	  event_pen.type = VFX_PEN_EVENT_TYPE_UP;
        mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_NEXT, event_pen);
    }
    onButtonUp(this_ptr);
}

void VappWidgetKeyMusicPlayerPanel::onButtonUp(VfxObjWeakPtr this_ptr)
{
    if(this_ptr != NULL)
    {
        updateDisplay();
    }
}


void VappWidgetKeyMusicPlayerPanel::switchPlayPause(VfxKeyEvent & event)
{
    VfxBool is_pause_disable;
    VfxS32 result = 0;
    VfxPenEvent event_pen;	
    VfxObjWeakPtr this_ptr = this;
    
    getState();
    mmi_kl_widget_musicplayer_get_info(VAPP_WIDGET_AUDPLAYER_INFO_PAUSE_DISABLE, (void*)&result);
    is_pause_disable = result ? VFX_TRUE : VFX_FALSE;    

    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_SWITCH_PLAY,event.type, m_State, is_pause_disable);
    if(event.type == VFX_KEY_EVENT_TYPE_DOWN)
    {
        event_pen.type = VFX_PEN_EVENT_TYPE_DOWN;
        if(m_State == STATE_PLAY)
        {
            if(is_pause_disable)
            {            
                mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_STOP, event_pen);
            }
            else
            {
                mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_PAUSE, event_pen);
            }   
        }
        else
        {
            mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_PLAY, event_pen);
        }
    }
    else if(event.type == VFX_KEY_EVENT_TYPE_UP)
    {
    	  event_pen.type = VFX_PEN_EVENT_TYPE_UP;
        if(m_State == STATE_PLAY)
        {
            if(is_pause_disable)
            {            
                mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_STOP, event_pen);
            }
            else
            {
                mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_PAUSE, event_pen);
            }   
        }
        else
        {
            mmi_kl_widget_musicplayer_button_process(VAPP_WIDGET_BUTTON_PLAY, event_pen);
        }
    }
    onButtonUp(this_ptr);
}

VfxBool VappWidgetKeyMusicPlayerPanel::onKeyInput(VfxKeyEvent & event)
{
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_KEY_TYPE, event.type, event.keyCode, m_IsPickNext, m_IsPickPrev);
    if(m_Album->switchState())
    {
        if(event.type == VFX_KEY_EVENT_TYPE_UP)
        {
            stopLPTimer();
	    m_IsPowerPressing = VFX_FALSE;
            m_IsPrevPressing = VFX_FALSE;
            m_IsNextPressing = VFX_FALSE;
            m_IsDownGetFirst = VFX_FALSE;
	    updateDisplay();
        }

        return VfxControl::onKeyInput(event);
    }
    if (event.type == VFX_KEY_EVENT_TYPE_DOWN)
    {
        //m_Album->setSwitchInfo(0);
        m_IsPickNext = VFX_FALSE;
        m_IsPickPrev = VFX_FALSE;
        m_IsDownGetFirst = VFX_TRUE;
        stopLPTimer();
        switch(event.keyCode)
        {
        case VFX_KEY_CODE_ARROW_UP:
            if(!m_IsReady)
            {
                return VfxControl::onKeyInput(event);
            }
            m_IsPrevPressing = VFX_TRUE;
            m_IsNextPressing = VFX_FALSE;
            m_IsPowerPressing = VFX_FALSE;
            switchPrev(event);
            return VFX_TRUE;
        case VFX_KEY_CODE_CSK:
            if(m_IsReady)
            {
                switchPlayPause(event);
            }
            m_IsNextPressing = VFX_FALSE;
            m_IsPrevPressing = VFX_FALSE;
            m_IsPowerPressing = VFX_TRUE;
            return VFX_TRUE;
        case VFX_KEY_CODE_ARROW_DOWN:
            if(!m_IsReady)
            {
                return VfxControl::onKeyInput(event);
            }
            m_IsNextPressing = VFX_TRUE;
            m_IsPrevPressing = VFX_FALSE;
            m_IsPowerPressing = VFX_FALSE;
            switchNext(event);
            return VFX_TRUE;
        default:
            break;
         }
    }
    else if(event.type == VFX_KEY_EVENT_TYPE_LONG_PRESS)
    {
        if(!m_IsReady && event.keyCode != VFX_KEY_CODE_CSK)
        {
            return VfxControl::onKeyInput(event);
        }
        if(!m_IsPowerPressing && !m_IsPrevPressing && !m_IsNextPressing)
        {
            return VfxControl::onKeyInput(event);
        }
        switch(event.keyCode)
        {
        case VFX_KEY_CODE_ARROW_UP:
            stopLPTimer();
            m_IsPickPrev = VFX_TRUE;
            m_IsPickNext = VFX_FALSE;
            startLPTimer();
            return VFX_TRUE;
        case VFX_KEY_CODE_ARROW_DOWN:
            stopLPTimer();
            m_IsPickNext = VFX_TRUE;
            m_IsPickPrev = VFX_FALSE;
            startLPTimer();
            return VFX_TRUE;
        default:
            m_IsPickNext = VFX_FALSE;
            m_IsPickPrev = VFX_FALSE;
            stopLPTimer();
            break;
        }
    }
    else if (event.type == VFX_KEY_EVENT_TYPE_UP)
    {
        VFX_TRACE(("\nyaling onkeyinput up\n"));
        stopLPTimer();
        if(!m_IsDownGetFirst)
        {
            return VFX_FALSE;
        }
        if(!m_IsPowerPressing && !m_IsPrevPressing && !m_IsNextPressing)
        {
            return VfxControl::onKeyInput(event);
        }
        m_IsPowerPressing = VFX_FALSE;
        m_IsPrevPressing = VFX_FALSE;
        m_IsNextPressing = VFX_FALSE;
        m_IsDownGetFirst = VFX_FALSE;
        if(m_IsPickNext || m_IsPickPrev)
        {
            m_IsPickNext = VFX_FALSE;
            m_IsPickPrev = VFX_FALSE;
            updateDisplay();
        }
        else
        {
            switch(event.keyCode)
            {
            case VFX_KEY_CODE_ARROW_UP:
                if(!m_IsReady)
                {
                    return VfxControl::onKeyInput(event);
                }
                switchPrev(event);
                return VFX_TRUE;
            case VFX_KEY_CODE_CSK:
                if(m_IsReady)
                {
                    switchPlayPause(event);
                }
                else
                {
                    mmi_kl_widget_musicplayer_launch_app();
                }
                return VFX_TRUE;
            case VFX_KEY_CODE_ARROW_DOWN:
                if(!m_IsReady)
                {
                    return VfxControl::onKeyInput(event);
                }
                switchNext(event);
                return VFX_TRUE;
            default:
                break;
            }
        }
    }   
   
   return VfxControl::onKeyInput(event);
}


VfxBool VappWidgetKeyMusicPlayerPanel::onPenInput(VfxPenEvent & event)
{
    VfxBool ret = VFX_FALSE;
    VfxSize distance;
    VfxPoint pos(event.getRelPos(this));
    VfxObjWeakPtr this_ptr = this;

    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_PEN_TYPE, event.type, m_State, m_IsSwitchSong, m_IsSwitchState);
    if(m_Album->switchState())
    {
        return VFX_TRUE;
    }

    switch(event.type)       
    {
    case  VFX_PEN_EVENT_TYPE_DOWN:
        m_IsPenEventCancel = VFX_FALSE;
        VFX_TRACE(("\nyaling on pen input down\n"));
        //m_Album->setSwitchInfo(0);
        if (m_State != STATE_PLAY && m_PlayButton->isContains(pos, BUT_PLAY))
        {
            if(!m_IsReady)
            {
                m_IsLaunchApp = VFX_TRUE;
                return  VFX_TRUE;
            }
            m_FirstTap = event.pos;
            m_LastMovePos = event.pos;
            m_IsSwitchState = VFX_TRUE;
            m_IsSwitchSong = VFX_FALSE;
            m_IsPowerPressing = VFX_FALSE;
            m_IsPrevPressing = VFX_FALSE;
            m_IsNextPressing = VFX_FALSE;
            ret = VFX_TRUE;
            return ret;
        }
        #ifdef __MMI_MAINLCD_320X240__
        else if(m_IsReady && m_PrevButton->isContains(pos, BUT_PREV))
        {
            VfxKeyEvent event;
            m_IsPrevPressing = VFX_TRUE;
            m_IsNextPressing = VFX_FALSE;
            m_IsSwitchSong = VFX_FALSE;
            m_IsSwitchState = VFX_FALSE;
            event.type = VFX_KEY_EVENT_TYPE_DOWN;
            switchPrev(event);
            return VFX_TRUE;
        }
        else if(m_IsReady && m_NextButton->isContains(pos, BUT_NEXT))
        {
            VfxKeyEvent event;
            m_IsPrevPressing = VFX_FALSE;
            m_IsNextPressing = VFX_TRUE;
            m_IsSwitchSong = VFX_FALSE;
            m_IsSwitchState = VFX_FALSE;
            event.type = VFX_KEY_EVENT_TYPE_DOWN;
            switchNext(event);
            return VFX_TRUE;
        }
        #endif
        else if(m_Album->isContains(pos))
        {
            if(!m_IsReady)
            {
                m_IsLaunchApp = VFX_TRUE;
                return  VFX_TRUE;
            }
            m_FirstTap = event.pos;
            m_LastMovePos = event.pos;
            if(m_State!= STATE_PLAY && !m_PlayButton->isContains(pos, BUT_PLAY))
            {
                m_IsSwitchSong = VFX_TRUE;
                m_IsSwitchState = VFX_FALSE;
            }
            else
            {
                m_IsSwitchSong = VFX_FALSE;
                m_IsSwitchState = VFX_TRUE;
            }
            ret = VFX_TRUE;
            return ret;
        }                    
        break;
    case VFX_PEN_EVENT_TYPE_LONG_TAP:
        if(m_IsPrevPressing || m_IsNextPressing)
        {
            stopLPTimer();
            if(m_IsPrevPressing)
            {
                m_IsPickPrev = VFX_TRUE;
                m_IsPickNext = VFX_FALSE;
            }

            if(m_IsNextPressing)
            {
                m_IsPickPrev = VFX_FALSE;
                m_IsPickNext = VFX_TRUE;
            }
            startLPTimer();
        }
        ret = MMI_TRUE;
        return ret;
    case VFX_PEN_EVENT_TYPE_MOVE:
        
        VFX_TRACE(("\nyaling on pen input move\n"));
        if(!m_IsReady)
        {
            return  MMI_TRUE;
        }
        if(m_IsPenEventCancel)
        {
            return VFX_TRUE;
        }
        #ifdef __MMI_MAINLCD_320X240__
        if(m_IsPrevPressing || m_IsNextPressing)
        {
            if(m_IsPrevPressing && !m_PrevButton->isContains(pos, BUT_PREV))
            {
                VfxKeyEvent event;
                stopLPTimer();
                event.type = VFX_KEY_EVENT_TYPE_UP;
                m_IsPrevPressing = VFX_FALSE;
                switchPrev(event);
                return VFX_TRUE;
            }

            if(m_IsNextPressing && !m_NextButton->isContains(pos, BUT_NEXT))
            {
                VfxKeyEvent event;
                stopLPTimer();
                event.type = VFX_KEY_EVENT_TYPE_UP;
                m_IsNextPressing = VFX_FALSE;
                switchNext(event);
                return VFX_TRUE;
            }
        }
        #endif
        if (m_IsSwitchSong || m_IsSwitchState)
        {
            if (abs(m_LastMovePos.x - event.pos.x) >= VAPP_WIDGET_PLAYER_TOUCH_MIN_RDS ||
                abs(m_LastMovePos.y - event.pos.y) >= VAPP_WIDGET_PLAYER_TOUCH_MIN_RDS)
            {
                VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_PEN_TYPE_SWITCH_SONG);
               
                m_IsSwitchState = VFX_FALSE;
                m_IsSwitchSong = VFX_TRUE;
                distance = VfxSize((event.pos.x - m_FirstTap.x), 
                                   (event.pos.y - m_FirstTap.y));                
                m_Album->setDragSmart(distance, pos);                
            }
            ret = VFX_TRUE;
             return ret;
        }        

    case VFX_PEN_EVENT_TYPE_UP:
        VFX_TRACE(("\nyaling on pen input up\n"));
        stopLPTimer();
        if(!m_IsReady && m_Album->isContains(pos))
        {
            mmi_kl_widget_musicplayer_launch_app();
            return  VFX_TRUE;
        }  
        else if(!m_IsReady)
        {
            return VFX_TRUE;
        }
        #ifdef __MMI_MAINLCD_320X240__
        if(m_IsPrevPressing || m_IsNextPressing)
        {
            if(m_IsPrevPressing)
            {
                VfxKeyEvent event;
                event.type = VFX_KEY_EVENT_TYPE_UP;
                m_IsPrevPressing = VFX_FALSE;
                switchPrev(event);
                return VFX_TRUE;
            }

            if(m_IsNextPressing)
            {
                VfxKeyEvent event;
                event.type = VFX_KEY_EVENT_TYPE_UP;
                m_IsNextPressing = VFX_FALSE;
                switchNext(event);
                return VFX_TRUE;
            }
        }
        #endif
        if(m_IsPenEventCancel)
        {
            return VFX_TRUE;
        }
        if (m_IsSwitchSong || m_IsSwitchState)
        {
            if (abs(m_LastMovePos.x - event.pos.x) >= VAPP_WIDGET_PLAYER_TOUCH_MIN_RDS ||
                abs(m_LastMovePos.y - event.pos.y) >= VAPP_WIDGET_PLAYER_TOUCH_MIN_RDS)
            {
                m_IsSwitchSong = VFX_TRUE;
            }
            else
            {
                if(m_IsSwitchSong)
                {
                    m_IsSwitchSong = VFX_FALSE;
                    distance = VfxSize((0),(0));
                    m_Album->setDragSmart(distance, pos);
                }
            }
        }
        if (m_IsSwitchSong)
        {
            VfxU8 m_switchsong = 0; /* 1, prev ; 2, next */
            distance = VfxSize((event.pos.x - m_FirstTap.x), 
                               (event.pos.y - m_FirstTap.y));
            m_Album->setDragSmartDone(distance, pos);
            if(event.pos.y > m_FirstTap.y)
            {
                m_switchsong = 1;
                /*
                VfxKeyEvent event;
                event.type = VFX_KEY_EVENT_TYPE_DOWN;
                switchPrev(event);
                event.type = VFX_KEY_EVENT_TYPE_UP;
                switchPrev(event);
                */
            }
            else
            {
                m_switchsong = 2;
                /*
                VfxKeyEvent event;
                event.type = VFX_KEY_EVENT_TYPE_DOWN;
                switchNext(event);
                event.type = VFX_KEY_EVENT_TYPE_UP;
                switchNext(event);
                */
            }
            m_Album->setSwitchInfo(m_switchsong);
            m_IsSwitchSong = VFX_FALSE;
            ret = VFX_TRUE;
             return ret;
        }
        else if(m_IsSwitchState)
        {
            VfxKeyEvent  event;
            event.type = VFX_KEY_EVENT_TYPE_DOWN;
            switchPlayPause(event);
            event.type = VFX_KEY_EVENT_TYPE_UP;
            switchPlayPause(event);      
             return VFX_TRUE;
        }
        break;

    case VFX_PEN_EVENT_TYPE_ABORT:
        stopLPTimer();
        if(!m_IsReady)
        {
            return  MMI_TRUE;
        }  
        VFX_TRACE(("\nyaling on pen input abort\n"));
        if(m_IsSwitchSong)
        {          
            m_Album->cancelDragSmart(pos);            
        }
        m_IsSwitchSong = VFX_FALSE;
        m_IsSwitchState = VFX_FALSE;
        m_IsPrevPressing = VFX_FALSE;
        m_IsNextPressing = VFX_FALSE;
         return VFX_TRUE;
    }

   return VFX_TRUE;
}

void VappWidgetKeyMusicPlayerPanel::switchSong(VfxU8 type)
{
    if (type == 1) /* prev */
    {
        VfxKeyEvent event;
        event.type = VFX_KEY_EVENT_TYPE_DOWN;
        switchPrev(event);
        event.type = VFX_KEY_EVENT_TYPE_UP;
        switchPrev(event);
    }
    else if(type == 2) /* next */
    {
        VfxKeyEvent event;
        event.type = VFX_KEY_EVENT_TYPE_DOWN;
        switchNext(event);
        event.type = VFX_KEY_EVENT_TYPE_UP;
        switchNext(event);
    }
}

void  VappWidgetKeyMusicPlayerPanel::suspend(void)
{
    getState();
    if(m_State == STATE_PLAY)
    {
        stopCurTimer();
    }        
}

void  VappWidgetKeyMusicPlayerPanel::resume(void)
{
    getState();
    if(m_State == STATE_PLAY)
    {
        startCurTimer();
    }
    setCurProgress();
}


VfxChar* VappWidgetKeyMusicPlayerPanel::getFilename(void)
{
    mmi_kl_widget_musicplayer_get_info(VAPP_WIDGET_AUDPLAYER_INFO_TITLE, m_FileName);
    return m_FileName;
}


VfxChar* VappWidgetKeyMusicPlayerPanel::getArtistname(void)
{
    VFX_TRACE(("\nYaling get artist name\n"));
    mmi_kl_widget_musicplayer_get_info(VAPP_WIDGET_AUDPLAYER_INFO_ARTIST, m_ArtistName);
    return m_ArtistName;
}

VfxU64 VappWidgetKeyMusicPlayerPanel::getDuration(void)
{
    mmi_kl_widget_musicplayer_get_info(VAPP_WIDGET_AUDPLAYER_INFO_DURATION, &m_Duration);
    return m_Duration;
}

VfxU64 VappWidgetKeyMusicPlayerPanel::getPlaytime(void)
{
    mmi_kl_widget_musicplayer_get_info(VAPP_WIDGET_AUDPLAYER_INFO_CURR_TIME, &m_CurrentTime);
    return m_CurrentTime;
}

VfxU16 VappWidgetKeyMusicPlayerPanel::getState(void)
{
    mmi_kl_widget_musicplayer_get_info(VAPP_WIDGET_AUDPLAYER_INFO_STATE, &m_State);
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_GET_STATE, m_State);
    return m_State;
}

 
VAPP_WIDGET_SYS_PUBLISH_NATIVE(
    VappWidgetKeyMusicPlayer,
    VAPP_WIDGET_TYPE_KEY_MUSIC_PLAYER,
    VappWidgetKeyMusicPlayerPublisher);

VAPP_WIDGET_IMPLEMENT_CLASS(VappWidgetKeyMusicPlayer, VappWidget);


/*****************************************************************************
 * Class VappWidgetKeyMusicPlayer
 *****************************************************************************/
VappWidgetKeyMusicPlayer::VappWidgetKeyMusicPlayer(): m_Panel(NULL)
{

}

VappWidgetId VappWidgetKeyMusicPlayer::getId() const
{
    return VappWidgetId(VAPP_WIDGET_SRC_NATIVE, VAPP_WIDGET_TYPE_KEY_MUSIC_PLAYER);
}


VfxSize VappWidgetKeyMusicPlayer::getMaxSize() const
{
    return VfxSize(VAPP_WG_KEY_MUSIC_PLAYER_WIDTH, VAPP_WG_KEY_MUSIC_PLAYER_HEIGHT);
}


VfxS32 VappWidgetKeyMusicPlayer::getName(VfxWChar *string, VfxS32 size) const
{
#ifdef __MMI_MEDIA_PLAYER__
    const VfxWChar *str = vfxSysResGetStr(VAPP_WG_KEY_STR_MUSIC_PLAYER);
#else
    const VfxWChar *str = vfxSysResGetStr(VAPP_WG_KEY_STR_AUDIO_PLAYER);
#endif
    VFX_ASSERT(string && size > 0);

    mmi_wcsncpy((WCHAR *)string, (const WCHAR *)str, size - 1);

    return vfx_sys_wcslen(string);
}


VfxFrame *VappWidgetKeyMusicPlayer::createIcon(VfxObject *parentObj)
{
    VfxImageFrame *icon;

    VFX_OBJ_CREATE(icon, VfxImageFrame, parentObj);
    icon->setResId(VAPP_KL_WG_ICON_MUSIC_PLAYER);

    return icon;
}

void VappWidgetKeyMusicPlayer::onCreateView()
{
    VappWidget::onCreateView();
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_ENTRY);
    VFX_OBJ_CREATE(m_Panel, VappWidgetKeyMusicPlayerPanel, this);
}

void VappWidgetKeyMusicPlayer::onReleaseView()
{  
    VFX_LOG(VFX_INFO2, TRC_VAPP_KEY_WG_MUSIC_PLAYER_EXIT);
    VFX_OBJ_CLOSE(m_Panel);
    VappWidget::onReleaseView();
}

void VappWidgetKeyMusicPlayer::onSuspend()
{
    m_Panel->suspend();
}

void VappWidgetKeyMusicPlayer::onResume()
{
    m_Panel->resume();
}

VfxPoint VappWidgetKeyMusicPlayer::onGetEditButtonOffset()
{
    return VfxPoint(0, 0);
}

VfxBool VappWidgetKeyMusicPlayer::onPreviewPenInput(VfxPenEvent & event)
{
    return VFX_FALSE;
}

VfxBool VappWidgetKeyMusicPlayer::onPenInput(VfxPenEvent & event)
{
    return VFX_TRUE;
}

#endif  /*#defined(__MMI_VUI_WIDGET_KEY_MUSIC_PLAYER__)*/


