/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *
 *
 * Project:
 * --------
 *  Venus
 *
 * Description:
 * ------------
 *  Internal UI componets of home screen
 *
 * Author:
 * -------
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/*****************************************************************************
 * Include
 *****************************************************************************/

#include "MMI_features.h"

#ifdef __MMI_VUI_HOMESCREEN__

#include "vfx_cpp_base.h"
#include "vfx_datatype.h"
#include "vfx_basic_type.h"
#include "vrt_datatype.h"
#include "vrt_system.h"
#include "vfx_sys_memory.h"
#include "vfx_object.h"
#include "vdat_network_info.h"
#include "vfx_signal.h"
#include "vapp_hs_shortcut_panel.h"
#include "vfx_timer.h"
#include "vapp_hs_widget_base.h"
#include "vapp_hs_widget_mgr.h"
#include "vfx_system.h"
#include "vapp_shell_panel.h"
#include "vfx_input_event.h"
#include "vcp_popup.h"
#include "vfx_string.h"
#include "vfx_frame.h"
#include "vfx_auto_animate.h"
#include "vfx_control.h"
#include "vfx_transform.h"
#include "vfx_async_signal.h"
#include "vapp_hs_scr.h"
#include "vapp_hs_cp.h"
#include "vadp_v2p_hs.h"
#include "vadp_app_trc.h"
#include "vapp_wallpaper_cfg.h"
#include "vapp_wallpaper_kit.h"
#include "vapp_hs_res.h"

/* Pluto MMI headers: */
extern "C"
{

#include "kal_general_types.h"
#include "kal_public_api.h"
#include "kal_trace.h"

#include "GlobalResDef.h"
#include "MMIDataType.h"
#include "mmi_frm_events_gprot.h"
#include "wgui_categories_util.h"
#include "AlertScreen.h"
#include "limits.h"
#include "IdleGprot.h"
#include "PhoneSetupGprots.h"   // extern pluto setting api
#include "SimSpaceGprot.h"      // mmi_sim_space_launch
#include "lcd_sw_inc.h"

#if defined(__MMI_SEARCH_WEB_GOOGLE__)
#include "SearchWebGprot.h"
#endif

}

#if defined(__AFX_RT_TEST__)
// For Venus Testbed entry
extern "C" void vtst_rt_main_entry(void);
#endif


/*****************************************************************************
 * Home screen app category
 *****************************************************************************/

VfxBool VappHsScr::s_is_widget_bar_opened = VFX_FALSE;

VfxBool VappHsScr::s_bootupInit = VFX_TRUE;

VfxS32 VappHsScr::s_desktop_pos = 0;

VfxS32 VappHsScr::s_widget_bar_pos = 0;

const VfxFloat VappHsScr::s_moveOpacity = 0.65f;

const VfxS32 VappHsScr::s_closeWidgetBarDelay = 15000;

const VfxS32 VappHsScr::s_penOffsetThreshold = 15;

#if !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__)
const VfxS32 VappHsScr::s_maxDeskTopWidget = 10;
#else
const VfxS32 VappHsScr::s_maxDeskTopWidget = 10;
#endif /* !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__) */

const VfxS32 VappHsScr::s_lockWidgetDelayedTime = 1000;

VappHsScr::VappHsScr() :
    m_wallpaper(NULL),
    m_idleModeText(NULL),
    m_widgetBar(NULL),
    m_desktop(NULL),
#if defined(VAPP_HS_CFG_MULTI_DESKTOP)
    m_desktopIndicator(NULL),
#endif
#if defined(VAPP_HS_CFG_SHORTCUT_PANEL)
    m_shortcutPanel(NULL),
#endif
#if defined(__MMI_SEARCH_WEB_GOOGLE__)
    m_searchBar(NULL),
#endif
    m_widgetMgr(NULL),
    m_movingFrameS(NULL),
    m_movingFrameL(NULL),
    m_movingFrameOriParent(NULL),
    m_timerAddWidget(NULL),
    m_timerLockWidget(NULL),
    m_timerResumeWallpaper(NULL),
    m_timerCloseWidgetBar(NULL),
    m_widgetType(0),
    m_widgetId(0),
    m_errStrId(0),
    m_longPressEnable(VFX_FALSE),
    m_isRecvPenDown(VFX_FALSE),
    m_isSuspendForScreenExit(VFX_FALSE)
{
    // Do nothing.
}


VfxSize VappHsScr::getScreenSize()
{
    vrt_size_struct main_screen_size;
    vrt_color_type_enum main_screen_color_format;

    vrt_sys_get_main_screen_info(&main_screen_size, &main_screen_color_format);

    return VfxSize(main_screen_size.width, main_screen_size.height);
}


void VappHsScr::initWallpaper()
{
    if(m_wallpaper)
    {
        VFX_OBJ_CLOSE(m_wallpaper);
    }
    //
    // Create the wallpaper.
    //
    m_wallpaper = VappWallpaperKit::createWallpaper(this, VAPP_WALLPAPER_SRC_HOMESCREEN, VappHsDesktop::TOTAL_PAGE);

    // suspend on init view , it will resume on enter view
    m_wallpaper->suspend();
}


void VappHsScr::deinitWallpaper()
{
    if(m_wallpaper)
    {
        VFX_OBJ_CLOSE(m_wallpaper);

        m_isSuspendForScreenExit = VFX_FALSE;
    }
}


void VappHsScr::initIdleModeText()
{
#if defined(__MMI_SEARCH_WEB_GOOGLE__)
    // If search bar is turned on, do not display the idle mode text.
    if (mmi_search_web_hot_key_is_enabled(MMI_SEARCH_WEB_HOT_KEY_TOUCH_HINT))
    {
        return;
    }
#endif /* defined(__MMI_SEARCH_WEB_GOOGLE__) */

    VfxSize screenSize = getScreenSize();
    VfxPoint p;

    p.x = 0;
    p.y = screenSize.height - INDICATOR_GAP_Y - IDLE_MODE_TEXT_GAP_Y;

    VFX_OBJ_CREATE(m_idleModeText, VappHsIdleModeText, this);
    m_idleModeText->setAnchor(VfxFPoint(0.0f, 1.0f));
    m_idleModeText->setPos(p);

    VdatNetworkInfo *networkSrv = VFX_OBJ_GET_INSTANCE(VdatNetworkInfo);
    networkSrv->m_signalIdleModeTextChanged.connect(this, &VappHsScr::onIdleModeTextChanged);
    networkSrv->m_signalIdleModeIconChanged.connect(this, &VappHsScr::onIdleModeIconChanged);

    // Update here; or the text will appear later when the home screen is shown.
    onIdleModeTextChanged(networkSrv);
    onIdleModeIconChanged(networkSrv);
}


void VappHsScr::deinitIdleModeText()
{
    VdatNetworkInfo *networkSrv = VFX_OBJ_GET_INSTANCE(VdatNetworkInfo);

    networkSrv->m_signalIdleModeTextChanged.disconnect(this, &VappHsScr::onIdleModeTextChanged);
    networkSrv->m_signalIdleModeIconChanged.disconnect(this, &VappHsScr::onIdleModeIconChanged);

    VFX_OBJ_CLOSE(m_idleModeText);
}


void VappHsScr::initDesktop()
{
    // Create.
    VFX_OBJ_CREATE(m_desktop, VappHsDesktop, this);
    m_desktop->m_signalBoundsChanged.connect(this, &VappHsScr::onDesktopBoundsChanged);

    // Set the valid region on the desktop. The valid region of the desktop
    // is the whole desktop minus the status bar and the shortcut bar.
    VfxRect rect = getAppBounds();

#if defined(VAPP_HS_CFG_MULTI_DESKTOP)
    // If the shortcut bar is present, minus the height of the bar.
    rect.size.height -= VappHsShortcutPanel::SHORTCUT_BAR_HEIGHT;
#endif

    m_desktop->setVerticalValidRegion(rect.origin.y, rect.size.height);

    // Restore to the previous position.
    VfxRect bounds = m_desktop->getBounds();
    bounds.origin.x = s_desktop_pos;

    m_desktop->setBounds(bounds);
    m_desktop->alignment();
}


void VappHsScr::deinitDesktop()
{
    s_desktop_pos = m_desktop->getBounds().origin.x;

    VFX_OBJ_CLOSE(m_desktop);
}


void VappHsScr::initDesktopIndicator()
{
#if defined(VAPP_HS_CFG_MULTI_DESKTOP)
    VfxSize screenSize = getScreenSize();
    VfxPoint p;

    p.x = screenSize.width - INDICATOR_GAP_X;
    p.y = screenSize.height - INDICATOR_GAP_Y;

    // Create.
    VFX_OBJ_CREATE(m_desktopIndicator, VappHsDesktopIndicator, this);
    m_desktopIndicator->setAnchor(VfxFPoint(1.0f, 1.0f));
    m_desktopIndicator->setPos(p);

    // Restore to the previous position.
    m_desktopIndicator->highlight(s_desktop_pos);
#endif /* defined(VAPP_HS_CFG_MULTI_DESKTOP) */
}


void VappHsScr::deinitDesktopIndicator()
{
#if defined(VAPP_HS_CFG_MULTI_DESKTOP)
    VFX_OBJ_CLOSE(m_desktopIndicator);
#endif
}


void VappHsScr::initShortcutPanel()
{
#if defined(VAPP_HS_CFG_SHORTCUT_PANEL)
    VFX_OBJ_CREATE(m_shortcutPanel, VappHsShortcutPanel, this);

    m_shortcutPanel->m_signalFolded.connect(this, &VappHsScr::onShortcutPanelFolded);

#if defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__)
    // For performance, hide the desktop if panel is open.
    if (m_desktop && m_shortcutPanel->isUnFold())
    {
        m_desktop->setHidden(VFX_TRUE);
    }
#endif /* defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__) */
#endif /* defined(VAPP_HS_CFG_SHORTCUT_PANEL) */
}


void VappHsScr::deinitShortcutPanel()
{
#if defined(VAPP_HS_CFG_SHORTCUT_PANEL)
    VFX_OBJ_CLOSE(m_shortcutPanel);
#endif
}


void VappHsScr::initSearchBar()
{
#if defined(__MMI_SEARCH_WEB_GOOGLE__)
    if (mmi_search_web_hot_key_is_enabled(MMI_SEARCH_WEB_HOT_KEY_TOUCH_HINT))
    {
        VfxPoint pos;
        pos.x = LCD_WIDTH / 2;
        pos.y = LCD_HEIGHT - INDICATOR_GAP_Y - IDLE_MODE_TEXT_GAP_Y;

        VFX_OBJ_CREATE(m_searchBar, VappHsSearchBar, this);
        m_searchBar->setAnchor(0.5f, 1.0f);
        m_searchBar->setPos(pos);

        VFX_ASSERT(m_desktop);
        m_desktop->addChildFrame(m_searchBar);
    }
#endif /* defined(__MMI_SEARCH_WEB_GOOGLE__) */
}


void VappHsScr::deinitSearchBar()
{
#if defined(__MMI_SEARCH_WEB_GOOGLE__)
    VFX_OBJ_CLOSE(m_searchBar);
#endif /* defined(__MMI_SEARCH_WEB_GOOGLE__) */
}


void VappHsScr::initTimer()
{
    // Timer to add widget to the widget bar.
    VFX_OBJ_CREATE(m_timerAddWidget, VfxTimer, this);
    m_timerAddWidget->setStartDelay(DEFAULT_AUTO_ANIMATE_TIME);
    m_timerAddWidget->m_signalTick.connect(this, &VappHsScr::onTimerAddWidget);

    // Timer to lock widget on the desktop.
    VFX_OBJ_CREATE(m_timerLockWidget, VfxTimer, this);
    m_timerLockWidget->setStartDelay(s_lockWidgetDelayedTime);
    m_timerLockWidget->m_signalTick.connect(this, &VappHsScr::onTimerLockWidget);

    // Timer to close widget bar automatically.
    VFX_OBJ_CREATE(m_timerCloseWidgetBar, VfxTimer, this);
    m_timerCloseWidgetBar->setStartDelay(s_closeWidgetBarDelay);
    m_timerCloseWidgetBar->m_signalTick.connect(this, &VappHsScr::onCloseWidgetBar);
}


void VappHsScr::deinitTimer()
{
    VFX_OBJ_CLOSE(m_timerCloseWidgetBar);
    VFX_OBJ_CLOSE(m_timerLockWidget);
    VFX_OBJ_CLOSE(m_timerAddWidget);
}


void VappHsScr::initWidget()
{
    VappHsWidget *widget;
    VappHsDndImage *widgetIcon;

    //
    // Widget bar.
    //
    VFX_OBJ_CREATE(m_widgetBar, VappHsWidgetBar, this);

    m_widgetBar->m_signalUpdateFolding.connect(this, &VappHsScr::onWidgetBarUpdateFolding);

    //
    // Widget manager.
    //
    VFX_OBJ_CREATE(m_widgetMgr, VappHsWidgetMgr, this);

    m_widgetMgr->load();
    m_widgetMgr->bindWidgetBar(m_widgetBar);
    m_widgetMgr->bindDesktop(m_desktop);

    for (widget = m_widgetMgr->getFirst();
         widget != NULL;
         widget = m_widgetMgr->getNext())
    {
        widget->setIsCached(VFX_TRUE);
        widget->m_signalDrag.connect(this, &VappHsScr::onControlDesktopDrag);
        widget->m_signalMove.connect(this, &VappHsScr::onControlDesktopMove);
        widget->m_signalDrop.connect(this, &VappHsScr::onControlDesktopDrop);
        widget->m_signalRequest.connect(this, &VappHsScr::onControlWidgetRequest);
        widget->m_signalReset.connect(this, &VappHsScr::onControlWidgetReset);
    }

    for (widgetIcon = m_widgetMgr->getFirstIcon();
         widgetIcon != NULL;
         widgetIcon = m_widgetMgr->getNextIcon())
    {
        widgetIcon->m_scrollWay = VappHsDndImage::VERT_SCROLL;
        widgetIcon->m_signalDrag.connect(this, &VappHsScr::onControlWidgetBarDrag);
        widgetIcon->m_signalMove.connect(this, &VappHsScr::onControlWidgetBarMove);
        widgetIcon->m_signalDrop.connect(this, &VappHsScr::onControlWidgetBarDrop);
        widgetIcon->m_signalAbort.connect(this, &VappHsScr::onControlWidgetBarAbort);
    }

    //
    // Restore the previous state.
    //
    if (s_is_widget_bar_opened)
    {
        m_widgetBar->unfold();
    }
    else
    {
        m_widgetBar->fold();
    }

    VfxRect bounds = m_widgetBar->m_controlPanel->getBounds();
    bounds.origin.y = s_widget_bar_pos;
    m_widgetBar->m_controlPanel->setBounds(bounds);
    m_widgetBar->alignment();
}


void VappHsScr::deinitWidget()
{
    //
    // Backup the previous state.
    //
    if (m_widgetBar->isUnfold())
    {
        s_is_widget_bar_opened = VFX_TRUE;
    }
    else
    {
        s_is_widget_bar_opened = VFX_FALSE;
    }

    s_widget_bar_pos = m_widgetBar->m_controlPanel->getBounds().origin.y;

    //
    // Close the objects.
    //
    for (VappHsWidget *widget = m_widgetMgr->getFirst();
         widget != NULL;
         widget = m_widgetMgr->getNext())
    {
        widget->releaseIconView();
        VFX_OBJ_CLOSE(widget);
    }

    for (VappHsDndImage *widgetIcon = m_widgetMgr->getFirstIcon();
         widgetIcon != NULL;
         widgetIcon = m_widgetMgr->getNextIcon())
    {
        VFX_OBJ_CLOSE(widgetIcon);
    }

    VFX_OBJ_CLOSE(m_widgetMgr);

    VFX_OBJ_CLOSE(m_widgetBar);
}


void VappHsScr::activateWidget()
{
    // Each time the widgets are activated, restart the timer.
    if (m_timerCloseWidgetBar && m_timerCloseWidgetBar->getIsEnabled())
    {
        m_timerCloseWidgetBar->start();
    }

    m_widgetMgr->activateWidget(m_isRedrawingBkScreens);
}


void VappHsScr::deactivateWidget()
{
    // In case that the widget is on the dropping animation when the App
    // category is deleted, immediately emit the signal such that the widget is
    // put into the widget bar and the widget setting can be updated.
    if (m_timerAddWidget && m_timerAddWidget->getIsEnabled())
    {
        onTimerAddWidget(m_timerAddWidget);
    }

    // Some widget can change its position by itself, e.g. the pet widget. We
    // save the position to the NVRAM before the widgets are deactivated.
    m_widgetMgr->serializeToNvram();

    m_widgetMgr->deactivateWidget();
}


void VappHsScr::onInit()
{
    VFX_LOG(VFX_STATE, VAPP_HS_ON_INIT_MSG);

    VappShellPanel::onInit();

    setBgColor(VFX_COLOR_BLACK);
}


void VappHsScr::onDeinit()
{
    VFX_LOG(VFX_STATE, VAPP_HS_ON_DEINIT_MSG);

    VappShellPanel::onDeinit();
}


void VappHsScr::onInitView()
{
    VFX_LOG(VFX_STATE, VAPP_HS_ON_INIT_VIEW_MSG);

    VappShellPanel::onInitView();

    initWallpaper();

    initIdleModeText();

    initDesktop();

    initDesktopIndicator();

    initTimer();

    initSearchBar();

    initWidget();
}


void VappHsScr::onDeinitView()
{
    VFX_LOG(VFX_STATE, VAPP_HS_ON_DEINIT_VIEW_MSG);

    deinitWidget();

    deinitSearchBar();

    deinitTimer();

    deinitDesktopIndicator();

    deinitDesktop();

    deinitIdleModeText();

    deinitWallpaper();

    VappShellPanel::onDeinitView();
}


void VappHsScr::onResumeWallpaper(VfxTimer *timer)
{
    if (m_wallpaper)
    {
        m_wallpaper->resume();
    }
    VFX_OBJ_CLOSE(m_timerResumeWallpaper);
}


void VappHsScr::onEnterView()
{
    VFX_LOG(VFX_STATE, VAPP_HS_ON_ENTER_VIEW_MSG);

    VappShellPanel::onEnterView();

    // suspend wallpaper until bootup initiation finished
    if(s_bootupInit == VFX_TRUE)
    {
        VFX_DEV_ASSERT(m_timerResumeWallpaper == NULL);
        VFX_OBJ_CREATE(m_timerResumeWallpaper, VfxTimer, this);       
        m_timerResumeWallpaper->setStartDelay(1000);
        m_timerResumeWallpaper->m_signalTick.connect(this, &VappHsScr::onResumeWallpaper);
        m_timerResumeWallpaper->start();   
        s_bootupInit = VFX_FALSE;
    }
    else
    {
        if (m_wallpaper)
        {
            m_wallpaper->resume();
        }
    }

    initShortcutPanel();

    activateWidget();

#if defined(__MMI_VUI_SHELL_MULTI_PAGE__)
    // Because user can open or close the widget bar by dragging the button on
    // the widget bar, pen event on the widget bar does not scroll the pages.
    deregDefaultPageAct(m_widgetBar);

    for (VappHsDndImage *widgetIcon = m_widgetMgr->getFirstIcon();
         widgetIcon != NULL;
         widgetIcon = m_widgetMgr->getNextIcon())
    {
        // Because the user can directly drag the widget icon, pen event on the
        // widget icon does not scroll the pages.
        deregDefaultPageAct(widgetIcon);
    }
#endif /* defined(__MMI_VUI_SHELL_MULTI_PAGE__) */
}


void VappHsScr::onExitView(ShellExitCauseEnum cause)
{
    VFX_LOG(VFX_STATE, VAPP_HS_ON_EXIT_VIEW_MSG);

    deactivateWidget();

    deinitShortcutPanel();

    if(m_timerResumeWallpaper)
    {   
        // needs stop timer if timer is not timeout before exit HS
        if(m_timerResumeWallpaper->getIsEnabled())
        {
            m_timerResumeWallpaper->stop();
        }
        VFX_OBJ_CLOSE(m_timerResumeWallpaper);
    }
    if (m_wallpaper)
    {
        m_wallpaper->suspend();
    }

    VappShellPanel::onExitView(cause);
}


void VappHsScr::onScreenEnter(VfxBool isBackward)
{
    //
    // MAUI_03024078.
    //
    // We need to suspend the video; otherwise, GDI cannot flattern the VRT 
    // layer to the main base layer.
    //
    if (m_wallpaper && m_isSuspendForScreenExit)
    {
        m_wallpaper->resume();

        m_isSuspendForScreenExit = VFX_FALSE;
    }
}


void VappHsScr::onScreenExit(VfxBool isBackward)
{
    //
    // MAUI_03024078.
    //
    // We need to suspend the video; otherwise, GDI cannot flattern the VRT 
    // layer to the main base layer.
    //
    if (m_wallpaper && !m_isSuspendForScreenExit)
    {
        m_wallpaper->suspend();

        m_isSuspendForScreenExit = VFX_TRUE;
    }
}


void VappHsScr::onSwitchBegin(VfxBool isSwitchOut)
{
    VFX_UNUSED(isSwitchOut);

    if (m_wallpaper)
    {
        m_wallpaper->suspend();
    }
}


void VappHsScr::onSwitchEnd()
{
    if (m_wallpaper)
    {
        m_wallpaper->resume();
    }
}


VfxBool VappHsScr::onKeyInput(VfxKeyEvent &event)
{
#if defined(__AFX_RT_TEST__)
    if (event.type == VFX_KEY_EVENT_TYPE_DOWN)
    {
        if (event.keyCode == VFX_KEY_CODE_CAMERA)
        {
            vtst_rt_main_entry();
            return VFX_TRUE;
        }
    }
#endif /* defined(__AFX_RT_TEST__) */

#if (MMI_MAX_SIM_NUM >= 3)
    if (event.type == VFX_KEY_EVENT_TYPE_DOWN &&
        event.keyCode == VFX_KEY_CODE_ARROW_UP)
    {
        mmi_sim_space_launch();
        return VFX_TRUE;
    }
#endif /* (MMI_MAX_SIM_NUM >= 3) */

#if defined(VAPP_HS_CFG_MULTI_DESKTOP)
    if (event.type == VFX_KEY_EVENT_TYPE_DOWN &&
        event.keyCode == VFX_KEY_CODE_ENTER)
    {
        rotateDesktop();
        return VFX_TRUE;
    }
#endif /* defined(VAPP_HS_CFG_MULTI_DESKTOP) */

    if (event.type == VFX_KEY_EVENT_TYPE_UP &&
        event.keyCode == VFX_KEY_CODE_END)
    {
        if (!isAllFold())
        {
            foldAll();
            return VFX_TRUE;
        }
    }

    return VappShellPanel::onKeyInput(event);
}


#if defined(__PLUTO_MMI_PACKAGE__) && defined(__MMI_VUI_HOMESCREEN_LIVE_WALLPAPER__)
void VappHsScr::onCommandPopCallback(VfxObject *obj, VfxId id)
{
    if (id == WALLPAPER_GALLERY)
    {
        mmi_phnset_wallpaper_entry_system(GRP_ID_INVALID);
    }
    else if (id == WALLPAPER_FMGR)
    {
        mmi_phnset_wallpaper_entry_fmgr(GRP_ID_INVALID);
    }
    else if (id == WALLPAPER_LIVE)
    {
        mmi_phnset_wallpaper_entry_vui_live_wallpaper(GRP_ID_INVALID);
    }
    else
    {
        m_wallpaper->resume();
    }
}


void VappHsScr::showWallpaperConfirm(void)
{
    // Popup's parent must be VfxScreen
    VcpCommandPopup *cmdPopup;
    VFX_OBJ_CREATE(cmdPopup, VcpCommandPopup, findScreen());
    cmdPopup->setText(VFX_WSTR_RES(VAPP_HS_STR_WALLPAPER_SETTING));
    cmdPopup->addItem(WALLPAPER_LIVE, VFX_WSTR_RES(VAPP_HS_STR_WALLPAPER_LIVE_WALLPAPER));
    cmdPopup->addItem(WALLPAPER_GALLERY, VFX_WSTR_RES(VAPP_HS_STR_WALLPAPER_GALLERY));
    cmdPopup->addItem(WALLPAPER_FMGR,   VFX_WSTR_RES(VAPP_HS_STR_WALLPAPER_DOWNLOAD));
    cmdPopup->addItem(WALLPAPER_CANCEL, VFX_WSTR_RES(STR_GLOBAL_CANCEL), VCP_POPUP_BUTTON_TYPE_CANCEL);
    cmdPopup->m_signalButtonClicked.connect(this, &VappHsScr::onCommandPopCallback);
    cmdPopup->setAutoDestory(VFX_TRUE);
    cmdPopup->show(VFX_TRUE);
}
#endif /* defined(__PLUTO_MMI_PACKAGE__) && defined(__MMI_VUI_HOMESCREEN_LIVE_WALLPAPER__) */


VfxBool VappHsScr::onPenInput(VfxPenEvent &event)
{
    // Widget icon on the widget bar might abort the DnD action. Then, the
    // remained "pen move" and "pen up" events will still be routed.
    if (event.type != VFX_PEN_EVENT_TYPE_DOWN && !m_isRecvPenDown)
    {
        return VFX_FALSE;
    }

    // Let wallpaper receive the pen event.
    m_wallpaper->doPenInput(event);

    // Let desktop receive the pen event.
    m_desktop->doPenInput(event);

    switch (event.type)
    {
        case VFX_PEN_EVENT_TYPE_DOWN:
            m_isRecvPenDown = VFX_TRUE;
            m_longPressEnable = VFX_TRUE;
            break;

        case VFX_PEN_EVENT_TYPE_LONG_TAP:
        {
        #if defined(__PLUTO_MMI_PACKAGE__) && defined(__MMI_VUI_HOMESCREEN_LIVE_WALLPAPER__)
            if(m_longPressEnable == VFX_TRUE)
            {
                VfxS32 diffX = event.pos.x - event.downPos.x;
                VfxS32 diffY = event.pos.y - event.downPos.y;
                VfxU32 offset = vfxSqrt(diffX * diffX + diffY * diffY);

                if(offset <= s_penOffsetThreshold)
                {
                    m_wallpaper->suspend();
                    showWallpaperConfirm();
                }
            }
        #endif /* defined(__PLUTO_MMI_PACKAGE__) && defined(__MMI_VUI_HOMESCREEN_LIVE_WALLPAPER__) */

            break;
        }
        case VFX_PEN_EVENT_TYPE_MOVE:
        {
        #if defined(__PLUTO_MMI_PACKAGE__) && defined(__MMI_VUI_HOMESCREEN_LIVE_WALLPAPER__)    
            VfxS32 diffX = event.pos.x - event.downPos.x;
            VfxS32 diffY = event.pos.y - event.downPos.y;
            VfxU32 offset = vfxSqrt(diffX * diffX + diffY * diffY);

            if(offset > s_penOffsetThreshold)
            {
                m_longPressEnable = VFX_FALSE;
            }
        #endif /* defined(__PLUTO_MMI_PACKAGE__) && defined(__MMI_VUI_HOMESCREEN_LIVE_WALLPAPER__) */

            break;
        }
        case VFX_PEN_EVENT_TYPE_UP:
            m_isRecvPenDown = VFX_FALSE;
            m_longPressEnable = VFX_FALSE;
            break;

        default:
            break;
    }

    return VFX_TRUE;
}


VfxBool VappHsScr::onPreviewPenInput(VfxPenEvent &event)
{
#if defined(VAPP_HS_CFG_SHORTCUT_PANEL)
    if (m_shortcutPanel)
    {
        m_shortcutPanel->cancelShortcutDrop();
    }
#endif /* defined(VAPP_HS_CFG_SHORTCUT_PANEL) */

    // If some widget is during the dropping animation, drop it immediately such
    // that the state of the widget DnD mechanism can be reset, e.g., the
    // m_movingFrameS, m_movingFrameL variables and etc.
    if (m_timerAddWidget && m_timerAddWidget->getIsEnabled())
    {
        m_timerAddWidget->m_signalTick.emit(m_timerAddWidget);
        m_timerAddWidget->stop();
    }

    // If "lock widget" timer is present, lock the widget if the user touch the
    // area out of the widget; otherwise, keep the widget unlocked until the
    // timer fires.
    if (m_timerLockWidget && m_timerLockWidget->getIsEnabled() && m_movingFrameL)
    {
        if (m_movingFrameL->containPoint(event.getRelPos(m_movingFrameL)))
        {
            m_movingFrameL->setFreeDrag(VFX_TRUE);
        }
        else
        {
            m_timerLockWidget->m_signalTick.emit(m_timerLockWidget);
            m_timerLockWidget->stop();
        }
    }

    if (m_timerCloseWidgetBar && m_timerCloseWidgetBar->getIsEnabled())
    {
        if (event.type == VFX_PEN_EVENT_TYPE_DOWN)
        {
            // For pen event down, start a infinite timer such that the widget
            // bar is not close during a pen event cycle, i.e. DOWN, MOVE, UP or
            // ABORT. (INT_MAX is about 25 days.)
            m_timerCloseWidgetBar->setStartDelay(INT_MAX);
            m_timerCloseWidgetBar->start(); // will stop and restart
        }
        else if (event.type == VFX_PEN_EVENT_TYPE_UP ||
                 event.type == VFX_PEN_EVENT_TYPE_ABORT)
        {
            // After the pen event cycle finishes, restart the timer with
            // the pre-defined delayed time.
            m_timerCloseWidgetBar->setStartDelay(s_closeWidgetBarDelay);
            m_timerCloseWidgetBar->start(); // will stop and restart
        }
    }

    return VappShellPanel::onPreviewPenInput(event);
}


void VappHsScr::onTimerAddWidget(VfxTimer *timer)
{
    VFX_UNUSED(timer);

    VFX_LOG(VFX_STATE, VAPP_HS_ON_TIMER_ADD_WIDGET_MSG, 0);

    if (m_movingFrameS)
    {
        VFX_LOG(VFX_STATE, VAPP_HS_ON_TIMER_ADD_WIDGET_MSG, 1);

        m_movingFrameS->removeFromParentFrame();

        m_movingFrameOriParent->restoreImage(
            m_movingFrameS,
            VFX_FALSE,      // do not blink the image icon
            VFX_FALSE);     // do not re-arrange the widget bar

        m_movingFrameS = NULL;
    }

    if (m_movingFrameL)
    {
        VFX_LOG(VFX_STATE, VAPP_HS_ON_TIMER_ADD_WIDGET_MSG, 2);

        // TODO: comment
        m_movingFrameL->setHidden(VFX_FALSE);

        // Do not need widget view
        m_movingFrameL->removeFromParentFrame();
        m_movingFrameL->releaseView(VFX_TRUE);
        m_movingFrameL = NULL;
    }

    m_widgetMgr->serializeToNvram();
}


void VappHsScr::onTimerLockWidget(VfxTimer *timer)
{
    VFX_UNUSED(timer);

    if (m_movingFrameL)
    {
    #if defined(__MMI_VUI_SHELL_MULTI_PAGE__)
        // Because the widget leaves the Drag-and-Drop mode, pen event on the
        // widget can scroll the cube.
        regDefaultPageAct(m_movingFrameL);
    #endif /* defined(__MMI_VUI_SHELL_MULTI_PAGE__) */

        m_movingFrameL->setFreeDrag(VFX_FALSE);
        m_movingFrameL->setOpacity(1.0f);
        m_movingFrameL = NULL;
    }
}


void VappHsScr::previewDrop(
    VappHsInteractiveImageArray *dst,
    VfxPenEvent &event,
    VfxPoint &currentPos,
    VfxPoint &finalPos)
{
    currentPos = m_movingFrameS->getPos();

    dst->insertImage(m_movingFrameS, event);

    VfxRect bounds = m_movingFrameS->getBounds();
    VfxPoint midPoint = VfxPoint(bounds.getMidX(), bounds.getMidY());

    finalPos = m_movingFrameS->convertPointTo(midPoint, this);

    // Re-add the icon view to the APP category.
    dst->backupImage(m_movingFrameS);
    dst->removeImage(m_movingFrameS, VFX_FALSE);

    m_movingFrameOriParent = dst;

    addChildFrame(m_movingFrameS);
}


void VappHsScr::previewDropExt(VfxPoint &currentPos, VfxPoint &finalPos)
{
    currentPos = m_movingFrameS->getPos();

    m_movingFrameOriParent->restoreImage(m_movingFrameS, VFX_FALSE);

    VfxRect bounds = m_movingFrameS->getBounds();
    VfxPoint midPoint = VfxPoint(bounds.getMidX(), bounds.getMidY());

    finalPos = m_movingFrameS->convertPointTo(midPoint, this);

    // Re-add the icon view to the APP category.
    m_movingFrameOriParent->backupImage(m_movingFrameS);
    m_movingFrameOriParent->removeImage(m_movingFrameS, VFX_FALSE);

    addChildFrame(m_movingFrameS);
}


VfxS32 VappHsScr::getActiveWidgetNum()
{
    const VfxFrame *iter;
    VfxS32 count = 0;

    // in desktop widget
    for (iter = m_desktop->getFirstChildFrame();
         iter != NULL;
         iter = iter->getNextFrame())
    {
        // skip non-widget frame
        VappHsWidget *widget;

        for (widget = m_widgetMgr->getFirst();
             widget != NULL;
             widget = m_widgetMgr->getNext())
        {
            if (iter == widget)
            {
                break;
            }
        }

        if (widget == NULL)
        {
            continue; // this is a non-widget frame
        }

        ++count;
    }

    return count;
}


void VappHsScr::resetAnchor(VfxFrame *frame, VfxPoint &offset)
{
    VfxPoint pos = frame->getPos();
    pos.x -= offset.x;
    pos.y -= offset.y;

    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(VFX_TRUE);
    frame->setPos(pos);
    frame->setAnchor(VfxFPoint(0.5f, 0.5f));
    VfxAutoAnimate::commit();
}


void VappHsScr::setAnchor(VfxFrame *frame, VfxPoint &offset)
{
    VfxRect rect = frame->getBounds();

    // TODO: getMidX and getMidY does not round to the nearest number. Plus 0.5
    // here by ourself.
    VfxFloat x = (VfxFloat)(offset.x + rect.getMidX() + 0.5f) / rect.getWidth();
    VfxFloat y = (VfxFloat)(offset.y + rect.getMidY() + 0.5f) / rect.getHeight();

    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(VFX_TRUE);
    frame->setAnchor(VfxFPoint(x, y));
    VfxAutoAnimate::commit();
}


void VappHsScr::getScaleRatio(
    VfxFrame *to,
    VfxFrame *from,
    VfxFloat &x,
    VfxFloat &y)
{
    VfxSize toSize = to->getBounds().size;
    VfxSize fromSize = from->getBounds().size;

    x = (VfxFloat)toSize.width / fromSize.width;
    y = (VfxFloat)toSize.height / fromSize.height;
}


void VappHsScr::getOffset(
    VfxControl *frame,
    VfxPenEvent &event,
    VfxPoint &offset)
{
    VfxRect bounds = frame->getBounds();
    VfxPoint penPos = event.getRelPos(frame);

    offset.x = penPos.x - bounds.getMidX();
    offset.y = penPos.y - bounds.getMidY();
}


void VappHsScr::setWidgetDrag(
    VappHsDndImage *image,
    VappHsWidget *widget,
    VfxPenEvent &event,
    VfxBool isFromImage)
{
    m_movingFrameS = image;
    m_movingFrameL = widget;

#if defined(__MMI_VUI_SHELL_MULTI_PAGE__)
    // Because the widget enters the Drag-and-Drop mode, pen event on the widget
    // does not scroll the cube.
    deregDefaultPageAct(widget);
#endif /* defined(__MMI_VUI_SHELL_MULTI_PAGE__) */

    // Set icon to widget transform matrix.
    m_trS2l.init(VRT_TRANSFORM_TYPE_AFFINE);
    getScaleRatio(
        m_movingFrameL,             // to
        m_movingFrameS,             // from
        m_trS2l.data.affine.sx,
        m_trS2l.data.affine.sy);

    // Set widget to icon transform matrix.
    m_trL2s.init(VRT_TRANSFORM_TYPE_AFFINE);
    getScaleRatio(
        m_movingFrameS,             // to
        m_movingFrameL,             // from
        m_trL2s.data.affine.sx,
        m_trL2s.data.affine.sy);

    if (isFromImage)
    {
        // Calculate the widget pen offset (from middle point to the pen point).
        m_penPointOffsetL.x = (VfxS32)(m_penPointOffsetS.x * m_trS2l.data.affine.sx);
        m_penPointOffsetL.y = (VfxS32)(m_penPointOffsetS.y * m_trS2l.data.affine.sy);
    }
    else
    {
        // Calculate the icon pen offset (from middle point to the pen point).
        m_penPointOffsetS.x = (VfxS32)(m_penPointOffsetL.x * m_trL2s.data.affine.sx);
        m_penPointOffsetS.y = (VfxS32)(m_penPointOffsetL.y * m_trL2s.data.affine.sy);
    }

    // Initialization (disable auto. animation during initialization)

    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(VFX_TRUE);

    setAnchor(m_movingFrameS, m_penPointOffsetS);
    setAnchor(m_movingFrameL, m_penPointOffsetL);

    m_movingFrameS->setPos(event.getRelPos(this));
    m_movingFrameL->setPos(m_movingFrameS->getPos());

    if (isFromImage)
    {
        // drag from widge bar
    #if !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__)
        m_movingFrameS->setTransform(VFX_TRANSFORM_IDENTITY);
        m_movingFrameL->setTransform(m_trL2s);
    #endif /* !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__) */

        m_movingFrameS->setOpacity(1.0f);
        m_movingFrameL->setOpacity(0.0f);
    }
    else
    {
    #if !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__)
        m_movingFrameS->setTransform(m_trS2l);
        m_movingFrameL->setTransform(VFX_TRANSFORM_IDENTITY);
    #endif /* !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__) */

        m_movingFrameS->setOpacity(0.0f);
        m_movingFrameL->setOpacity(1.0f);
    }

    VfxAutoAnimate::commit();

    // Use auto animation for the opacity of the active item.

    if (isFromImage)
    {
        m_movingFrameS->setOpacity(s_moveOpacity);
    }
    else
    {
        m_movingFrameL->setOpacity(s_moveOpacity);
    }

    // Add icon and widget in the App category.
    addChildFrame(m_movingFrameS);
    addChildFrame(m_movingFrameL);
    m_wallpaper->setWidgetDragged(event.pos, m_movingFrameL);
}


void VappHsScr::setWidgetMove(VfxPenEvent &event)
{
    if (m_movingFrameS && m_movingFrameL)
    {
        m_wallpaper->setWidgetMoved(event.pos, m_movingFrameL);
        VfxRect barBounds = m_widgetBar->getBounds();

        if ((m_widgetBar->isUnfold() && m_widgetBar->containPoint(event.getRelPos(m_widgetBar))) ||
            (!m_widgetBar->isUnfold() && barBounds.contains(event.getRelPos(m_widgetBar))))
        {
            // Inside widget bar.

            if (!m_widgetBar->isUnfold())
            {
                m_widgetBar->unfold();
            }

        #if !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__)
            m_movingFrameS->setTransform(VFX_TRANSFORM_IDENTITY);
            m_movingFrameL->setTransform(m_trL2s);
        #endif /* !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__) */

            m_movingFrameS->setOpacity(s_moveOpacity);
            m_movingFrameL->setOpacity(0.0f);

            m_widgetBar->cross(event);
        }
        else
        {
            // Outside widget bar.

        #if !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__)
            m_movingFrameS->setTransform(m_trS2l);
            m_movingFrameL->setTransform(VFX_TRANSFORM_IDENTITY);
        #endif /* !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__) */

            m_movingFrameS->setOpacity(0.0f);
            m_movingFrameL->setOpacity(s_moveOpacity);

            m_widgetBar->arrange(-1);
        }

        // Force the position to make the moving smooth and real-time.
        VfxPoint pos = event.getRelPos(this);
        m_movingFrameS->forcePos(pos);
        m_movingFrameL->forcePos(pos);
    }
}


void VappHsScr::setWidgetDrop(VfxPenEvent &event, VfxBool isRestore)
{
    if (m_movingFrameS && m_movingFrameL)
    {
        m_wallpaper->setWidgetDropped(event.pos, m_movingFrameL);
        resetAnchor(m_movingFrameS, m_penPointOffsetS);
        resetAnchor(m_movingFrameL, m_penPointOffsetL);

        if (isRestore)
        {
            // Scenario:
            //  Abort the dragging operation.
            //
            //  This happens when the user intends to scroll the widget bar,
            //  rather than drag the widget.
            //
            // Icon view:
            //  Set to the original size and opacity. Restore to previous
            //  position for scrolling.
            //
            // Widget view:
            //  It is not needed. Release widget view.

        #if !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__)
            m_movingFrameS->setTransform(VFX_TRANSFORM_IDENTITY);
        #endif
            m_movingFrameS->setOpacity(1.0f);

            m_movingFrameS->removeFromParentFrame();
            m_movingFrameOriParent->restoreImage(m_movingFrameS);
            m_movingFrameS = NULL;

            m_movingFrameL->removeFromParentFrame();
            m_movingFrameL->releaseView();
            m_movingFrameL = NULL;
        }
        else if (m_widgetBar->containPoint(event.getRelPos(m_widgetBar)))
        {
            // THIS PART IS COMPLICATED. BE PATIENT.
            //
            // Scenario:
            //  Drop on the widget bar.
            //
            // Problem:
            //  If we directly add the icon view to the widget bar, the icon
            //  view might be cutted by the bounds of the widget bar.
            //
            // Solution:
            //  1) Preview the final position of the icon
            //  2) Add the icon back to the App category
            //  3) Animate the icon to its final position
            //  4) Start a timer to callback when the animation completes
            //  5) When timer fires, add the widget to the widget bar

        #if !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__)
            m_movingFrameS->setTransform(VFX_TRANSFORM_IDENTITY);
        #endif
            m_movingFrameS->setOpacity(1.0f);

            VfxPoint currentPos, finalPos;

            previewDrop(m_widgetBar, event, currentPos, finalPos);

            VfxAutoAnimate::begin();
            VfxAutoAnimate::setDisable(VFX_TRUE);
            m_movingFrameS->setPos(currentPos);
            VfxAutoAnimate::commit();

            m_movingFrameS->setPos(finalPos);

            // TODO: add comment
            m_movingFrameL->setHidden(VFX_TRUE);

            m_timerAddWidget->start();
        }
        else if (getActiveWidgetNum() >= s_maxDeskTopWidget)
        {
            // THIS PART IS COMPLICATED. BE PATIENT.
            //
            // Scenario:
            //  Drop on the desktop. But #widget exceeds the max number.
            //
            // Problem and Solution:
            //  Similar as the above one. But, we let the widget view directly
            //  change to the icon view at the begining.

            VfxPoint currentPos, finalPos;

            previewDropExt(currentPos, finalPos);

            VfxAutoAnimate::begin();
            VfxAutoAnimate::setDisable(VFX_TRUE);

        #if !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__)
            m_movingFrameS->setTransform(VFX_TRANSFORM_IDENTITY);
        #endif
            m_movingFrameS->setPos(currentPos);
            m_movingFrameS->setOpacity(1.0f);

            VfxAutoAnimate::commit();

            m_movingFrameS->setPos(finalPos);

            // TODO: add comment
            m_movingFrameL->setHidden(VFX_TRUE);

            m_timerAddWidget->start();
        }
        else
        {
            // Scenario:
            //  Drop on the desktop.
            //
            // Icon View:
            //  It isn't needed. Remove it from App category.
            //
            // Widget view:
            //  Set to the original size and opacity. Put it on the desktop.

            m_movingFrameS->removeFromParentFrame();
            m_movingFrameS = NULL;

            // Reset the transform matrx. For the opacity, it is reset when the
            // widget is again locked on the desktop.
        #if !defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__)
            m_movingFrameL->setTransform(VFX_TRANSFORM_IDENTITY);
        #endif

            VfxAutoAnimate::begin();
            VfxAutoAnimate::setDisable(VFX_TRUE);
            VfxPoint pos = m_movingFrameL->getPos();
            m_movingFrameL->setPos(convertPointTo(pos, m_desktop));
            VfxAutoAnimate::commit();

            m_desktop->addWidget(m_movingFrameL);

            m_timerLockWidget->start();

            // Handle the case that pen-up comes without any pen-move thus the
            // widget bar is never re-arranged. (MAUI_01758400)
            m_widgetBar->arrange(-1);

            m_widgetMgr->serializeToNvram();
        }
    }
}


void VappHsScr::onControlWidgetBarDrag(
    VappHsDndImage *image,
    VfxPenEvent &event)
{
    VappHsWidget *widget = NULL;

    // If "lock widget" timer is present, it means the user wants to drag this
    // widget before it is locked again. Reset variable and stop timer.
    if (m_timerLockWidget->getIsEnabled() && m_movingFrameL)
    {
        m_timerLockWidget->m_signalTick.emit(m_timerLockWidget);
        m_timerLockWidget->stop();
    }

    // backup original image info for restore
    m_movingFrameOriParent = m_widgetBar;
    m_movingFrameOriParent->backupImage(image);

    // Get the icon pen offset (from middle point to the pen point).
    getOffset(image, event, m_penPointOffsetS);

    // remvoe image from widget bar
    m_widgetBar->removeImage(image, VFX_FALSE);

    // find widget
    for (VfxS32 i = m_widgetMgr->getTotalNum() - 1; i >= 0; i--)
    {
        if (m_widgetMgr->getIcon(i) == image)
        {
            widget = m_widgetMgr->get(i);
            break;
        }
    }
    VFX_ASSERT(widget);

    // create widget view
    widget->createView();

    setWidgetDrag(image, widget, event, VFX_TRUE);
}


void VappHsScr::onControlWidgetBarMove(
    VappHsDndImage *image,
    VfxPenEvent &event)
{
    setWidgetMove(event);
}


void VappHsScr::onControlWidgetBarDrop(
    VappHsDndImage *image,
    VfxPenEvent &event)
{
    setWidgetDrop(event, VFX_FALSE);
}


void VappHsScr::onControlWidgetBarAbort(
    VappHsDndImage *image,
    VfxPenEvent &event)
{
    setWidgetDrop(event, VFX_TRUE);
}


void VappHsScr::onControlDesktopDrag(
    VappHsWidget *widget,
    VfxPenEvent &event)
{
    VappHsDndImage *image = NULL;

    // If "lock widget" timer is present, it means the user wants to drag this
    // widget before it is locked again. Reset variable and stop timer.
    if (m_timerLockWidget->getIsEnabled() && m_movingFrameL)
    {
        m_timerLockWidget->m_signalTick.emit(m_timerLockWidget);
        m_timerLockWidget->stop();
    }

    // Get the widget pen offset (from middle point to the pen point).
    getOffset(widget, event, m_penPointOffsetL);

    // remove widget from desktop
    m_desktop->removeWidget(widget);

    // create image frame
    for (VfxS32 i = m_widgetMgr->getTotalNum() - 1; i >= 0; i--)
    {
        if (m_widgetMgr->get(i) == widget)
        {
            image = m_widgetMgr->getIcon(i);
        }
    }
    VFX_ASSERT(image);

    setWidgetDrag(image, widget, event, VFX_FALSE);
}


void VappHsScr::onControlDesktopMove(
    VappHsWidget *widget,
    VfxPenEvent &event)
{
    setWidgetMove(event);
}


void VappHsScr::onControlDesktopDrop(
    VappHsWidget *widget,
    VfxPenEvent &event)
{
    setWidgetDrop(event, VFX_FALSE);
}


void VappHsScr::onControlWidgetRequest(
    VappHsWidget *widget,
    VappHsWidget::RequestId requestId)
{
    VFX_ASSERT(widget);

    switch (requestId)
    {
    #if defined(__MMI_VUI_SHELL_MULTI_PAGE__)
        case VappHsWidget::REQ_ID_CHANGE_CUBE_TO_SCROLLABLE:
            // Pen event on the widget bar can scroll the cube.
            regDefaultPageAct(widget);
            break;

        case VappHsWidget::REQ_ID_CHANGE_CUBE_TO_UNSCROLLABLE:
            // Pen event on the widget bar does not scroll the cube.
            deregDefaultPageAct(widget);
            break;
    #endif /* defined(__MMI_VUI_SHELL_MULTI_PAGE__) */

        default:
            break;
    }
}


void VappHsScr::onControlWidgetReset(VappHsWidget *widget, VfxU16 errStringId)
{
    VFX_ASSERT(widget);

    m_widgetType = widget->getType();
    m_widgetId = widget->getId();
    m_errStrId = errStringId;

    vfxPostInvoke(this, &VappHsScr::popupError);
}


#if defined(VAPP_HS_CFG_SHORTCUT_PANEL)
void VappHsScr::onShortcutPanelFolded(VappHsShortcutPanel *panel)
{
    if (panel->isUnFold())
    {
        m_wallpaper->suspend();

    #if defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__)
        // For performance, hide the desktop if panel is open.
        if (m_desktop)
        {
            m_desktop->setHidden(VFX_TRUE);
        }
    #endif /* defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__) */
    }
    else
    {
        m_wallpaper->resume();

    #if defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__)
        // Unhide the widgets after shortcut pool is folded.
        if (m_desktop)
        {
            m_desktop->setHidden(VFX_FALSE);
        }
    #endif /* defined(__MMI_VUI_HOMESCREEN_LITE_DISPLAY__) */
    }
}
#endif /* defined(VAPP_HS_CFG_SHORTCUT_PANEL) */


void VappHsScr::onDesktopBoundsChanged(VfxFrame *source, const VfxRect &oldBounds)
{
#if defined(VAPP_HS_CFG_MULTI_DESKTOP)
    VfxS32 x = m_desktop->getBounds().origin.x;

    m_wallpaper->setDesktopBoundsChanged(VappHsDesktop::TOTAL_PAGE, source, oldBounds);

    // change desktop indicator
    if (m_desktopIndicator)
    {
        m_desktopIndicator->highlight(x);
    }
#endif
}


void VappHsScr::onWidgetBarUpdateFolding(VfxBool isFold)
{
    if (m_timerCloseWidgetBar)
    {
        if (isFold)
        {
            VFX_LOG(VFX_STATE, VAPP_HS_ON_WIDGET_BAR_UPDATE_FOLDING_MSG, 1);

            m_timerCloseWidgetBar->stop();
        }
        else
        {
            VFX_LOG(VFX_STATE, VAPP_HS_ON_WIDGET_BAR_UPDATE_FOLDING_MSG, 0);

            // If the widget bar is open because the user is dragging the widget
            // and moving the widget in the bounds of the widget bar, the timer
            // value should be large such that it will not close during the DnD
            // period. Please refer to the onPreviewPenInput. (MAUI_01881649).
            if (m_movingFrameS)
            {
                m_timerCloseWidgetBar->setStartDelay(INT_MAX);
            }

            m_timerCloseWidgetBar->start();
        }
    }
}


void VappHsScr::onCloseWidgetBar(VfxTimer *timer)
{
    VFX_UNUSED(timer);

    VFX_LOG(VFX_STATE, VAPP_HS_ON_CLOSE_WIDGET_BAR_MSG);

    m_widgetBar->fold();
}


void VappHsScr::onIdleModeTextChanged(VdatNetworkInfo *networkSrv)
{
    VFX_LOG(VFX_STATE, VAPP_HS_ON_SET_IDLE_MODE_TEXT_MSG);

    if (m_idleModeText)
    {
        m_idleModeText->setText(networkSrv->getIdleModeText());
    }
}


void VappHsScr::onIdleModeIconChanged(VdatNetworkInfo *networkSrv)
{
    VFX_LOG(VFX_STATE, VAPP_HS_ON_SET_IDLE_MODE_ICON_MSG);

    if (m_idleModeText)
    {
        m_idleModeText->setIcon(networkSrv->getIdleModeIcon());
    }
}


VfxBool VappHsScr::isAllFold()
{
#if defined(VAPP_HS_CFG_SHORTCUT_PANEL)
    if (!m_shortcutPanel || m_shortcutPanel->isUnFold())
    {
        return VFX_FALSE;
    }
#endif /* defined(VAPP_HS_CFG_SHORTCUT_PANEL) */

    if (!m_widgetBar || m_widgetBar->isUnfold())
    {
        return MMI_FALSE;
    }

    return VFX_TRUE;
}


void VappHsScr::foldAll()
{
    // If the "lock widget" timer is active, emit the event to lock the widget
    // immediately because the user has interacted with the home screen.
    if (m_timerLockWidget && m_timerLockWidget->getIsEnabled())
    {
        m_timerLockWidget->m_signalTick.emit(m_timerLockWidget);
        m_timerLockWidget->stop();
    }

#if defined(VAPP_HS_CFG_SHORTCUT_PANEL)
    if (m_shortcutPanel && m_shortcutPanel->isUnFold())
    {
        m_shortcutPanel->fold();
    }
#endif /* defined(VAPP_HS_CFG_SHORTCUT_PANEL) */

    // If widget bar is unfold, fold the widget bar.
    if (m_widgetBar && m_widgetBar->isUnfold())
    {
        // If some widget is during the dropping animation, drop it immediately.
        // Or, the widget might be animated to a weird position because the
        // widget bar is closed. (MAUI_01775646)
        if (m_timerAddWidget && m_timerAddWidget->getIsEnabled())
        {
            VFX_LOG(VFX_FUNC, VAPP_HS_FOLD_ALL_MSG, 1);

            m_timerAddWidget->m_signalTick.emit(m_timerAddWidget);
            m_timerAddWidget->stop();
        }

        m_widgetBar->fold();
    }
}


void VappHsScr::rotateDesktop()
{
    VFX_LOG(VFX_FUNC, VAPP_HS_ROTATE_DESKTOP_MSG, 0);

    // If the "lock widget" timer is active, emit the event to lock the widget
    // immediately because the user has interacted with the home screen.
    if (m_timerLockWidget->getIsEnabled())
    {
        m_timerLockWidget->m_signalTick.emit(m_timerLockWidget);
        m_timerLockWidget->stop();
    }

    // If the "close widget bar" timer is active, restart it because the user
    // has interacted with the home screen.
    if (m_timerCloseWidgetBar && m_timerCloseWidgetBar->getIsEnabled())
    {
        m_timerCloseWidgetBar->start(); // will stop and restart
    }

    // Behavior:
    //  - If the shortcut pool is open, close it first.
    //  - Otherwise, rotate the desktop.
#if defined(VAPP_HS_CFG_SHORTCUT_PANEL)
    if (m_shortcutPanel && m_shortcutPanel->isUnFold())
    {
        m_shortcutPanel->fold();
    }
    else
#endif /* defined(VAPP_HS_CFG_SHORTCUT_PANEL) */
    {
        VfxRect bounds;
        VfxS32 idx;

        bounds = m_desktop->getBounds();

        idx = (bounds.origin.x + VappHsDesktop::PAGE_WIDTH) / VappHsDesktop::PAGE_WIDTH;
        idx = (idx < 1 ? 1 : idx);
        idx = (idx > VappHsDesktop::TOTAL_PAGE ? VappHsDesktop::TOTAL_PAGE : idx);

        if (idx == VappHsDesktop::TOTAL_PAGE)
        {
            bounds.origin.x = 0;
        }
        else
        {
            bounds.origin.x = idx * VappHsDesktop::PAGE_WIDTH;
        }

        m_desktop->setBounds(bounds);
    }
}


void VappHsScr::popupError(void *data)
{
    VappHsWidgetMgr::dismissWidget(m_widgetType, VFX_TRUE, m_widgetId);

    mmi_popup_display_simple(
        (WCHAR *)get_string((VfxU16)m_errStrId),
        MMI_EVENT_FAILURE,
        mmi_idle_get_group_id(),
        NULL);
}

#endif /* __MMI_VUI_HOMESCREEN__ */

