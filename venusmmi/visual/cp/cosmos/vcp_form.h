/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005 
*                                         
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
* Filename:
* ---------
*  vcp_form.h
*
* Project:
* --------
*  Venus
*
* Description:
* ------------
*  Venus Form component 
*
* Author:
* -------
 * -------
* 
*============================================================================
*             HISTORY
* Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
*
*------------------------------------------------------------------------------
* Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*============================================================================
****************************************************************************/

#ifndef _VCP_FORM_MENU_H_
#define _VCP_FORM_MENU_H_

/***************************************************************************** 
* Include
*****************************************************************************/
#include "vcp_text_editor.h"
#include "vcp_image_button.h"
#include "vcp_button_util.h"
#include "vcp_textview.h"
#include "vcp_activity_indicator.h"
#include "vfx_control.h"
#include "vfx_basic_type.h"
#include "vfx_datatype.h"
#include "vfx_input_event.h"
#include "vfx_object.h"
#include "vfx_class_info.h"
#include "vfx_datatype.h"
#include "vfx_cpp_base.h"
#include "vfx_signal.h"
#include "vfx_basic_type.h"
#include "vfx_frame.h"
#include "vfx_signal.h"
#include "vfx_draw_context.h"
#include "vfx_string.h"
#include "vfx_text_frame.h"
#include "vfx_input_event.h"
#include "vfx_primitive_frame.h"
#include "vcp_switch.h"
#include "vcp_button.h"
#include "vfx_cpp_base.h"
#include "vfx_object_list.h"
#include "vcp_scrollable.h"
#include "mmi_rp_srv_venus_component_form_def.h"


#if defined(__MMI_VUI_COSMOS_CP__) 

//#define VCP_FRM_KEY_BASED_FOCUS_HANDLING
//#define VCP_FORM_STRETCHES_ON_SCROLL_END

#define VCP_FORM_BG_COLOR                   VFX_COLOR_RES(VCP_COL_FORM_BG)
#define VCP_FORM_HIDDEN_BG_COLOR            VFX_COLOR_RES(VCP_COL_FORM_HIDDEN_BG)
#define VCP_FORM_ITEM_BG_COLOR              VFX_COLOR_RES(VCP_COL_FORM_ITEM_BG)
#define VCP_FORM_HIGHLIGHTED_FONT_COLOR     VFX_COLOR_RES(VCP_COL_FORM_HIGHLIGHTED_FONT)
#define VCP_FORM_MAIN_FONT_COLOR            VFX_COLOR_RES(VCP_COL_FORM_MAIN_FONT)
#define VCP_FORM_MAIN_FONT_COLOR_DISABLED   VFX_COLOR_RES(VCP_COL_FORM_MAIN_FONT_DISABLED)
#define VCP_FORM_HINT_TEXT_COLOR            VFX_COLOR_RES(VCP_COL_FORM_HINT_TEXT)
#define VCP_FORM_HINT_TEXT_COLOR_DISABLED   VFX_COLOR_RES(VCP_COL_FORM_HINT_TEXT_DISABLED)
#define VCP_FORM_DISABLED_OVERLAY_COLOR     VFX_COLOR_RES(VCP_COL_FORM_DISABLED_OVERLAY)
#define VCP_FORM_WARNING_TEXT_COLOR         VFX_COLOR_RES(VCP_COL_FORM_WARNING_TEXT)
#define VCP_FORM_CAPTION_TEXT_COLOR         VFX_COLOR_RES(VCP_COL_FORM_CAPTION_TEXT)


#define VCP_FORM_DARK_FONT_COLOR    VCP_FORM_MAIN_FONT_COLOR

/***************************************************************************** 
* Typedef
*****************************************************************************/

// Enum for defining the dimensional constants used in Form
// You may use these constants when implementing your own item classes.
// These are defined for all supported resolutions.
// <group DOM_Form_Macro&Enum_Enum>
enum VcpFormDimensionsEnum
{
#if defined(__MMI_MAINLCD_320X480__)
    VCPFRM_SIDE_MARGIN_SMALL = 5,
    VCPFRM_SIDE_MARGIN_LARGE = 10,
    VCPFRM_ITEM_HORZ_GAP_1 = 3,
    VCPFRM_ITEM_HORZ_GAP_2 = 5,

    VCPFRM_INDENT_L1 = 2, // Left gap for caption block
    VCPFRM_INDENT_L2 = 6, // Left gap for controls like buttons (in addition to VCPFRM_INDENT_L1 )
    VCPFRM_INDENT_L3 = 10, // Left gap inside the controls, for like, start of button text

    VCPFRM_STD_UI_EDITOR_HEIGHT = 38, // Standard editor height
    VCPFRM_STD_UI_CNTRL_HEIGHT = 45,    // Standard control height (generally used for buttons)
    VCPFRM_STD_CELL_HEIGHT = 51,    // Height of cell type items

    VCPFRM_FONT_SIZE_1= 14,
    VCPFRM_FONT_SIZE_2= 18,
    VCPFRM_FONT_SIZE_3 = 20,
    VCPFRM_FONT_SIZE_4 = 20,
    VCPFRM_FONT_SIZE_5 = 20,

    TEXTITEM_HEIGHT = 50,
    PICTURE_ITEM_HEIGHT_SMALL = 70,
    PICTURE_ITEM_HEIGHT_MEDIUM = 100,
    PICTURE_ITEM_HEIGHT_LARGE = 150,
#elif defined(__MMI_MAINLCD_480X800__)    
    VCPFRM_SIDE_MARGIN_SMALL = 6,
    VCPFRM_SIDE_MARGIN_LARGE = 14,
    VCPFRM_ITEM_HORZ_GAP_1 = 5,
    VCPFRM_ITEM_HORZ_GAP_2 = 7,

    VCPFRM_INDENT_L1 = 4,
    VCPFRM_INDENT_L2 = 10,
    VCPFRM_INDENT_L3 = 14,

    VCPFRM_STD_UI_EDITOR_HEIGHT = 70,
    VCPFRM_STD_UI_CNTRL_HEIGHT = 70,
    VCPFRM_STD_CELL_HEIGHT = 86,

    VCPFRM_FONT_SIZE_1= 22,
    VCPFRM_FONT_SIZE_2= 28,
    VCPFRM_FONT_SIZE_3 = 30,
    VCPFRM_FONT_SIZE_4 = 30,
    VCPFRM_FONT_SIZE_5 = 38,

    TEXTITEM_HEIGHT = 50,
    PICTURE_ITEM_HEIGHT_SMALL = 70,
    PICTURE_ITEM_HEIGHT_MEDIUM = 100,
    PICTURE_ITEM_HEIGHT_LARGE = 150,
#elif defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__)    
    VCPFRM_SIDE_MARGIN_SMALL = 5,
    VCPFRM_SIDE_MARGIN_LARGE = 10,
    VCPFRM_ITEM_HORZ_GAP_1 = 3,
    VCPFRM_ITEM_HORZ_GAP_2 = 5,

    VCPFRM_INDENT_L1 = 2,
    VCPFRM_INDENT_L2 = 3,
    VCPFRM_INDENT_L3 = 6,

    VCPFRM_STD_UI_EDITOR_HEIGHT = 36,
    VCPFRM_STD_UI_CNTRL_HEIGHT = 40,
    VCPFRM_STD_CELL_HEIGHT = 45,

    VCPFRM_FONT_SIZE_1= 13,
    VCPFRM_FONT_SIZE_2= 14,
    VCPFRM_FONT_SIZE_3 = 16,
    VCPFRM_FONT_SIZE_4 = 16,
    VCPFRM_FONT_SIZE_5 = 20,

    TEXTITEM_HEIGHT = 50,
    PICTURE_ITEM_HEIGHT_SMALL = 70,
    PICTURE_ITEM_HEIGHT_MEDIUM = 100,
    PICTURE_ITEM_HEIGHT_LARGE = 150,
#else
    VCPFRM_SIDE_MARGIN_SMALL = 5,
    VCPFRM_SIDE_MARGIN_LARGE = 10,
    VCPFRM_ITEM_HORZ_GAP_1 = 3,
    VCPFRM_ITEM_HORZ_GAP_2 = 5,

    VCPFRM_INDENT_L1 = 2,
    VCPFRM_INDENT_L2 = 6,
    VCPFRM_INDENT_L3 = 10,

    VCPFRM_STD_UI_EDITOR_HEIGHT = 36,
    VCPFRM_STD_UI_CNTRL_HEIGHT = 40,
    VCPFRM_STD_CELL_HEIGHT = 45,

    VCPFRM_FONT_SIZE_1= 14,
    VCPFRM_FONT_SIZE_2= 16,
    VCPFRM_FONT_SIZE_3 = 24,
    VCPFRM_FONT_SIZE_4 = 20,
    VCPFRM_FONT_SIZE_5 = 20,

    TEXTITEM_HEIGHT = 50,
    PICTURE_ITEM_HEIGHT_SMALL = 70,
    PICTURE_ITEM_HEIGHT_MEDIUM = 100,
    PICTURE_ITEM_HEIGHT_LARGE = 150,
#endif

    //Backward compatibilty

    VCPFRM_ITEM_HORZ_GAP = VCPFRM_ITEM_HORZ_GAP_2,
    VCPFRM_ITEM_HORZ_GAP_SMALL = VCPFRM_ITEM_HORZ_GAP_1,

    VCPFRM_STANDARD_BTN_HEIGHT = VCPFRM_STD_UI_CNTRL_HEIGHT,

    VCPFRM_LEFT_INDENT_L1 = VCPFRM_INDENT_L1,
    VCPFRM_LEFT_INDENT_L2 = VCPFRM_INDENT_L2,
    VCPFRM_LEFT_INDENT_L3 = VCPFRM_INDENT_L3,

    FONT_SMALL = VCPFRM_FONT_SIZE_1,
    FONT_MEDIUM = VCPFRM_FONT_SIZE_2,
    FONT_LARGE = VCPFRM_FONT_SIZE_3
};

enum VcpFormStyleEnum 
{    
    VCPFORM_STYLE1,
    VCPFORM_STYLE2,
    VCPFORM_TOTAL_STYLES
};

typedef enum VcpFormItemTypeEnum 
{
    VCPFRM_ITEMTYPE_INVALID,
    VCPFRM_ITEMTYPE_CAPTION_TYPE1,
    VCPFRM_ITEMTYPE_CAPTION_TYPE2,
    VCPFRM_ITEMTYPE_BIG_BTN_W_RIGHT_ICON,
    VCPFRM_ITEMTYPE_BIG_ADD_BTN,
    VCPFRM_ITEMTYPE_MEDIUM_BTN_W_ICON,
    VCPFRM_ITEMTYPE_SMALL_IMG_BTN,
    VCPFRM_ITEMTYPE_TEXTBOX_SMALL,
    VCPFRM_ITEMTYPE_TEXTBOX_MEDIUM,
    VCPFRM_ITEMTYPE_TEXTBOX_LARGE,
    VCPFRM_ITEMTYPE_MULTILINE_TEXT,
    VCPFRM_ITEMTYPE_THUMB_BTN_SMALL,
    VCPFRM_ITEMTYPE_THUMB_BTN_MEDIUM,
    VCPFRM_ITEMTYPE_THUMB_BTN_LARGE,
    VCPFRM_ITEMTYPE_REMOVABLE_TEXT_ENTRY,    
    VCPFRM_ITEMTYPE_LAUNCHER_CELL,
    VCPFRM_ITEMTYPE_SWITCH_CELL,

    VCPFRM_ITEMTYPE_TOTAL
}VcpFormItemTypeEnum;

// Enum of accessory types available with VcpFormItemLauncherCell
// <group DOM_Form_Macro&Enum_Enum>
enum VcpFormAccessoryType
{
    VCPFORM_NEXT_ITEM_ICON, // An arrow icon signifying a next menu tree
    VCPFORM_NONE
};

enum VcpFormScrollingState
{
    VCPFRM_STATE_DRAGGING,    
    VCPFRM_STATE_GLIDING,
    VCPFRM_STATE_TOP_STRETCHING,
    VCPFRM_STATE_TOP_RECOILING,
    VCPFRM_STATE_BOTTOM_STRETCHING,
    VCPFRM_STATE_BOTTOM_RECOILING,
    VCPFRM_STATE_STATIONARY
};

/***************************************************************************** 
* Define
*****************************************************************************/

// Constant ID used as invalid ID
// <group DOM_Form_Macro&Enum_Macro>
#define VCPFRM_ITEMID_INVALID    0xFFFFFFFF

/******* Images *******/

#define VCPFRM_BUTTON_BKG_1
#define VCPFRM_BUTTON_BKG_2
#define VCPFRM_BUTTON_BKG_3

// Enum for positioning of label on VcpFormItemLabeledControl type items
// <group DOM_Form_Macro&Enum_Enum>
enum VcpFormLabelPositionEnum 
{
    VCPFORM_NO_LABEL, // No label
    VCPFORM_TOP_LEFT,    // Label on top left side
    VCPFORM_LEFT,    // Label on left side, in same line with the control

    TOTAL_POSITIONS
};

// Enum for positioning of the item in Form's viewable window
// Used with the API VcpForm::scrollItemToView()
// <group DOM_Form_Macro&Enum_Enum>
enum VcpFormScrollViewPosition
{
    VCPFORM_SCROLL_TOP,
    VCPFORM_SCROLL_BOTTOM,
    VCPFORM_SCROLL_CENTER
};

// DOM-NOT_FOR_SDK-BEGIN

/***************************************************************************** 
* class VcpFormDisableOverlayFrame (Helper class)
* This frame is used as an overlay to make items un-hittable, when they are disabled.
*****************************************************************************/
class VcpFormDisableOverlayFrame : public VfxControl
{
public:
    // Default constructor
    // <group DOM_Form_VcpFormDisableOverlayFrame_Constructor/Destructor>
    VcpFormDisableOverlayFrame()
    {}

    // <group DOM_Form_VcpFormDisableOverlayFrame_Override>
    virtual void onInit()
    {
        VfxControl::onInit();
        setBgColor(VCP_FORM_DISABLED_OVERLAY_COLOR);
    }
    // <group DOM_Form_VcpFormDisableOverlayFrame_Override>
    virtual VfxBool onPenInput(VfxPenEvent &event)
    {
        VfxControl::onPenInput(event);
        return VFX_TRUE;
    }
};

/***************************************************************************** 
* class VcpFormTextEditor (Helper class)
* This control is a wrapper for text editors used in Form.
* It includes a warning text at the bottom, which can be shown/hidden whenever required.
// <group DOM_Form_VcpFormTextEditor>    
*****************************************************************************/
class VcpFormTextEditor : public VfxFrame
{    
    VFX_DECLARE_CLASS(VcpFormTextEditor);

public:
    // Default constructor
    // <group DOM_Form_VcpFormTextEditor_Constructor/Destructor>
    VcpFormTextEditor();

    // <group DOM_Form_VcpFormTextEditor_Override>
    virtual void onInit();        

    // <group DOM_Form_VcpFormTextEditor_Property>
    void setWarningText(const VfxWString &text);

	/* vaib mem reduction */
	// <group DOM_Form_VcpFormTextEditor_Property>
    void setWarningText(VfxResId text_id);

	/* vaib mem reduction */
	// <group DOM_Form_VcpFormTextEditor_Property>
    void setWarningText(const VfxWChar* text_buf);
	
    // <group DOM_Form_VcpFormTextEditor_Property>
    VfxWString getWarningText() const;    

    // Get the child Editor control
    // Returns : Actual VcpTextEditor instance to access editor API
    // <group DOM_Form_VcpFormTextEditor_Method>    
    VcpTextEditor *getEditor() const;    

    // Set the size of editor.
    // It accepts size of editor, without including the warning text.
    // It automatically adjust the size to include warnign text, if required.
    // <group DOM_Form_VcpFormTextEditor_Property>
    void  setEditorSize(const VfxSize &size);

    // Set the size of editor.
    // It accepts size of editor, without including the warning text.
    // It automatically adjusts the size to include warning text, if required.
    // <group DOM_Form_VcpFormTextEditor_Property>  
    void setEditorSize(VfxS32 width, VfxS32 height);

    // It returns the size of child editor control, excluding warning text
    // Returns : Editor Size
    // <group DOM_Form_VcpFormTextEditor_Property>    
    VfxSize getEditorSize() const;

private:

    // <group DOM_Form_VcpFormTextEditor_Implementation>    
    VcpTextEditor *m_editor;
    // <group DOM_Form_VcpFormTextEditor_Implementation>    
    VfxTextFrame *m_warningTextFrm;    
};

// DOM-NOT_FOR_SDK-END

/***********************************
* Inteface classes
***********************************/

class VcpForm;

/***************************************************************************** 
* class VcpFormItemBase
* This class acts as a base class of all the items supported in Form.
* i.e. Form only accepts items derived from VcpFormItemBase as its items
*****************************************************************************/
class VcpFormItemBase: public VfxControl
{
    VFX_DECLARE_CLASS(VcpFormItemBase);

    // Default constructor
    // <group DOM_Form_VcpFormItemBase_Constructor/Destructor>        
    VcpFormItemBase();

public:

    // <group DOM_Form_VcpFormItemBase_Override>        
    virtual void onInit();
    // <group DOM_Form_VcpFormItemBase_Override>        
    virtual void onUpdate();

    // Handler which gets called whenever parent Form changes bounds
    // <group DOM_Form_VcpFormItemBase_Overridable>        
    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);

    // Handler which gets called everytime positions of items are updated.
    // This function defines any item specific steps which are executed if that type of item 
    // happens to be the top most item in the form.
    // Usually it is used to control the top gap in Form content.
    // <group DOM_Form_VcpFormItemBase_Overridable>        
    virtual void firstItemDependentChanges(VcpForm *parent);

    // Handler which gets called everytime positions of items are updated.
    // This function gets the previos item's pointer, and runs any item specific steps to be executed on previous item.
    // It can serve purposes like: making changes in gaps, or showing/hiding separator line.
    // <group DOM_Form_VcpFormItemBase_Overridable>        
    virtual void executePrevDependentBehavior(VcpFormItemBase *prevItem);

    // Set item ID
    // <group DOM_Form_VcpFormItemBase_Property>        
    void setId(VfxId id)
    {
        m_id = id;
    }

    // Get current item ID
    // <group DOM_Form_VcpFormItemBase_Property>        
    VfxId getId()
    {
        return m_id;
    }

    // Set height [Mandatory]
    // It is important to set this property instead of directly setting Frame Bounds.
    // Form expects that item width is not changed by client application.
    // Width of item frame is set automatically equal to form width, and should not be externally changed.
    // It tells Form about the desired height of the item, and is preserved even when items are hidden.
    // Note: For correct layout in Form, It is important to set this property
    // <group DOM_Form_VcpFormItemBase_Property>        
    void setHeight(VfxS32);

    // Returns Height of item
    // <group DOM_Form_VcpFormItemBase_Property>        
    VfxS32 getHeight() const
    {
        return m_height;
    }

    // Hide the item
    // <group DOM_Form_VcpFormItemBase_Property>        
    void setIsHidden(VfxBool state);

    // Checks whether the item is hidden or not
    // <group DOM_Form_VcpFormItemBase_Property>        
    VfxBool getIsHidden() const
    {
        return m_isHidden;
    }

    // Add a separator line at the bottom of item
    // <group DOM_Form_VcpFormItemBase_Property>        
    void setHasSeparator(VfxBool value);

    // Check if there is a separator line after this item
    // <group DOM_Form_VcpFormItemBase_Property>        
    VfxBool getHasSeparator() const;

#if defined(VCP_FRM_KEY_BASED_FOCUS_HANDLING)
    // Check if this item can-handle-key-event
    // <group DOM_Form_VcpFormItemBase_Property>        
    virtual VfxBool canHandleKeyEvent();
#endif /* defined(VCP_FRM_KEY_BASED_FOCUS_HANDLING) */

    
    // Disable/Enable the item.
    // Disabling an item makes it unresponsive to touch inputs.
    // It changes the item UI to a greyed look.
    // <group DOM_Form_VcpFormItemBase_Property>        
    virtual void setIsDisabled(VfxBool state);

    // Signals that the item has changed height.
    // This signal is used by parent form, to adjust the positions of other items accordingly.
    // <group DOM_Form_VcpFormItemBase_Event>        
    VfxSignal1 <
        VfxId> // ID of this item
        m_signalHeightChange;

    // Implementation
protected:
    // <group DOM_Form_VcpFormItemBase_Implementation>        
    VfxId m_id;
    // <group DOM_Form_VcpFormItemBase_Implementation>        
    VfxS32 m_height;    
    // <group DOM_Form_VcpFormItemBase_Implementation>        
    VfxPoint m_pos;
    // <group DOM_Form_VcpFormItemBase_Implementation>        
    VfxBool m_isHidden;
    // <group DOM_Form_VcpFormItemBase_Implementation>        
    VfxFrame *m_separator;
    // <group DOM_Form_VcpFormItemBase_Implementation>        
    VcpFormDisableOverlayFrame  *m_cover;
};

/***************************************************************************** 
* class VcpFormItemCustomFrame [Standard Item class]
* This class defines a blank item with nothing on it.
* It leaves the client application free to customize it with child frames and insert into Form.
* This item type acts as a blank canvas frame.
*****************************************************************************/
class VcpFormItemCustomFrame: public VcpFormItemBase
{
    VFX_DECLARE_CLASS(VcpFormItemCustomFrame);

public:
    // Default constructor
    // <group DOM_Form_VcpFormItemCustomFrame_Constructor/Destructor>        
    VcpFormItemCustomFrame();

    // Initializes
    // <group DOM_Form_VcpFormItemCustomFrame_Override>        
    virtual void onInit();

    // This function gets called whenever there's a change in parent form's bounds
    // It is responsible to relayout the item according to the new form bounds (mainly width)
    // <group DOM_Form_VcpFormItemCustomFrame_Override>        
    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);

    // This fucntion accepts a frame and makes it a child frame of this item
    // It also causes the item to have same height as the frame being attached.
    // Basically it's used when you have created and set up your own frame, 
    // and now wish to insert it in the form as an item.
    // <group DOM_Form_VcpFormItemCustomFrame_Method>        
    void attachCustomFrame(VfxFrame *customframe);
    
    // Returns the attached child frame
    // <group DOM_Form_VcpFormItemCustomFrame_Method>            
    VfxFrame *getFrame()
    {
        return m_customFrame;
    }            

    // Implementation
private:
    VfxFrame *m_customFrame;
};

/***************************************************************************** 
* class VcpFormItemCaption [Standard Item class]
* This class defines a single line caption item.
* It's a single line text caption.
* It's used as a caption for the items following it in form.
*****************************************************************************/
class VcpFormItemCaption: public VcpFormItemBase
{
    enum dimensions
    {
#if defined(__MMI_MAINLCD_320X480__)
        CAPTION_HEIGHT = 24,
        CAPTION_FONT_SIZE  = VCPFRM_FONT_SIZE_1,
#elif defined(__MMI_MAINLCD_480X800__)
        CAPTION_HEIGHT = 35,
        CAPTION_FONT_SIZE  = VCPFRM_FONT_SIZE_1,
#elif defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__)
        CAPTION_HEIGHT = 20,
        CAPTION_FONT_SIZE  = VCPFRM_FONT_SIZE_1,
#else
        CAPTION_HEIGHT = 24,
        CAPTION_FONT_SIZE  = VCPFRM_FONT_SIZE_1,
#endif
        TOTAL
    };

    VFX_DECLARE_CLASS(VcpFormItemCaption);

public:
    // Default constructor
    // <group DOM_Form_VcpFormItemCaption_Constructor/Destructor>            
    VcpFormItemCaption();

    // <group DOM_Form_VcpFormItemCaption_Override>            
    virtual void onInit();
    // <group DOM_Form_VcpFormItemCaption_Override>            
    virtual void onDraw(VfxDrawContext &dc);

    // <group DOM_Form_VcpFormItemCaption_Override>            
    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);
    // <group DOM_Form_VcpFormItemCaption_Override>                
    virtual void executePrevDependentBehavior(VcpFormItemBase *prevItem);
    
    // Set the caption text.
    // Default text: empty string
    // <group DOM_Form_VcpFormItemCaption_Property>                
    void setText(const VfxWString &text);

	/* vaib mem reduction*/
	// Set the caption text.
    // Default text: empty string
    // <group DOM_Form_VcpFormItemCaption_Property>                
    void setText(VfxResId text_id);

	/* vaib mem reduction*/
	// Set the caption text.
    // Default text: empty string
    // <group DOM_Form_VcpFormItemCaption_Property>                
    void setText(const VfxWChar* text_buf);
		
    // Returns the caption text.
    // <group DOM_Form_VcpFormItemCaption_Property>                
    VfxWString getText();

    void setStyle(VcpFormStyleEnum style);
    VcpFormStyleEnum getStyle();    

private:
    VfxWString m_text;
    VfxTextFrame *m_textFrame;
    VcpFormStyleEnum m_style;
};

/***************************************************************************** 
* class VcpFormItemLabeledControl [Standard item class]
* This class defines a labeled item.
* It basically acts as a base class for all items that have a single control 
* along with an attached label.
*****************************************************************************/
class VcpFormItemLabeledControl : public VcpFormItemBase
{
    VFX_DECLARE_CLASS(VcpFormItemLabeledControl);

public:
    enum dimensions
    {
        LEFT_GAP = VCPFRM_INDENT_L1 + VCPFRM_INDENT_L2,
        TOP_GAP = VCPFRM_ITEM_HORZ_GAP_2,
        BOTTOM_GAP = VCPFRM_ITEM_HORZ_GAP_2,
#if defined(__MMI_MAINLCD_320X480__)
        LABEL_MAX_WIDTH = 80,
        TEXT_SEPARATION_GAP = 5,
#elif defined(__MMI_MAINLCD_480X800__)
        LABEL_MAX_WIDTH = 148,
        TEXT_SEPARATION_GAP = 10,
#elif defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__)
        LABEL_MAX_WIDTH = 70,
        TEXT_SEPARATION_GAP = 5,
#else
        LABEL_MAX_WIDTH = 80,
        TEXT_SEPARATION_GAP = 5,
#endif
    };
    // Default constructor
    // <group DOM_Form_VcpFormItemLabeledControl_Constructor/Destructor>                
    VcpFormItemLabeledControl();

    // Initializes
    // <group DOM_Form_VcpFormItemLabeledControl_Override>                
    virtual void onInit();

    // <group DOM_Form_VcpFormItemLabeledControl_Override>                    
    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);

    // Set the label position (available positions: VcpFormLabelPositionEnum)
    // Default label position: NO LABEL
    // <group DOM_Form_VcpFormItemLabeledControl_Property>
    virtual void setLabelPosition(VcpFormLabelPositionEnum pos);
    
    // Returns Current lable position
    // <group DOM_Form_VcpFormItemLabeledControl_Property>
    VcpFormLabelPositionEnum getLabelPosition();

    // Set label text
    // <group DOM_Form_VcpFormItemLabeledControl_Property>
    virtual void setLabelText(VfxWString text);
    
	/* vaib mem reduction */
	// Set label text
    // <group DOM_Form_VcpFormItemLabeledControl_Property>
    virtual void setLabelText(VfxResId text_id);

	/* vaib mem reduction */
	// Set label text
    // <group DOM_Form_VcpFormItemLabeledControl_Property>
    virtual void setLabelText(const VfxWChar* text_buf);
    
    void setLabelTextFromXML(const VfxWString &text);

    // Get label text
    // <group DOM_Form_VcpFormItemLabeledControl_Property>
    VfxWString getLabelText();    

    // This function calculates the correct VfxRect to place the child control,
    // according to the current label position.
    // It would only return the RECT value. The layout function is responsible to use 
    // this value and actually position and resize the child control.
    // <group DOM_Form_VcpFormItemLabeledControl_Method>
    virtual VfxRect getControlRect();

protected:
    VfxTextFrame *m_label;
    VfxWString m_labelText;
    VcpFormLabelPositionEnum m_labelPos;

    // Implements the layouting according to the properties
    // <group DOM_Form_VcpFormItemLabeledControl_Override>
    virtual void onUpdate();
};


/***************************************************************************** 
* Class VcpFormItemBigArrowButton [Standard item class] 
* This item is a full length button with a small arrow icon.
* Arrow icon indicates to the user that this button would launch a new screen
* Since it's derived from VcpFormItemLabeledControl, it can have an optional label.
* It also supports hint text.
*****************************************************************************/
class VcpFormItemBigArrowButton: public VcpFormItemLabeledControl
{
    VFX_DECLARE_CLASS(VcpFormItemBigArrowButton);

public:
    // Default constructor
    // <group DOM_Form_VcpFormItemBigArrowButton_Constructor/Destructor>
    VcpFormItemBigArrowButton();

    // Initializes
    // <group DOM_Form_VcpFormItemBigArrowButton_Override>
    virtual void onInit();

    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);

    virtual void setLabelPosition(VcpFormLabelPositionEnum pos);

    // Set button main text
    // Default button text: empty string
    // <group DOM_Form_VcpFormItemBigArrowButton_Property>    
    void setButtonText(const VfxWString& text);

	/* vaib mem reduction */
	// Set button main text
    // Default button text: empty string
    // <group DOM_Form_VcpFormItemBigArrowButton_Property>    
    void setButtonText(VfxResId text_id);

	/* vaib mem reduction */
	// Set button main text
    // Default button text: empty string
    // <group DOM_Form_VcpFormItemBigArrowButton_Property>    
    void setButtonText(const VfxWChar* text_buf);
    
    // Get current button text
    // <group DOM_Form_VcpFormItemBigArrowButton_Property>
    VfxWString getButtonText();

    // Set hint text
    // Hint text shows up in a smaller font and generally used to tell 
    // some extra information, like currently selected option.
    // <group DOM_Form_VcpFormItemBigArrowButton_Property>
    void setHintText(VfxWString text);
    
	/* vaib mem reduction */
    // Hint text shows up in a smaller font and generally used to tell 
    // some extra information, like currently selected option.
    // <group DOM_Form_VcpFormItemBigArrowButton_Property>  
    void setHintText(VfxResId text_id);

	/* vaib mem reduction */
    // Hint text shows up in a smaller font and generally used to tell 
    // some extra information, like currently selected option.
    // <group DOM_Form_VcpFormItemBigArrowButton_Property> 
    void setHintText(const VfxWChar* text_buf);
    
    // Returns current hint text
    // Hint text shows up in a smaller font and generally used to tell 
    // some extra information, like currently selected option.
    // <group DOM_Form_VcpFormItemBigArrowButton_Property>
    VfxWString getHintText();

    // Returns pointer to child button
    // Use this function to directly access child VcpButton API
    // <group DOM_Form_VcpFormItemBigArrowButton_Method>
    VcpArrowButton *getButton();

    // Notifies that the button is clicked.
    // <group DOM_Form_VcpFormItemBigArrowButton_Event>
    VfxSignal1 <
                VfxId>  // ID of sender item
               m_signalButtonClick;

    // Implementation
private:
    VcpArrowButton *m_button;
    void onButtonClick(VfxObject *btn, VfxId id);

protected:
    // <group DOM_Form_VcpFormItemBigArrowButton_Override>
    virtual void onUpdate();
};

/***************************************************************************** 
* Class VcpFormItemBigAddButton [Standard item class] 
* This item is a full length button with a '+' icon.
* Add icon indicates to the user that this button would help to add a new element
* Since it's derived from VcpFormItemLabeledControl, it can have an optional label.
*****************************************************************************/
class VcpFormItemBigAddButton: public VcpFormItemLabeledControl
{
    VFX_DECLARE_CLASS(VcpFormItemBigAddButton);

public:
    // Default constructor
    // <group DOM_Form_VcpFormItemBigAddButton_Constructor/Destructor>
    VcpFormItemBigAddButton();

    // Initializes
    // <group DOM_Form_VcpFormItemBigAddButton_Override>
    virtual void onInit();

    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);

    virtual void setLabelPosition(VcpFormLabelPositionEnum pos);

    // Set button main text
    // Default button text: empty string
    // <group DOM_Form_VcpFormItemBigAddButton_Property>    
    void setButtonText(const VfxWString& text);

	/* vaib mem reduction */
	// Set button main text
    // Default button text: empty string
    // <group DOM_Form_VcpFormItemBigAddButton_Property>    
    void setButtonText(VfxResId text_id);

	/* vaib mem reduction */
	// Set button main text
    // Default button text: empty string
    // <group DOM_Form_VcpFormItemBigAddButton_Property>    
    void setButtonText(const VfxWChar* text_buf);
    
    // Get button text 
    // <group DOM_Form_VcpFormItemBigAddButton_Property>    
    VfxWString getButtonText();

    // Returns pointer to child button
    // Use this function to directly access child VcpButton API
    // <group DOM_Form_VcpFormItemBigAddButton_Method>
    VcpAddButton *getButton();

    // Notifies that the button is clicked.
    // <group DOM_Form_VcpFormItemBigAddButton_Event>
    VfxSignal1 <
                VfxId>  // ID of sender item
               m_signalButtonClick;

private:
    VcpAddButton *m_button;
    void onButtonClick(VfxObject *btn, VfxId id);

protected:
    // <group DOM_Form_VcpFormItemBigArrowButton_Override>
    virtual void onUpdate();
};

/***************************************************************************** 
* Class VcpFormItemBigButton [Standard item class] 
* This item is a full length button without any icon
* Since it's derived from VcpFormItemLabeledControl, it can have an optional label.
*****************************************************************************/
class VcpFormItemBigButton: public VcpFormItemLabeledControl
{
    VFX_DECLARE_CLASS(VcpFormItemBigButton);
public:
    // Default constructor
    // <group DOM_Form_VcpFormItemBigButton_Constructor/Destructor>
    VcpFormItemBigButton();

    // Initializes
    // <group DOM_Form_VcpFormItemBigButton_Override>    
    virtual void onInit();

    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);

    virtual void setLabelPosition(VcpFormLabelPositionEnum pos);

    // Set button main text
    // Default button text: empty string
    // <group DOM_Form_VcpFormItemBigButton_Property>    
    void setButtonText(VfxWString text);

	/* vaib mem reduction */
	// Set button main text
    // Default button text: empty string
    // <group DOM_Form_VcpFormItemBigButton_Property>    
    void setButtonText(VfxResId text_id);

	/* vaib mem reduction */
	// Set button main text
    // Default button text: empty string
    // <group DOM_Form_VcpFormItemBigButton_Property>    
    void setButtonText(const VfxWChar* text_buf);

    // Get button text 
    // <group DOM_Form_VcpFormItemBigButton_Property>        
    VfxWString getButtonText();

    // Set hint text
    // Hint text shows up in a smaller font and generally used to tell 
    // some extra information, like currently selected option.
    // <group DOM_Form_VcpFormItemBigButton_Property>
    void setHintText(VfxWString text);

	/* vaib mem reduction */
	// Set hint text
    // Hint text shows up in a smaller font and generally used to tell 
    // some extra information, like currently selected option.
    // <group DOM_Form_VcpFormItemBigButton_Property>
    void setHintText(VfxResId text_id);

	/* vaib mem reduction */
	// Set hint text
    // Hint text shows up in a smaller font and generally used to tell 
    // some extra information, like currently selected option.
    // <group DOM_Form_VcpFormItemBigButton_Property>
    void setHintText(const VfxWChar* text_buf);

    // Returns current hint text
    // Hint text shows up in a smaller font and generally used to tell 
    // some extra information, like currently selected option.
    // <group DOM_Form_VcpFormItemBigButton_Property>    
    VfxWString getHintText();


    // Returns pointer to child button
    // Use this function to directly access child VcpButton API
    // <group DOM_Form_VcpFormItemBigButton_Method>
    VcpButton *getButton();

    // Notifies that the button is clicked.
    // <group DOM_Form_VcpFormItemBigButton_Event>
    VfxSignal1 <
                VfxId>  // ID of sender item
               m_signalButtonClick;

    // Implementation
private:
    VcpButton *m_button;
    VfxTextFrame *m_hintText;
    void onButtonClick(VfxObject *btn, VfxId id);

protected:
    virtual void onUpdate();
};

/***************************************************************************** 
* Class VcpFormItemTextInput [Standard item class] 
* This item is a full length single-line text editor
* Since it's derived from VcpFormItemLabeledControl, it can have an optional label.
*****************************************************************************/
class VcpFormItemTextInput: public VcpFormItemLabeledControl
{
    VFX_DECLARE_CLASS(VcpFormItemTextInput);

public:
    // Default constructor
    // <group DOM_Form_VcpFormItemTextInput_Constructor/Destructor>
    VcpFormItemTextInput();

    // Initializes
    // <group DOM_Form_VcpFormItemTextInput_Override>    
    virtual void onInit();
        
    // <group DOM_Form_VcpFormItemTextInput_Override>        
    virtual VfxRect getControlRect();

    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);

    virtual void setLabelPosition(VcpFormLabelPositionEnum pos);

    // Set editor text.
    // Note: This function only allows a default length of 128 character string.
    //       If you need to add a longer string, you can allocate your own text buffer and use 
    //       VcpTextEditor API. The editor can be accessed using getTextBox()
    // Default button text: empty
    // <group DOM_Form_VcpFormItemTextInput_Property>    
    void setText(VfxWString text);

	/* vaib mem reduction */
	// Set editor text.
    // Note: This function only allows a default length of 128 character string.
    //       If you need to add a longer string, you can allocate your own text buffer and use 
    //       VcpTextEditor API. The editor can be accessed using getTextBox()
    // Default button text: empty
    // <group DOM_Form_VcpFormItemTextInput_Property>    
    void setText(VfxResId text_id);

	/* vaib mem reduction */
	// Set editor text.
    // Note: This function only allows a default length of 128 character string.
    //       If you need to add a longer string, you can allocate your own text buffer and use 
    //       VcpTextEditor API. The editor can be accessed using getTextBox()
    // Default button text: empty
    // <group DOM_Form_VcpFormItemTextInput_Property>    
    void setText(const VfxWChar* text_buf);

    void setTextFromXML(const VfxWString &text);

    // Get editor text 
    // <group DOM_Form_VcpFormItemTextInput_Property>            
    VfxWString getText();

    // Returns pointer to child editor
    // Use this function to directly access child VcpTextEditor API
    // <group DOM_Form_VcpFormItemTextInput_Method> 
    VcpTextEditor *getTextBox();

    // Warning text is an optional red colored text which is shown just below the editor.     
    // You can use it to notify user that the input is not valid.     
    // When set as a non empty text string, it unfolds below the editor box, increasing the height of this item
    // If you set it empty/NULL string, it hides again, restoring the item height to original.
    // <group DOM_Form_VcpFormItemTextInput_Property> 
    void setWarningText(const VfxWString &value);
    
	/* vaib mem reduction */
	// Warning text is an optional red colored text which is shown just below the editor.     
    // You can use it to notify user that the input is not valid.     
    // When set as a non empty text string, it unfolds below the editor box, increasing the height of this item
    // If you set it empty/NULL string, it hides again, restoring the item height to original.
    // <group DOM_Form_VcpFormItemTextInput_Property> 
    void setWarningText(VfxResId value);

	/* vaib mem reduction */
	// Warning text is an optional red colored text which is shown just below the editor.     
    // You can use it to notify user that the input is not valid.     
    // When set as a non empty text string, it unfolds below the editor box, increasing the height of this item
    // If you set it empty/NULL string, it hides again, restoring the item height to original.
    // <group DOM_Form_VcpFormItemTextInput_Property> 
    void setWarningText(const VfxWChar* value);
    
#if defined(VCP_FRM_KEY_BASED_FOCUS_HANDLING)
    virtual VfxBool canHandleKeyEvent();
#endif /* defined(VCP_FRM_KEY_BASED_FOCUS_HANDLING) */

    virtual void setFocused(VfxBool value);

private:
    VcpFormTextEditor *m_textBox;
    VfxWChar m_inputString[128];

protected:
    virtual void onUpdate();
};

/***************************************************************************** 
* Class VcpFormItemRemovableTextEntry [Standard item class] 
* This item is special input control, with three controls in a single line:
* - An arrow button for category selection, an input editor and a Add/Delete button
* It is used to get input of multiple entries such as phone numbers, email etc.
* It has two modes: 
* 1. Add mode: In this, first two controls are inactive, and last button is an add button (with '+' symbol)
* 2. Cancel mode: In this, all controls are active, and right-most button is cancel button (wth 'X' synbol)
*****************************************************************************/
class VcpFormItemRemovableTextEntry : public VcpFormItemBase
{
    VFX_DECLARE_CLASS(VcpFormItemRemovableTextEntry);

    enum dimensions
    {
#if defined(__MMI_MAINLCD_320X480__)    
        LEFT_BUTTON_SIZE = 92,
        TEXT_BOX_SIZE = 162,
        RIGHT_BUTTON_SIZE = 40,
        GAP = 5
#elif defined(__MMI_MAINLCD_480X800__)
        LEFT_BUTTON_SIZE = 155,
        TEXT_BOX_SIZE = 211,
        RIGHT_BUTTON_SIZE = 70,
        GAP = 6
#elif defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__)
        LEFT_BUTTON_SIZE = 70,
        TEXT_BOX_SIZE = 114,
        RIGHT_BUTTON_SIZE = VCPFRM_STD_UI_EDITOR_HEIGHT,
        GAP = 5
#else
        LEFT_BUTTON_SIZE = 92,
        TEXT_BOX_SIZE = 162,
        RIGHT_BUTTON_SIZE = 40,
        GAP = 5
#endif    
    };
    
public:
    // Default constructor
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Constructor/Destructor>
    VcpFormItemRemovableTextEntry();
    
    // Constructor that accepts the initial mode
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Constructor/Destructor>    
    VcpFormItemRemovableTextEntry(VfxBool mode);    

    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);
    virtual void onUpdate();
    
private:    

    VcpArrowButton   *m_leftButton;
    VcpFormTextEditor  *m_textBox;
    VcpAddButton *m_addButton;
    VcpCancelButton *m_removeButton;
    VfxBool m_mode;
    VfxBool m_hasLeftButton;
    VfxWChar m_inputString[128];

    void onAddRemoveClick(VfxObject*sender, VfxId btnId);
    void updateChildren();
    void updateLayout();

public:
    // Initializes
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Override>    
    virtual void onInit();
    
    // Get left button.
    // Use this pointer to directly access the VcpArrowButton API
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Override>        
    VcpArrowButton *getLeftButton();
    
    // Get left button.
    // Use this pointer to directly access the VcpArrowButton API
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Override>            
    VcpTextEditor  *getTextBox();  

    // Set the current mode    
    // VFX_TRUE -> Add mode
    // VFX_FALSE -> Cancel mode
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Override>                
    void setMode(VfxBool mode);
    
    // Get the current mode    
    // VFX_TRUE -> Add mode
    // VFX_FALSE -> Cancel mode
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Override>                
    VfxBool getMode();
    
    // Warning text is an optional red colored text which is shown just below the editor.     
    // You can use it to notify user that the input is not valid.     
    // When set as a non empty text string, it unfolds below the editor box, increasing the height of this item
    // If you set it empty/NULL string, it hides again, restoring the item height to original.
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Property> 
    void setWarningText(const VfxWString &value);

	/* vaib mem reduction */
	// Warning text is an optional red colored text which is shown just below the editor.     
    // You can use it to notify user that the input is not valid.     
    // When set as a non empty text string, it unfolds below the editor box, increasing the height of this item
    // If you set it empty/NULL string, it hides again, restoring the item height to original.
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Property> 
    void setWarningText(VfxResId value);

	/* vaib mem reduction */
	// Warning text is an optional red colored text which is shown just below the editor.     
    // You can use it to notify user that the input is not valid.     
    // When set as a non empty text string, it unfolds below the editor box, increasing the height of this item
    // If you set it empty/NULL string, it hides again, restoring the item height to original.
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Property> 
    void setWarningText(const VfxWChar* value);
	
    // If set TRUE, this item would include a button on left side of editor
    // Default: VFX_TRUE
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Property> 
    void setHasLeftButton(VfxBool choice);

    // Returns whether left side button is available or not.
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Property> 
    VfxBool getHasLeftButton() const;   

#if defined(VCP_FRM_KEY_BASED_FOCUS_HANDLING)
    virtual VfxBool canHandleKeyEvent();
#endif /* defined(VCP_FRM_KEY_BASED_FOCUS_HANDLING) */

    virtual void setFocused(VfxBool value);
    VfxWString getText();
    void setText(VfxWString text);
	/* vaib mem reduction */
	void setText(VfxResId text_id);
	/* vaib mem reduction */
	void setText(const VfxWChar* text_buf);

    // Notifies that Add or Cancel button is clicked.
    // <group DOM_Form_VcpFormItemRemovableTextEntry_Event>
    VfxSignal3 <
        VcpFormItemRemovableTextEntry*,  // Sender object pointer
        VfxId,  // Sender ID 
        VfxBool>  // TRUE -> add button, FALSE -> remove button 
        m_signalAddRemoveClick;
};


/***************************************************************************** 
* Class VcpFormItemCell [Standard item class] 
* This item is a menu cell type item
* In these items, main content is on the item frame itself, instead of child controls.
* These, by default, respond to touch events with press-down effect, and implement button like tap behavior.
* This basic class supports a main text and a hint text
* It acts as a base class for all items with this kind of UI
*****************************************************************************/
class VcpFormItemCell: public VcpFormItemBase
{
    VFX_DECLARE_CLASS(VcpFormItemCell);
public:
    enum dimensions
    {
        HEIGHT = VCPFRM_STD_CELL_HEIGHT,
        MAIN_FONT_SIZE = VCPFRM_FONT_SIZE_4,
        HINT_FONT_SIZE = VCPFRM_FONT_SIZE_1,
        RIGHT_MARGIN = VCPFRM_INDENT_L1 + VCPFRM_INDENT_L2,
#if defined(__MMI_MAINLCD_320X480)  
        LEFT_MARGIN = VCPFRM_INDENT_L3,
        TOP_MARGIN = 6,
        BOTTOM_MARGIN = 6,
        HINT_ACC_GAP = 10
#elif defined(__MMI_MAINLCD_480X800__)
        LEFT_MARGIN = 18,
        TOP_MARGIN = 13,
        BOTTOM_MARGIN = 13,
        HINT_ACC_GAP = 14
#elif defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__)
        LEFT_MARGIN = VCPFRM_INDENT_L1 + VCPFRM_INDENT_L2,
        TOP_MARGIN = 7,
        BOTTOM_MARGIN = 4,
        HINT_ACC_GAP = 10
#else
        LEFT_MARGIN = VCPFRM_INDENT_L3,
        TOP_MARGIN = 6,
        BOTTOM_MARGIN = 6,
        HINT_ACC_GAP = 10
#endif        
    };

    enum statetype
    {
        NORMAL,
        PRESSED
    };

    // Default constructor
    // <group DOM_Form_VcpFormItemCell_Constructor/Destructor>
    VcpFormItemCell();

    // Initializes
    // <group DOM_Form_VcpFormItemCell_Override>
    virtual void onInit();
    // <group DOM_Form_VcpFormItemCell_Override>
    virtual VfxBool onPenInput(VfxPenEvent &event);
    // <group DOM_Form_VcpFormItemCell_Override>
	virtual void onUpdate();
	
    // <group DOM_Form_VcpFormItemCell_Override>    
    virtual void firstItemDependentChanges(VcpForm *parent);

    // <group DOM_Form_VcpFormItemCell_Override>
    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);

    // <group DOM_Form_VcpFormItemCell_Override>
	virtual void setIsDisabled(VfxBool state);	
    
    // This function gets called whenever there is a tap in the cell (if the cell isTappable)
    // Implement this function in your derived classes for any steps to execute on cell tap.
    // Ofcourse do not forget to call this parent class function in your implementation.
    // <group DOM_Form_VcpFormItemCell_Overridable>
    virtual void onCellTap(VfxPenEvent &event);

    // Set isTappable property.
    // If TRUE, then cell shows a press-down effect to highlight.
    // If FALSE, then cell frame does not respond to touch events. Although child control stay active/hittable
    // <group DOM_Form_VcpFormItemCell_Property>
    void setIsTappable(VfxBool IsTappable);
    // Get isTappable property status.
    // If TRUE, then cell shows a press-down effect to highlight.
    // If FALSE, then cell frame does not respond to touch events. Although child control stay active/hittable
    // <group DOM_Form_VcpFormItemCell_Property>
    VfxBool getIsTappable();

    VfxTextFrame *m_mainText;
    VfxTextFrame *m_hintText;
    VfxPoint m_downPos;
    VfxBool m_isTappable;
    statetype m_state;

    // Set the main text of cell
    // <group DOM_Form_VcpFormItemCell_Property>
    virtual void setMainText(const VfxWString &text);

	/* vaib mem reduction */
	// <group DOM_Form_VcpFormItemCell_Property>
    virtual void setMainText(VfxResId text_id);

	/* vaib mem reduction */
	// <group DOM_Form_VcpFormItemCell_Property>
    virtual void setMainText(const VfxWChar* text_buf);
    // Get the main text of cell
    // <group DOM_Form_VcpFormItemCell_Property>
    VfxWString getMainText();

    // Set the hint text of cell
    // <group DOM_Form_VcpFormItemCell_Property>    
    void setHintText(const VfxWString &text);

	/* vaib mem reduction */
	// <group DOM_Form_VcpFormItemCell_Property>    
    void setHintText(VfxResId text_id);

	/* vaib mem reduction */
	// <group DOM_Form_VcpFormItemCell_Property>    
    void setHintText(const VfxWChar* text_buf);

    // Get the hint text of cell
    // <group DOM_Form_VcpFormItemCell_Property>    
    VfxWString getHintText();

    // Notifies that the cell is tapped 
    // <group DOM_Form_VcpFormItemCell_Event>
    VfxSignal2 <
        VcpFormItemCell*, // Sender
        VfxId // Sender id
    > m_signalTap;
    
    // Notifies that the cell is long-pressed 
    // <group DOM_Form_VcpFormItemCell_Event>
    VfxSignal2 <
        VcpFormItemCell*, // Sender
        VfxId // Sender id
    > m_signalLongTap;


    virtual void onFocusedTimeEnd(VfxTimer *timer);
};
/***************************************************************************** 
* Class VcpFormItemLauncherCell [Standard item class] 
* This item is a menu cell type item, with a purpose to launch new screen.
* It has a optional arrow icon (shown by default) that indicates to the user,
* that a new selection screen would be launched.
* It's called accessory NEXT_ITEM_CICON. 
*****************************************************************************/
class VcpFormItemLauncherCell : public VcpFormItemCell 
{
    VFX_DECLARE_CLASS(VcpFormItemLauncherCell);

public:

    // Enum to list hint text positions
    // <group DOM_Form_VcpFormItemLauncherCell_Enum>
    enum HintPositionEnum
    {
        HINT_POSITION_BOTTOM_LEFT,  // Hint text just below the main text
        HINT_POSITION_RIGHT_END,    // Hint text on right end, aligned with Main text

        HINT_POSITION_NONE
    };

    // Default constructor        
    // <group DOM_Form_VcpFormItemLauncherCell_Constructor/Destructor>
    VcpFormItemLauncherCell();

    virtual void onInit();
    virtual VfxBool onPenInput(VfxPenEvent &event);
    virtual void onCellTap(VfxPenEvent &event);
    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);
    virtual void onUpdate();

    // Set the hint text posiiton.
    // It can be one of the possible positions listed in HintPositionEnum
    // <group DOM_Form_VcpFormItemLauncherCell_Property>
    void setHintPosition(HintPositionEnum hintPos);
    HintPositionEnum getHintPosition();

    // Set Accessory type
    // Choose one from VcpFormAccessoryType enum     
    // <group DOM_Form_VcpFormItemLauncherCell_Property>
    void setAccessory(VcpFormAccessoryType acc);
    // Get Accessory type
    // Returns VcpFormAccessoryType
    // <group DOM_Form_VcpFormItemLauncherCell_Property>
    VcpFormAccessoryType getAccessory();

    virtual void onFocusedTimeEnd(VfxTimer *timer);
private:    
    // Variable
    VfxImageFrame *m_accessory;
    VcpFormAccessoryType m_accType;
    HintPositionEnum m_hintPosition;
};

/***************************************************************************** 
* Class VcpFormItemSwitchCell [Standard item class] 
* <group DOM_Form_VcpFormItemSwitchCell>
* This item is a menu cell type item, with an ON/OFF switch control
* As expected, its purpose is to act as an ON/OFF setting
* Since it is derived from VcpFormItemCell, it can be tapped to launch actions.
* But, unlike other cells, its isTappable property is FALSE by default. You need 
* to first set it TRUE, to make it respond to taps.
* Note: When user taps the switch control to change its state, it does not actually change 
*       the switch state right away. The cell would emit a signal to notify parent application about 
*       user request. Parent application can now process the swicth request first and then actually 
*       set the switch to new state using setSwitchState() (if processing is succesful)
*****************************************************************************/
class VcpFormItemSwitchCell : public VcpFormItemCell
{
    VFX_DECLARE_CLASS(VcpFormItemSwitchCell);

public:
    // Default constructor        
    // <group DOM_Form_VcpFormItemSwitchCell_Constructor/Destructor>
    VcpFormItemSwitchCell();

    virtual void onInit();
    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);
    virtual void onUpdate();
private:
    VcpSwitch *m_switch;    
    VcpActivityIndicator *m_activityInd;

public:
    // Set the current switch status to ON or OFF
    // <group DOM_Form_VcpFormItemSwitchCell_Property>
    void setSwitchStatus(VfxBool state);
    // Get the current switch status
    // <group DOM_Form_VcpFormItemSwitchCell_Property>
    VfxBool getSwitchStatus();

    // Sometimes the parent application may need significantly long time to 
    // process the switch request made by user. 
    // If you think your switch operation would take long time, then you can 
    // choose to first show a processing-indicator using this function. 
    // It would show an animated VcpActivityIndicator.
    // The indicator would automatically close when you setSwitchState() again to 
    // its final position, after processing is complete)    
    // <group DOM_Form_VcpFormItemSwitchCell_Method>
    void showProcessInd();
    
    // You can manually hide a processing indicator if needed, using this function, 
    // although it's not usually required.
    // Please also refer: showProcessInd()
    // <group DOM_Form_VcpFormItemSwitchCell_Method>
    void hideProcessInd();

    // Signal to notify that user has tapped the switch control, and wants to toggle it.
    // At this point, switch has not actually changed it's state.
    // <group DOM_Form_VcpFormItemSwitchCell_Event>
    VfxSignal3 <
        VcpFormItemSwitchCell*, // Sender
        VfxId, // Sender id
        VfxBool                 // New switch value
    > m_signalSwitchChangeReq;

    VfxSignal3 <
        VcpFormItemSwitchCell*, // Sender
        VfxId, // Sender id
        VfxBool                 // New switch value
    > m_signalToggleAnimationDone;

private:
    // Implementation
    void onUserSwitchChangeReq(VcpSwitch* sw, VfxBool status);
    void onSwitchAnimationCompleted(VcpSwitch *sw, VfxBool state);

};

/***************************************************************************** 
* Class VcpFormItemAidButtonCell [Standard item class] 
* <group DOM_Form_VcpFormItemAidButtonCell>
* This item is a menu cell type item, with a small VcpButton on the right end.
* Overall it behaves like a normal tappable cell.
* This extra button on the right end is called an aid-button, as it may be put 
* to some special applciation specific use.
*****************************************************************************/
class VcpFormItemAidButtonCell : public VcpFormItemCell
{
    VFX_DECLARE_CLASS(VcpFormItemAidButtonCell);

public:
    // Default constructor        
    // <group DOM_Form_VcpFormItemAidButtonCell_Constructor/Destructor>
    VcpFormItemAidButtonCell();

    virtual void onInit();
    virtual void onUpdate();

    // Set the text for Aid button
    // <group DOM_Form_VcpFormItemAidButtonCell_Property>    
    void setButtonText(const VfxWString &text);
    
	/* vaib mem reduction */
	// <group DOM_Form_VcpFormItemAidButtonCell_Property>    
    void setButtonText(VfxResId text_id);

	/* vaib mem reduction */
	// <group DOM_Form_VcpFormItemAidButtonCell_Property>    
    void setButtonText(const VfxWChar* text_buf);
	
    // Get the aid button text
    // <group DOM_Form_VcpFormItemAidButtonCell_Property>        
    VfxWString getButtonText();

    // Get the pointer to the aid button
    // Use this to directly access the VcpButton API for aid-button
    // <group DOM_Form_VcpFormItemAidButtonCell_Method>        
    VcpButton *getAidButton() const
    {
        return m_button;
    }
    // This signal notifies that aid button is clicked
    // <group DOM_Form_VcpFormItemAidButtonCell_Event>        
    VfxSignal2 <
        VcpFormItemAidButtonCell*, // Sender item pointer
        VfxId // Sender id        
    > m_signalAidButtonPress;

private:
    VcpButton *m_button;    
    virtual void onFormBoundsChanged(VfxFrame *frm, const VfxRect &rect);
    void onButtonPress(VfxObject* btn, VfxId id);
};

// DOM-NOT_FOR_SDK-BEGIN

/***********************************
* Internal Utility classes
***********************************/

/***************************************************************************** 
* Class VcpFormIndexer (Internal Helper class)
* This class is responsible for the positoning of items in the form's content region.
* Its API is not relevant for parent application.
* <group DOM_Form_VcpFormIndexer>        
*****************************************************************************/
class VcpFormIndexer: public VfxBase
{
    // Constructor/ Destructor
public:
    VcpFormIndexer();    
    class VcpFormItemdata: public VfxObject
    {
    public:
        VcpFormItemdata(){}
        VfxId itemId;
        VcpFormItemBase *item;
    };
    VfxObjList m_mappingList;        
    VfxS32 m_count;
    // Method
public:
    VfxBool insert(VfxId id, VcpFormItemBase *frame, VfxObject *parent, VfxId refId, VfxBool addBeforeRefId);
    VfxBool remove(VfxId id);
    VcpFormItemBase *get(VfxId id);
    VcpFormItemBase *getLastItem();
    VfxId getNextId(VfxId id); 
    VfxS32 getCount() const
    {
        return m_count;
    }
    VcpFormItemBase *getItemAtIndex(VfxS32 index);

};
class VcpForm;

/***************************************************************************** 
* Class VcpFormLayouter (Internal Helper class)
* This class is responsible for the positoning of items in the form's content region.
* Its API is not relevant for parent application.
* <group DOM_Form_VcpFormLayouter>    
*****************************************************************************/
class VcpFormLayouter: public VfxBase
{
    // Constructor/Destructor
public:
    // Default contructor
    // <group DOM_Form_VcpFormLayouter_Constructor/Destructor>        
    VcpFormLayouter();
    // Method
public:
    // This function updates positions of all the items according to their 
    // sequence and current height. 
    // This is executed everytime there is a change in any item size or sequence.
    // For efficiency, it takes a target item ID and make adjustments downwards, 
    // starting from that item, as only positions of items below are disturbed.
    // <group DOM_Form_VcpFormLayouter_Method>        
    VfxS32 updatePositions(VfxId itemId, VcpFormIndexer m_indexer);
    
#if defined(VCP_FORM_STRETCHES_ON_SCROLL_END)    
    // This function implements the stretching effect animation.
    // It is executed whenever user tries to drag form beyond its top/bottom boundaries
    // <group DOM_Form_VcpFormLayouter_Method>
    
    VfxS32 executeStretchingEffect(VfxS32 newPosY, VcpFormIndexer m_indexer);
#endif
    
    // This function introduces the layouter with its parent form, on which it needs to operate.
    // <group DOM_Form_VcpFormLayouter_Method>
    void attachMasterForm(VcpForm *parentForm);
    // Stores the top gap of content region.
    // This is the Y position for first item.
    // <group DOM_Form_VcpFormLayouter_Variable>
    VfxS32 m_itemHorzGap;
    // Parent form pointer
    // <group DOM_Form_VcpFormLayouter_Variable>
    VcpForm *m_parentForm;
    // Scrolling state. 
    // Relevant only for the stretching effect implementation
    // <group DOM_Form_VcpFormLayouter_Implementation>
    VcpFormScrollingState m_scrollState;
    // <group DOM_Form_VcpFormLayouter_Implementation>
    VfxS32 m_scrollVelocity ;
    // <group DOM_Form_VcpFormLayouter_Implementation>
    VfxS32 m_recoilTime ; //ms
    // <group DOM_Form_VcpFormLayouter_Implementation>
    VfxS32 m_stretchStartPosY; 
}; 

// DOM-NOT_FOR_SDK-END

/***************************************************************************** 
* Class VcpForm (Main component class)
* To use form, you first need to create an object of this class as your application's child frame
*****************************************************************************/
class VcpForm : public VcpScrollable
{
    VFX_DECLARE_CLASS(VcpForm);

    
public:
    // Default constructor
    // <group DOM_Form_VcpForm_Constructor/Destructor>        
    VcpForm();

    friend class VcpFormLayouter;
    
    // <group DOM_Form_VcpForm_Override>
    virtual void onInit();

#if defined(VCP_FORM_STRETCHES_ON_SCROLL_END)
    virtual VfxBool onPreviewPenInput(VfxPenEvent &event);
#endif

    // Implementation
private:
    // <group DOM_Form_VcpForm_Implementation>
    VfxS32 m_itemCount;
    // <group DOM_Form_VcpForm_Implementation>
    VcpFormIndexer    m_indexer;
    // <group DOM_Form_VcpForm_Implementation>
    VcpFormLayouter m_layouter;
    // <group DOM_Form_VcpForm_Implementation>
    VfxS32 m_formWidth;
    // <group DOM_Form_VcpForm_Implementation>
    VfxS32 m_formHeight;

#if defined(VCP_FRM_KEY_BASED_FOCUS_HANDLING)
    // <group DOM_Form_VcpForm_Implementation>
    VfxS32 m_currentKeyFocusIndex;
#endif /* defined(VCP_FRM_KEY_BASED_FOCUS_HANDLING) */

    // <group DOM_Form_VcpForm_Implementation>
    VfxFrame *m_topShadow;

#if defined(VCP_FORM_STRETCHES_ON_SCROLL_END)    
    VfxBool m_stretchingEffectIsEnabled;
#endif

    // <group DOM_Form_VcpForm_Implementation>
    VfxS32 m_contentTopGap;

    VfxBool m_isAnimEnabled;
protected:
    // <group DOM_Form_VcpForm_Override>
    virtual void onBoundsChange(VfxFrame *frm, const VfxRect &rect);
    // <group DOM_Form_VcpForm_Slot>
    virtual void onItemHeightChange(VfxId id);
	// <group DOM_Form_VcpForm_Override>
	virtual void onUpdate();
	
    // <group DOM_Form_VcpForm_Implementation>
    virtual void adjustContentOffsetPosition();

private:
    // <group DOM_Form_VcpForm_Implementation>
    void adjustContentOffsetPosition(VfxS32 contentHeight, VfxS32 viewOrigin, VfxS32 viewHeight);

    // Property
public:

#if defined(VCP_FORM_STRETCHES_ON_SCROLL_END)        
    // Enable/Disable strecthing effect
    // Default: OFF
    // With this effect, when user is scrolling form and reaches the ends, 
    // Form appears to be getting strectched, instead of just stopping on the boundary.
    // <group DOM_Form_VcpForm_Property>
    
    void setStretchingEffectIsEnabled(VfxBool status)
    {
        m_stretchingEffectIsEnabled = status;
    }
    // Check whether strecthing effect is ON/OFF
    // <group DOM_Form_VcpForm_Property>    
    
    VfxBool getStretchingEffectIsEnabled() const
    {
        return m_stretchingEffectIsEnabled;
    }
#endif    
    // Sets a top gap for the content. 
    // This gap tells how many Y pixels to leave before the first item.
    // <group DOM_Form_VcpForm_Property>
    void setContentTopGap(VfxS32 gap = VCPFRM_ITEM_HORZ_GAP_2);
    // Get top gap
    // <group DOM_Form_VcpForm_Property>
    VfxS32 getContentTopGap()
    {
        return m_contentTopGap;
    }
    
    // Sets whether position and size changes would be animated or not.
    // This is usually required FALSE during the page transition to avoid stuttered animations caused by page-transition animation. 
    // Default value: VFX_TRUE
    // <group DOM_Form_VcpForm_Property>
    void setIsAnimEnabled(VfxBool state);
    void setIsAnimWaitEnabled(VfxBool state);
    
    // <group DOM_Form_VcpForm_Property>
    VfxBool getIsAnimEnabled() const;
    VfxBool getIsAnimWaitEnabled() const;
    
    void setTopShadowIsHidden(VfxBool state);

    VfxBool getTopShadowIsHidden() const;
    
    // Method
public:
    // Add new item to the end
    // <group DOM_Form_VcpForm_Method>
    void addItem(VcpFormItemBase *item, VfxId itemId = VCPFRM_ITEMID_INVALID);
    
    void addItemFromXML(VcpFormItemBase *item);

    // Insert new item before the old item: ReferenceId
    // Note: You can insert 'After' ReferenceId, if you send addBeforeRefId as VFX_FALSE
    // <group DOM_Form_VcpForm_Method>
    void insertItem(VcpFormItemBase *item, VfxId ReferenceId , VfxId itemId = VCPFRM_ITEMID_INVALID, VfxBool addBeforeRefId = VFX_TRUE);

    // Remove an item by specifying the ID
    // <group DOM_Form_VcpForm_Method>
    void removeItem(VfxId itemId);

    // Get the pointer of item by specifying the ID
    // <group DOM_Form_VcpForm_Method>
    VcpFormItemBase *getItem(VfxId);    

    // Insert a separator line after the given item (specifying item ID)
    // Note: The separator line is a property of form-item. 
    //       It can also be added/removed by using itemPointer->setHasSeparator()
    // <group DOM_Form_VcpForm_Method>
    void insertSeparator(VfxId afterId = VCPFRM_ITEMID_INVALID);
    
    // Insert a separator line after the given item (specifying item pointer)
    // Note: The separator line is a property of form-item. 
    //       It can also be added/removed by using itemPointer->setHasSeparator()
    // <group DOM_Form_VcpForm_Method>    
    void insertSeparator(VcpFormItemBase *target);    

    // Remove a separator line after the given item (specifying item ID)
    // Note: The separator line is a property of form-item. 
    //       It can also be added/removed by using itemPointer->setHasSeparator()
    // <group DOM_Form_VcpForm_Method>        
    void removeSeparator(VfxId afterId = VCPFRM_ITEMID_INVALID);
    
    // Remove a separator line after the given item (specifying item pointer)
    // Note: The separator line is a property of form-item. 
    //       It can also be added/removed by using itemPointer->setHasSeparator()
    // <group DOM_Form_VcpForm_Method>        
    void removeSeparator(VcpFormItemBase *target);

    // Add a caption item (VcpFormItemCaption) with given text to the end.
    // Note: This is just a convenient alternative of adding a caption.
    //       This could also be achieved by first creating a VcpFormItemCaption object,
    //       set its text and ID, and use addItem() to insert it in Form.
    // <group DOM_Form_VcpForm_Method>
    void addCaption(VfxWString text, VfxId id=VCPFRM_ITEMID_INVALID);    

	/* vaib mem reduction */
	// <group DOM_Form_VcpForm_Method>
    void addCaption(VfxResId text_id, VfxId id=VCPFRM_ITEMID_INVALID); 

	/* vaib mem reduction */
	// <group DOM_Form_VcpForm_Method>
    void addCaption(const VfxWChar* text_buf, VfxId id=VCPFRM_ITEMID_INVALID); 

    // Returns Current count of total items added in Form.
    // <group DOM_Form_VcpForm_Method>
    VfxS32 getItemCount() const
    {
        return m_itemCount;
    }

#if defined(VCP_FRM_KEY_BASED_FOCUS_HANDLING) || defined(__MMI_VUI_COSMOS_CP__)
    // <group DOM_Form_VcpForm_Override>
    virtual VfxBool onKeyInput(VfxKeyEvent &event);
#endif /* defined(VCP_FRM_KEY_BASED_FOCUS_HANDLING) */

    // Auto scrolls form to bring a particular item (specified by ID) to view.
    // Used when you need to place a certain item in particular part viewable region.
    // Item can be scrolled to top, center or bottom of the view window in form.
    // This target position is specified by VcpFormScrollViewPosition.
    // If you do not want this change animated (visible scrolling), send isAnim as VFX_FALSE
    // <group DOM_Form_VcpForm_Method>
    void scrollItemToView(VfxId id, VcpFormScrollViewPosition pos, VfxBool isAnim = VFX_TRUE);

    // <group DOM_Form_VcpForm_Method>
    void scrollItemToView(VcpFormItemBase *item, VcpFormScrollViewPosition pos, VfxBool isAnim = VFX_TRUE);
};

#endif /* #if defined (__MMI_VUI_COSMOS_CP__) */
#endif
