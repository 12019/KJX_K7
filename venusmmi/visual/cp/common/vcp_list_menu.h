/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2008
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES. ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vcp_list_menu.h
 *
 * Project:
 * --------
 *  Venus list menu component
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#ifndef _VCP_LIST_MENU_H_
#define _VCP_LIST_MENU_H_


/***************************************************************************** 
 * Include
 *****************************************************************************/
#include "vrt_datatype.h"
#include "vfx_cpp_base.h"
#include "vfx_datatype.h"
#include "vfx_string.h"
#include "vcp_text_utils.h"
#include "vfx_image_src.h"
#include "vfx_frame.h"
#include "vfx_weak_ptr.h"
#include "vfx_animation.h"
#include "vfx_object.h"
#include "vfx_class_info.h"
#include "vfx_basic_type.h"
#include "vfx_signal.h"
#include "vfx_input_event.h"
#include "vfx_control.h"
#include "vfx_text_frame.h"
#include "vfx_draw_context.h"
#include "vfx_primitive_frame.h"
#include "vcp_text_view.h"
#include "vcp_state_image.h"
#include "vcp_base_menu.h"
#include "vcp_image_button.h"
#include "vcp_text_editor.h"

//suppress build warning 997
#if defined(__MTK_TARGET__)
#pragma diag_suppress 997
#endif

//add here for APP to use img resource
#include "mmi_rp_srv_venus_component_list_menu_def.h"

#if defined(__MMI_VUI_COSMOS_CP__)
#include "vcp_menu_seek_bar.h"
#endif


/***************************************************************************** 
 * Define
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */

#define VCP_LIST_MENU_REORDER_ITEM_BG_SHADOW_HEIGHT 10

#if defined(__MMI_MAINLCD_320X480__)

#if defined(__MMI_VUI_COSMOS_CP__)
#define VCP_LIST_MENU_SEARCH_BAR_HEIGHT         50
#define VCP_LIST_MENU_CELL_HEIGHT_SINGLE_LINE   51
#define VCP_LIST_MENU_CELL_HEIGHT_MULTI_LINE    51
#define VCP_LIST_MENU_FONT_SIZE_SMALL           VFX_FONT_DESC_VF_SIZE(14)
#define VCP_LIST_MENU_FONT_SIZE_MEDIUM          VFX_FONT_DESC_VF_SIZE(20)
#else /* defined(__MMI_VUI_COSMOS_CP__) */
#define VCP_LIST_MENU_SEARCH_BAR_HEIGHT         50
#define VCP_LIST_MENU_CELL_HEIGHT_SINGLE_LINE   52
#define VCP_LIST_MENU_CELL_HEIGHT_MULTI_LINE    65
#define VCP_LIST_MENU_FONT_SIZE_SMALL           VFX_FONT_DESC_SIZE_SMALL
#define VCP_LIST_MENU_FONT_SIZE_MEDIUM          VFX_FONT_DESC_SIZE_MEDIUM
#endif /* defined(__MMI_VUI_COSMOS_CP__) */

#elif defined(__MMI_MAINLCD_480X800__)

#define VCP_LIST_MENU_SEARCH_BAR_HEIGHT         85
#define VCP_LIST_MENU_CELL_HEIGHT_SINGLE_LINE   86
#define VCP_LIST_MENU_CELL_HEIGHT_MULTI_LINE    86
#define VCP_LIST_MENU_FONT_SIZE_SMALL           VFX_FONT_DESC_VF_SIZE(21)
#define VCP_LIST_MENU_FONT_SIZE_MEDIUM          VFX_FONT_DESC_VF_SIZE(30)

#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))

#define VCP_LIST_MENU_SEARCH_BAR_HEIGHT         45
#define VCP_LIST_MENU_CELL_HEIGHT_SINGLE_LINE   45
#define VCP_LIST_MENU_CELL_HEIGHT_MULTI_LINE    45
#define VCP_LIST_MENU_FONT_SIZE_SMALL           VFX_FONT_DESC_VF_SIZE(12)
#define VCP_LIST_MENU_FONT_SIZE_MEDIUM          VFX_FONT_DESC_VF_SIZE(16)

#else /* Shell: QVGA / WQVGA */

#define VCP_LIST_MENU_SEARCH_BAR_HEIGHT         45
#define VCP_LIST_MENU_CELL_HEIGHT_SINGLE_LINE   39
#define VCP_LIST_MENU_CELL_HEIGHT_MULTI_LINE    57
#define VCP_LIST_MENU_FONT_SIZE_SMALL           VFX_FONT_DESC_SIZE_SMALL
#define VCP_LIST_MENU_FONT_SIZE_MEDIUM          VFX_FONT_DESC_SIZE_MEDIUM

#endif

#define VCP_LIST_MENU_DISABLED_CELL_FORGROUND_COLOR VRT_COLOR_MAKE(178, 220, 220, 220)

#if defined(__MMI_VUI_COSMOS_CP__)
#define VCP_LIST_MENU_SEARCH_BAR_ID_IN_SEEK_BAR 0xffffffff
#endif

#define VCP_LIST_MENU_EMPTY_TEXT_WITH_RATIO (0.8f)

/* DOM-NOT_FOR_SDK-END */


// <group DOM_ListMenu_Macro&Enum_Enum>
// List menu cell style enums, each style stands for a kind of list item layout of data (image and text)
enum VcpListMenuCellStyleEnum
{
    VCP_LIST_MENU_CELL_STYLE_NONE,                  // None
    VCP_LIST_MENU_CELL_STYLE_CUSTOM,                // Custom content frame
    VCP_LIST_MENU_CELL_STYLE_SINGLE_TEXT,           // Single text cell
    VCP_LIST_MENU_CELL_STYLE_MULTI_TEXT,            // One text and one sub-text in the second line

    VCP_LIST_MENU_CELL_STYLE_MULTI_TEXT_EX,         // One text and one sub-text in the same line
    VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT,           // one text and two sub-text
    VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT_EX,        // Two icons with one text and two sub-text, and the two icons are on the right-top corner
    VCP_LIST_MENU_CELL_STYLE_QUADRUPLE_TEXT,        // one text and three sub-text, and the two icons are on the right-top corner
    VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT,      // One icon with single text cell, and the icon is on the left side
    VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT_EX,   // One icon with single text cell, and the icon is on the right side
    VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT_EX2,  // Two icon with single text cell, and one icon is on the left side, and another icon is on the right side
    VCP_LIST_MENU_CELL_STYLE_ICON_MULTI_TEXT,       // One icon with one text and one sub-text in the second line
    VCP_LIST_MENU_CELL_STYLE_ICON_MULTI_TEXT_EX,    // One icon with one text and one sub-text in the same line
    VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT,      // One icon with one text and two sub-text
    VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT_EX,   // Three icons with one text and two sub-text, and one icon on the left side, and the other two icons on the right-top corner
    VCP_LIST_MENU_CELL_STYLE_ICON_QUADRUPLE_TEXT,   // One icon with one text and three sub-text
    VCP_LIST_MENU_CELL_STYLE_ICON_QUINTUPLE_TEXT,   // One icon with one text and four sub-text

    VCP_LIST_MENU_CELL_STYLE_MAX
};


// <group DOM_ListMenu_Macro&Enum_Enum>
// List menu focus behavior enums, the focus means there is a highlight background in one list item
enum VcpListMenuFocusBehaviorEnum
{
    VCP_LIST_MENU_FOCUS_BEHAVIOR_NONE,      // No focus item
    VCP_LIST_MENU_FOCUS_BEHAVIOR_SEMI,      // There is focus item when touching down on a list item,  or pressing down/up navigation key
    VCP_LIST_MENU_FOCUS_BEHAVIOR_EMPHASIS,  // Only for list menu witch custom content frame, focus item may have different height
    VCP_LIST_MENU_FOCUS_BEHAVIOR_ALWAYS     // There is always focus item  
};

// <group DOM_ListMenu_Macro&Enum_Enum>
// List menu field enums, one field is one kind of list data in the list item, and application should provide the corresponding data to list menu by content provider according to the field name
enum VcpListMenuFieldEnum
{
    VCP_LIST_MENU_FIELD_DUMMY,                      // Dummy field
    VCP_LIST_MENU_FIELD_ICON,                       // Icon field
    VCP_LIST_MENU_FIELD_TEXT,                       // Main text field
    VCP_LIST_MENU_FIELD_SUB_TEXT1,                  // First sub-text field
    VCP_LIST_MENU_FIELD_CMD_BUT_IMG_NORMAL,         // Image of the normal command button
    VCP_LIST_MENU_FIELD_CMD_BUT_IMG_PRESSED,        // Image of the pressed command button 
    VCP_LIST_MENU_FIELD_CMD_BUT_IMG_DISABLED,       // Image of the disabled command button
    VCP_LIST_MENU_FIELD_CMD_BUT_IMG_HIGHLIGHT,      // Image of the highlight command button
    VCP_LIST_MENU_FIELD_DISCLOSURE_IMG,             // Imgae of the disclosure control
    VCP_LIST_MENU_FIELD_HIGHLIGHT_DISCLOSURE_IMG,   // Imgae of the highlight disclosure control
    VCP_LIST_MENU_FIELD_ICON_EXTRA1,                // Extra icon field 1
    VCP_LIST_MENU_FIELD_ICON_EXTRA2,                // Extra icon field 2
    VCP_LIST_MENU_FIELD_SUB_TEXT2,                  // Second sub-text field
    VCP_LIST_MENU_FIELD_SUB_TEXT3,                  // Third sub-text field
    VCP_LIST_MENU_FIELD_TAIL_TEXT,                  // Tail text of main text field
    VCP_LIST_MENU_FIELD_GROUP_HEADER_TEXT,          // Text of the group header

    VCP_LIST_MENU_FIELD_MAX
};

// <group DOM_ListMenu_Macro&Enum_Enum>
// List item state enums, such as the selection states
enum VcpListMenuItemStateEnum
{
    VCP_LIST_MENU_ITEM_STATE_NONE,          // The list item doesn't have selection state, and it means there is not check box or radio button
    VCP_LIST_MENU_ITEM_STATE_UNSELECTED,    // The unselected state of list item
    VCP_LIST_MENU_ITEM_STATE_SELECTED       // The selected state of list item
};

// <group DOM_ListMenu_Macro&Enum_Enum>
// List menu mode, each mode stands for a corresponding built-in editing control in list item
enum VcpListMenuModeEnum
{
    VCP_LIST_MENU_MODE_NORMAL,                  // The normal list menu mode, means there is no built-in editing control in the list item
    VCP_LIST_MENU_MODE_REORDER,                 // The reorder mode of list menu, there is a reorder thumb in the front of the list item
    VCP_LIST_MENU_MODE_SINGLE_SELECTION,        // The single selection mode of list menu, there is a radio button in the front of list item
    VCP_LIST_MENU_MODE_MULTI_SELECTION,         // The multiple selection mode of list menu, there is a check box in the front of list item
    VCP_LIST_MENU_MODE_HEAD_SINGLE_CHECK_MARK,  // The head single check mark mode of list menu, there wouold be a check mark control in the fromt of the list item
    VCP_LIST_MENU_MODE_HEAD_MULTI_CHECK_MARK,   // The head multiple check mark mode of list menu, there wouold be a check mark control in the fromt of the list item
    VCP_LIST_MENU_MODE_TAIL_SINGLE_CHECK_MARK,  // The tail single check mark mode of list menu, there wouold be a check mark control in the fromt of the list item
    VCP_LIST_MENU_MODE_TAIL_MULTI_CHECK_MARK,   // The tail multiple check mark mode of list menu, there wouold be a check mark control in the fromt of the list item

    VCP_LIST_MENU_MODE_MAX
};


// <group DOM_ListMenu_Macro&Enum_Enum>
// List menu control mode, each mode stands for a corresponding built-in control in list item
enum VcpListMenuControlModeEnum
{
    VCP_LIST_MENU_CONTROL_MODE_NORMAL,            // The normal list menu mode, means there is no built-in control in the list item
    VCP_LIST_MENU_CONTROL_MODE_CMD_BUTTON,        // The command button mode of list menu, there is a command button in the end of the list item
    VCP_LIST_MENU_CONTROL_MODE_DISCLOSURE,        // The disclosure mode of list menu, there is a disclosure image in the end of the list item

    VCP_LIST_MENU_CONTROL_MODE_MAX
};


// <group DOM_ListMenu_Macro&Enum_Enum>
// List menu CMD button state, for APP to control the state of the button
enum VcpListMenuCmdStateEnum
{
    VCP_LIST_MENU_CMD_STATE_DEFAULT,    // Default state, list menu will handle it automatically
    VCP_LIST_MENU_CMD_STATE_NORMAL,     // Normal state
    VCP_LIST_MENU_CMD_STATE_PRESSED,    // Pressed state
    VCP_LIST_MENU_CMD_STATE_DISABLED,   // Disabled state
    VCP_LIST_MENU_CMD_STATE_HIGHLIGHT,  // Highlight state

    VCP_LIST_MENU_CMD_STATE_END_OF_ENUM
};


// <group DOM_ListMenu_Macro&Enum_Enum>
// List menu text color style enums, the real color value is from theme
enum VcpListMenuTextColorEnum
{
    VCP_LIST_MENU_TEXT_COLOR_NORMAL,    // The normal text color
    VCP_LIST_MENU_TEXT_COLOR_HIGHLIGHT, // The highlight text color
    VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT,  // The lowlight text color
    VCP_LIST_MENU_TEXT_COLOR_DISABLED   // The disabled text color
};

// <group DOM_ListMenu_Macro&Enum_Enum>
// List menu control types
enum VcpListMenuCellControlTypeEnum
{
    VCP_LIST_MENU_CELL_CONTROL_TYPE_NONE,           // None
    VCP_LIST_MENU_CELL_CONTROL_TYPE_REORDER_THUMB,  // Reorder control
    VCP_LIST_MENU_CELL_CONTROL_TYPE_CMD_BUTTON,     // Command button control
    VCP_LIST_MENU_CELL_CONTROL_TYPE_CHECK_BOX,      // Check box control
    VCP_LIST_MENU_CELL_CONTROL_TYPE_RADIO_BUTTON,   // Radio button control
    VCP_LIST_MENU_CELL_CONTROL_TYPE_CHECK_MARK,     // Chect mar control
    VCP_LIST_MENU_CELL_CONTROL_TYPE_DISCLOSURE,     // Disclosure control
    VCP_LIST_MENU_CELL_CONTROL_TYPE_CUSTOM          // Custom control
};

// <group DOM_ListMenu_Macro&Enum_Enum>
// List menu control location type
enum VcpListMenuCellControlLocationTypeEnum
{
    VCP_LIST_MENU_CELL_CONTROL_LOCATION_TYPE_HEAD,  // Head control
    VCP_LIST_MENU_CELL_CONTROL_LOCATION_TYPE_TAIL   // Tail control
};


// <group DOM_ListMenu_Macro&Enum_Enum>
// List menu margin area type enums, the margin area frame is attached by application, it can scroll with list menu cells
enum VcpListMenuMarginAreaEnum 
{
    VCP_LIST_MENU_MARGIN_AREA_TOP,   // Top margin area, means the margin area frame is in the top of the other list menu items
    VCP_LIST_MENU_MARGIN_AREA_BOTTOM, // Bottom margin area, means the margin area frame is in the button of the other list menu items
    VCP_LIST_MENU_MARGIN_AREA_END
};

// <group DOM_ListMenu_Macro&Enum_Enum>
// List menu margin area frame placement type enums
enum VcpListMenuMarginAreaFramePlacementEnum 
{
    VCP_LIST_MENU_MARGIN_AREA_FRAME_PLACEMENT_LEFT,     // Place the frmae at left
    VCP_LIST_MENU_MARGIN_AREA_FRAME_PLACEMENT_CENTER,   // Plcae the frame at center
    VCP_LIST_MENU_MARGIN_AREA_FRAME_PLACEMENT_RIGHT,     // Plcae the frame at right                                              
	VCP_LIST_MENU_MARGIN_AREA_FRAME_PLACEMENT_FULL,
	VCP_LIST_MENU_MARGIN_AREA_FRAME_PLACEMENT_END,
};


// <group DOM_ListMenu_Struct>
// List menu theme structure
typedef struct
{
    vrt_color_type bgColor;                 // Background color
    vrt_color_type normalTextColor;         // Normal text color
    vrt_color_type highlightTextColor;      // Highlight text color
    vrt_color_type lowlightTextColor;       // Lowlight text color
    vrt_color_type disabledTextColor;       // Disabled text color
    vrt_color_type focusNormalTextColor;    // Normal text color of focus list item
    vrt_color_type focusHighlightTextColor; // Highlight text color of focus list item
    vrt_color_type focusLowlightTextColor;  // Lowlight text color of fucus list item
    vrt_color_type focusDisabledTextColor;  // Disabled text color of focus list item
    VfxResId       highlightCellBgImgId;    // Background image of highlight list item
    VfxResId       checkBoxOnImgId;         // Check box on image
    VfxResId       checkBoxOffImgId;        // Check box off image
    VfxResId       radioButtonOnImgId;      // Radio button on image
    VfxResId       radioButtonOffImgId;     // Radio button off image
    VfxResId       groupHeaderBgImgId;      // Group header background image
    VfxResId       checkMarkImgId;          // Check mark image
} VcpListMenuThemeStruct, *pVcpListMenuThemeStruct;

// <group DOM_ListMenu_Struct>
// List menu history structure
typedef struct 
{
    VcpBaseMenuViewState baseMenuHistory;   // The base menu history data
}VcpListMenuHistoryStruct, *pVcpListMenuHistoryStruct;


/***************************************************************************** 
 * Pre-declaration
 *****************************************************************************/
class VcpBaseListMenu;
class VcpListMenu;
class VcpListMenuLayout;
class VcpListMenuCell;

class VcpGroupListMenu;
class VcpGroupListMenuLayout;
class VcpListMenuSearchBar;

class IVcpGroupListMenuContentProvider;

typedef IVcpGroupListMenuContentProvider IVcpListMenuContentProviderInt;



/* VcpListMenuCellClientBaseFrame is a class of the center client region of list menu item */
class VcpListMenuCellClientBaseFrame : public VfxFrame
{
// Constructor / Destructor
public:
    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Constructor/Destructor>
    VcpListMenuCellClientBaseFrame(){}

// Method
public:
    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Method>
    // Update the client frame, including getting latest data from content provider and re-layout them
    void update(
        VfxBool isAnim  // [IN] If enable animation while updating
        ); 

    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Method>
    // Re-layout the elements (texts, images...) in the client frame
    void layout(
        VfxBool isAnim  // [IN] If enable animation while layout
        );

// Property
public:
    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Property>
    // The style of this client frame, it's same with the list menu cell style
    VcpListMenuCellStyleEnum m_style;

// Overridable
public:
    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Overridable>
    // Create the elements (text, images...) in the client frame, sub-class should override this virtual function to create its own elements
    virtual void onCreateElements() = 0;

    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Overridable>
    // Close the elements (text, images...) in the client frame, sub-class should override this virtual function to close its own elements
    virtual void onCloseElements() = 0;

    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Overridable>
    // Layout the elements (text, images...) in the client frame
    virtual void onLayoutElements() = 0;

    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Overridable>
    // Get the latest data of the elements (text, images...) from content provider 
    virtual void onUpdateElements() = 0;

    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Overridable>
    // used for VCP_LIST_MENU_FOCUS_BEHAVIOR_EMPHASIS
    virtual void onUpdateEmphasisFocus(
        VfxBool isFocus // [IN] whether the cell is focus
        ) {}

    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Overridable>
    // Update the text frame styles
    virtual void onUpdateTextFrameStyle(
        VcpListMenuFieldEnum fieldType, // [IN] The field type
        VfxTextFrame *frame             // [IN] The pointer to the text frame
        ){}

    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Overridable>
    // Update the text view styles
    virtual void onUpdateTextViewStyle(
        VcpListMenuFieldEnum fieldType, // [IN] The field type
        VcpTextView *frame              // [IN] The pointer to the text view
        ){}

    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Overridable>
    // Get the text of the text element in this client frame, returning VFX_FALSE means can't get the text
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getText(
        VcpListMenuFieldEnum fieldType, // [IN] The field type
        VfxWString &text                // [OUT] The text to be gotten
        ) 
        { 
            return VFX_FALSE;
        }

// Override
protected:
    virtual void onInit();
    virtual void onDeinit();

// Method
protected:
    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Method>
    // Get the corresponding cell, used by sub-class
    // RETURNS: instance of VcpListMenuCell
    VcpListMenuCell *getCell();

    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Method>
    // Get the corresponding menu, used by sub-class
    // RETURNS: instance of VcpBaseListMenu
    VcpBaseListMenu *getMenu();

    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Method>
    // Get the corresponding content provider, used by sub-class
    // RETURNS: instance of IVcpListMenuContentProviderInt
    IVcpListMenuContentProviderInt *getContentProvider();

    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Method>
    // Internal method to create the text frame according to if there is specified text format, if has, we should use VcpTextView to replace VfxTextFrame
    // RETURNS: instance of VfxFrame
    VfxFrame *createItemTextFrameInt(
        VcpListMenuFieldEnum fieldType  // [IN] the type of the field in the cell
        );

    void updateTextColorInt(VfxFrame* target,VcpListMenuFieldEnum fieldType);  

    void createItemTextFrameHelper(
        VfxFrame *& textFrame,
        VcpListMenuFieldEnum fieldType  // [IN] the type of the field in the cell
        );

    void resetImageContentHelper(
            VfxImageFrame *& imageFrame,
            VcpListMenuFieldEnum fieldType);

    void closeElementHelper(
            VfxImageFrame * imageFrame,
            VcpListMenuFieldEnum fieldType);

    // <group DOM_ListMenu_VcpListMenuCellClientBaseFrame_Method>
    // Get the text in the text frame
    // RETURNS: VFX_TRUE or VFX_FALSE
    VfxBool getTextInt(
        VfxFrame *textFrame,    // [IN] The pointer to text frame or text view object
        VfxWString &text        // [OUT] The text to get
        );

    void setTextRect(VfxFrame *txt, VfxRect rect);
// Implementation
private:
    void onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds);
};




/* VcpListMenuCellBaseControl is a base class of the list menu item build-in controls */
class VcpListMenuCellBaseControl : public VfxControl
{
// Constructor / Destructor
public:
    // <group DOM_ListMenu_VcpListMenuCellBaseControl_Constructor/Destructor>
    VcpListMenuCellBaseControl(){m_type = VCP_LIST_MENU_CELL_CONTROL_TYPE_NONE;}

// Property
public:
    // <group DOM_ListMenu_VcpListMenuCellBaseControl_Property>
    // The control type
    VcpListMenuCellControlTypeEnum m_type;

// Method
public:
    // <group DOM_ListMenu_VcpListMenuCellBaseControl_Method>
    // Update the control status, if the control need to get latest state
    // from application, it would use the content provider to get
    virtual void update(
        VfxBool isAnim  // [IN] If enable animation while updating
        ) {};

    // <group DOM_ListMenu_VcpListMenuCellBaseControl_Method>
    // Set the control highlight state when the highlight state of cell is changed
    virtual void setHighlight(
        VfxBool isHighlight // [IN] If enable animation while updating
        ) {};

// Override
protected:
    virtual void onInit();

// Overridable
protected:
    // <group DOM_ListMenu_VcpListMenuCellBaseControl_Overridable>
    // The slot of the bounds change event of this control, we will re-layout the position of the control here
    virtual void onBoundsValueChanged(
        VfxFrame *source,           // [IN] frame to resize
        const VfxRect &oldBounds    // [IN] old bounds
        ){}

// Method
protected:
    // <group DOM_ListMenu_VcpListMenuCellBaseControl_Method>
    // Get the corresponding cell, used by sub-class
    // RETURNS: instance of VcpListMenuCell
    VcpListMenuCell *getCell();

    // <group DOM_ListMenu_VcpListMenuCellBaseControl_Method>
    // Get the corresponding menu, used by sub-class
    // RETURNS: instance of VcpBaseListMenu
    VcpBaseListMenu *getMenu();
    
    // <group DOM_ListMenu_VcpListMenuCellBaseControl_Method>
    // Get the corresponding content provider, used by sub-class
    // RETURNS: instance of IVcpListMenuContentProviderInt
    IVcpListMenuContentProviderInt *getContentProvider();
};


/*
 *  IVcpGroupListMenuContentProvider is a interface which provides the data 
 *  for VcpGroupListMenu. The virtual functions should be
 *  implemented to provide the list menu cell content. Otherwise the list 
 *  menu can not work. Becasue this class is a interface, the user 
 *  should inherit it as follow form.
 *  EXAMPLE
 * <code>
 *  class GroupListMenuData : public VfxObject, public IVcpGroupListMenuContentProvider
 *  {}
 * </code>
 *  VfxObject can be replaced as any non-interface class.
 */
class IVcpGroupListMenuContentProvider
{
// Overridable
public:
    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Set the list menu pointer to content provider
    virtual void setMenu(VcpGroupListMenu *menu) {}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the text resource for the text fields of list cell
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemText(
        VcpMenuPos pos,                 // [IN] the position of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VfxWString &text,               // [OUT] the text resource
        VcpListMenuTextColorEnum &color // [OUT] the text color
        ) {return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the text format for the text fields of list cell, if app doesn't provide a special format, list menu will the text as simple string
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemTextFormat(
        VcpMenuPos pos,                 // [IN] the position of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VcpRichText &format             // [OUT] the text resource
        ) {return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the text frame format for the text fields of list cell, and user can update the text frame font, text color, etc.
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemTextFrameFormat(
        VcpMenuPos pos,                 // [IN] the position of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VfxTextFrame *frame             // [OUT] the text frame
        ) {return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the image resource for the image fields of list cell
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemImage(
        VcpMenuPos pos,                 // [IN] the position of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VfxImageSrc &image              // [OUT] the image resource
        ) {return VFX_FALSE;}
    
    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the empty text resource for the text when list menu is empty
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getMenuEmptyText(
        VfxWString &text,               // [OUT] the text resource
        VcpListMenuTextColorEnum &color // [OUT] the text color
        ) {return VFX_FALSE;}
    
    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Free the image resource for the image fields of list cell
    virtual void closeItemImage(
        VcpMenuPos pos,                 // [IN] the position of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VfxImageSrc Image               // [IN] the image resource
        ) {}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the item count of specified group
    // RETURNS: VfxU32
    virtual VfxU32 getCount(VfxU32 group) const {return 0;}



    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get if the item is disabled
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemIsDisabled(
        VcpMenuPos pos  // [IN] position of the item
        ) const {return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get if the item is highlight-able
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemIsHighlightable(
        VcpMenuPos pos  // [IN] position of the item
        ) const {return VFX_TRUE;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the group count of the group list menu
    // RETURNS: VfxU32
    virtual VfxU32 getGroupCount() const {return 0;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get if the specified group header is valid
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool hasGroupHeader(
        VfxS32 group    // [IN] position of the item
        ) const {return VFX_TRUE;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the state of a list item
    // RETURNS: VcpListMenuItemStateEnum
    virtual VcpListMenuItemStateEnum getItemState(
        VcpMenuPos pos   // [IN] position of the item
        ) const {return VCP_LIST_MENU_ITEM_STATE_NONE;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get if the state is valid for a list item
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemStateValidation(
        VcpMenuPos pos,                 // [IN] the position of item
        VcpListMenuItemStateEnum state  // [IN] the state to be checked
        ) const {return VFX_TRUE;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the state of a CMD button
    // RETURNS: VcpListMenuCmdStateEnum
    virtual VcpListMenuCmdStateEnum getItemCmdState(
        VcpMenuPos pos  // [IN] the position of item
        ) const {return VCP_LIST_MENU_CMD_STATE_DEFAULT;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the content frame of the item, it's used when the cell style is VCP_LIST_MENU_CELL_STYLE_CUSTOM, uer should create and layout its owned cell content frame and return it here
    // RETURNS: instance of VcpListMenuCellClientBaseFrame
    virtual VcpListMenuCellClientBaseFrame *getItemCustomContentFrame(
        VcpMenuPos pos,         // [IN] position of the item
        VfxFrame *parentFrame   // [IN] parent frame of the custom content frame
        ) {return NULL;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Uer should release the resource of the content frame which is created by itself, such as image resource
    virtual void closeItemCustomContentFrame(
        VcpMenuPos pos,                         // [IN] position of the item
        VcpListMenuCellClientBaseFrame *cell    // [IN] the content frame to be released
        ){VFX_OBJ_CLOSE(cell);}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get custom control of the item, it's used when the menu control mode is VCP_LIST_MENU_CONTROL_MODE_CUSTOM, uer should create and return it here
    // RETURNS: instance of VcpListMenuCellBaseControl
    virtual VcpListMenuCellBaseControl *getItemCustomControl(
        VcpMenuPos pos,                                     // [IN] position of the item
        VcpListMenuCellControlLocationTypeEnum location,    // [IN] Control location
        VfxFrame *parentFrame                               // [IN] parent frame of the custom content frame
        ) {return NULL;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Uer should release the resource of the custom control which is created by itself, such as image resource
    virtual void closeItemCustomControl(
        VcpMenuPos pos,                                     // [IN] position of the item
        VcpListMenuCellControlLocationTypeEnum location,    // [IN] Control location
        VcpListMenuCellBaseControl *cellControl             // [IN] the content frame to be released
        ){VFX_OBJ_CLOSE(cellControl);}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Swap two items, user should update its internal data of the two items
    virtual VfxBool swapItem(VcpMenuPos pos1, VcpMenuPos pos2)
    {
        return VFX_FALSE;
    }

#if defined(__MMI_VUI_COSMOS_CP__)
    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the count of seek bar entries
    // RETURNS: VfxU32
    virtual VfxU32 getSeekBarEntryCount(){return 0;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the text of the seek bar entry
    // RETURNS: VFX_TRUE or VFX_TRUE
    virtual VfxBool getSeekBarEntryText(
        VfxU32 index,       // [IN] index of the seek bar entry
        VfxWString &text    // [OUT] the text of the seek bar entry
        ){return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpGroupListMenuContentProvider_Overridable>
    // Get the position of the list item need jump to according to the seek bar entry index which is touched
    // RETURNS: VFX_TRUE or VFX_TRUE
    virtual VfxBool getItemPosNeedJumpTo(
        VfxU32 touchedSeekBarEntryIndex,    // [IN] the index of the touched seek bar entry
        VcpMenuPos &posJumpTo               // [OUT] the list menu position need jump to
        ) {return VFX_FALSE;}
#endif /* #if defined(__MMI_VUI_COSMOS_CP__) */
	

};


/*
 *  IVcpListMenuContentProvider is a interface which provides the data 
 *  for VcpListMenu. The virtual functions should be
 *  implemented to provide the list menu cell content. Otherwise the list 
 *  menu can not work. Becasue this class is a interface, the user 
 *  should inherit it as follow form.
 *  EXAMPLE
 * <code>
 *  class ListMenuData : public VfxObject, public IVcpListMenuContentProvider
 *  {}
 * </code>
 *  VfxObject can be replaced as any non-interface class.
 */
class IVcpListMenuContentProvider : public IVcpGroupListMenuContentProvider
{
// Overridable
public:
    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Set the list menu pointer to content provider
    virtual void setMenu(VcpListMenu *menu) {}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the text resource for the text fields of list cell
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemText(
        VfxU32 index,                   // [IN] the index of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VfxWString &text,               // [OUT] the text resource
        VcpListMenuTextColorEnum &color // [OUT] the text color
        ) {return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the text format for the text fields of list cell, and if app doesn't provide a special format, list menu will the text as simple string
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemTextFormat(
        VfxU32 index,                   // [IN] the index of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VcpRichText &format             // [OUT] the text resource
        ) {return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the text frame format for the text fields of list cell, and user can update the text frame font, text color, etc.
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemTextFrameFormat(
        VfxU32 index,                   // [IN] the index of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VfxTextFrame *frame             // [OUT] the text frame
        ) {return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the image resource for the image fields of list cell
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemImage(
        VfxU32 index,                   // [IN] the index of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VfxImageSrc &image              // [OUT] the image resource
        ) {return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Free the image resource for the image fields of list cell
    virtual void closeItemImage(
        VfxU32 index,                   // [IN] the index of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VfxImageSrc Image               // [IN] the image resource
        ) {}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the item count of the list menu
    // RETURNS: VfxU32
    virtual VfxU32 getCount() const {return 0;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get if the item is disabled
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemIsDisabled(
        VfxU32 index    // [IN] the index of item
        ) const {return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get if the item is highlight-able
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemIsHighlightable(
        VfxU32 index    // [IN] the index of item
        ) const {return VFX_TRUE;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the state of a list item
    // RETURNS: VcpListMenuItemStateEnum
    virtual VcpListMenuItemStateEnum getItemState(
        VfxU32 index    // [IN] index of the item
        ) const {return VCP_LIST_MENU_ITEM_STATE_NONE;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get if the state is valid for a list item
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemStateValidation(
        VfxU32 index,                   // [IN] index of the item
        VcpListMenuItemStateEnum state  // [IN] the state to be checked
        ) const {return VFX_TRUE;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the state of a CMD button
    // RETURNS: VcpListMenuCmdStateEnum
    virtual VcpListMenuCmdStateEnum getItemCmdState(
        VfxU32 index    // [IN] index of the item
        ) const {return VCP_LIST_MENU_CMD_STATE_DEFAULT;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Swap two items, user should update its internal data of the two items
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool swapItem(
        VfxU32 index1,  // [IN] index of the first item
        VfxU32 index2   // [IN] index of the second item
        ) {return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the content frame of the item, it's used when the cell style is VCP_LIST_MENU_CELL_STYLE_CUSTOM, uer should create and layout its owned cell content frame and return it here
    // RETURNS: instance of VcpListMenuCellClientBaseFrame
    virtual VcpListMenuCellClientBaseFrame *getItemCustomContentFrame(
        VfxU32 index,           // [IN] index of the item
        VfxFrame *parentFrame   // [IN] parent frame of the custom content frame
        ) {return NULL;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Uer should release the resource of the content frame which is created by itself, such as image resource
    virtual void closeItemCustomContentFrame(
        VfxU32 index,                           // [IN] index of the item
        VcpListMenuCellClientBaseFrame *cell    // [IN] the content frame to be released
        ){VFX_OBJ_CLOSE(cell);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get custom control of the item, it's used when the menu control mode is VCP_LIST_MENU_CONTROL_MODE_CUSTOM, uer should create and return it here
    // RETURNS: instance of VcpListMenuCellBaseControl
    virtual VcpListMenuCellBaseControl *getItemCustomControl(
        VfxU32 index,                                       // [IN] index of the item
        VcpListMenuCellControlLocationTypeEnum location,    // [IN] Control location
        VfxFrame *parentFrame                               // [IN] parent frame of the custom content frame
        ) {return NULL;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Uer should release the resource of the custom control which is created by itself, such as image resource
    virtual void closeItemCustomControl(
        VfxU32 index,                                       // [IN] index of the item
        VcpListMenuCellControlLocationTypeEnum location,    // [IN] Control location
        VcpListMenuCellBaseControl *cellControl             // [IN] the content frame to be released
        ){VFX_OBJ_CLOSE(cellControl);}

#if defined(__MMI_VUI_COSMOS_CP__)
    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the index of the list item need jump to according to the seek bar entry index which is touched
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemIndexNeedJumpTo(
        VfxU32 touchedSeekBarEntryIndex,    // [IN] the index of the touched seek bar entry
        VfxU32 &indexJumpTo                 // [OUT] the list menu index need jump to
        ){return VFX_FALSE;}
#endif /* #if defined(__MMI_VUI_COSMOS_CP__) */

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Set the list menu pointer to content provider
    virtual void setMenu(VcpGroupListMenu *menu) {}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the text resource for the text fields of list cell
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemText(
        VcpMenuPos pos,                 // [IN] the position of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VfxWString &text,               // [OUT] the text resource
        VcpListMenuTextColorEnum &color // [OUT] the text color
        ) {return getItemText(pos.pos, fieldType, text, color);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the text format for the text fields of list cell, if app doesn't provide a special format, list menu will the text as simple string
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemTextFormat(
        VcpMenuPos pos,                 // [IN] the position of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VcpRichText &format             // [OUT] the text resource
        ) {return getItemTextFormat(pos.pos, fieldType, format);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the text frame format for the text fields of list cell, and user can update the text frame font, text color, etc.
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemTextFrameFormat(
        VcpMenuPos pos,                 // [IN] the position of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VfxTextFrame *frame             // [OUT] the text frame
        ) {return getItemTextFrameFormat(pos.pos, fieldType, frame);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the image resource for the image fields of list cell
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemImage(
        VcpMenuPos pos,                 // [IN] the position of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VfxImageSrc &image              // [OUT] the image resource
        ) {return  getItemImage(pos.pos, fieldType, image);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Free the image resource for the image fields of list cell
    virtual void closeItemImage(
        VcpMenuPos pos,                 // [IN] the position of item
        VcpListMenuFieldEnum fieldType, // [IN] the type of the field in the cell
        VfxImageSrc Image               // [IN] the image resource
        ) {closeItemImage(pos.pos, fieldType, Image);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the empty text resource for the text when list menu is empty
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getMenuEmptyText(
        VfxWString &text,               // [OUT] the text resource
        VcpListMenuTextColorEnum &color // [OUT] the text color
        ) {return VFX_FALSE;}
    
    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the item count of specified group
    // RETURNS: VfxU32
    virtual VfxU32 getCount(VfxU32 group) const {return getCount();}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get if the item is disabled
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemIsDisabled(
        VcpMenuPos pos  // [IN] position of the item
        ) const {return getItemIsDisabled(pos.pos);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get if the item is highlight-able
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemIsHighlightable(
        VcpMenuPos pos  // [IN] position of the item
        ) const {return getItemIsHighlightable(pos.pos);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the group count of the group list menu
    // RETURNS: VfxU32
    virtual VfxU32 getGroupCount() const {return 0;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get if the specified group header is valid
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool hasGroupHeader(
        VfxS32 group    // [IN] position of the item
        ) const {return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the state of a list item
    // RETURNS: VcpListMenuItemStateEnum
    virtual VcpListMenuItemStateEnum getItemState(
        VcpMenuPos pos   // [IN] position of the item
        ) const {return getItemState(pos.pos);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get if the state is valid for a list item
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool getItemStateValidation(
        VcpMenuPos pos,                 // [IN] the position of item
        VcpListMenuItemStateEnum state  // [IN] the state to be checked
        ) const {return getItemStateValidation(pos.pos, state);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the state of a CMD button
    // RETURNS: VcpListMenuCmdStateEnum
    virtual VcpListMenuCmdStateEnum getItemCmdState(
        VcpMenuPos pos  // [IN] the position of item
        ) const {return getItemCmdState(pos.pos);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the content frame of the item, it's used when the cell style is VCP_LIST_MENU_CELL_STYLE_CUSTOM, uer should create and layout its owned cell content frame and return it here
    // RETURNS: instance of VcpListMenuCellClientBaseFrame
    virtual VcpListMenuCellClientBaseFrame *getItemCustomContentFrame(
        VcpMenuPos pos,         // [IN] position of the item
        VfxFrame *parentFrame   // [IN] parent frame of the custom content frame
        ) {return getItemCustomContentFrame(pos.pos, parentFrame);}


    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get custom control of the item, it's used when the menu control mode is VCP_LIST_MENU_CONTROL_MODE_CUSTOM, uer should create and return it here
    // RETURNS: instance of VcpListMenuCellBaseControl
    virtual VcpListMenuCellBaseControl *getItemCustomControl(
        VcpMenuPos pos,                                     // [IN] position of the item
        VcpListMenuCellControlLocationTypeEnum location,    // [IN] Control location
        VfxFrame *parentFrame                               // [IN] parent frame of the custom content frame
        ) {return getItemCustomControl(pos.pos, location, parentFrame);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
	// Swap two items, user should update its internal data of the two items
	virtual VfxBool swapItem(VcpMenuPos pos1, VcpMenuPos pos2)
    {
        return swapItem(pos1.pos, pos2.pos);
    }
    
    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Uer should release the resource of the content frame which is created by itself, such as image resource
    virtual void closeItemCustomContentFrame(
        VcpMenuPos pos,                         // [IN] position of the item
        VcpListMenuCellClientBaseFrame *cell    // [IN] the content frame to be released
    ){closeItemCustomContentFrame(pos.pos, cell);}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Uer should release the resource of the custom control which is created by itself, such as image resource
    virtual void closeItemCustomControl(
        VcpMenuPos pos,                                     // [IN] position of the item
        VcpListMenuCellControlLocationTypeEnum location,    // [IN] Control location
        VcpListMenuCellBaseControl *cellControl             // [IN] the content frame to be released
    ){closeItemCustomControl(pos.pos, location, cellControl);}

    
#if defined(__MMI_VUI_COSMOS_CP__)
    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the count of seek bar entries
    // RETURNS: VfxU32
    virtual VfxU32 getSeekBarEntryCount(){return 0;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the text of the seek bar entry
    // RETURNS: VFX_TRUE or VFX_TRUE
    virtual VfxBool getSeekBarEntryText(
        VfxU32 index,       // [IN] index of the seek bar entry
        VfxWString &text    // [OUT] the text of the seek bar entry
        ){return VFX_FALSE;}

    // <group DOM_ListMenu_IVcpListMenuContentProvider_Overridable>
    // Get the position of the list item need jump to according to the seek bar entry index which is touched
    // RETURNS: VFX_TRUE or VFX_TRUE
    virtual VfxBool getItemPosNeedJumpTo(
        VfxU32 touchedSeekBarEntryIndex,    // [IN] the index of the touched seek bar entry
        VcpMenuPos &posJumpTo               // [OUT] the list menu position need jump to
        ) { VfxU32 pos = posJumpTo.pos; 
            VfxBool ret = getItemIndexNeedJumpTo(touchedSeekBarEntryIndex, pos);
            posJumpTo.group = 0;
            posJumpTo.pos = pos;
            return ret;}
#endif /* #if defined(__MMI_VUI_COSMOS_CP__) */










};



/* Vcpbase menu is a base class for VcpListMenu & VcpGroupListMenu */
class VcpBaseListMenu : public VcpBaseMenu
{
    VFX_DECLARE_CLASS(VcpBaseListMenu);  

// Constructor / Destructor
public:

    // <group DOM_ListMenu_VcpBaseListMenu_Constructor/Destructor>
    VcpBaseListMenu();

// Method
public:
    void updateAllControls();
        

    // <group DOM_ListMenu_VcpListMenu_Method>
    // Set the index of emphasis focus item
    void setEmphasisFocusItemIndex(
        VfxS32 index   // [IN] The item index
    )
    {
        m_emphasisFocusItem = VcpMenuPos(0, index);
    }

    // <group DOM_ListMenu_VcpListMenu_Method>
    // to get the index of emphasis focus item
    // RETURNS: VfxU32
    VfxS32 getEmphasisFocusItemIndex() const {return m_emphasisFocusItem.pos;}


    // <group DOM_ListMenu_VcpListMenu_Method>
    // Set the index of emphasis focus item
    void setEmphasisFocusItem(
        VcpMenuPos pos   // [IN] The item index
    )
    {
        m_emphasisFocusItem = pos;
    }

    // <group DOM_ListMenu_VcpListMenu_Method>
    // to get the index of emphasis focus item
    // RETURNS: VfxU32
    VcpMenuPos getEmphasisFocusItem() const {return m_emphasisFocusItem;}


    // <group DOM_ListMenu_VcpListMenu_Method>
    // get the emphasis focus item height
    // RETURNS: VfxU32
    VfxU32 getEmphasisFocusItemHeight() const
    {
        return m_emphasisFocusItemHeight;
    }

    // <group DOM_ListMenu_VcpListMenu_Method>
    // Set the emphasis focus item height
    void setEmphasisFocusItemHeight(
    VfxU32 height   // [IN] The item height
    )
    {
        m_emphasisFocusItemHeight = height;
    }    

    virtual VfxBool hasGroupHeader(
        VfxS32 group    // [IN] position of the item
        ) {return VFX_TRUE;}


    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Set the list menu theme structure
    virtual void setThemeData(
        VcpListMenuThemeStruct &themeData   // [IN] The theme data structure
        )
        {
            m_themeData = themeData;
        }

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Get the list menu theme structure
    // RETURNS: VcpListMenuThemeStruct
    virtual VcpListMenuThemeStruct &getThemeData() {return m_themeData;}

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Set the meun mode, user can use this API to turn on or off check box mode, reorder mode and so on, the default mode is VCP_LIST_MENU_MODE_NORMAL, if you want to turn off a mode, you can set the mode to VCP_LIST_MENU_MODE_NORMAL
    virtual void setMenuMode(
        VcpListMenuModeEnum mode,   // [IN] The menu mode to be turned on
        VfxBool isAnim = VFX_FALSE  // [IN] If the animation effect of enabling the mode is available
        );

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Set the meun mode for XML only
    void setMenuModeXML(
        VcpListMenuModeEnum mode    // [IN] The menu mode to be turned on
        )
    {
       setMenuMode(mode);
    }

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // to get the menu mode
    // RETURNS: VcpListMenuModeEnum
    virtual VcpListMenuModeEnum getMenuMode() const {return m_menuMode;}

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Set the meun control mode, user can use this API to turn on or off the quick command button and the disclosure control, the default mode is VCP_LIST_MENU_CONTROL_MODE_NORMAL, if you want to turn off a mode, you can set the mode to VCP_LIST_MENU_CONTROL_MODE_NORMAL
    virtual void setMenuControlMode(
        VcpListMenuControlModeEnum mode,    // [IN] The menu control mode to be turned on
        VfxBool isAnim = VFX_FALSE          // [IN] If the animation effect of enabling the mode is available
        );

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Set the meun control mode for XML only
    void setMenuControlModeXML(
        VcpListMenuControlModeEnum mode     // [IN] The menu control mode to be turned on
        )
    {
        setMenuControlMode(mode);
    }

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // to get the menu control mode
    // RETURNS: VcpListMenuControlModeEnum
    virtual VcpListMenuControlModeEnum getMenuControlMode() const {return m_menuControlMode;}

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Mandatory to be called after creating VcpListMenu object, to set the style of the list items
    virtual void setCellStyle(
        VcpListMenuCellStyleEnum style      // [IN] The user specified list menu cell style
        )
        {
            m_cellStyle = style;
        }
    
    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // To get the style of list items
    // RETURNS: VcpListMenuCellStyleEnum
    virtual VcpListMenuCellStyleEnum getCellStyle() const {return m_cellStyle;}

    
    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Optional, the default focus style is VCP_LIST_MENU_FOCUS_BEHAVIOR_NONE
    virtual void setFocusStyle(
        VcpListMenuFocusBehaviorEnum style  // [IN] The focus style
        )
        {
            m_focusBehavior = style;
        }
    
    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // To get the focus behavior
    // RETURNS: VcpListMenuFocusBehaviorEnum
    virtual VcpListMenuFocusBehaviorEnum getFocusStyle() const {return m_focusBehavior;}

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Update all items, user can use this method to refresh all list items if their content or state are changed
    virtual void updateAllItems(); 

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Reset all items, user can use this method to refresh all list items if it wants to initialize the whole list menu again
    virtual void resetAllItems(
        VfxBool needKeepViewState = VFX_FALSE   // [IN] If need to keep current view state (the visible range of list menu)
        ); 

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Get the history data of list menu, application would get history before closing list menu
    virtual void getHistory(
        pVcpListMenuHistoryStruct history   // [OUT] The list menu history
        )
        {
            getViewState(&(history->baseMenuHistory));
        }

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Set the history data of list menu, after creating list menu, application would set history in the end of the setting of list menu 
    virtual void setHistory(
        pVcpListMenuHistoryStruct history   // [IN] The list menu history
        )
        {
            setViewState(&(history->baseMenuHistory));
        }

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Add a margin area frame, the margin area frame can be any frame created by application, the frame will scroll with the cells of list menu
    virtual void addMarginAreaFrame(
        VcpListMenuMarginAreaEnum area,                     // [IN] The margin area type
        VcpListMenuMarginAreaFramePlacementEnum placement,  // [IN] The frame placement
        VfxFrame *frame                                     // [IN] The frame to be added
    );

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Delete a magin area frame which is added before
    virtual void removeMarginAreaFrame(
        VfxFrame *frame // [IN] The frame to be removed
        );

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Enable search Bar
    // RETURNS: instance of VcpListMenuSearchBar
    VcpListMenuSearchBar *enableSearchBar(
        VfxBool isAnim = VFX_FALSE  // [IN] enable search bar with animation or not
        );

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Disable search Bar
    void disableSearchBar(
        VfxBool isAnim = VFX_FALSE  // [IN] disable search bar with animation or not
        );

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Get the pointer to the search Bar
    // RETURNS: instance of VcpListMenuSearchBar
    VcpListMenuSearchBar *getSearchBar() {return m_searchBar;}

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Get if the search bar enabled
    // RETURNS: VFX_TRUE or VFX_FALSE
    VfxBool isSearchBarEnabled();

#if defined(__MMI_VUI_COSMOS_CP__)
    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Disable shadow
    void setShadowIsDisabled(
        VfxBool isDisabled  // [IN] disable shadow or not
        )
        {
            m_isShadowDisabled = isDisabled;
        }

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Get whether shadow is disabled
    // RETURNS: VFX_TRUE or VFX_FALSE
    VfxBool getShadowIsDisabled()
    {
        return m_isShadowDisabled;
    }

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Enable menu seek bar
    void enableSeekBar(
        VfxBool isAnim = VFX_FALSE  // [IN] enable seek bar with animation or not
        );

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Disable menu seek bar, the seek bar component will be closed
    void disableSeekBar(
        VfxBool isAnim = VFX_FALSE  // [IN] disable seek bar with animation or not
        );

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Hide seek bar, the seek bar component is not closed
    void setSeekBarHidden(
        VfxBool isHidden,           // [IN] hide / unhide seek bar
        VfxBool isAnim = VFX_FALSE  // [IN] hide / unhide seek bar with animation or not
        );

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Update seek bar, list menu will refetch the seek bar data from content provider then update to seek bar
    void updateSeekBar();

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Get if the seek bar enabled
    // RETURNS: VFX_TRUE or VFX_FALSE
    VfxBool isSeekBarEnabled();
#endif /* #if defined(__MMI_VUI_COSMOS_CP__) */

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Set if the separators of list menu item are hidden
    void setItemSeparatorHidden(
        VfxBool isHidden    // [IN] display separator or not
        );

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Get if the separators of list menu item are hidden
    // RETURNS: VFX_TRUE or VFX_FALSE
    VfxBool getItemSeparatorHidden();

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Set if the highlight of list menu item are hidden
    void setItemHighlightHidden(VfxBool isHidden);

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Get if the highlight of list menu item are hidden
    // RETURNS: VFX_TRUE or VFX_FALSE
    VfxBool getItemHighlightHidden();

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Set whether check getItemIsDisabled in onTouchCell
    void setIsNoDisableCheckForTouch(
        VfxBool isDisabled  // [IN] if true, do not check getItemIsDisabled in onTouchCell for non-disabled cell
    )
    {
        m_isNoDisableCheckForTouch = isDisabled;
    }

    // <group DOM_ListMenu_VcpBaseListMenu_Method>
    // Get whether check getItemIsDisabled in onTouchCell
    // RETURNS: VFX_TRUE or VFX_FALSE
    VfxBool getIsNoDisableCheckForTouch(void)
    {
        return m_isNoDisableCheckForTouch;
    }

// Override
public:
    virtual void setBgColor(const VfxColor &value);
    virtual void setImgContent(const VfxImageSrc &value);
    virtual void setBounds(const VfxRect &value);
    
// Event
public:
    // <group DOM_ListMenu_VcpBaseListMenu_Event>
    // This signal is invoked when view scroll end
    // void YourClass::onViewScrollEnd(VcpBaseListMenu *sender)
    VfxSignal1 <
        VcpBaseListMenu *   // [IN] instance of the list menu
    > m_signalViewScrollEnd;

    // <group DOM_ListMenu_VcpBaseListMenu_Event>
    // This signal is invoked when view scroll end
    // void YourClass::onViewScrollStart(VcpBaseListMenu *sender)
    VfxSignal1 <
        VcpBaseListMenu *   // [IN] instance of the list menu
    > m_signalViewScrollStart;
    
// Override
protected:
    virtual void onInit();
    virtual void onDeinit();
    void onAddChild(VfxObject *child);  
	virtual void onObjectNotify(VfxId id, void *userData);
    virtual VfxBool onSerialize(VfxArchive &ar);
    virtual void onRestore(VfxArchive &ar);
    virtual void onViewScrollStart();
    virtual void onViewScrollEnd();
    virtual void onAfterCreateLayout();
    virtual void onUpdate();
    virtual VfxFrame* createCell(VfxS32 group, VfxS32 pos);
    virtual void onCloseCell(VfxS32 group, VfxS32 pos, VfxFrame* cellFrame);
    virtual void onUpdateCell(const VfxRect &rect, VfxS32 group, VfxS32 pos, VfxFrame* cell, VfxU32 flag);
    virtual void onFocusIndexChange(VcpMenuPos focusItem, VcpMenuPos previousFocusItem);
    virtual VfxBool IsSupportTransition() {return VFX_FALSE;}
    virtual void onDrag(VfxS32 xoffset, VfxS32 yoffset);
    virtual void onDragStart();
    virtual void onDragEnd();

// Event
protected:
    // Internal used command button clicked signal
    VfxSignal1<VcpMenuPos> m_signalCmdButtonClickedInt;

    // Internal used item selection changed signal
    VfxSignal2 <VcpMenuPos, VcpListMenuItemStateEnum> m_signalItemSelectionStateChangedInt;

    // Internal used focus changed signal
    VfxSignal2 <VcpMenuPos, VcpMenuPos> m_signalFocusChangedInt;

    // Internal used item tapped signal
    VfxSignal1 <VcpMenuPos> m_signalItemTappedInt;

    // Internal used item selected signal
    VfxSignal1 <VcpMenuPos> m_signalItemSelectedInt;

// Implementation
protected:
    // The sub-class need to override this function to provide the pointer of the content provider
    virtual IVcpListMenuContentProviderInt *getContentProviderInt() = 0;

    virtual void startDragCell(VcpMenuPos pos, VfxFrame* dragCell) {}
    virtual void endDragCell(VcpMenuPos pos, VfxFrame* dragCell) {}

    virtual void updateFocus();
    void onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds);

    void updateEmptyText();

    #if defined(__MMI_VUI_COSMOS_CP__)
    void onSeekBarTouched(VfxId id);
    #endif
    
// Variable
protected:
    enum
    {
#if defined(__MMI_MAINLCD_480X800__)
        HEADER_GAP = 2,
#else
        HEADER_GAP = 1,
#endif
#if defined(__MMI_MAINLCD_320X480__)
        MENU_SEEK_BAR_GAP = 8
#elif defined(__MMI_MAINLCD_480X800__)
        MENU_SEEK_BAR_GAP = 14
#else
        MENU_SEEK_BAR_GAP = 5
#endif
    };

    // The theme data of list menu
    VcpListMenuThemeStruct m_themeData;

    // The focus behavior of the list menu
    VcpListMenuFocusBehaviorEnum m_focusBehavior; 

    // The cell style of the list menu
    VcpListMenuCellStyleEnum m_cellStyle; 

    // The menu mode
    VcpListMenuModeEnum m_menuMode; 

    // The menu control mode
    VcpListMenuControlModeEnum m_menuControlMode; 
 

    // The pointer to the search bar of list menu
    VcpListMenuSearchBar *m_searchBar;

    // The background color the the items
    VfxColor m_cellbgColor; 

    // The height of the focused item
    VfxU32 m_emphasisFocusItemHeight;

    
    // The index of the emphasis focused item
    VcpMenuPos m_emphasisFocusItem;
    
#if defined(__MMI_VUI_COSMOS_CP__)
    // The pointer to the seek bar of list menu
    VcpMenuSeekBar *m_seekBar;

    // If the shadow is disabled
    VfxBool m_isShadowDisabled;
#endif

    // If the item separaters are hidden
    VfxBool m_isItemSeparaterHidden;

    // If the item highlight is hidden
    VfxBool m_isItemHighlightHidden;

    // If it's dragging cell
    VfxBool m_isDraggingCell;

    // The text shown in the center of list menu when there is no items
    VfxTextFrame *m_emptyText;

    // If the dragging is stopped
    VfxBool m_isScrollStopped;

    // If in reset
    VfxBool m_isInReset;

    // whether to check getItemIsDisabled in onTouchCell
    VfxBool m_isNoDisableCheckForTouch;

    friend class VcpMenuCache;
    friend class VcpMenuRegionIter;
    friend class VcpBaseListMenuLayout;
    friend class VcpGroupListMenuHeader;
    friend class VcpListMenuCell;
    friend class VcpListMenuCellClientBaseFrame;
    friend class VcpListMenuCellBaseControl;
    friend class VcpListMenuCmdButton;
    friend class VcpListMenuSelectable;
    friend class VcpListMenuRadioButton;
    friend class VcpListMenuCheckBox;
    friend class VcpListMenuCheckMark;
    friend class VcpListMenuSearchBar;
};


/***************************************************************************** 
 * Class VcpBaseListMenuLayout
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/*
 *  VcpBaseListMenuLayout is a base class of list menu layouts
 */
class VcpBaseListMenuLayout : public VcpBaseMenuLayout
{
    VFX_DECLARE_CLASS(VcpBaseListMenuLayout);  
    
// Constructor / Destructor
public:
    VcpBaseListMenuLayout(VcpBaseMenu* menu);

// Method
public:
    VfxBool getNextEnabledPos(VcpMenuPos &pos);
    VfxBool getPrevEnabledPos(VcpMenuPos &pos);

// Override
public:
    void setCellHeight(VfxS32 height) { m_cellHeight = height; }
    VfxS32 getCellHeight(void) const { return m_cellHeight; }
    
    void setHeaderHeight(VfxS32 height) { m_headerHeight = height; }
    VfxS32 getHeaderHeight(void) const { return m_headerHeight; }
    

    virtual ScrollDirEnum getScrollDir() { return SCROLLDIR_VERT; }
    virtual VcpMenuRegion queryRegion(const VfxRect& r);
    virtual VcpMenuPos queryPosByPt(const VfxPoint& pt) = 0;       
    virtual VfxBool navDir(NavDirEnum dir);
    virtual VfxBool hasGroupHeader(VfxS32 group);    
    virtual VfxS32 getContentLength();
    virtual VfxRect queryCellRect(VcpMenuPos pos);
    virtual VfxRect queryGroupHeaderRect(VfxS32 group);


    virtual VfxRect queryMarginItemRect(VcpMenuPos pos);
    
// Implementation
protected:
    virtual void onInit();

    VcpBaseListMenu *getBaseListMenu() { return (VcpBaseListMenu *)m_pMenu;}

    VfxS32 getFirstHeaderTopMargin();

    VfxS32 m_cellHeight;
    VfxS32 m_headerHeight;
    
};
/* DOM-NOT_FOR_SDK-END */


/*
 *  VcpListMenu is a class that can create a list menu, which provides
 *  various menu cell templates and various list mode
 */
class VcpListMenu : public VcpBaseListMenu
{
    VFX_DECLARE_CLASS(VcpListMenu);

// Constructor / Destructor
public:
    // <group DOM_ListMenu_VcpListMenu_Constructor/Destructor>
    VcpListMenu();

// Method
public:

    // <group DOM_ListMenu_VcpListMenu_Method>
    // Mandatory to be called after creating VcpListMenu object, VcpListMenu use the methods of the provider to get resource of every cell
    void setContentProvider(
        IVcpListMenuContentProvider *contentProvider    // [IN] The content provider object created by user
        );

    // <group DOM_ListMenu_VcpListMenu_Method>
    // to get the content provider pointer
    // RETURNS: instance of IVcpListMenuContentProvider
    IVcpListMenuContentProvider *getContentProvider() {return m_contentProvider;}

    // <group DOM_ListMenu_VcpListMenu_Method>
    // Optional, the defualt item state is VCP_LIST_MENU_ITEM_STATE_NONE the initial state of the item is queried by getItemState() of IVcpListMenuContentProvider, this API is called when user want to change the item state after the item is created
    void setItemState(
        VfxU32 index,                   // [IN] The index of the item
        VcpListMenuItemStateEnum state  // [IN] The state of the item
        );

    // <group DOM_ListMenu_VcpListMenu_Method>
    // Get the state if a list menu item
    // RETURNS: VcpListMenuItemStateEnum
    VcpListMenuItemStateEnum getItemState(
        VfxU32 index    // [IN] The index of the item
        ) const;

    // <group DOM_ListMenu_VcpListMenu_Method>
    // to get the index of focus item
    // RETURNS: VfxU32
    VfxU32 getFocusItemIndex() const {return m_focusItem.pos;}

    

    // <group DOM_ListMenu_VcpListMenu_Method>
    // Get the item height by index
    // RETURNS: VfxUew
    VfxU32 getItemHeight(
        VfxU32 index    // [IN] The index of the item
        );

    // <group DOM_ListMenu_VcpListMenu_Method>
    // Set the item height of all items
    void setItemHeight(
        VfxU32 height   // [IN] The item height
        );

    virtual VfxBool hasGroupHeader(
        VfxS32 group    // [IN] The group index
    )
    {
        return VFX_FALSE;
    }
    



    // <group DOM_ListMenu_VcpListMenu_Method>
    // Update a item, user can use this method to refresh a list item if its 
    // content or state is changed
    void updateItem(
        VfxU32 index    // [IN] The index of the item
        );

    // <group DOM_ListMenu_VcpListMenu_Method>
    // Get the list menu cell object if user need
    // RETURNS: instance of VcpListMenuCell
    VcpListMenuCell *getCell(
        VfxU32 index    // [IN] The index of the item
        );

    // <group DOM_ListMenu_VcpListMenu_Method>
    // Get the content frame object of the cell
    // RETURNS: instance of VfxFrame
    VfxFrame *getContentFrame(
        VfxU32 index    // [IN] The index of the item
        );
    
    // <group DOM_ListMenu_VcpListMenu_Method>
    // Get the text of the specified field of an item
    // RETURNS: VFX_TRUE or VFX_FALSE
    VfxBool getItemTextIfPresent(
        VfxU32 index,                   // [IN]  The index of the item
        VcpListMenuFieldEnum fieldType, // [IN]  The type of the field in the cell
        VfxWString &text                // [OUT] The text of the specified field of the list item
        );

    // <group DOM_ListMenu_VcpListMenu_Method>
    // Set the visible menu region to be visible
    void setVisibleMenuRegion(
        VfxS32 beginIndex,  // [IN] The begin index of the region, if -1, means don't care the begin index, just make the end index of item as the last visible item
        VfxS32 endIndex,    // [IN] The end index of the region, if -1, means don't care the end index, just make the begin index of item as the first visible item 
        VfxBool isAnim      // [IN] If the animation effect of setting the visible menu region is available
        );

    // <group DOM_ListMenu_VcpListMenu_Method>
    // Set the menu item to be visible
    void setVisibleMenuItem(
        VfxS32 index,               // [IN] The index of menu item to be visible
        VfxBool isAnim = VFX_FALSE  // [IN] If the animation effect of setting the visible menu item is available
        )
        {
            vfxPostInvoke2(this, &VcpListMenu::setVisibleMenuItemInt, index, isAnim);
        }

// Event
public:

    // <group DOM_ListMenu_VcpListMenu_Event>
    // This signal is invoked when the item selection state is changed
    // void YourClass::onItemStateChanged(VcpListMenu *sender, VfxU32 index, VcpListMenuItemStateEnum newState)
    VfxSignal3 <
        VcpListMenu *,              // Sender
        VfxU32,                     // List item index
        VcpListMenuItemStateEnum    // The new state
    > m_signalItemSelectionStateChanged;

    // <group DOM_ListMenu_VcpListMenu_Event>
    // This signal is invoked when index of the focused item is changed
    // void YourClass::onFocusChanged(VcpListMenu *sender, VfxU32 index, VfxU32 preIndex)
    VfxSignal3 <
        VcpListMenu *,  // Sender
        VfxU32,         // Current focus list item index
        VfxU32          // Previous focus list item index
    > m_signalFocusChanged;


    // <group DOM_ListMenu_VcpListMenu_Event>
    // This signal is invoked when a list item is tapped
    // void YourClass::onItemTapped(VcpListMenu *sender, VfxU32 index)
    VfxSignal2 <
        VcpListMenu *,  // Sender
        VfxU32          // List item index
    > m_signalItemTapped;

    // <group DOM_ListMenu_VcpListMenu_Event>
    // This signal is invoked when a list item is long tapped
    // void YourClass::onItemLongTapped(VcpListMenu *sender, VfxU32 index)
    VfxSignal2 <
        VcpListMenu *,  // Sender
        VfxU32          // List item index
    > m_signalItemLongTapped;

    // <group DOM_ListMenu_VcpListMenu_Event>
    // This signal is invoked the quick command button is clicked
    // void YourClass::onCmdButtonClicked(VcpListMenu *sender, VfxU32 index)
    VfxSignal2<
        VcpListMenu *,  // Sender
        VfxU32          // List item index
    > m_signalCmdButtonClicked;

    // <group DOM_ListMenu_VcpListMenu_Event>
    // This signal is invoked when a list item is touched down
    // void YourClass::onItemTouchedDown(VcpGroupListMenu *sender, VfxU32 pos)
    VfxSignal2 <
        VcpListMenu *,  // Sender
        VfxU32          // List item position
    > m_signalItemTouchedDown;

    // <group DOM_ListMenu_VcpListMenu_Event>
    // This signal is invoked when a list item is touched up
    // void YourClass::onItemTouchedUp(VcpGroupListMenu *sender, VfxU32 pos)
    VfxSignal2 <
        VcpListMenu *,  // Sender
        VfxU32          // List item position
    > m_signalItemTouchedUp;

    // <group DOM_ListMenu_VcpListMenu_Event>
    // This signal is invoked when a list ends dragging cells
    // void YourClass::onEndRagCell(VcpGroupListMenu *sender)
    VfxSignal1 <
        VcpListMenu *   // Sender
    > m_signalEndDragCell;
    
// Override
public:
    virtual void setCellStyle(VcpListMenuCellStyleEnum style );
    virtual void setThemeData(VcpListMenuThemeStruct &themeData);
 
// Override
protected:
    virtual void onInit();
    virtual VfxBool onKeyInput(VfxKeyEvent &event);
    virtual VcpBaseMenuLayout* createLayout();
    virtual VfxFrame* createGroupHeader(VfxS32 group){ return NULL; }
    virtual void onTouchCell(VcpMenuPos cellPos, CellTouchTypeEnum touchType, VfxPoint pt, VfxFrame *cell);
    virtual void onFocusIndexChange(VcpMenuPos focusItem, VcpMenuPos previousFocusItem);
    virtual IVcpListMenuContentProviderInt *getContentProviderInt();    


// Property
protected:


    // The height of the item
    VfxU32 m_itemHeight;


    IVcpListMenuContentProvider *m_contentProvider;

// Implementation
protected:
    virtual void startDragCell(VcpMenuPos pos, VfxFrame* dragCell);
    virtual void endDragCell(VcpMenuPos pos, VfxFrame* dragCell);

    void onCmdButtonClickedInt(VcpMenuPos pos);
    void onItemStateChangedInt(VcpMenuPos pos, VcpListMenuItemStateEnum newState);

    void setVisibleMenuItemInt(VfxS32 index, VfxBool isAnim)
    {
        makeVisible(VcpMenuPos(0, index), isAnim);
    }

    friend class VcpListMenuLayout;
    friend class VcpMenuCache;
    friend class VcpMenuRegionIter;
    friend class VcpListMenuCell;
    friend class VcpListMenuCellClientBaseFrame;
    friend class VcpListMenuCellBaseControl;
};


/***************************************************************************** 
 * Class VcpListMenuLayout
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuLayout is a class that provides the layout logic of the cells in VcpListMenu object */
class VcpListMenuLayout : public VcpBaseListMenuLayout
{
// Constructor / Destructor
public:
    VcpListMenuLayout(VcpBaseMenu* menu) : VcpBaseListMenuLayout(menu) {}

// Method
public:
    

// Override
public:
    virtual VfxS32 getGroupCount(){ return 1; }
    virtual VfxS32 getCellCount(VfxS32 group);

    virtual VcpMenuPos queryPosByPt(const VfxPoint& pt);
    virtual void getPreferFocusMargin(VfxS32 margin[4]);
    
// Override
protected:
    virtual void onInit();
    
// Variable
protected:


// Implementation
protected:
    VcpListMenu *getListMenu() { return (VcpListMenu *)m_pMenu;}
};
/* DOM-NOT_FOR_SDK-END */


/*
 *  VcpGroupListMenu is a class that can create a group list menu, which provides
 *  various menu cell templates and various list mode, the menu items can be divided
 *  into several groups, there is a group header on the top each group 
 */
class VcpGroupListMenu : public VcpBaseListMenu
{
    VFX_DECLARE_CLASS(VcpGroupListMenu);

// Constructor / Destructor
public:
    VcpGroupListMenu();

// Method
public:
    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Mandatory to be called after creating VcpGroupListMenu object, VcpGroupListMenu use the methods of the provider to get resource of every cell
    void setContentProvider(
        IVcpGroupListMenuContentProvider *contentProvider   // [IN] The content provider object created by user
        );

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Get the content provider pointer
    // RETURNS: instance of IVcpGroupListMenuContentProvider
    IVcpGroupListMenuContentProvider *getContentProvider() {return m_contentProvider;}

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Optional, the defualt item state is VCP_LIST_MENU_ITEM_STATE_NONE, the initial state of the item is queried by getItemState() of IVcpListMenuContentProvider, this API is called when user want to change the item state after the item is created
    void setItemState(
        VcpMenuPos pos,                 // [IN] The position of the item
        VcpListMenuItemStateEnum state  // [IN] The state of the item
        );

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Get the state if a list menu item
    // RETURNS: VcpListMenuItemStateEnum
    VcpListMenuItemStateEnum getItemState(
        VcpMenuPos pos  // [IN]  The position of the item
        ) const;

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Get the position of focus item
    // RETURNS: VcpMenuPos
    VcpMenuPos getFocusItemPos() const {return m_focusItem;}

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Get the item height
    // RETURNS: VfxU32
    VfxU32 getItemHeight();

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Set the item height of all items
    void setItemHeight(
        VfxU32 height   // [IN] The item height
        );

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Get the group header height 
    // RETURNS: VfxU32
    VfxU32 getHeaderHeight();

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Set the group header height 
    void setHeaderHeight(
        VfxU32 height   // [IN] The item height
        );

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Update a item, user can use this method to refresh a list item if its content or state is changed
    void updateItem(
        VcpMenuPos pos  // [IN]  The position of the item
        );

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Get the list menu cell object if user need
    // RETURNS: instance of VcpListMenuCell
    VcpListMenuCell *getCell(
        VcpMenuPos pos  // [IN]  The position of the item
        );

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Get the content frame object of the cell
    // RETURNS: instance of VfxFrame
    VfxFrame *getContentFrame(
        VcpMenuPos pos                  // [IN]  The position of the item
        );
    
    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Get the text of the specified field of an item
    // RETURNS: VFX_TRUE or VFX_FALSE
    VfxBool getItemTextIfPresent(
        VcpMenuPos pos,                 // [IN]  The position of the item
        VcpListMenuFieldEnum fieldType, // [IN]  The type of the field in the cell
        VfxWString &text                // [OUT] The text of the specified field of the list item
        );

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Set if all group headers are hidden, if hidden, there is no group of items, all list items are in one single group, the group index is 0
    void setGroupHeaderHidden(
        VfxBool isHidden,           // [IN] If hidden
        VfxBool isAmin = VFX_FALSE  // [IN] If there is animation
        );

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Get if the group headers are hidden
    // RETURNS: VFX_TRUE or VFX_FALSE
    VfxBool getGroupHeaderHidden();

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Get if there is group header of a specified group index
    // RETURNS: VFX_TRUE or VFX_FALSE
    virtual VfxBool hasGroupHeader(
        VfxS32 group    // [IN] The group index
        );

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Set the visible menu region to be visible
    void setVisibleMenuRegion(
        VcpMenuPos beginPos,    // [IN] The begin position of the region, if (-1, -1), means don't care the begin position, just make the end position of item as the last visible item
        VcpMenuPos endPos,      // [IN] The end position of the region, if (-1, -1), means don't care the end position, just make the begin position of item as the first visible item 
        VfxBool isAnim          // [IN] If the animation effect of setting the visible menu region is available
        );

    // <group DOM_ListMenu_VcpGroupListMenu_Method>
    // Set the menu item to be visible
    void setVisibleMenuItem(
        VcpMenuPos pos,             // [IN] The pos of menu item to be visible
        VfxBool isAnim = VFX_FALSE  // [IN] If the animation effect of setting the visible menu item is available
        )
        {
            vfxPostInvoke2(this, &VcpGroupListMenu::setVisibleMenuItemInt, pos, isAnim);
        }

// Event
public:

    // <group DOM_ListMenu_VcpGroupListMenu_Event>
    // This signal is invoked when the item selection state is changed
    // void YourClass::onItemStateChanged(VcpGroupListMenu *sender, VcpMenuPos pos, VcpListMenuItemStateEnum newState)
    VfxSignal3 <
        VcpGroupListMenu *,         // Sender
        VcpMenuPos,                 // List item index
        VcpListMenuItemStateEnum    // The new state
    > m_signalItemSelectionStateChanged;

    // <group DOM_ListMenu_VcpGroupListMenu_Event>
    // This signal is invoked when index of the focused item is changed
    // void YourClass::onFocusChanged(VcpGroupListMenu *sender, VcpMenuPos pos, VfxU32 preIndex)
    VfxSignal3 <
        VcpGroupListMenu *, // Sender
        VcpMenuPos,         // Current focus list item position
        VcpMenuPos          // Previous focus list item position
    > m_signalFocusChanged;
    
    // <group DOM_ListMenu_VcpGroupListMenu_Event>
    // This signal is invoked when a list item is tapped
    // void YourClass::onItemTapped(VcpGroupListMenu *sender, VcpMenuPos pos)
    VfxSignal2 <
        VcpGroupListMenu *, // Sender
        VcpMenuPos          // List item position
    > m_signalItemTapped;

    // <group DOM_ListMenu_VcpGroupListMenu_Event>
    // This signal is invoked when a list item is long tapped
    // void YourClass::onItemLongTapped(VcpGroupListMenu *sender, VcpMenuPos pos)
    VfxSignal2 <
        VcpGroupListMenu *, // Sender
        VcpMenuPos          // List item position
    > m_signalItemLongTapped;

    // <group DOM_ListMenu_VcpGroupListMenu_Event>
    // This signal is invoked the quick command button is clicked
    // void YourClass::onCmdButtonClicked(VcpGroupListMenu *sender, VcpMenuPos pos)
    VfxSignal2<
        VcpGroupListMenu *, // Sender
        VcpMenuPos          // List item position
    > m_signalCmdButtonClicked;
    
    // <group DOM_ListMenu_VcpGroupListMenu_Event>
    // This signal is invoked when a list item is touched down
    // void YourClass::onItemTapped(VcpGroupListMenu *sender, VcpMenuPos pos)
    VfxSignal2 <
        VcpGroupListMenu *, // Sender
        VcpMenuPos          // List item position
    > m_signalItemTouchedDown;

    // <group DOM_ListMenu_VcpGroupListMenu_Event>
    // This signal is invoked when a list item is touched up
    // void YourClass::onItemTapped(VcpGroupListMenu *sender, VcpMenuPos pos)
    VfxSignal2 <
        VcpGroupListMenu *, // Sender
        VcpMenuPos          // List item position
    > m_signalItemTouchedUp;
    
// Override
public:
    virtual void setMenuMode(VcpListMenuModeEnum mode, VfxBool isAnim = VFX_FALSE);
    virtual void setCellStyle(VcpListMenuCellStyleEnum style );
    virtual void setThemeData(VcpListMenuThemeStruct &themeData);
    
// Override
protected:
    virtual void onInit();
    virtual VfxBool onKeyInput(VfxKeyEvent &event);
    virtual VcpBaseMenuLayout* createLayout();
    virtual VfxFrame* createGroupHeader(VfxS32 group);
    virtual void onCloseGroupHeader(VfxS32 group, VfxFrame* groupFrame);
    virtual void onUpdateGroupHeader(const VfxRect &rect, VfxS32 group, VfxFrame* groupObject, VfxU32 flag);
    virtual void onTouchCell(VcpMenuPos cellPos, CellTouchTypeEnum touchType, VfxPoint pt, VfxFrame *cell);
    virtual void onFocusIndexChange(VcpMenuPos focusItem, VcpMenuPos previousFocusItem);
    virtual IVcpListMenuContentProviderInt *getContentProviderInt();


// Property
protected:
    // The height of the item
    VfxU32 m_itemHeight;

    // The height of the item
    VfxU32 m_headerHeight;

    // Pointer to content provider
    IVcpGroupListMenuContentProvider *m_contentProvider;   

    // If the group headers are hidden
    VfxBool m_isGroupHeaderHidden;
    
// Implementation
protected:
    void onCmdButtonClickedInt(VcpMenuPos pos);
    void onItemStateChangedInt(VcpMenuPos pos, VcpListMenuItemStateEnum newState);

    void setVisibleMenuItemInt(VcpMenuPos pos, VfxBool isAnim)
    {
        makeVisible(pos, isAnim);
    }

    friend class VcpListMenuLayout;
    friend class VcpMenuCache;
    friend class VcpMenuRegionIter;
    friend class VcpListMenuCell;
    friend class VcpListMenuCellClientBaseFrame;
    friend class VcpListMenuCellBaseControl;
};


/***************************************************************************** 
 * Class VcpGroupListMenuLayout
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpGroupListMenuLayout is a class that provides the layout logic of the cells in VcpGroupListMenu object */
class VcpGroupListMenuLayout : public VcpBaseListMenuLayout
{
// Constructor / Destructor
public:
    VcpGroupListMenuLayout(VcpBaseMenu* menu) : VcpBaseListMenuLayout(menu) {}

// Method
public:

// Override
public:
    virtual VfxS32 getGroupCount();
    virtual VfxS32 getCellCount(VfxS32 group);
    virtual VcpMenuPos queryPosByPt(const VfxPoint& pt);
    virtual void getPreferFocusMargin(VfxS32 margin[4]);

// Override
protected:
    virtual void onInit();

// Variable
protected:

// Implementation
protected:
    VcpGroupListMenu *getListMenu() { return (VcpGroupListMenu *)m_pMenu;}
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpGroupListMenuHeader
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpGroupListMenuHeader is a class of the group list menu header */
class VcpGroupListMenuHeader : public VfxControl
{
// Constructor / Destructor
public:
    VcpGroupListMenuHeader(VfxU32 group) : m_group(group){}

// Method
public:
    VfxBool getText(VcpListMenuFieldEnum fieldTyp, VfxWString &text);
    
// Override
protected:
    virtual void onInit();
    virtual void onUpdate();

// Implementation
private:
    enum
    {
#if defined(__MMI_MAINLCD_320X480__)
        GAP = 10,
#elif defined(__MMI_MAINLCD_480X800__)
        GAP = 14,
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
        GAP = 5,
#else /* Shell: QVGA / WQVGA */
        GAP = 11,
#endif
    };

    VfxTextFrame *m_textFrame1;
    VfxU32 m_group;

// Implementation
protected:
    VcpBaseListMenu* getMenu();
    IVcpListMenuContentProviderInt *getContentProvider();

// Implementation
private:
    void onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds);
    void update();
};
/* DOM-NOT_FOR_SDK-END */


/* VcpListMenuCell is a class of the list menu item */
class VcpListMenuCell : public VfxControl
{
// Constructor / Destructor
public:
    // <group DOM_ListMenu_VcpListMenuCell_Constructor/Destructor>
    VcpListMenuCell(VcpListMenuCellStyleEnum style, VcpMenuPos pos);

public:
    // <group DOM_ListMenu_VcpListMenuCell_Enum>
    // Control mode type enum
    enum ControlModeTyepEnum
    {
        CONTROL_MODE_TYPE_NONE,         // None
        CONTROL_MODE_TYPE_MENU_MODE,    // Menu mode
        CONTROL_MODE_TYPE_CONTROL_MODE, // Menu control mode
        CONTROL_MODE_TYPE_CUSTOM,       // Custom mode

        CONTROL_MODE_TYPE_MAX
    };
    
// Property
public:
    // <group DOM_ListMenu_VcpListMenuCell_Property>
    // Cell type
    VcpListMenuCellStyleEnum m_cellStyle;

    // <group DOM_ListMenu_VcpListMenuCell_Property>
    // Cell position
    VcpMenuPos m_pos;

    // <group DOM_ListMenu_VcpListMenuCell_Property>    
    // Whether the cell is highlighted
    VfxBool m_isHighlight;
    VfxBool m_prevHighlight;    

    // <group DOM_ListMenu_VcpListMenuCell_Property>
    // Head control pointer
    VcpListMenuCellBaseControl *m_headControl;

    // <group DOM_ListMenu_VcpListMenuCell_Property>
    // Tail control pointer
    VcpListMenuCellBaseControl *m_tailControl;

    // <group DOM_ListMenu_VcpListMenuCell_Property>
    // Client frame pointer
    VcpListMenuCellClientBaseFrame *m_clientFrame;

    // <group DOM_ListMenu_VcpListMenuCell_Property>
    // Head margin width
    VfxU32 m_headMarginWidth;

    // <group DOM_ListMenu_VcpListMenuCell_Property>
    // Tail margin width
    VfxU32 m_tailMarginWidth;

// Method
public:

    void updateControls();

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // Get menu
    // RETURNS: instance of VcpBaseListMenu
    VcpBaseListMenu* getMenu();

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // Get content provider
    // RETURNS: instnace of IVcpListMenuContentProviderInt
    IVcpListMenuContentProviderInt *getContentProvider();

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // Update cell position
    void updatePos(
        const VfxRect& r,   // [IN] new rect
        VfxBool isAnim      // [IN] with animation or not
        );

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // Show control
    void showControl(
        ControlModeTyepEnum controlModeType,    // [IN] control mode type
        VfxBool isAnim                          // [IN] with animation or not
        );

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // hide control
    void hideControl(
        ControlModeTyepEnum controlModeType,    // [IN] control mode type
        VfxBool isAnim                          // [IN] with animation or not
        );

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // On cell drag
    void onCellDrag(
        VfxPenEvent &event  // [IN] pen event
        );

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // On cell move
    void onCellMove(
        VfxPenEvent &event  // [IN] pen event
        );


    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // On cell drop
    void onCellDrop(
        VfxPenEvent &event  // [IN] pen event
        );

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // Set highlight
    void setHighlight(
        VfxBool isHighlight,    // [IN] highlight or not
        VfxBool isAnim          // [IN] with animation or not
        );

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // Get text color
    // RETURNS: VfxColor
    VfxColor getTextColor(
        VcpListMenuTextColorEnum colorStyle // [IN] color style
        );

#if defined(__MMI_VUI_COSMOS_CP__)
    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // Update shadow
    void updateShadow(
        VfxBool isHidden    // [IN] display shadow or not
        );
#endif

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // Set head margin width
    void setHeadMarginWidth(
        VfxU32 width    // [IN] width
        ){m_headMarginWidth = width;}

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // Set tail margin width
    void setTailMarginWidth(
        VfxU32 width    // [IN] width
        ){m_tailMarginWidth = width;}

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // Update disabled foreground
    void updateDisabledForground();

    // <group DOM_ListMenu_VcpListMenuCell_Method>
    // Check whether there is a disabled forground frame
    // RETURNS: VFX_TRUE or VFX_FALSE
    VfxBool getIsDisabledForground(void)
    {
        return (m_disabledForground) ? (VFX_TRUE) : (VFX_FALSE);
    }

    void onDelayedHighlight(VfxTimer *t);    
// Override
protected:
    virtual void onInit();
    virtual void onDeinit();
    virtual void onUpdate();

// Override
public:
    virtual void setBounds(const VfxRect &value);

// Implementation
private:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
        TAIL_CONTROL_LEFT_GAPS   = 0,
        TAIL_CONTROL_RIGHT_GAPS  = 10,
        HEAD_CONTROL_LEFT_GAPS   = 10,
        HEAD_CONTROL_RIGHT_GAPS  = 0,
        HEAD_CONTROL_TOP_GAPS    = 5,
        HEAD_CONTROL_BOTTOM_GAPS  = 5,
        HEAD_CONTROL_MAX_WIDTH   = 30
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        TAIL_CONTROL_LEFT_GAPS   = 0,
        TAIL_CONTROL_RIGHT_GAPS  = 14,
        HEAD_CONTROL_LEFT_GAPS   = 14,
        HEAD_CONTROL_RIGHT_GAPS  = 0,
        HEAD_CONTROL_TOP_GAPS    = 13,
        HEAD_CONTROL_BOTTOM_GAPS  = 13,
        HEAD_CONTROL_MAX_WIDTH   = 52
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        TAIL_CONTROL_LEFT_GAPS  = 0,
        TAIL_CONTROL_RIGHT_GAPS  = 5,
        HEAD_CONTROL_LEFT_GAPS   = 5,
        HEAD_CONTROL_RIGHT_GAPS  = 0,
        HEAD_CONTROL_TOP_GAPS    = 7,
        HEAD_CONTROL_BOTTOM_GAPS  = 4,
        HEAD_CONTROL_MAX_WIDTH   = 25
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        TAIL_CONTROL_LEFT_GAPS   = 0,
        TAIL_CONTROL_RIGHT_GAPS  = 0,
        HEAD_CONTROL_LEFT_GAPS   = 0,
        HEAD_CONTROL_RIGHT_GAPS  = 0,
        HEAD_CONTROL_TOP_GAPS    = 4,
        HEAD_CONTROL_BOTTOM_GAPS  = 4,
        HEAD_CONTROL_MAX_WIDTH   = 35
    };
#endif   
    enum
    {
        CONTROL_HIDE_DURATION = 500,
        CONTROL_SHOW_DURATION = 500
    };

private:
    VfxBool m_dragging;
    VfxPoint m_dragPt;
    VfxTimer *m_moveTimer;
    VfxPoint m_movePt;
    VcpListMenuCellControlTypeEnum m_headControlType;
    VcpListMenuCellControlTypeEnum m_tailControlType;
    VfxFrame *m_topSeparatorLine, *m_bottomSeparatorLine;
    ControlModeTyepEnum m_headControlMode;
    ControlModeTyepEnum m_tailControlMode;
#if defined(__MMI_VUI_COSMOS_CP__)
    VfxImageFrame *m_topShadow;
#endif
    VfxBool m_isCustomClientFrame;
    VfxFrame *m_disabledForground;
    VfxBool m_isHeadControlClosing;
    VfxBool m_isTailControlClosing;
    VfxTimer *m_delayTimer;

private:
    void onCellMoveInt(VfxPoint &point);
    void createClientFrame();
    void createControls();
    void closeHeadControl();
    void closeTailControl();
    void closeControls();
    void showHeadControl(VfxBool isAnim);
    void hideHeadControl(VfxBool isAnim);
    void showTailControl(VfxBool isAnim);
    void hideTailControl(VfxBool isAnim);
    void updateSeparators();
    void onHideTailControlTimeLineStopped(VfxBaseTimeline *timeline, VfxBool isCompleted);
    void onHideHeadControlTimeLineStopped(VfxBaseTimeline *timeline, VfxBool isCompleted);
    void onMoveTimeOutFunc(VfxTimer *t);
};



/***************************************************************************** 
 * Class VcpListMenuCellSingleTextFrame
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCellSingleTextFrame is a class of the center client region of list menu item which contains one text  */
class VcpListMenuCellSingleTextFrame : public VcpListMenuCellClientBaseFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellSingleTextFrame();

// Override
public:
    virtual void onCreateElements();
    virtual void onCloseElements();
    virtual void onLayoutElements();
    virtual void onUpdateElements();
    virtual void onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame);
    virtual void onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame);
    virtual VfxBool getText(VcpListMenuFieldEnum fieldType, VfxWString &text);

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
    #if defined(__MMI_VUI_COSMOS_CP__)
        LEFT_GAPS   =  10,
        RIGHT_GAPS  =  3
    #else
        LEFT_GAPS   =  3,
        RIGHT_GAPS  =  3
    #endif
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        LEFT_GAPS   =  14,
        RIGHT_GAPS  =  14
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        LEFT_GAPS   =  5,
        RIGHT_GAPS  =  5
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        LEFT_GAPS   =  11,
        RIGHT_GAPS  =  2
    };
#endif

    // The text element in this client frame
    VfxFrame *m_textFrame;
}; 
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellMultiTextFrame
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */ 
/* VcpListMenuCellMultiTextFrame is a class of the center client region of list menu item which contains two texts */  
class VcpListMenuCellMultiTextFrame : public VcpListMenuCellClientBaseFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellMultiTextFrame();

// Override
public:
    virtual void onCreateElements();
    virtual void onCloseElements(){}
    virtual void onLayoutElements();
    virtual void onUpdateElements();
    virtual void onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame);
    virtual void onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame);
    virtual VfxBool getText(VcpListMenuFieldEnum fieldType, VfxWString &text);

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
        TEXT1_LEFT_GAPS   = 10,
        TEXT1_RIGHT_GAPS  = 10,
        TEXT1_TOP_GAPS    = 6,
        TEXT2_LEFT_GAPS   = 10,
        TEXT2_RIGHT_GAPS  = 10,
        TEXT2_BOTTOM_GAPS = 6
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        TEXT1_LEFT_GAPS   = 14,
        TEXT1_RIGHT_GAPS  = 14,
        TEXT1_TOP_GAPS    = 13,
        TEXT2_LEFT_GAPS   = 14,
        TEXT2_RIGHT_GAPS  = 14,
        TEXT2_BOTTOM_GAPS = 13
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        TEXT1_LEFT_GAPS   = 5,
        TEXT1_RIGHT_GAPS  = 5,
        TEXT1_TOP_GAPS    = 7,
        TEXT2_LEFT_GAPS   = 5,
        TEXT2_RIGHT_GAPS  = 5,
        TEXT2_BOTTOM_GAPS = 4
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        TEXT1_LEFT_GAPS   = 11,
        TEXT1_RIGHT_GAPS  = 8,
        TEXT1_TOP_GAPS    = 11,
        TEXT2_LEFT_GAPS   = 11,
        TEXT2_RIGHT_GAPS  = 8,
        TEXT2_BOTTOM_GAPS = 8
    };
#endif

    // The first text element in this client frame
    VfxFrame *m_textFrame1;

    // The second text element in this client frame
    VfxFrame *m_textFrame2;
}; 
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellMultiTextFrameEx
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCellMultiTextFrameEx is a class of the center client region of list menu item which contains one icon and two texts, one in the left, another in the right */  
class VcpListMenuCellMultiTextFrameEx : public VcpListMenuCellClientBaseFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellMultiTextFrameEx();

// Override
public:
    virtual void onCreateElements(){}
    virtual void onCloseElements(){}
    virtual void onLayoutElements();
    virtual void onUpdateElements();
    virtual void onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame);
    virtual void onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame);
    virtual VfxBool getText(VcpListMenuFieldEnum fieldType, VfxWString &text);

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
        TEXT1_LEFT_GAPS   = 10,
        TEXT1_RIGHT_GAPS  = 10,
        TEXT2_LEFT_GAPS   = 7,
        TEXT2_RIGHT_GAPS  = 10
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        TEXT1_LEFT_GAPS   = 14,
        TEXT1_RIGHT_GAPS  = 14,
        TEXT2_LEFT_GAPS   = 10,
        TEXT2_RIGHT_GAPS  = 14
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        TEXT1_LEFT_GAPS   = 5,
        TEXT1_RIGHT_GAPS  = 5,
        TEXT2_LEFT_GAPS   = 5,
        TEXT2_RIGHT_GAPS  = 5
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        TEXT1_LEFT_GAPS   = 11,
        TEXT1_RIGHT_GAPS  = 8,
        TEXT2_LEFT_GAPS   = 5,
        TEXT2_RIGHT_GAPS  = 8
    };
#endif

    // The first text element in this client frame
    VfxFrame *m_textFrame1;

    // The second text element in this client frame
    VfxFrame *m_textFrame2;
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellTripleTextFrame
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCellTripleTextFrame is a class of the center client region of list menu item which contains three texts */  
class VcpListMenuCellTripleTextFrame : public VcpListMenuCellClientBaseFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellTripleTextFrame();

// Override
public:
    virtual void onCreateElements(){}
    virtual void onCloseElements(){}
    virtual void onLayoutElements();
    virtual void onUpdateElements();
    virtual void onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame);
    virtual void onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame);
    virtual VfxBool getText(VcpListMenuFieldEnum fieldType, VfxWString &text);

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
        TEXT1_LEFT_GAPS   = 10,
        TEXT1_RIGHT_GAPS  = 10,
        TEXT1_TOP_GAPS    = 6,
        TEXT2_LEFT_GAPS   = 10,
        TEXT2_RIGHT_GAPS  = 10,
        TEXT2_BOTTOM_GAPS = 6,
        TEXT3_LEFT_GAPS   = 10,
        TEXT3_RIGHT_GAPS  = 10,
        TEXT3_BOTTOM_GAPS = 6
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        TEXT1_LEFT_GAPS   = 14,
        TEXT1_RIGHT_GAPS  = 14,
        TEXT1_TOP_GAPS    = 13,
        TEXT2_LEFT_GAPS   = 14,
        TEXT2_RIGHT_GAPS  = 14,
        TEXT2_BOTTOM_GAPS = 13,
        TEXT3_LEFT_GAPS   = 14,
        TEXT3_RIGHT_GAPS  = 14,
        TEXT3_BOTTOM_GAPS = 13
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        TEXT1_LEFT_GAPS   = 5,
        TEXT1_RIGHT_GAPS  = 5,
        TEXT1_TOP_GAPS    = 7,
        TEXT2_LEFT_GAPS   = 5,
        TEXT2_RIGHT_GAPS  = 5,
        TEXT2_BOTTOM_GAPS = 4,
        TEXT3_LEFT_GAPS   = 5,
        TEXT3_RIGHT_GAPS  = 5,
        TEXT3_BOTTOM_GAPS = 4
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        TEXT1_LEFT_GAPS   = 11,
        TEXT1_RIGHT_GAPS  = 6,
        TEXT1_TOP_GAPS    = 11,
        TEXT2_LEFT_GAPS   = 11,
        TEXT2_RIGHT_GAPS  = 5,
        TEXT2_BOTTOM_GAPS = 10,
        TEXT3_LEFT_GAPS   = 5,
        TEXT3_RIGHT_GAPS  = 8,
        TEXT3_BOTTOM_GAPS = 10
    };
#endif

    // The first text element in this client frame
    VfxFrame *m_textFrame1;

    // The second text element in this client frame
    VfxFrame *m_textFrame2;

    // The third text element in this client frame
    VfxFrame *m_textFrame3;
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellTripleTextFrameEx
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCellTripleTextFrameEx is a class of the center client region of list menu item which contains two icons and three texts */  
class VcpListMenuCellTripleTextFrameEx : public VcpListMenuCellTripleTextFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellTripleTextFrameEx();

// Override
public:
    virtual void onCloseElements();
    virtual void onLayoutElements();
    virtual void onUpdateElements();

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
        IMG_EX1_LEFT_GAPS   = 10,
        IMG_EX1_RIGHT_GAPS  = 10,
        IMG_EX1_TOP_GAPS    = 6,
        IMG_EX2_LEFT_GAPS   = 0,
        IMG_EX2_RIGHT_GAPS  = 10,
        IMG_EX2_TOP_GAPS    = 6
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        IMG_EX1_LEFT_GAPS   = 14,
        IMG_EX1_RIGHT_GAPS  = 14,
        IMG_EX1_TOP_GAPS    = 13,
        IMG_EX2_LEFT_GAPS   = 0,
        IMG_EX2_RIGHT_GAPS  = 14,
        IMG_EX2_TOP_GAPS    = 13
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        IMG_EX1_LEFT_GAPS   = 5,
        IMG_EX1_RIGHT_GAPS  = 5,
        IMG_EX1_TOP_GAPS    = 7,
        IMG_EX2_LEFT_GAPS   = 0,
        IMG_EX2_RIGHT_GAPS  = 5,
        IMG_EX2_TOP_GAPS    = 7
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        IMG_EX1_LEFT_GAPS   = 5,
        IMG_EX1_RIGHT_GAPS  = 6,
        IMG_EX1_TOP_GAPS    = 11,
        IMG_EX2_LEFT_GAPS   = 0,
        IMG_EX2_RIGHT_GAPS  = 6,
        IMG_EX2_TOP_GAPS    = 11
    };
#endif

    // The extra image element 1 in this client frame
    VfxImageFrame *m_extraImgFrame1;

    // The extra image element 2 in this client frame
    VfxImageFrame *m_extraImgFrame2;
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellQuadTextFrameEx
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCellQuadTextFrameEx is a class of the center client region of list menu item which contains two icons and four texts */  
class VcpListMenuCellQuadTextFrameEx : public VcpListMenuCellTripleTextFrameEx
{
// Constructor / Destructor
public:
    VcpListMenuCellQuadTextFrameEx();

// Override
public:
    virtual void onCloseElements();
    virtual void onLayoutElements();
    virtual void onUpdateElements();
    virtual void onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame);
    virtual void onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame);
    virtual VfxBool getText(VcpListMenuFieldEnum fieldType, VfxWString &text);

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
        TEXT4_LEFT_GAPS   = 6,
        TEXT4_RIGHT_GAPS  = 8,
        TEXT4_TOP_GAPS    = 6
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        TEXT4_LEFT_GAPS   = 10,
        TEXT4_RIGHT_GAPS  = 14,
        TEXT4_TOP_GAPS    = 13
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        TEXT4_LEFT_GAPS   = 5,
        TEXT4_RIGHT_GAPS  = 5,
        TEXT4_TOP_GAPS    = 7
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        TEXT4_LEFT_GAPS   = 4,
        TEXT4_RIGHT_GAPS  = 6,
        TEXT4_TOP_GAPS    = 11
    };
#endif

    // The fourth text element in this client frame
    VfxFrame *m_textFrame4;
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellIconSingleTextFrame
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */ 
/* VcpListMenuCellSingleTextFrame is a class of the center client region of list menu item which contains one icon and one text */ 
class VcpListMenuCellIconSingleTextFrame : public VcpListMenuCellClientBaseFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellIconSingleTextFrame();

// Override
public:
    virtual void onCreateElements();
    virtual void onCloseElements();
    virtual void onLayoutElements();
    virtual void onUpdateElements();
    virtual void onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame);
    virtual void onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame);
    virtual VfxBool getText(VcpListMenuFieldEnum fieldType, VfxWString &text);

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
    #if defined(__MMI_VUI_COSMOS_CP__)
        TEXT_LEFT_GAPS   = 0,
        TEXT_RIGHT_GAPS  = 10,
        IMG_LEFT_GAPS    = 10,
        IMG_RIGHT_GAPS   = 10,
        IMG_MAX_WIDTH    = 30
    #else
        TEXT_LEFT_GAPS   = 0,
        TEXT_RIGHT_GAPS  = 10,
        IMG_LEFT_GAPS    = 14,
        IMG_RIGHT_GAPS   = 14,
        IMG_MAX_WIDTH    = 30
    #endif
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        TEXT_LEFT_GAPS   = 0,
        TEXT_RIGHT_GAPS  = 14,
        IMG_LEFT_GAPS    = 14,
        IMG_RIGHT_GAPS   = 14,
        IMG_MAX_WIDTH    = 45
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        TEXT_LEFT_GAPS   = 0,
        TEXT_RIGHT_GAPS  = 5,
        IMG_LEFT_GAPS    = 5,
        IMG_RIGHT_GAPS   = 5,
        IMG_MAX_WIDTH    = 25
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        TEXT_LEFT_GAPS   = 0,
        TEXT_RIGHT_GAPS  = 8,
        IMG_LEFT_GAPS    = 11,
        IMG_RIGHT_GAPS   = 11,
        IMG_MAX_WIDTH    = 23
    };
#endif

    // The text element in this client frame
    VfxFrame *m_textFrame;

    // The image element in this client frame
    VfxImageFrame *m_imageFrame;
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellIconSingleTextFrameEx
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCellIconSingleTextFrameEx is a class of the center client region of list menu item which contains one text on the left side and one icon on the right side */ 
class VcpListMenuCellIconSingleTextFrameEx : public VcpListMenuCellSingleTextFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellIconSingleTextFrameEx();

// Override
public:
    virtual void onCreateElements();
    virtual void onCloseElements();
    virtual void onLayoutElements();
    virtual void onUpdateElements();

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
        IMG_LEFT_GAPS    = 10,
        IMG_RIGHT_GAPS   = 10,
        IMG_MAX_WIDTH    = 30
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        IMG_LEFT_GAPS    = 14,
        IMG_RIGHT_GAPS   = 14,
        IMG_MAX_WIDTH    = 45
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        IMG_LEFT_GAPS    = 5,
        IMG_RIGHT_GAPS   = 5,
        IMG_MAX_WIDTH    = 25
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        IMG_LEFT_GAPS    = 11,
        IMG_RIGHT_GAPS   = 11,
        IMG_MAX_WIDTH    = 23
    };
#endif

    // The image element in this client frame
    VfxImageFrame *m_imageFrame;
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellIconSingleTextFrameEx2
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */ 
/* VcpListMenuCellIconSingleTextFrameEx2 is a class of the center client region of list menu item which contains one text on the left side, one icon on the right side and one icon on the left side */ 
class VcpListMenuCellIconSingleTextFrameEx2 : public VcpListMenuCellIconSingleTextFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellIconSingleTextFrameEx2();

// Override
public:
    virtual void onCloseElements();
    virtual void onLayoutElements();
    virtual void onUpdateElements();

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
        IMG_EX_LEFT_GAPS    = 10,
        IMG_EX_RIGHT_GAPS   = 10,
        IMG_EX_MAX_WIDTH    = 30
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        IMG_EX_LEFT_GAPS    = 14,
        IMG_EX_RIGHT_GAPS   = 14,
        IMG_EX_MAX_WIDTH    = 45
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        IMG_EX_LEFT_GAPS    = 5,
        IMG_EX_RIGHT_GAPS   = 5,
        IMG_EX_MAX_WIDTH    = 25
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        IMG_EX_LEFT_GAPS    = 11,
        IMG_EX_RIGHT_GAPS   = 11,
        IMG_EX_MAX_WIDTH    = 23
    };
#endif

    // The image element in this client frame
    VfxImageFrame *m_imageFrameEx;
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellIconMultiTextFrame
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */ 
/* VcpListMenuCellIconMultiTextFrame is a class of the center client region of list menu item which contains one icon and two texts */  
class VcpListMenuCellIconMultiTextFrame : public VcpListMenuCellClientBaseFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellIconMultiTextFrame();

// Override
public:
    virtual void onCreateElements();
    virtual void onCloseElements();
    virtual void onLayoutElements();
    virtual void onUpdateElements();
    virtual void onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame);
    virtual void onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame);
    virtual VfxBool getText(VcpListMenuFieldEnum fieldType, VfxWString &text);

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
    #if defined(__MMI_VUI_COSMOS_CP__)
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 10,
        TEXT1_TOP_GAPS    = 6,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 10,
        TEXT2_BOTTOM_GAPS = 6,
        IMG_LEFT_GAPS     = 10,
        IMG_RIGHT_GAPS    = 10,
        IMG_MAX_WIDTH     = 30
    #else
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 10,
        TEXT1_TOP_GAPS    = 15,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 10,
        TEXT2_BOTTOM_GAPS = 11,
        IMG_LEFT_GAPS     = 11,
        IMG_RIGHT_GAPS    = 11,
        IMG_MAX_WIDTH     = 30
    #endif
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 14,
        TEXT1_TOP_GAPS    = 13,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 14,
        TEXT2_BOTTOM_GAPS = 13,
        IMG_LEFT_GAPS     = 14,
        IMG_RIGHT_GAPS    = 14,
        IMG_MAX_WIDTH     = 45
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 5,
        TEXT1_TOP_GAPS    = 7,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 5,
        TEXT2_BOTTOM_GAPS = 4,
        IMG_LEFT_GAPS     = 5,
        IMG_RIGHT_GAPS    = 5,
        IMG_MAX_WIDTH     = 25
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 8,
        TEXT1_TOP_GAPS    = 11,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 8,
        TEXT2_BOTTOM_GAPS = 8,
        IMG_LEFT_GAPS     = 8,
        IMG_RIGHT_GAPS    = 8,
        IMG_MAX_WIDTH     = 29
    };
#endif

    // The first text element in this client frame
    VfxFrame *m_textFrame1;

    // The second text element in this client frame
    VfxFrame *m_textFrame2;

    // The image element in this client frame
    VfxImageFrame *m_imageFrame;
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellIconMultiTextExFrame
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCellIconMultiTextExFrame is a class of the center client region of list menu item which contains one icon and two texts, one in the left, another in the right */  
class VcpListMenuCellIconMultiTextExFrame : public VcpListMenuCellClientBaseFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellIconMultiTextExFrame();

// Override
public:
    virtual void onCreateElements();
    virtual void onCloseElements();
    virtual void onLayoutElements();
    virtual void onUpdateElements();
    virtual void onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame);
    virtual void onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame);
    virtual VfxBool getText(VcpListMenuFieldEnum fieldType, VfxWString &text);

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 10,
        TEXT2_LEFT_GAPS   = 10,
        TEXT2_RIGHT_GAPS  = 10,
        IMG_LEFT_GAPS     = 10,
        IMG_RIGHT_GAPS    = 10,
        IMG_MAX_WIDTH     = 30
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 14,
        TEXT2_LEFT_GAPS   = 14,
        TEXT2_RIGHT_GAPS  = 14,
        IMG_LEFT_GAPS     = 14,
        IMG_RIGHT_GAPS    = 14,
        IMG_MAX_WIDTH     = 45
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 5,
        TEXT2_LEFT_GAPS   = 5,
        TEXT2_RIGHT_GAPS  = 5,
        IMG_LEFT_GAPS     = 5,
        IMG_RIGHT_GAPS    = 5,
        IMG_MAX_WIDTH     = 25
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 8,
        TEXT2_LEFT_GAPS   = 5,
        TEXT2_RIGHT_GAPS  = 8,
        IMG_LEFT_GAPS     = 8,
        IMG_RIGHT_GAPS    = 8,
        IMG_MAX_WIDTH     = 23
    };
#endif

    // The first text element in this client frame
    VfxFrame *m_textFrame1;

    // The second text element in this client frame
    VfxFrame *m_textFrame2;

    // The image element in this client frame
    VfxImageFrame *m_imageFrame;
}; 
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellIconTripleTextFrame
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCellIconTripleTextFrame is a class of the center client region of list menu item which contains one icon and three texts */  
class VcpListMenuCellIconTripleTextFrame : public VcpListMenuCellClientBaseFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellIconTripleTextFrame();

// Override
public:
    virtual void onCreateElements();
    virtual void onCloseElements();
    virtual void onLayoutElements();
    virtual void onUpdateElements();
    virtual void onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame);
    virtual void onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame);
    virtual VfxBool getText(VcpListMenuFieldEnum fieldType, VfxWString &text);

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 10,
        TEXT1_TOP_GAPS    = 6,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 10,
        TEXT2_BOTTOM_GAPS = 6,
        TEXT3_LEFT_GAPS   = 0,
        TEXT3_RIGHT_GAPS  = 10,
        TEXT3_BOTTOM_GAPS = 6,
        IMG_LEFT_GAPS     = 10,
        IMG_RIGHT_GAPS    = 10,
        IMG_MAX_WIDTH     = 30
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 14,
        TEXT1_TOP_GAPS    = 13,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 14,
        TEXT2_BOTTOM_GAPS = 13,
        TEXT3_LEFT_GAPS   = 0,
        TEXT3_RIGHT_GAPS  = 14,
        TEXT3_BOTTOM_GAPS = 13,
        IMG_LEFT_GAPS     = 14,
        IMG_RIGHT_GAPS    = 14,
        IMG_MAX_WIDTH     = 45
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 5,
        TEXT1_TOP_GAPS    = 7,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 5,
        TEXT2_BOTTOM_GAPS = 4,
        TEXT3_LEFT_GAPS   = 0,
        TEXT3_RIGHT_GAPS  = 5,
        TEXT3_BOTTOM_GAPS = 4,
        IMG_LEFT_GAPS     = 5,
        IMG_RIGHT_GAPS    = 5,
        IMG_MAX_WIDTH     = 25
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 6,
        TEXT1_TOP_GAPS    = 11,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 5,
        TEXT2_BOTTOM_GAPS = 10,
        TEXT3_LEFT_GAPS   = 5,
        TEXT3_RIGHT_GAPS  = 8,
        TEXT3_BOTTOM_GAPS = 10,
        IMG_LEFT_GAPS     = 8,
        IMG_RIGHT_GAPS    = 8,
        IMG_MAX_WIDTH     = 23
    };
#endif

    // The first text element in this client frame
    VfxFrame *m_textFrame1;

    // The second text element in this client frame
    VfxFrame *m_textFrame2;

    // The third text element in this client frame
    VfxFrame *m_textFrame3;

    // The image element in this client frame
    VfxImageFrame *m_imageFrame;
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellIconTripleTextFrameEx
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCellIconTripleTextFrameEx is a class of the center client region of list menu item which contains three icons and three texts */  
class VcpListMenuCellIconTripleTextFrameEx : public VcpListMenuCellIconTripleTextFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellIconTripleTextFrameEx();

// Override
public:
    virtual void onCloseElements();
    virtual void onLayoutElements();
    virtual void onUpdateElements();

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
        IMG_EX1_LEFT_GAPS   = 10,
        IMG_EX1_RIGHT_GAPS  = 10,
        IMG_EX1_TOP_GAPS    = 6,
        IMG_EX2_LEFT_GAPS   = 0,
        IMG_EX2_RIGHT_GAPS  = 10,
        IMG_EX2_TOP_GAPS    = 6,
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        IMG_EX1_LEFT_GAPS   = 14,
        IMG_EX1_RIGHT_GAPS  = 14,
        IMG_EX1_TOP_GAPS    = 13,
        IMG_EX2_LEFT_GAPS   = 0,
        IMG_EX2_RIGHT_GAPS  = 14,
        IMG_EX2_TOP_GAPS    = 13,
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        IMG_EX1_LEFT_GAPS   = 5,
        IMG_EX1_RIGHT_GAPS  = 5,
        IMG_EX1_TOP_GAPS    = 7,
        IMG_EX2_LEFT_GAPS   = 0,
        IMG_EX2_RIGHT_GAPS  = 5,
        IMG_EX2_TOP_GAPS    = 7,
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        IMG_EX1_LEFT_GAPS   = 5,
        IMG_EX1_RIGHT_GAPS  = 6,
        IMG_EX1_TOP_GAPS    = 11,
        IMG_EX2_LEFT_GAPS   = 0,
        IMG_EX2_RIGHT_GAPS  = 6,
        IMG_EX2_TOP_GAPS    = 11,
    };
#endif

    // The extra image element 1 in this client frame
    VfxImageFrame *m_extraImgFrame1;

    // The extra image element 2 in this client frame
    VfxImageFrame *m_extraImgFrame2;
}; 
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellIconQuadTextFrame
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */ 
/* VcpListMenuCellIconQuadTextFrame is a class of the center client region of list menu item which contains one icon and four texts */  
class VcpListMenuCellIconQuadTextFrame : public VcpListMenuCellClientBaseFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellIconQuadTextFrame();

// Override
public:
    virtual void onCreateElements();
    virtual void onCloseElements();
    virtual void onLayoutElements();
    virtual void onUpdateElements();
    virtual void onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame);
    virtual void onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame);
    virtual VfxBool getText(VcpListMenuFieldEnum fieldType, VfxWString &text);

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
    #if defined(__MMI_VUI_COSMOS_CP__)
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 10,
        TEXT1_TOP_GAPS    = 6,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 8,
        TEXT2_BOTTOM_GAPS = 6,
        TEXT3_LEFT_GAPS   = 7,
        TEXT3_RIGHT_GAPS  = 10,
        TEXT3_TOP_GAPS    = 6,
        TEXT4_LEFT_GAPS   = 7,
        TEXT4_RIGHT_GAPS  = 10,
        TEXT4_BOTTOM_GAPS = 6,
        IMG_LEFT_GAPS     = 10,
        IMG_RIGHT_GAPS    = 10,
        IMG_MAX_WIDTH     = 30
    #else
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 8,
        TEXT1_TOP_GAPS    = 14,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 8,
        TEXT2_BOTTOM_GAPS = 13,
        TEXT3_LEFT_GAPS   = 7,
        TEXT3_RIGHT_GAPS  = 10,
        TEXT3_TOP_GAPS    = 14,
        TEXT4_LEFT_GAPS   = 7,
        TEXT4_RIGHT_GAPS  = 10,
        TEXT4_BOTTOM_GAPS = 14,
        IMG_LEFT_GAPS     = 11,
        IMG_RIGHT_GAPS    = 11,
        IMG_MAX_WIDTH     = 30
    #endif
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 14,
        TEXT1_TOP_GAPS    = 13,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 14,
        TEXT2_BOTTOM_GAPS = 13,
        TEXT3_LEFT_GAPS   = 14,
        TEXT3_RIGHT_GAPS  = 14,
        TEXT3_TOP_GAPS    = 13,
        TEXT4_LEFT_GAPS   = 14,
        TEXT4_RIGHT_GAPS  = 14,
        TEXT4_BOTTOM_GAPS = 13,
        IMG_LEFT_GAPS     = 14,
        IMG_RIGHT_GAPS    = 14,
        IMG_MAX_WIDTH     = 45
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 5,
        TEXT1_TOP_GAPS    = 7,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 5,
        TEXT2_BOTTOM_GAPS = 4,
        TEXT3_LEFT_GAPS   = 5,
        TEXT3_RIGHT_GAPS  = 5,
        TEXT3_TOP_GAPS    = 7,
        TEXT4_LEFT_GAPS   = 5,
        TEXT4_RIGHT_GAPS  = 5,
        TEXT4_BOTTOM_GAPS = 4,
        IMG_LEFT_GAPS     = 5,
        IMG_RIGHT_GAPS    = 5,
        IMG_MAX_WIDTH     = 25
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 6,
        TEXT1_TOP_GAPS    = 11,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 5,
        TEXT2_BOTTOM_GAPS = 10,
        TEXT3_LEFT_GAPS   = 5,
        TEXT3_RIGHT_GAPS  = 8,
        TEXT3_TOP_GAPS    = 11,
        TEXT4_LEFT_GAPS   = 5,
        TEXT4_RIGHT_GAPS  = 8,
        TEXT4_BOTTOM_GAPS = 10,
        IMG_LEFT_GAPS     = 8,
        IMG_RIGHT_GAPS    = 8,
        IMG_MAX_WIDTH     = 23
    };
#endif

    // The first text element in this client frame
    VfxFrame *m_textFrame1;

    // The second text element in this client frame
    VfxFrame *m_textFrame2;

    // The third text element in this client frame
    VfxFrame *m_textFrame3;

    // The forth text element in this client frame
    VfxFrame *m_textFrame4;

    // The image element in this client frame
    VfxImageFrame *m_imageFrame;
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCellIconQuintTextFrame
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */ 
/* VcpListMenuCellIconQuintTextFrame is a class of the center client region of list menu item which contains one icon and five texts */  
class VcpListMenuCellIconQuintTextFrame : public VcpListMenuCellClientBaseFrame
{
// Constructor / Destructor
public:
    VcpListMenuCellIconQuintTextFrame();

// Override
public:
    virtual void onCreateElements();
    virtual void onCloseElements();
    virtual void onLayoutElements();
    virtual void onUpdateElements();
    virtual void onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame);
    virtual void onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame);
    virtual VfxBool getText(VcpListMenuFieldEnum fieldType, VfxWString &text);

// Variable
protected:
#if defined(__MMI_MAINLCD_320X480__)
    enum
    {
    #if defined(__MMI_VUI_COSMOS_CP__)
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 10,
        TEXT1_TOP_GAPS    = 6,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 10,
        TEXT2_TOP_GAPS    = 6,
        TEXT3_LEFT_GAPS   = 0,
        TEXT3_RIGHT_GAPS  = 10,
        TEXT3_BOTTOM_GAPS = 6,
        TEXT4_LEFT_GAPS   = 7,
        TEXT4_RIGHT_GAPS  = 10,
        TEXT4_TOP_GAPS    = 6,
        TEXT5_LEFT_GAPS   = 7,
        TEXT5_RIGHT_GAPS  = 10,
        TEXT5_BOTTOM_GAPS = 6,
        IMG_LEFT_GAPS     = 10,
        IMG_RIGHT_GAPS    = 10,
        IMG_MAX_WIDTH     = 30
    #else
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 10,
        TEXT1_TOP_GAPS    = 14,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 8,
        TEXT2_TOP_GAPS    = 14,
        TEXT3_LEFT_GAPS   = 0,
        TEXT3_RIGHT_GAPS  = 8,
        TEXT3_BOTTOM_GAPS = 13,
        TEXT4_LEFT_GAPS   = 7,
        TEXT4_RIGHT_GAPS  = 10,
        TEXT4_TOP_GAPS    = 14,
        TEXT5_LEFT_GAPS   = 7,
        TEXT5_RIGHT_GAPS  = 10,
        TEXT5_BOTTOM_GAPS = 14,
        IMG_LEFT_GAPS     = 11,
        IMG_RIGHT_GAPS    = 11,
        IMG_MAX_WIDTH     = 30
    #endif
    };
#elif defined(__MMI_MAINLCD_480X800__)
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 10,
        TEXT1_TOP_GAPS    = 13,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 14,
        TEXT2_TOP_GAPS    = 13,
        TEXT3_LEFT_GAPS   = 0,
        TEXT3_RIGHT_GAPS  = 14,
        TEXT3_BOTTOM_GAPS = 13,
        TEXT4_LEFT_GAPS   = 14,
        TEXT4_RIGHT_GAPS  = 14,
        TEXT4_TOP_GAPS    = 13,
        TEXT5_LEFT_GAPS   = 10,
        TEXT5_RIGHT_GAPS  = 14,
        TEXT5_BOTTOM_GAPS = 13,
        IMG_LEFT_GAPS     = 14,
        IMG_RIGHT_GAPS    = 14,
        IMG_MAX_WIDTH     = 45
    };
#elif defined(__MMI_VUI_COSMOS_CP__) && (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X240__))
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 5,
        TEXT1_TOP_GAPS    = 7,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 5,
        TEXT2_TOP_GAPS    = 7,
        TEXT3_LEFT_GAPS   = 0,
        TEXT3_RIGHT_GAPS  = 5,
        TEXT3_BOTTOM_GAPS = 4,
        TEXT4_LEFT_GAPS   = 5,
        TEXT4_RIGHT_GAPS  = 5,
        TEXT4_TOP_GAPS    = 7,
        TEXT5_LEFT_GAPS   = 5,
        TEXT5_RIGHT_GAPS  = 5,
        TEXT5_BOTTOM_GAPS = 4,
        IMG_LEFT_GAPS     = 5,
        IMG_RIGHT_GAPS    = 5,
        IMG_MAX_WIDTH     = 25
    };
#else /* Shell: QVGA / WQVGA */
    enum
    {
        TEXT1_LEFT_GAPS   = 0,
        TEXT1_RIGHT_GAPS  = 10,
        TEXT1_TOP_GAPS    = 11,
        TEXT2_LEFT_GAPS   = 0,
        TEXT2_RIGHT_GAPS  = 6,
        TEXT2_TOP_GAPS    = 11,
        TEXT3_LEFT_GAPS   = 0,
        TEXT3_RIGHT_GAPS  = 6,
        TEXT3_BOTTOM_GAPS = 10,
        TEXT4_LEFT_GAPS   = 5,
        TEXT4_RIGHT_GAPS  = 8,
        TEXT4_TOP_GAPS    = 11,
        TEXT5_LEFT_GAPS   = 5,
        TEXT5_RIGHT_GAPS  = 8,
        TEXT5_BOTTOM_GAPS = 11,
        IMG_LEFT_GAPS     = 8,
        IMG_RIGHT_GAPS    = 8,
        IMG_MAX_WIDTH     = 23
    };
#endif

    // The first text element in this client frame
    VfxFrame *m_textFrame1;

    // The second text element in this client frame
    VfxFrame *m_textFrame2;

    // The third text element in this client frame
    VfxFrame *m_textFrame3;

    // The forth text element in this client frame
    VfxFrame *m_textFrame4;

    // The fifth text element in this client frame
    VfxFrame *m_textFrame5;

    // The image element in this client frame
    VfxImageFrame *m_imageFrame;
};
/* DOM-NOT_FOR_SDK-END */



/***************************************************************************** 
 * Class VcpListMenuCellThumb
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCellThumb is a class of the list menu item drag thumb */
class VcpListMenuCellThumb : public VcpListMenuCellBaseControl
{
// Constructor / Destructor
public:
    VcpListMenuCellThumb();

// Override
public:
    virtual VfxBool onPenInput(VfxPenEvent &event);
    virtual void onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds);
    virtual VfxBool onPenAbortAccepted(VfxControl *aborter, VfxPenAbortReasonEnum reason);

// Override
protected:
    virtual void onInit();

// Implementation
protected:
    // The image frame of the thumb icon
    VfxImageFrame *m_thumbIcon;

    // Is dragging
    VfxBool m_isDragging;

};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCmdButton
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCmdButton is a class of the list menu item quick command button */
class VcpListMenuCmdButton : public VcpListMenuCellBaseControl
{
// Constructor / Destructor
public:
    VcpListMenuCmdButton(VcpStateImage stateImage);

// Override
public:
    virtual void onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds);
    virtual void update(VfxBool isAnim);

// Method
public:
    // update state of image button
    virtual void updateState();

// Override
protected:
    virtual void onInit();
    virtual VfxBool onContainPoint(const VfxPoint &point) const;
    
// Implementation
protected:
    VcpImageButton* m_imageButton;
    VcpStateImage m_stateImage;
    void onButtonClicked(VfxObject *source, VfxId id);
};
/* DOM-NOT_FOR_SDK-END */

/***************************************************************************** 
 * Class VcpListMenuSelectable
 *****************************************************************************/
class VcpListMenuSelectable : public VcpListMenuCellBaseControl
{
// Constructor / Destructor
public:
    VcpListMenuSelectable();

// Method
public:
    // Set the selection state of the radio button
    virtual void setSelection(VfxBool isSelected);

// Override
public:
    virtual void update(VfxBool isAnim);
    virtual void onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds);

// Override
protected:
    virtual void onInit();

// Implementation
protected:
    // The image frame for the radio button images
    VfxImageFrame* m_imageFrame;

    // If it's selected radio button
    VfxBool m_isSelected;

// Implementation
protected:

    // The slot of the cell selected event, we will change the the radio button state there
    virtual void onCellSelected(VcpMenuPos pos) = 0;

private:
    void cellSelected(VcpMenuPos pos);
};

/***************************************************************************** 
 * Class VcpListMenuRadioButton
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuRadioButton is a class of the list menu item radio button */
class VcpListMenuRadioButton : public VcpListMenuSelectable
{
// Constructor / Destructor
public:
    VcpListMenuRadioButton();

// Method
public:
    // Set the selection state of the radio button
    virtual void setSelection(VfxBool isSelected);

// Implementation
protected:

    // The slot of the cell selected event, we will change the the radio button state there
    virtual void onCellSelected(VcpMenuPos pos);
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCheckBox
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCheckBox is a class of the list menu item check box */
class VcpListMenuCheckBox : public VcpListMenuSelectable
{
// Constructor / Destructor
public:
    VcpListMenuCheckBox();

// Method
public:
    // Set the selection state of the radio button
    virtual void setSelection(VfxBool isSelected);

// Implementation
protected:
    // The slot of the cell selected event, we will change the 
    // the radio button state there
    virtual void onCellSelected(VcpMenuPos pos);
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuDisclosure
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuDisclosure is a class of the list menu item disclosure control */
class VcpListMenuDisclosure : public VcpListMenuCellBaseControl
{
// Constructor / Destructor
public:
    VcpListMenuDisclosure(VfxImageSrc img);

// Override
public:
    virtual void onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds);
    virtual void setHighlight(VfxBool isHighlight);

// Override
protected:
    virtual void onInit();

// Implementation
protected:
    // The image frame for disclosure control 
    VfxImageFrame* m_imageFrame;

    // The image of disclosure control 
    VfxImageSrc m_image;
};
/* DOM-NOT_FOR_SDK-END */


/***************************************************************************** 
 * Class VcpListMenuCheckMark
 *****************************************************************************/
/* DOM-NOT_FOR_SDK-BEGIN */
/* VcpListMenuCheckMark is a class of the list menu item check mark */
class VcpListMenuCheckMark : public VcpListMenuSelectable
{
// Constructor / Destructor
public:
    VcpListMenuCheckMark(VfxBool isMultiSelect);

// Method
public:
    // Set the selection state of the radio button
    virtual void setSelection(VfxBool isSelected);


// Implementation
protected:
    // If it's selected radio button
    VfxBool m_isMultiSelect;

// Implementation
protected:
    // The slot of the cell selected event, we will change the 
    // the radio button state there
    virtual void onCellSelected(VcpMenuPos pos);

};
/* DOM-NOT_FOR_SDK-END */


/* VcpListMenuSearchBar is a class of the list menu search bar component */
class VcpListMenuSearchBar : public VfxControl
{
// Constructor / Destructor
public:
    // <group DOM_ListMenu_VcpListMenuSearchBar_Constructor/Destructor>
    VcpListMenuSearchBar();

// Method
public:
    // <group DOM_ListMenu_VcpListMenuSearchBar_Method>
    // Get the pointer to the text editor in the search bar
    // RETURNS: instance of VcpTextEditor
    VcpTextEditor *getSearchEditor() {return m_textEditor;}

    // <group DOM_ListMenu_VcpListMenuSearchBar_Method>
    // Set the max search text length
    void setMaxSearchLength(
        VfxS32 length   // [IN] text length
        );

    // <group DOM_ListMenu_VcpListMenuSearchBar_Method>
    // Update the layout of the editor and button in search bar
    void updateLayout();

    // <group DOM_ListMenu_VcpListMenuSearchBar_Method>
    // Set left margin width
    void setLeftMarginWidth(
        VfxU32 width    // [IN] width
        );

    // <group DOM_ListMenu_VcpListMenuSearchBar_Method>
    // Set right margin width
    void setRightMarginWidth(
        VfxU32 width    // [IN] width
        );

// Property
public:
    // <group DOM_ListMenu_VcpListMenuSearchBar_Property>
    // The text editor
    VcpTextEditor *m_textEditor;

    // <group DOM_ListMenu_VcpListMenuSearchBar_Property>
    // The search button
    VcpImageButton *m_searchButton;

    // <group DOM_ListMenu_VcpListMenuSearchBar_Property>
    // Left margin width
    VfxU32 m_leftMarginWidth;

    // <group DOM_ListMenu_VcpListMenuSearchBar_Property>
    // Right margin width
    VfxU32 m_rightMarginWidth;

// Override
protected:
    virtual void onInit();
    virtual void onDeinit();

// Member
private:
    enum
    {
        TOP_BOTTOM_MARGIN = 8
    };

    // The max search text length
    VfxS32 m_maxSearchLength;

    // The search text buffer
    VfxWChar *m_textBuf;

    // The search icon in editor area
    VfxImageFrame *m_searchIcon;

    // The shadow image of search bar
    VfxImageFrame *m_shadow;

// Implementation
private:
    void onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds);
};
#endif /* _VCP_LIST_MENU_H_ */

