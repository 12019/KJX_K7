/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2008
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES. ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vcp_list_menu.cpp
 *
 * Project:
 * --------
 *  Venus list menu component
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
 
/***************************************************************************** 
 * Include
 *****************************************************************************/

#ifdef __MTK_TARGET__
#ifdef __VENUS_SWLA_DBG_ON__
#define __MAUI_SOFTWARE_LA__
#else
//#define __MAUI_SOFTWARE_LA__
#endif
#endif
extern "C"
{
    #include "kal_public_api.h"
    #include "kal_general_types.h"
    #include "gui_typedef.h"
    #include "gui_touch_feedback.h"
    #include "string.h"
    #include "ImeGprot.h"
    #include "GlobalResDef.h"
#ifdef __MAUI_SOFTWARE_LA__
    #include "SST_sla.h"
#endif
}

#include "vrt_datatype.h"
#include "vfx_datatype.h"
#include "vfx_sys_memory.h"
#include "vfx_object.h"
#include "vcp_base_menu.h"
#include "vfx_cpp_base.h"
#include "vfx_string.h"
#include "vcp_text_utils.h"
#include "vfx_image_src.h"
#include "vfx_frame.h"
#include "vfx_class_info.h"
#include "vfx_signal.h"
#include "vfx_basic_type.h"
#include "vcp_menu_seek_bar.h"
#include "vfx_auto_animate.h"
#include "vfx_control.h"
#include "vfx_input_event.h"
#include "DebugInitDef_Int.h"
#include "vfx_text_frame.h"
#include "vfx_font_desc.h"
#include "vfx_primitive_frame.h"
#include "vfx_animation.h"
#include "vfx_draw_context.h"
#include "vcp_state_image.h"
#include "vcp_text_view.h"
#include "stdio.h"
#include "vcp_image_button.h"
#include "vcp_text_editor.h"
#include "vcp_list_menu.h"

#if defined(__MMI_VUI_COSMOS_CP__)
#include "mmi_rp_app_cosmos_global_def.h"
#endif /* defined(__MMI_VUI_COSMOS_CP__) */
   

/***************************************************************************** 
 * Define
 *****************************************************************************/

/***************************************************************************** 
 * Static Declaration
 *****************************************************************************/
 
/***************************************************************************** 
 * Local Variable
 *****************************************************************************/

/***************************************************************************** 
 * Global Variable
 *****************************************************************************/
static VcpListMenuThemeStruct s_default_list_menu_theme = {
    VRT_COLOR_MAKE(255, 255, 255, 255),
    VRT_COLOR_MAKE(255, 15, 15, 15),
    VRT_COLOR_MAKE(255, 15, 15, 15),
    VRT_COLOR_MAKE(255, 50, 50, 50),
    VRT_COLOR_MAKE(255, 180, 180, 180),
    VRT_COLOR_MAKE(255, 255, 255, 255),
    VRT_COLOR_MAKE(255, 255, 255, 255),
    VRT_COLOR_MAKE(255, 255, 255, 255),
    VRT_COLOR_MAKE(255, 255, 255, 255),
    VCP_IMG_LIST_MENU_HIGHLIGHT_ITEM_BACKGROUND,
    VCP_IMG_LIST_MENU_CHECK_BOX_ON,
    VCP_IMG_LIST_MENU_CHECK_BOX_OFF,
    VCP_IMG_LIST_MENU_RADIO_BUTTON_ON,
    VCP_IMG_LIST_MENU_RADIO_BUTTON_OFF,
    VCP_IMG_LIST_MENU_GROUP_HEADER_BG,
    VCP_IMG_LIST_MENU_CHECK_MARK
};

/***************************************************************************** 
 * Local Function
 *****************************************************************************/

// Helper Functions

VfxS32 vcpListMenuHelperGetDefaultItemHeight(VcpListMenuCellStyleEnum style)
{
    switch (style)
    {
    case VCP_LIST_MENU_CELL_STYLE_CUSTOM:
        // App need to set cell height by setItemHeight()
        return -1;

    case VCP_LIST_MENU_CELL_STYLE_SINGLE_TEXT:
    case VCP_LIST_MENU_CELL_STYLE_MULTI_TEXT_EX:
    case VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT:
    case VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT_EX:
    case VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT_EX2:
    case VCP_LIST_MENU_CELL_STYLE_ICON_MULTI_TEXT_EX:
        return VCP_LIST_MENU_CELL_HEIGHT_SINGLE_LINE;

    case VCP_LIST_MENU_CELL_STYLE_MULTI_TEXT:
    case VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT:
    case VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT_EX:
    case VCP_LIST_MENU_CELL_STYLE_QUADRUPLE_TEXT:
    case VCP_LIST_MENU_CELL_STYLE_ICON_MULTI_TEXT:
    case VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT:
    case VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT_EX:
    case VCP_LIST_MENU_CELL_STYLE_ICON_QUADRUPLE_TEXT:
    case VCP_LIST_MENU_CELL_STYLE_ICON_QUINTUPLE_TEXT:
        return VCP_LIST_MENU_CELL_HEIGHT_MULTI_LINE;
        
    default:
        VFX_ASSERT(0); // Need to config cell height according to cell style and LCD resolution
        return -1;
    }
}

void vcpListMenuHelperSetVisibleMenuRegion(VcpBaseMenu * baseMenu, const VcpMenuPos & beginPos, const VcpMenuPos & endPos, VfxBool isAnim, VfxS32 headerGap, VfxBool isGroup)
{
    VfxBool beginPosValid, endPosValid;

    beginPosValid = beginPos.isValid();
    endPosValid = endPos.isValid();

    if (!isGroup)
    {
        beginPosValid &= beginPos.pos != -1;
        endPosValid &= endPos.pos != -1;
    }

    if (!beginPosValid && !endPosValid)
    {
        return;
    }

    VcpBaseMenuLayout *layout = baseMenu->getLayout();

    VfxRect beginRect, endRect, visibleRect;

    if (beginPosValid)
    {
        beginRect = layout->queryCellRect(beginPos);

        // tricky solution: remove header gap
        if (beginPos.pos == -1)
        {
            VfxS32 y = beginRect.origin.y - headerGap;

            y = (y < 0) ? (0) : (y);
            beginRect.origin.y = y;
        }
    }

    if (endPosValid)
    {
        endRect = layout->queryCellRect(endPos);
    }

    if (!beginPosValid)
    {
        visibleRect.origin.x = endRect.origin.x;
        visibleRect.origin.y = endRect.getMaxY() - baseMenu->getSize().height;
        visibleRect.size.width = endRect.getWidth();
        visibleRect.size.height = baseMenu->getSize().height;
    }
    else if (!endPosValid)
    {
        visibleRect.origin.x = beginRect.origin.x;
        visibleRect.origin.y = beginRect.origin.y;
        visibleRect.size.width = beginRect.getWidth();
        visibleRect.size.height = baseMenu->getSize().height;
    }
    else
    {
        visibleRect.origin.x = beginRect.origin.x;
        visibleRect.origin.y = beginRect.origin.y;
        visibleRect.size.width = beginRect.getWidth();
        visibleRect.size.height = VFX_MIN(baseMenu->getSize().height, endRect.getMaxY() - beginRect.origin.y);
    }

    baseMenu->makeVisible(visibleRect, isAnim);
}

/***************************************************************************** 
 * Class VcpBaseListMenu
 *****************************************************************************/

VFX_IMPLEMENT_VIRTUAL_CLASS("VcpBaseListMenu", VcpBaseListMenu, VcpBaseMenu);


VcpBaseListMenu::VcpBaseListMenu() : 
    m_themeData(::s_default_list_menu_theme),
    m_focusBehavior(VCP_LIST_MENU_FOCUS_BEHAVIOR_SEMI),
    m_cellStyle(VCP_LIST_MENU_CELL_STYLE_NONE),
    m_menuMode(VCP_LIST_MENU_MODE_NORMAL),
    m_menuControlMode(VCP_LIST_MENU_CONTROL_MODE_NORMAL),
    m_searchBar(NULL),
    m_cellbgColor(VRT_COLOR_TRANSPARENT),
    m_emphasisFocusItemHeight((VfxU32)(VCP_LIST_MENU_CELL_HEIGHT_SINGLE_LINE * 1.5f)),
    m_emphasisFocusItem(VcpMenuPos()),    
#if defined(__MMI_VUI_COSMOS_CP__)
    m_seekBar(NULL),
    m_isShadowDisabled(VFX_FALSE),
#endif
    m_isItemSeparaterHidden(VFX_FALSE),
    m_isItemHighlightHidden(VFX_FALSE),
    m_isDraggingCell(VFX_FALSE),
    m_emptyText(NULL),
    m_isScrollStopped(VFX_TRUE),
    m_isInReset(VFX_FALSE),
    m_isNoDisableCheckForTouch(VFX_FALSE)   
{
#if defined(__MMI_VUI_COSMOS_CP__)
    m_themeData.bgColor = VFX_COLOR_RES(VCP_COL_LIST_MENU_BG).value;
    m_themeData.normalTextColor = VFX_COLOR_RES(VCP_COL_LIST_MENU_NORMAL_TEXT).value;
    m_themeData.highlightTextColor = VFX_COLOR_RES(VCP_COL_LIST_MENU_HIGHLIGHT_TEXT).value;
    m_themeData.lowlightTextColor = VFX_COLOR_RES(VCP_COL_LIST_MENU_LOWLIGHT_TEXT).value;
    m_themeData.disabledTextColor = VFX_COLOR_RES(VCP_COL_LIST_MENU_DISABLED_TEXT).value;
    m_themeData.focusNormalTextColor = VFX_COLOR_RES(VCP_COL_LIST_MENU_FOCUS_NORMAL_TEXT).value;
    m_themeData.focusHighlightTextColor = VFX_COLOR_RES(VCP_COL_LIST_MENU_FOCUS_HIGHLIGHT_TEXT).value;
    m_themeData.focusLowlightTextColor = VFX_COLOR_RES(VCP_COL_LIST_MENU_FOCUS_LOWLIGHT_TEXT).value;
    m_themeData.focusDisabledTextColor = VFX_COLOR_RES(VCP_COL_LIST_MENU_FOCUS_DISABLED_TEXT).value;
#endif /* #if defined(__MMI_VUI_COSMOS_CP__) */
}


void VcpBaseListMenu::onInit()
{
#ifdef __MAUI_SOFTWARE_LA__
      SLA_CustomLogging("LIN", SA_start);
#endif 
    VcpBaseMenu::onInit();

    m_signalBoundsChanged.connect(this, &VcpBaseListMenu::onBoundsValueChanged);

    if (m_focusBehavior == VCP_LIST_MENU_FOCUS_BEHAVIOR_ALWAYS)
    {
        getLayout()->setFocusItem(VcpMenuPos(0, 0));
    }

    setAutoAnimate(VFX_TRUE);
#ifdef __MAUI_SOFTWARE_LA__
      SLA_CustomLogging("LIN", SA_stop);
#endif     
}


void VcpBaseListMenu::onDeinit()
{
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LDI", SA_start);
#endif
    VcpBaseMenu::onDeinit();
#ifdef __MAUI_SOFTWARE_LA__
      SLA_CustomLogging("LDI", SA_stop);
#endif    
}


void VcpBaseListMenu::onAfterCreateLayout()
{    
}


void VcpBaseListMenu::onUpdate()
{
#ifdef __MAUI_SOFTWARE_LA__
      SLA_CustomLogging("LUP", SA_start);
#endif   
    VfxBool relayout = m_needRelayout;

    VcpBaseMenu::onUpdate();

    VcpBaseListMenuLayout *layout = (VcpBaseListMenuLayout *)getLayout();

    if (m_focusBehavior == VCP_LIST_MENU_FOCUS_BEHAVIOR_ALWAYS)
    {
        if (!layout) 
        {
            return;
        }

        if (!layout->getFocusItem().isValid())
        {
            updateFocus();
        }
    }

    if (relayout)
    {
        if (m_searchBar)
        {
        #if defined(__MMI_VUI_COSMOS_CP__)
            if (m_seekBar && !m_seekBar->getHidden())
            {
                m_searchBar->setRightMarginWidth(m_seekBar->getSize().width + MENU_SEEK_BAR_GAP);
            }
            else
        #endif
            {
                m_searchBar->setRightMarginWidth(0);
            }

            m_searchBar->updateLayout();
        }
    }

    IVcpListMenuContentProviderInt *contentProvider = getContentProviderInt();

    if (contentProvider)
    {
        if (layout->getGroupCount() == 0 ||
            (layout->getGroupCount() == 1 && !layout->hasGroupHeader(0) && layout->getCellCount(0) == 0))
        {
            VfxWString text;
            VcpListMenuTextColorEnum textColor;
            
            if (contentProvider->getMenuEmptyText(text, textColor))
            {
                if (!m_emptyText)
                {
                    VFX_OBJ_CREATE(m_emptyText, VfxTextFrame, this);
                    //addChildFrame(m_emptyText); //add to Scrollable
                }

                m_emptyText->setString(text);
                m_emptyText->setLineMode(VfxTextFrame::LINE_MODE_MULTI);
                m_emptyText->setAlignMode(VfxTextFrame::ALIGN_MODE_CENTER);
                m_emptyText->setAutoResized(VFX_TRUE);
                {
                    VfxAutoAnimate::begin();
                    VfxAutoAnimate::setDisable(VFX_TRUE);
                    m_emptyText->setSize((VfxS32)(getSize().width * VCP_LIST_MENU_EMPTY_TEXT_WITH_RATIO), 0);
                    m_emptyText->forceUpdate();
                    VfxAutoAnimate::commit();
                }
#if defined(__MMI_VUI_COSMOS_CP__)
                m_emptyText->setColor(VFX_COLOR_RES(CLR_COSMOS_TEXT_EMPTY));
                m_emptyText->setFont(VFX_FONT_RES(FNT_COSMOS_TEXT_EMPTY));
#else /* defined(__MMI_VUI_COSMOS_CP__) */
                m_emptyText->setColor(VFX_COLOR_GREY);
#endif /* defined(__MMI_VUI_COSMOS_CP__) */
                m_emptyText->setAnchor(0.5, 0.5);

                updateEmptyText();

                m_emptyText->setAutoAnimate(VFX_TRUE);
            }
        }
        else if (m_emptyText)
        {
            VFX_OBJ_CLOSE(m_emptyText);
            m_emptyText = NULL;
        }
    }
#ifdef __MAUI_SOFTWARE_LA__
      SLA_CustomLogging("LUP", SA_stop);
#endif       
}


void VcpBaseListMenu::updateAllControls()
{
    VcpMenuRegionIter itr(this, getRealContentRegion());
    VcpListMenuCell *item = NULL;

    while(!itr.isEnd())
    {
        VcpMenuPos p = itr.next();

        if (!p.isGroupHeader())
        {
            item = (VcpListMenuCell *)getCellIfPresent(p.group, p.pos);

            if (item)
            {
                item->updateControls();
            }
        }        
    }
}


void VcpBaseListMenu::updateAllItems()
{
#ifdef __MAUI_SOFTWARE_LA__
      SLA_CustomLogging("LUA", SA_start);
#endif   
    updateLayout();

#if defined(__MMI_VUI_COSMOS_CP__)
    updateSeekBar();
#endif

    VcpMenuRegionIter itr(this, getRealContentRegion());
    VcpListMenuCell *item = NULL;
    VcpGroupListMenuHeader *header = NULL;

    while(!itr.isEnd())
    {
        VcpMenuPos p = itr.next();

        if (!p.isGroupHeader())
        {
            item = (VcpListMenuCell *)getCellIfPresent(p.group, p.pos);

            if (item)
            {
                item->checkUpdate();
            }
        }
        else
        {
            header = (VcpGroupListMenuHeader *)getHeaderIfPresent(p.group);

            if (header)
            {
                header->checkUpdate();
            }
        }
    }
#ifdef __MAUI_SOFTWARE_LA__
      SLA_CustomLogging("LUA", SA_stop);
#endif       
}


void VcpBaseListMenu::resetAllItems(VfxBool needKeepViewState)
{
#ifdef __MAUI_SOFTWARE_LA__
      SLA_CustomLogging("LRA", SA_start);
#endif    
    
    m_emphasisFocusItem = VcpMenuPos();

    VcpBaseMenuViewState viewState;

    m_isInReset = VFX_TRUE;

    if (needKeepViewState)
    {
        getViewState(&viewState);
    }

    
    reset();


    if (needKeepViewState)
    {
        setViewState(&viewState);
    }

#if defined(__MMI_VUI_COSMOS_CP__)
    updateSeekBar();
#endif

    m_isInReset = VFX_FALSE;
#ifdef __MAUI_SOFTWARE_LA__
      SLA_CustomLogging("LRA", SA_stop);
#endif
}

void VcpBaseListMenu::setMenuMode(VcpListMenuModeEnum mode, VfxBool isAnim)
{
    if (m_menuMode == mode)
    {
        return;
    }
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LMM", SA_start);
#endif
    
    m_menuMode = mode;

    VcpMenuRegionIter itr(this, getRealContentRegion());
    VcpListMenuCell *item = NULL;
    
    while(!itr.isEnd())
    {
        VcpMenuPos p = itr.next();

        if (!p.isGroupHeader())
        {
            item = (VcpListMenuCell *)getCellIfPresent(p.group, p.pos);

            if (item)
            {
                if (m_menuMode == VCP_LIST_MENU_MODE_NORMAL)
                {
                    item->hideControl(VcpListMenuCell::CONTROL_MODE_TYPE_MENU_MODE, isAnim);
                }
                else
                {
                    item->showControl(VcpListMenuCell::CONTROL_MODE_TYPE_MENU_MODE, isAnim);
                }

                item->updateDisabledForground();
            }
        }
    }

    updateLayout();
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LMM", SA_stop);
#endif    
}


void VcpBaseListMenu::setMenuControlMode(VcpListMenuControlModeEnum mode, VfxBool isAnim)
{
    if (m_menuControlMode == mode)
    {
        return;
    }
    
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LMC", SA_start);
#endif
    m_menuControlMode = mode;

    VcpMenuRegionIter itr(this, getRealContentRegion());
    VcpListMenuCell *item = NULL;
    
    while(!itr.isEnd())
    {
        VcpMenuPos p = itr.next();

        if (!p.isGroupHeader())
        {
            item = (VcpListMenuCell *)getCellIfPresent(p.group, p.pos);

            if (item)
            {
                if (m_menuControlMode == VCP_LIST_MENU_CONTROL_MODE_NORMAL)
                {
                    item->hideControl(VcpListMenuCell::CONTROL_MODE_TYPE_CONTROL_MODE, isAnim);
                }
                else
                {
                    item->showControl(VcpListMenuCell::CONTROL_MODE_TYPE_CONTROL_MODE, isAnim);
                }
            }
        }
    }

    updateLayout();
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LMC", SA_stop);
#endif    
}


VcpListMenuSearchBar * VcpBaseListMenu::enableSearchBar(VfxBool isAnim)
{
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LES", SA_start);
#endif


    if (!m_searchBar)
    {
        VFX_OBJ_CREATE(m_searchBar, VcpListMenuSearchBar, this);

    #if defined(__MMI_VUI_COSMOS_CP__)
        if (m_seekBar && !m_seekBar->getHidden())
        {
            m_searchBar->setRightMarginWidth(m_seekBar->getSize().width + MENU_SEEK_BAR_GAP);
        }
    #endif

        m_searchBar->setLeftMarginWidth(MENU_SEEK_BAR_GAP);
        m_searchBar->setBounds(0, 0, getBounds().getWidth(), VCP_LIST_MENU_SEARCH_BAR_HEIGHT);

        if (m_cellbgColor != VfxColor(VRT_COLOR_TRANSPARENT))
        {
            m_searchBar->setBgColor(m_cellbgColor);
        }

        addMarginAreaFrame(VCP_LIST_MENU_MARGIN_AREA_TOP,
                    VCP_LIST_MENU_MARGIN_AREA_FRAME_PLACEMENT_FULL,
                    m_searchBar);
        

    #if defined(__MMI_VUI_COSMOS_CP__)
        updateSeekBar();
    #endif
    }

#ifdef __MAUI_SOFTWARE_LA__
              SLA_CustomLogging("LES", SA_stop);
#endif

    return m_searchBar;
}


void VcpBaseListMenu::addMarginAreaFrame(VcpListMenuMarginAreaEnum area, VcpListMenuMarginAreaFramePlacementEnum placement, VfxFrame *frame)
{
    VcpBaseMenuMarginAreaEnum a = (VcpBaseMenuMarginAreaEnum) area;
    VcpBaseMenuMarginAreaFramePlacementEnum p = (VcpBaseMenuMarginAreaFramePlacementEnum) placement;
    
    addMarginItem(a, p, frame);
}

void VcpBaseListMenu::removeMarginAreaFrame(VfxFrame *frame)
{
    removeMarginItem(frame);    
}



void VcpBaseListMenu::disableSearchBar(VfxBool isAnim)
{
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LDS", SA_start);
#endif
    if (m_searchBar)
    {
        removeMarginAreaFrame(m_searchBar);

        VFX_OBJ_CLOSE(m_searchBar);

        m_searchBar = NULL;

        updateLayout();

    #if defined(__MMI_VUI_COSMOS_CP__)
        updateSeekBar();
    #endif
    }
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LDS", SA_stop);
#endif    
}


VfxBool VcpBaseListMenu::isSearchBarEnabled()
{
    if (!m_searchBar)
    {
        return VFX_FALSE;
    }
    else 
    {
        return !m_searchBar->getHidden();
    }
}



#if defined(__MMI_VUI_COSMOS_CP__)
void VcpBaseListMenu::enableSeekBar(VfxBool isAnim)
{
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LEs", SA_start);
#endif
    if (!m_seekBar)
    {
        VFX_OBJ_CREATE(m_seekBar, VcpMenuSeekBar, this);
        
        m_seekBar->setHeight(getBounds().getHeight());
        m_seekBar->setPos(getBounds().getWidth(), 0);

        m_seekBar->setAutoAnimate(VFX_TRUE);

        /* Cannot have onInit animation because the size of page is incorrect.
        As a result, seek bar position becomes negative first and positive in onBoundsValueChanged. */
        
        m_seekBar->setPos(getBounds().getWidth() - m_seekBar->getBounds().getWidth() - MENU_SEEK_BAR_GAP, 0);


        updateSeekBar();

        m_seekBar->m_signalMenuSeekBarTouch.connect(this, &VcpBaseListMenu::onSeekBarTouched);

        updateLayout();
    }
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LEs", SA_stop);
#endif    
}


void VcpBaseListMenu::disableSeekBar(VfxBool isAnim)
{
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LDs", SA_start);
#endif   
    if (m_seekBar)
    {
        VfxAutoAnimate::begin();
        VfxAutoAnimate::setDisable(!isAnim);
        
        m_seekBar->m_signalMenuSeekBarTouch.disconnect(this, &VcpBaseListMenu::onSeekBarTouched);

        VFX_OBJ_CLOSE(m_seekBar);

        m_seekBar = NULL;

        updateLayout();

        VfxAutoAnimate::commit();
    }
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LDs", SA_stop);
#endif       
}



void VcpBaseListMenu::onSeekBarTouched(VfxId id)
{
    if (id == 0)
    {
        if (m_searchBar)
        {
            makeVisible(
                m_searchBar->getRect(), 
                VFX_TRUE);
            return ;
        }
    }
    
    VcpMenuPos posJumpTo;

    IVcpListMenuContentProviderInt *contentProvider = getContentProviderInt();

    if (contentProvider && contentProvider->getItemPosNeedJumpTo(id, posJumpTo))
    {
        vcpListMenuHelperSetVisibleMenuRegion(this, posJumpTo, VcpMenuPos(-1, -1), VFX_TRUE, HEADER_GAP, VFX_TRUE);        
    }
}


void VcpBaseListMenu::setSeekBarHidden(VfxBool isHidden, VfxBool isAnim)
{
    if (m_seekBar)
    {
        VfxAutoAnimate::begin();
        VfxAutoAnimate::setDisable(!isAnim);
    
        m_seekBar->setHidden(isHidden);

        updateLayout();

        VfxAutoAnimate::commit();
    }
}


void VcpBaseListMenu::updateSeekBar()
{
    if (!m_seekBar)
    {
        return;
    }

    IVcpListMenuContentProviderInt *contentProvider = getContentProviderInt();

    if (contentProvider)
    {
        m_seekBar->clearAllItems();

        VfxU32 seekEntryCount = contentProvider->getSeekBarEntryCount();
        VfxWString text;


        for (VfxU32 i = 0; i < seekEntryCount; i++)
        {
            if (contentProvider->getSeekBarEntryText(i, text))
            {
                m_seekBar->addTextItem(i, text);
            }
        }
    }
}
    

VfxBool VcpBaseListMenu::isSeekBarEnabled()
{
    if (!m_seekBar)
    {
        return VFX_FALSE;
    }
    else 
    {
        return !m_seekBar->getHidden();
    }
}
#endif /* #if defined(__MMI_VUI_COSMOS_CP__) */

void VcpBaseListMenu::setItemSeparatorHidden(VfxBool isHidden)
{
    if (m_isItemSeparaterHidden != isHidden)
    {
        m_isItemSeparaterHidden = isHidden;

        updateAllItems();
    }
}


VfxBool VcpBaseListMenu::getItemSeparatorHidden()
{
    return m_isItemSeparaterHidden;
}


void VcpBaseListMenu::setItemHighlightHidden(VfxBool isHidden)
{
    if (m_isItemHighlightHidden != isHidden)
    {
        m_isItemHighlightHidden = isHidden;

        updateAllItems();
    }
}


VfxBool VcpBaseListMenu::getItemHighlightHidden()
{
    return m_isItemHighlightHidden;
}


void VcpBaseListMenu::onAddChild(VfxObject *child)
{
#if defined(__MMI_VUI_COSMOS_CP__)
    VcpMenuSeekBar *seekBar = VFX_OBJ_DYNAMIC_CAST(child, VcpMenuSeekBar);
    if (seekBar) 
    {
        VfxControl::onAddChild(child); //must set parent as scrollable so seekbar hint can get correct parent
    }
    else
#endif
    {
        VcpBaseMenu::onAddChild(child); //set parent as scrollableView
    }
}

void VcpBaseListMenu::onObjectNotify(VfxId id, void *userData)
{
    switch (id)
    {
        case VFX_OBJECT_NOTIFY_ID_ADD_CHILD:
        {
            VfxObject* obj = (VfxObject*)userData;
            onAddChild(obj);
            return; 
        }       
        default:
        {
            VcpBaseMenu::onObjectNotify(id, userData);
            return;
        }
    }

}

VfxBool VcpBaseListMenu::onSerialize(VfxArchive &ar)
{
    VcpListMenuHistoryStruct history;
    
    getHistory(&history);

    ar.write((VfxU8 *)&history, sizeof(VcpListMenuHistoryStruct));

    return VFX_TRUE;
}


void VcpBaseListMenu::onRestore(VfxArchive &ar)
{
    VcpListMenuHistoryStruct history;

    ar.read((VfxU8 *)&history, sizeof(VcpListMenuHistoryStruct));

    setHistory(&history);
}


void VcpBaseListMenu::onViewScrollStart()
{
    if (m_isScrollStopped)
    {
        m_signalViewScrollStart.postEmit(this);
        m_isScrollStopped = VFX_FALSE;
    }
}


void VcpBaseListMenu::onViewScrollEnd()
{
    if (!m_isDraggingCell)
    {
        m_signalViewScrollEnd.postEmit(this);
        m_isScrollStopped = VFX_TRUE;
    }

    updateFocus();
}


void VcpBaseListMenu::updateFocus()
{
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LUF", SA_start);
#endif   
    if (m_focusBehavior == VCP_LIST_MENU_FOCUS_BEHAVIOR_ALWAYS && !m_view->m_isDragging && !m_isDraggingCell)
    {
        VcpBaseListMenuLayout *layout = (VcpBaseListMenuLayout *)getLayout();

        if (!layout) 
        {
            return;
        }

        VcpMenuPos highlightPos, focusItem = layout->getFocusItem();
        
        VcpMenuRegion visibleRegion = layout->queryRegion(m_view->getBounds());

        if (focusItem.isValid())
        {
            if (!visibleRegion.isWithin(layout->getFocusItem()))
            {
                highlightPos = layout->queryPosByPt(m_view->getBounds().origin);                                

                if (!highlightPos.isValid())
                    return;

                if (!getContentProviderInt())
                    return;

                if (getContentProviderInt()->getItemIsDisabled(highlightPos))
                {
                    if (!layout->getNextEnabledPos(highlightPos))
                    {
                        return;
                    }
                }
            }
            else
            {
                return;
            }
        }
        else
        {
            highlightPos = visibleRegion.begin;
        }

        layout->setFocusItem(highlightPos);
    }
#ifdef __MAUI_SOFTWARE_LA__
          SLA_CustomLogging("LUF", SA_stop);
#endif       
}


void VcpBaseListMenu::setBgColor(const VfxColor &value)
{
    // For performance, if App set the background color to VcpBaseListMenu, we change to set
    // the color to cells, then the cells could be cached to increase performance

    VcpBaseMenu::setBgColor(value);
    
    if (value.isOpaque())
    {
        m_cellbgColor = value;
    }
    else
    {
        m_cellbgColor = VRT_COLOR_TRANSPARENT;
    }
}


void VcpBaseListMenu::setImgContent(const VfxImageSrc &value)
{
    VcpBaseMenu::setImgContent(value);
    
    if (!value.isNull())
    {
        m_cellbgColor = VRT_COLOR_TRANSPARENT;
    }
}


void VcpBaseListMenu::setBounds(const VfxRect &value)
{  
    if (value.getWidth() != m_bounds.getWidth())
    {
        updateLayout(); // For rotation, if the width is changed, should call updateLayout
    }

    VcpBaseMenu::setBounds(value);

}


VfxFrame* VcpBaseListMenu::createCell(VfxS32 group, VfxS32 pos)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LCC", SA_start);
#endif   
    VcpListMenuCell *item;
    
    VFX_OBJ_CREATE_EX(item, VcpListMenuCell, this, (m_cellStyle, VcpMenuPos(group, pos)));
          
#if defined(__MMI_VUI_COSMOS_CP__)          
    if (m_seekBar && !m_seekBar->getHidden())
    {
        item->setTailMarginWidth(m_seekBar->getSize().width + MENU_SEEK_BAR_GAP);
    }
#endif
          
    if (m_cellbgColor != VfxColor(VRT_COLOR_TRANSPARENT))
    {
        item->setBgColor(m_cellbgColor);
    }
    
    //if (m_focusBehavior == VCP_LIST_MENU_FOCUS_BEHAVIOR_ALWAYS)
    {
        if (getLayout()->getFocusItem() == VcpMenuPos(group, pos))
        {
            item->setHighlight(VFX_TRUE, VFX_FALSE);

#if defined(__MMI_VUI_COSMOS_CP__)
            item->updateShadow(VFX_FALSE);
#endif
        }
    }
    
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LCC", SA_stop);
#endif   
    return item;
}

void VcpBaseListMenu::onCloseCell(VfxS32 group, VfxS32 pos, VfxFrame* cellFrame) 
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LOC", SA_start);
#endif      
    VFX_OBJ_CLOSE(cellFrame);
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LOC", SA_stop);
#endif  
}


void VcpBaseListMenu::onUpdateCell(const VfxRect &rect, VfxS32 group, VfxS32 pos, VfxFrame* cell, VfxU32 flag) 
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LUC", SA_start);
#endif  
    VcpListMenuCell* item = (VcpListMenuCell*) cell;

#if defined(__MMI_VUI_COSMOS_CP__)
    if (m_seekBar && !m_seekBar->getHidden())
    {
        item->setTailMarginWidth(m_seekBar->getSize().width + MENU_SEEK_BAR_GAP);
    }
    else
#endif
    {
        item->setTailMarginWidth(0);
    }

    item->updatePos(rect, VFX_TRUE);
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LUC", SA_stop);
#endif  
}

void VcpBaseListMenu::onFocusIndexChange(VcpMenuPos focusItem, VcpMenuPos previousFocusItem)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LFC", SA_start);
#endif  
    if (previousFocusItem.isValid() && !previousFocusItem.isGroupHeader())
    {
        VcpListMenuCell* item = (VcpListMenuCell*) getCellIfPresent(previousFocusItem.group, previousFocusItem.pos);
        
        if (item)
        {
            if (!m_isInReset)
            {               
                item->setHighlight(VFX_FALSE, VFX_FALSE);
            }
        }
    }
    
    if (focusItem.isValid() && !focusItem.isGroupHeader())
    {
        VcpListMenuCell* item = (VcpListMenuCell*) getCellIfPresent(focusItem.group, focusItem.pos);
        
        if (item)
        {
            if (!m_isInReset)
            {
                VcpMenuRegion region = getRealContentRegion();                
                VcpMenuRegionIter   itr(m_layout, region);
                while(!itr.isEnd())
                {
                    VcpMenuPos p = itr.next();
                    VcpListMenuCell* c = (VcpListMenuCell*) getCellIfPresent(p.group, p.pos);       
                    if (c && c->getImgContent() == VfxImageSrc(VCP_IMG_LIST_MENU_HIGHLIGHT_ITEM_BACKGROUND))
                    {
                        c->onDelayedHighlight(NULL);                        
                    }
                }
                item->setHighlight(VFX_TRUE, VFX_FALSE);
            }
        }
    }
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LFC", SA_stop);
#endif      
}


void VcpBaseListMenu::onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds)
{

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LBC", SA_start);
#endif  

#if defined(__MMI_VUI_COSMOS_CP__)
    if (m_seekBar)
    {
        m_seekBar->setHeight(getBounds().getHeight());
        m_seekBar->setPos(getBounds().getWidth() - m_seekBar->getBounds().getWidth() - MENU_SEEK_BAR_GAP, 0);
    }
#endif

    if (m_emptyText)
    {
        updateEmptyText();
    }
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LBC", SA_stop);
#endif      
}

void VcpBaseListMenu::updateEmptyText()
{
    VfxPoint p = m_view->getBounds().getMidPoint();
    p.y = (m_layout->getTotalLength() + m_layout->getMarginLength(VCP_BASE_MENU_MARGIN_AREA_TOP)) / 2;
    m_emptyText->setPos(p);
}


void VcpBaseListMenu::onDragStart()
{
    VcpBaseMenu::onDragStart();

    
}

void VcpBaseListMenu::onDragEnd()
{
    VcpBaseMenu::onDragEnd();
}

void VcpBaseListMenu::onDrag(VfxS32 xoffset, VfxS32 yoffset)
{
    VcpBaseMenu::onDrag(xoffset, yoffset);
    if (m_focusBehavior == VCP_LIST_MENU_FOCUS_BEHAVIOR_SEMI)
    {
        getLayout()->clearFocusItem();
    }
}



/***************************************************************************** 
 * Class VcpBaseListMenuLayout
 *****************************************************************************/

VFX_IMPLEMENT_VIRTUAL_CLASS("VcpBaseListMenuLayout", VcpBaseListMenuLayout, VcpBaseMenuLayout);

VcpBaseListMenuLayout::VcpBaseListMenuLayout(VcpBaseMenu* menu) :
    VcpBaseMenuLayout(menu)
{
}
void VcpBaseListMenuLayout::onInit()
{   
    VcpBaseMenuLayout::onInit();
        
}

VcpMenuRegion VcpBaseListMenuLayout::queryRegion(const VfxRect& r)
{
    return VcpMenuRegion(
            queryPosByPt(r.origin),
            queryPosByPt(VfxPoint(r.getMaxX(), r.getMaxY()))
        );
}

VfxBool VcpBaseListMenuLayout::navDir(NavDirEnum dir)
{
    // Igore left and right
    if (!((dir == NAV_DIR_UP) || (dir == NAV_DIR_DOWN)))
    {
        return VFX_FALSE;
    }

    VcpMenuRegion visibleRegion = queryRegion(m_viewRect);

#if defined(__MMI_VUI_COSMOS_CP__)
    VcpMenuPos pos = (dir == NAV_DIR_UP) ? (visibleRegion.begin) : (visibleRegion.end);

    VcpMenuPos newPos = pos.getPrevPos(this, VFX_TRUE);
    if(dir == NAV_DIR_UP)
    {
        newPos = pos.getPrevPos(this, VFX_TRUE);                
    }
    else
    {
        newPos = pos.getNextPos(this, VFX_TRUE);
    }

    VfxRect targetRect = m_viewRect;

    vcpBaseMenuNavDirHelper(this->m_pMenu, this, dir, pos, newPos, targetRect);

    m_pMenu->makeVisible(targetRect, VFX_TRUE);

    return VFX_TRUE;

#else /* defined(__MMI_VUI_COSMOS_CP__) */

    VcpBaseListMenu *listMenu = VFX_STATIC_CAST(m_pMenu, VcpBaseListMenu *);
    IVcpListMenuContentProviderInt *contentProvider = listMenu->getContentProviderInt();

    VcpMenuPos focusItem = m_pMenu->getFocusItem();
    VcpMenuPos focusMarginItem = m_pMenu->getFocusMarginItem();

   
    if(!focusItem.isValid())
    {   
        VcpMenuPos oldfocus;
        if(focusMarginItem.isValid())                
        {
            oldfocus = focusMarginItem;
            if (dir == NAV_DIR_UP)
            {
                if (focusMarginItem.group == VCP_BASE_MENU_MARGIN_AREA_TOP && 
                   focusMarginItem.pos == m_pMenu->m_marginItemArray[focusMarginItem.group].size() - 1)
                {
                    return VFX_TRUE;                    
                }
                if (focusMarginItem.group == VCP_BASE_MENU_MARGIN_AREA_TOP)
                {
                    focusMarginItem.pos++;                    
                }
                else if (focusMarginItem.group == VCP_BASE_MENU_MARGIN_AREA_BOTTOM)
                {
                    focusMarginItem.pos--;
                }
            }
            else if (dir == NAV_DIR_DOWN)
            {
                if (focusMarginItem.group == VCP_BASE_MENU_MARGIN_AREA_BOTTOM && 
                   focusMarginItem.pos == m_pMenu->m_marginItemArray[focusMarginItem.group].size() - 1)
                {
                    return VFX_TRUE;                    
                }
                if (focusMarginItem.group == VCP_BASE_MENU_MARGIN_AREA_TOP)
                {
                    focusMarginItem.pos--;                    
                }
                else if (focusMarginItem.group == VCP_BASE_MENU_MARGIN_AREA_BOTTOM)
                {
                    focusMarginItem.pos++;
                }                
            }
            if(focusMarginItem.pos < 0)
            {
                focusMarginItem.invalid();                
            }            
        }
        else
        {
            focusMarginItem = vcpBaseMenuLayoutQueryMarginItemByPt(m_pMenu, this, m_viewRect.origin);
        }

        if (focusMarginItem.isValid())
        {
            m_pMenu->setFocusMarginItem(focusMarginItem, VFX_TRUE);                    
            return VFX_TRUE;
        }

        VcpMenuPos p;

        if(oldfocus.isValid())
        {
            VfxRect fr = queryMarginItemRect(oldfocus);
            if (dir == NAV_DIR_UP)
            {
                p = queryPosByPt(VfxPoint(fr.getMinX(), fr.getMinY() - 5)); 
                
            }
            else if (dir == NAV_DIR_DOWN)
            {
                p = queryPosByPt(VfxPoint(fr.getMaxX(), fr.getMaxY() + 5)); 
            }
        }
        else
        {
           p = queryPosByPt(m_viewRect.origin);    
        }

   
         
        // we cannot focus on the header
        if (p.isGroupHeader()) 
        {
            p.pos = 0;
        }      

        if (contentProvider->getItemIsDisabled(p))
        {
            if (dir == NAV_DIR_UP && getNextEnabledPos(p))
            {
                m_pMenu->setFocusItem(p);
                return VFX_TRUE;
            }
            else if (dir == NAV_DIR_DOWN && getPrevEnabledPos(p))
            {
                m_pMenu->setFocusItem(p);
                return VFX_TRUE;
            }
            else
            {
                return VFX_FALSE;
            }
        }
        else
        {
            m_pMenu->setFocusItem(p);
            return VFX_TRUE;
        }
    }
    else if (focusItem.isValid() && !visibleRegion.isWithin(focusItem))
    {
        VcpMenuPos highlightPos;
        
        if (visibleRegion.begin.group > focusItem.group ||
            (visibleRegion.begin.group == focusItem.group &&
             visibleRegion.begin.pos >= focusItem.pos))
        {
            VcpMenuPos p = vcpBaseMenuLayoutQueryMarginItemByPt(m_pMenu, this, m_viewRect.origin);   
            if(p.isValid())
            {
                m_pMenu->setFocusMarginItem(p, VFX_TRUE);                    
                return VFX_TRUE;
            }
            highlightPos = visibleRegion.begin;                             
            if (contentProvider->getItemIsDisabled(highlightPos))
            {
                if (!getNextEnabledPos(highlightPos))
                {                        
                    return VFX_FALSE;
                }
            }
        }
        else
        {
            VcpMenuPos p = vcpBaseMenuLayoutQueryMarginItemByPt(m_pMenu, this, VfxPoint(m_viewRect.getMaxX(), m_viewRect.getMaxY()));
            if(p.isValid())
            {
                m_pMenu->setFocusMarginItem(p, VFX_TRUE);                    
                return VFX_TRUE;
            }                
            highlightPos = visibleRegion.end;

            if (contentProvider->getItemIsDisabled(highlightPos))
            {
                if (!getPrevEnabledPos(highlightPos))
                {
                    return VFX_FALSE;
                }
            }
        }

        if (!highlightPos.isGroupHeader())
        {
            m_pMenu->setFocusItem(highlightPos);
            return VFX_TRUE;
        }
        else
        {
            return VFX_FALSE;
        }
    }
    else /*focusItem && within visibleRegion*/
    {           
        VcpMenuPos f = focusItem;
        VfxRect fr = queryCellRect(focusItem);
      
        if (dir == NAV_DIR_UP)
        {
           if (!getPrevEnabledPos(f))
           {                
                VcpMenuPos p = vcpBaseMenuLayoutQueryMarginItemByPt(m_pMenu, this, VfxPoint(fr.getMinX(), fr.getMinY() - 5));
                if(p.isValid())
                {
                    m_pMenu->setFocusMarginItem(p, VFX_TRUE);                    
                    return VFX_TRUE;
                }               
               return VFX_FALSE;
           }
        }
        if (dir == NAV_DIR_DOWN)
        {
           if (!getNextEnabledPos(f))
           {
               VcpMenuPos p = vcpBaseMenuLayoutQueryMarginItemByPt(m_pMenu, this, VfxPoint(fr.getMaxX(), fr.getMaxY() + 5));
               if(p.isValid())
               {
                   m_pMenu->setFocusMarginItem(p, VFX_TRUE);                    
                   return VFX_TRUE;
               }               
               return VFX_FALSE;
           }
        }

        if (f.isValid())
        {
           m_pMenu->setFocusItem(f);
           return VFX_TRUE;
        }

    }

   
    return VFX_FALSE;
#endif /* defined(__MMI_VUI_COSMOS_CP__) */
}


VfxBool VcpBaseListMenuLayout::getNextEnabledPos(VcpMenuPos &pos)
{
    VcpBaseListMenu *listMenu = VFX_STATIC_CAST(m_pMenu, VcpBaseListMenu *);
    
    IVcpListMenuContentProviderInt *contentProvider = listMenu->getContentProviderInt();
    
    do
    {
        if (pos.group == getGroupCount() - 1 && pos.pos == getCellCount(pos.group) - 1)
        {
            pos.invalid();
        }
        else
        {
            pos = pos.getNextPos(this, VFX_FALSE);
        }

        if (!pos.isValid())
        {
            return VFX_FALSE;
        }
        
    }while (contentProvider->getItemIsDisabled(pos));

    if (pos.isValid())
    {
        return VFX_TRUE;
    }
    else
    {
        return VFX_FALSE;
    }
}


VfxBool VcpBaseListMenuLayout::getPrevEnabledPos(VcpMenuPos &pos)
{
    VcpBaseListMenu *listMenu = VFX_STATIC_CAST(m_pMenu, VcpBaseListMenu *);
    
    IVcpListMenuContentProviderInt *contentProvider = listMenu->getContentProviderInt();
    
    do
    {
        if (pos.group == 0 && pos.pos == 0)
        {
            pos.invalid();
        }
        else
        {
            pos = pos.getPrevPos(this, VFX_FALSE);
        }

        if (!pos.isValid())
        {
            return VFX_FALSE;
        }
        
    }while (contentProvider->getItemIsDisabled(pos));

    if (pos.isValid())
    {
        return VFX_TRUE;
    }
    else
    {
        return VFX_FALSE;
    }
}


VfxS32 VcpBaseListMenuLayout::getContentLength()
{   
    VfxU32 groupCount = getGroupCount();
    VfxU32 i;
    VfxS32 height = 0, diff = 0;

    VcpBaseListMenu *listMenu = VFX_STATIC_CAST(m_pMenu, VcpBaseListMenu *);
    
    if (listMenu->getFocusStyle() == VCP_LIST_MENU_FOCUS_BEHAVIOR_EMPHASIS &&
        listMenu->getEmphasisFocusItemIndex() != -1)
    {
        diff = listMenu->getEmphasisFocusItemHeight() - m_cellHeight;
    }

    

    for (i = 0; i < groupCount; i++)
    {
        if (getBaseListMenu()->hasGroupHeader(i))
        {           
            height += m_headerHeight;
        }
        height += getCellCount(i) * m_cellHeight;
    }

	VfxS32 emptyStringGap = 0;

    if (getGroupCount() == 0 || (getGroupCount() == 1 && !hasGroupHeader(0) && getCellCount(0) == 0))
	{
        VfxWString text;
        VcpListMenuTextColorEnum textColor;        
        IVcpListMenuContentProviderInt *contentProvider = listMenu->getContentProviderInt();
        if (contentProvider && contentProvider->getMenuEmptyText(text, textColor))
        {
            VfxS32 gap = m_cellHeight;
            VfxS32 baseheight = getMarginLength(VCP_BASE_MENU_MARGIN_AREA_TOP) + getMarginLength(VCP_BASE_MENU_MARGIN_AREA_BOTTOM);
            emptyStringGap = VFX_MAX(gap, m_viewRect.getHeight() - baseheight);            
            diff = 0;
        }     
    }



    return height + diff + getFirstHeaderTopMargin() + emptyStringGap;

}

VfxS32 VcpBaseListMenuLayout::getFirstHeaderTopMargin()
{
    VfxS32 margin = 0;
    for (VfxS32 i = 0 ; i < getGroupCount() ; i++)
    {
        if (getBaseListMenu()->hasGroupHeader(i))
        {
            margin = VFX_TRUE;
            break;
        }
        else
        {
            if (getCellCount(i) > 0)
            {
                break;
            }
        }
    }
    return margin;
}



VfxRect VcpBaseListMenuLayout::queryMarginItemRect(VcpMenuPos pos)
{
    return queryMarginItemRectHelper(m_pMenu, this, m_viewRect, pos, VFX_FALSE);
}



VfxRect VcpBaseListMenuLayout::queryCellRect(VcpMenuPos pos)
{
    VfxS32 y = 0, height = 0;
    VfxS32 i;

    
    for (i = 0; i <= pos.group; i++)
    {
        if (getBaseListMenu()->hasGroupHeader(i))
        {
            y += m_headerHeight;
        }
        
        if (i < pos.group)
        {
            y += (m_cellHeight * getCellCount(i));
        }
        else
        {
            if (pos.pos == -1)
            {
                if (getBaseListMenu()->hasGroupHeader(i))
                {
                    y -= m_headerHeight;
                    height = m_headerHeight;
                }
            }
            else
            {
                y += (m_cellHeight * pos.pos);

                height = m_cellHeight;
            }
            break;
        }
    }

    VcpBaseListMenu *listMenu = getBaseListMenu();
    VcpMenuPos emphasis = listMenu->getEmphasisFocusItem();

    if (listMenu->getFocusStyle() == VCP_LIST_MENU_FOCUS_BEHAVIOR_EMPHASIS &&
        emphasis.isValid())
    {
        VfxU32 emphasisHeight = listMenu->getEmphasisFocusItemHeight();

        if (pos.group > emphasis.group || (pos.group == emphasis.group && pos.pos > emphasis.pos))
        {
            y += (emphasisHeight - m_cellHeight);           
        }
        else if (pos.group == emphasis.group && pos.pos == emphasis.pos)
        {
            height = emphasisHeight;
        }
    }

    y += getMarginLength(VCP_BASE_MENU_MARGIN_AREA_TOP) + getFirstHeaderTopMargin();

    
    return VfxRect(0, y, getViewSize().width, height);
}


VfxRect VcpBaseListMenuLayout::queryGroupHeaderRect(VfxS32 group)
{
    if (!getBaseListMenu()->hasGroupHeader(group))
    {
        return VfxRect(0, 0, 0, 0);
    }

    VfxS32 y = 0, height = 0;
    VfxS32 i;

    for (i = 0; i <= group; i++)
    {
        if (getBaseListMenu()->hasGroupHeader(i))
        {
            y += m_headerHeight;
        }

        if (i < group)
        {
            y += (m_cellHeight * getCellCount(i));
        }
        else if (getBaseListMenu()->hasGroupHeader(i))
        {
            y -= m_headerHeight;
            height = m_headerHeight;
            break;
        }
    }

    VcpBaseListMenu *listMenu = getBaseListMenu();
    VcpMenuPos emphasis = listMenu->getEmphasisFocusItem();

    if (listMenu->getFocusStyle() == VCP_LIST_MENU_FOCUS_BEHAVIOR_EMPHASIS &&
       emphasis.isValid())
    {
       VfxU32 emphasisHeight = listMenu->getEmphasisFocusItemHeight();

       if (group > emphasis.group)
       {
           y += (emphasisHeight - m_cellHeight);           
       }
    }

  
    y += getMarginLength(VCP_BASE_MENU_MARGIN_AREA_TOP) + getFirstHeaderTopMargin();
  
    
    return VfxRect(0, y, getViewSize().width, height);
}



VfxBool VcpBaseListMenuLayout::hasGroupHeader(VfxS32 group)
{
    if (group < 0)
    {
        return VFX_FALSE;
    }

    return getBaseListMenu()->hasGroupHeader(group);
}



/***************************************************************************** 
 * Class VcpListMenu
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VcpListMenu", VcpListMenu, VcpBaseListMenu);
 
VcpListMenu::VcpListMenu() :
    m_itemHeight(VCP_LIST_MENU_CELL_HEIGHT_SINGLE_LINE),    
    m_contentProvider(NULL)
{
}

IVcpListMenuContentProviderInt* VcpListMenu::getContentProviderInt() 
{
    return VFX_STATIC_CAST(m_contentProvider,IVcpListMenuContentProviderInt *);
}


void VcpListMenu::setContentProvider(IVcpListMenuContentProvider *contentProvider)
{
    if (m_contentProvider != contentProvider)
    {
        m_contentProvider = contentProvider;

        updateLayout();
    }
    else
    {
        m_contentProvider = contentProvider;
    }

    if (m_contentProvider)
    {
        m_contentProvider->setMenu(this);      
    }

    
}


void VcpListMenu::setCellStyle(VcpListMenuCellStyleEnum style)
{
    VcpBaseListMenu::setCellStyle(style);

    VfxS32 defaultItemHeight = vcpListMenuHelperGetDefaultItemHeight(style);

    if (defaultItemHeight > 0)
    {
        setItemHeight(defaultItemHeight);
    }
}


void VcpListMenu::setItemState(VfxU32 index, VcpListMenuItemStateEnum state)
{
    updateItem(index);
}

VcpListMenuItemStateEnum VcpListMenu::getItemState(VfxU32 index) const
{
    return m_contentProvider->getItemState(index);
}


VfxU32 VcpListMenu::getItemHeight(VfxU32 index)
{
    return m_itemHeight;
}

void VcpListMenu::setItemHeight(VfxU32 height)
{
    m_itemHeight = height;

    ((VcpListMenuLayout *)m_layout)->setCellHeight(m_itemHeight);
}


void VcpListMenu::updateItem(VfxU32 index)
{
    VcpListMenuCell *item = NULL;
    
    item = (VcpListMenuCell *)getCellIfPresent(0, index);

    if (item)
    {
        item->checkUpdate();
    }
}


VcpListMenuCell* VcpListMenu::getCell(VfxU32 index)
{
    return (VcpListMenuCell *)getCellIfPresent(0, index); 
}

VfxFrame* VcpListMenu::getContentFrame(VfxU32 index)
{
    VcpListMenuCell *pCell = (VcpListMenuCell *)getCellIfPresent(0, index);

    if (pCell)
    {
        return pCell->m_clientFrame;
    }
    else
    {
        return NULL;
    }
}


void VcpListMenu::setThemeData(VcpListMenuThemeStruct &themeData)
{
    VcpBaseListMenu::setThemeData(themeData);

    setBgColor(m_themeData.bgColor);
}



VfxBool VcpListMenu::getItemTextIfPresent(VfxU32 index, VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    VcpListMenuCell *pCell = (VcpListMenuCell *)getCellIfPresent(0, index);

    if (pCell && pCell->m_clientFrame)
    {
        return pCell->m_clientFrame->getText(fieldType, text);
    }
    else
    {
        return VFX_FALSE;
    }
}


void VcpListMenu::setVisibleMenuRegion(VfxS32 beginIndex, VfxS32 endIndex, VfxBool isAnim)
{
    vcpListMenuHelperSetVisibleMenuRegion(this, VcpMenuPos(0, beginIndex), VcpMenuPos(0, endIndex), isAnim, HEADER_GAP, VFX_FALSE);
}


void VcpListMenu::onInit()
{
    VcpBaseListMenu::onInit();
    
    m_signalCmdButtonClickedInt.connect(this, &VcpListMenu::onCmdButtonClickedInt);

    m_signalItemSelectionStateChangedInt.connect(this, &VcpListMenu::onItemStateChangedInt);

#if !defined(__MMI_VUI_COSMOS_CP__)
    registerKeyHandler(VFX_KEY_CODE_ENTER);
#endif /* !defined(__MMI_VUI_COSMOS_CP__) */

    setBgColor(m_themeData.bgColor);
}


VfxBool VcpListMenu::onKeyInput(VfxKeyEvent &event)
{
#if !defined(__MMI_VUI_COSMOS_CP__)
    if (event.type == VFX_KEY_EVENT_TYPE_DOWN)
    {
        if (event.keyCode == VFX_KEY_CODE_ENTER)
        {
            if (getLayout()->getFocusItem() != VcpMenuPos()) 
            {
                m_signalItemSelectedInt.postEmit(getLayout()->getFocusItem());

                return VFX_TRUE;
            }
        }
    }
#endif /* !defined(__MMI_VUI_COSMOS_CP__) */

    return VcpBaseListMenu::onKeyInput(event);
}


VcpBaseMenuLayout* VcpListMenu::createLayout()
{
    VcpListMenuLayout *layout;

    VFX_OBJ_CREATE_EX(layout, VcpListMenuLayout, this, (this));
    
    return layout;
}

    
void VcpListMenu::onTouchCell(VcpMenuPos cellPos, CellTouchTypeEnum touchType, VfxPoint pt, VfxFrame *cell)
{
    if (m_focusBehavior == VCP_LIST_MENU_FOCUS_BEHAVIOR_NONE)
    {
        return;
    }

    if (getContentProvider())
    {
        if (getIsNoDisableCheckForTouch())
        {
            VcpListMenuCell* cell = getCell(cellPos.pos);

            if (cell && cell->getIsDisabledForground())
            {
                return;
            }
        }
        else if (getContentProvider()->getItemIsDisabled(cellPos.pos))
        {
            return;
        }

    }
    
    switch(touchType)
    {
    case TouchDown:
        if (!(m_focusBehavior == VCP_LIST_MENU_FOCUS_BEHAVIOR_EMPHASIS && m_emphasisFocusItem == cellPos))
        {
            getLayout()->setFocusItem(cellPos);
        }
        m_signalItemTouchedDown.postEmit(this, cellPos.pos);
        break;

    case TouchUp:
        if (m_focusBehavior == VCP_LIST_MENU_FOCUS_BEHAVIOR_SEMI ||
            m_focusBehavior == VCP_LIST_MENU_FOCUS_BEHAVIOR_EMPHASIS)
        {
            getLayout()->clearFocusItem();
        }
        if (m_focusBehavior == VCP_LIST_MENU_FOCUS_BEHAVIOR_EMPHASIS)
        {
            if (m_cellStyle == VCP_LIST_MENU_CELL_STYLE_CUSTOM && m_emphasisFocusItem.isValid())
            {
                VfxFrame *f = getContentFrame(m_emphasisFocusItem.pos);
                if (f)
                {
                    VcpListMenuCellClientBaseFrame *c = VFX_STATIC_CAST(f, VcpListMenuCellClientBaseFrame*);
                    if (c)
                    {
                        c->onUpdateEmphasisFocus(VFX_FALSE);
                    }
                }
            }

            m_emphasisFocusItem = cellPos;

            if (m_cellStyle == VCP_LIST_MENU_CELL_STYLE_CUSTOM && m_emphasisFocusItem.isValid())
            {
                VfxFrame *f = getContentFrame(m_emphasisFocusItem.pos);
                VcpListMenuCellClientBaseFrame *c = VFX_STATIC_CAST(f, VcpListMenuCellClientBaseFrame*);
                c->onUpdateEmphasisFocus(VFX_TRUE);
            }

            setVisibleMenuItem(m_emphasisFocusItem.pos, VFX_FALSE);
            updateLayout();
        }
        m_signalItemTouchedUp.postEmit(this, cellPos.pos);
        break;

    case TouchTap:
        m_signalItemTappedInt.emit(VcpMenuPos(0, cellPos.pos));
        m_signalItemTapped.postEmit(this, cellPos.pos);
        break;

    case TouchLongTap:
        m_signalItemLongTapped.postEmit(this, cellPos.pos);
        break;

    default:
        break;
    }
}


void VcpListMenu::onFocusIndexChange(VcpMenuPos focusItem, VcpMenuPos previousFocusItem)
{
    VcpBaseListMenu::onFocusIndexChange(focusItem, previousFocusItem);
    m_signalFocusChanged.postEmit(this, focusItem.pos, previousFocusItem.pos);
    m_signalFocusChangedInt.postEmit(VcpMenuPos(0, focusItem.pos), VcpMenuPos(0, previousFocusItem.pos));
}


void VcpListMenu::startDragCell(VcpMenuPos pos, VfxFrame* dragCell)
{
    getLayout()->clearFocusItem();

    m_isDraggingCell = VFX_TRUE;

    VfxS32     minDistance = 1000 * 1000 + 1000 * 1000; // Set a max distance
    VcpMenuPos pointCell;

    VfxS32 cx = dragCell->getPos().x;
    VfxS32 cy = dragCell->getPos().y;

    VcpMenuRegionIter itr(this, getRealContentRegion());
    
    while(!itr.isEnd())
    {
        VcpMenuPos p = itr.next();

        if (!p.isGroupHeader())
        {
            VfxRect r = getLayout()->queryCellRect(p);                
            VfxS32 x = r.getMidX();
            VfxS32 y = r.getMidY();
            VfxS32 distance = VFX_ABS(cx - x) * VFX_ABS(cx - x) + VFX_ABS(cy - y) * VFX_ABS(cy - y);

            if (minDistance > distance)
            {
                minDistance = distance;
                pointCell = p;
            }
        }
    }

    if (m_contentProvider &&
        pointCell != pos)
    {
        VcpMenuPos newPos = pointCell;
        VcpMenuPos oldPos = pos;
        VfxS32 step = ((newPos.pos - oldPos.pos) >= 0) ? (1) : (-1);
        VcpMenuPos nexPos = oldPos;

        while(nexPos.pos != newPos.pos &&
              nexPos.isValid() &&
              oldPos.isValid())
        {
            nexPos.pos = oldPos.pos + step;

            VcpListMenuCell *cell1 = (VcpListMenuCell *)getCellIfPresent(0, nexPos.pos);
            VcpListMenuCell *cell2 = (VcpListMenuCell *)getCellIfPresent(0, oldPos.pos);

            if (m_contentProvider->swapItem(nexPos.pos, oldPos.pos))
            {
                swapCell(nexPos, oldPos);

                if (cell1 && cell2)
                {
                    cell1->m_pos = oldPos;
                    cell2->m_pos = nexPos;
  
#if defined(__MMI_VUI_COSMOS_CP__)
                    cell1->updateShadow(VFX_FALSE);
                    cell2->updateShadow(VFX_FALSE);
#endif /* defined(__MMI_VUI_COSMOS_CP__) */

                    makeVisible(oldPos);
                    makeVisible(nexPos);
                }
            }

            oldPos.pos = nexPos.pos;
        }
    }

    VfxRect rect = dragCell->getRect();
    rect.origin.y -= rect.getHeight() / 2;
    rect.size.height += rect.getHeight();
    makeVisible(rect);
}

void VcpListMenu::endDragCell(VcpMenuPos pos, VfxFrame* dragCell)
{
    updateLayout();

    m_isDraggingCell = VFX_FALSE;

    m_signalEndDragCell.postEmit(this);
}


void VcpListMenu::onCmdButtonClickedInt(VcpMenuPos pos)
{
    m_signalCmdButtonClicked.postEmit(this, (VfxU32)pos.pos);
}

void VcpListMenu::onItemStateChangedInt(VcpMenuPos pos, VcpListMenuItemStateEnum newState)
{
    m_signalItemSelectionStateChanged.postEmit(this, (VfxU32)pos.pos, newState);
}

/***************************************************************************** 
 * Class VcpListMenuLayout
 *****************************************************************************/

void VcpListMenuLayout::onInit()
{
    VcpBaseListMenuLayout::onInit();

    m_cellHeight = getListMenu()->m_itemHeight; 
}


VfxS32 VcpListMenuLayout::getCellCount(VfxS32 group) 
{
    if (group == 0)
    {
        if (getListMenu()->getContentProvider())
        {
            return (VfxS32)getListMenu()->getContentProvider()->getCount();
        }
        else
        {
            return 0;
        }
    }
    
    return 0;
}



VcpMenuPos VcpListMenuLayout::queryPosByPt(const VfxPoint& pt) 
{
    VcpMenuPos p(0, -1);
    VfxS32 y = pt.y - getMarginLength(VCP_BASE_MENU_MARGIN_AREA_TOP);

    VcpListMenu *listMenu = getListMenu();
    VfxS32 emphasisIndex = listMenu->getEmphasisFocusItemIndex();
    if (listMenu->getFocusStyle() == VCP_LIST_MENU_FOCUS_BEHAVIOR_EMPHASIS &&
        emphasisIndex != -1)
    {
        VfxS32 minY = emphasisIndex *m_cellHeight;
        VfxS32 maxY = minY + listMenu->getEmphasisFocusItemHeight();

        if (y >= maxY)
        {
            p.pos = emphasisIndex + ((y - maxY) / m_cellHeight) + 1;
        }
        else if (y < minY)
        {
            p.pos = y / m_cellHeight;
        }
        else
        {
            p.pos = emphasisIndex;
        }
    }
    else
    {
        p.pos = y / m_cellHeight;
    }

    if (p.pos < 0)
    {
        p.pos = 0;
    }
    if (p.pos >= getCellCount(p.group))
    {
        p.pos = getCellCount(p.group) - 1;
    }

    return p;
}


void VcpListMenuLayout::getPreferFocusMargin(VfxS32 margin[4])
{
    VcpBaseListMenuLayout::getPreferFocusMargin(margin);
}


/***************************************************************************** 
 * Class VcpGroupListMenu
 *****************************************************************************/
VFX_IMPLEMENT_CLASS("VcpGroupListMenu", VcpGroupListMenu, VcpBaseListMenu);
 
VcpGroupListMenu::VcpGroupListMenu() :
    m_itemHeight(VCP_LIST_MENU_CELL_HEIGHT_SINGLE_LINE),
    m_headerHeight(0),
    m_contentProvider(NULL),
    m_isGroupHeaderHidden(VFX_FALSE)
{
    VfxImageSrc headerImgSrc(VCP_IMG_LIST_MENU_GROUP_HEADER_BG);

    m_headerHeight = headerImgSrc.getSize().height;
}
    
IVcpListMenuContentProviderInt* VcpGroupListMenu::getContentProviderInt() 
{
    return VFX_STATIC_CAST(m_contentProvider,IVcpListMenuContentProviderInt *);
}


void VcpGroupListMenu::setContentProvider(IVcpGroupListMenuContentProvider *contentProvider)
{
    if (m_contentProvider != contentProvider)
    {
        m_contentProvider = contentProvider;

        updateLayout();
    }
    else
    {
        m_contentProvider = contentProvider;
    }

    if (m_contentProvider)
    {
        m_contentProvider->setMenu(this);
    }
}


void VcpGroupListMenu::setCellStyle(VcpListMenuCellStyleEnum style)
{
    VcpBaseListMenu::setCellStyle(style);

    VfxS32 defaultItemHeight = vcpListMenuHelperGetDefaultItemHeight(style);

    if (defaultItemHeight > 0)
    {
        setItemHeight(defaultItemHeight);
    }
}


void VcpGroupListMenu::setItemState(VcpMenuPos pos, VcpListMenuItemStateEnum state)
{
    updateItem(pos);
}

VcpListMenuItemStateEnum VcpGroupListMenu::getItemState(VcpMenuPos pos) const
{
    return m_contentProvider->getItemState(pos);
}

void VcpGroupListMenu::setMenuMode(VcpListMenuModeEnum mode, VfxBool isAnim)
{
    switch(mode)
    {
    case VCP_LIST_MENU_MODE_REORDER:
        
        VFX_ASSERT(0); // Reorder mode can't be set to group list menu
        break;
    }

    VcpBaseListMenu::setMenuMode(mode, isAnim);
}


VfxU32 VcpGroupListMenu::getItemHeight()
{
    return m_itemHeight;
}


void VcpGroupListMenu::setItemHeight(VfxU32 height)
{
    m_itemHeight = height;

    ((VcpGroupListMenuLayout *)m_layout)->setCellHeight(m_itemHeight);
}

void VcpGroupListMenu::setHeaderHeight(VfxU32 height)
{
    m_headerHeight = height;

    ((VcpGroupListMenuLayout *)m_layout)->setHeaderHeight(m_headerHeight);
}

VfxU32 VcpGroupListMenu::getHeaderHeight()
{
    return m_headerHeight;
}


void VcpGroupListMenu::updateItem(VcpMenuPos pos)
{
    if (pos.isGroupHeader())
    {
        VcpGroupListMenuHeader *header = NULL;
        
        header = (VcpGroupListMenuHeader *)getHeaderIfPresent(pos.group);

        if (header)
        {
            header->checkUpdate();
        }
    }
    else
    {
        VcpListMenuCell *item = NULL;
        
        item = (VcpListMenuCell *)getCellIfPresent(pos.group, pos.pos);

        if (item)
        {
            item->checkUpdate();
        }
    }
}


VcpListMenuCell* VcpGroupListMenu::getCell(VcpMenuPos pos)
{
    if (pos.pos >= 0)
    {
        return (VcpListMenuCell *)getCellIfPresent(pos.group, pos.pos); 
    }
    else
    {
        return NULL;
    }
}

VfxFrame* VcpGroupListMenu::getContentFrame(VcpMenuPos pos)
{
    if (pos.pos == -1)
    {
        return NULL;
    }
    
    VcpListMenuCell *pCell = (VcpListMenuCell *)getCellIfPresent(pos.group, pos.pos);

    if (pCell)
    {
        return pCell->m_clientFrame;
    }
    else
    {
        return NULL;
    }
}


void VcpGroupListMenu::setThemeData(VcpListMenuThemeStruct &themeData)
{
    VcpBaseListMenu::setThemeData(themeData);

    setBgColor(m_themeData.bgColor);
}


VfxBool VcpGroupListMenu::getItemTextIfPresent(VcpMenuPos pos, VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    if (pos.isGroupHeader())
    {
        VcpGroupListMenuHeader *pHeader = (VcpGroupListMenuHeader *)getHeaderIfPresent(pos.group);

        if (pHeader && fieldType == VCP_LIST_MENU_FIELD_GROUP_HEADER_TEXT)
        {
            return pHeader->getText(VCP_LIST_MENU_FIELD_GROUP_HEADER_TEXT, text);
        }        
        else
        {
            return VFX_FALSE;
        }
    }
    else
    {
        VcpListMenuCell *pCell = (VcpListMenuCell *)getCellIfPresent(pos.group, pos.pos);

        if (pCell && pCell->m_clientFrame)
        {
            return pCell->m_clientFrame->getText(fieldType, text);
        }
        else
        {
            return VFX_FALSE;
        }
    }
}


void VcpGroupListMenu::setVisibleMenuRegion(VcpMenuPos beginPos, VcpMenuPos endPos, VfxBool isAnim)
{
    vcpListMenuHelperSetVisibleMenuRegion(this, beginPos, endPos, isAnim, HEADER_GAP, VFX_TRUE);
}


void VcpGroupListMenu::onInit()
{
    VcpBaseListMenu::onInit();
    
    m_signalCmdButtonClickedInt.connect(this, &VcpGroupListMenu::onCmdButtonClickedInt);

    m_signalItemSelectionStateChangedInt.connect(this, &VcpGroupListMenu::onItemStateChangedInt);

#if !defined(__MMI_VUI_COSMOS_CP__)
    registerKeyHandler(VFX_KEY_CODE_ENTER);
#endif /* !defined(__MMI_VUI_COSMOS_CP__) */

    setBgColor(m_themeData.bgColor);
}


VfxBool VcpGroupListMenu::onKeyInput(VfxKeyEvent &event)
{
#if !defined(__MMI_VUI_COSMOS_CP__)
    if (event.type == VFX_KEY_EVENT_TYPE_DOWN)
    {
        if (event.keyCode == VFX_KEY_CODE_ENTER)
        {
            if (getLayout()->getFocusItem() != VcpMenuPos()) 
            {
                m_signalItemSelectedInt.postEmit(getLayout()->getFocusItem());

                return VFX_TRUE;
            }
        }
    }
#endif /* !defined(__MMI_VUI_COSMOS_CP__) */

    return VcpBaseListMenu::onKeyInput(event);
}


VcpBaseMenuLayout* VcpGroupListMenu::createLayout()
{
    VcpGroupListMenuLayout *layout;

    VFX_OBJ_CREATE_EX(layout, VcpGroupListMenuLayout, this, (this));
    
    return layout;
}

VfxFrame* VcpGroupListMenu::createGroupHeader(VfxS32 group)
{
#ifdef __MAUI_SOFTWARE_LA__
        SLA_CustomLogging("LCH", SA_start);
#endif   

    VcpGroupListMenuHeader *header;
    
    VFX_OBJ_CREATE_EX(header, VcpGroupListMenuHeader, this, (group));
    

#ifdef __MAUI_SOFTWARE_LA__
        SLA_CustomLogging("LCH", SA_stop);
#endif   

    return header;
}


void VcpGroupListMenu::onCloseGroupHeader(VfxS32 group, VfxFrame* groupFrame)
{
#ifdef __MAUI_SOFTWARE_LA__
            SLA_CustomLogging("LOH", SA_start);
#endif 

    VFX_OBJ_CLOSE(groupFrame);

#ifdef __MAUI_SOFTWARE_LA__
        SLA_CustomLogging("LOH", SA_stop);
#endif 

}

void VcpGroupListMenu::onUpdateGroupHeader(const VfxRect &rect, VfxS32 group, VfxFrame* groupObject, VfxU32 flag)
{
    VcpGroupListMenuHeader *header = (VcpGroupListMenuHeader *)groupObject;

    header->setRect(rect);
}


    
void VcpGroupListMenu::onTouchCell(VcpMenuPos cellPos, CellTouchTypeEnum touchType, VfxPoint pt, VfxFrame *cell)
{
    if (m_focusBehavior == VCP_LIST_MENU_FOCUS_BEHAVIOR_NONE)
    {
        return;
    }

    // do nothing for group header
    if (cellPos.pos == -1)
    {
        return;
    }

    if (getContentProvider())
    {
        if (getIsNoDisableCheckForTouch())
        {
            VcpListMenuCell* cell = getCell(cellPos);

            if (cell && cell->getIsDisabledForground())
            {
                return;
            }
        }
        else if (getContentProvider()->getItemIsDisabled(cellPos))
        {
            return;
        }
    }
    
    switch(touchType)
    {
    case TouchDown:
        getLayout()->setFocusItem(cellPos);
        m_signalItemTouchedDown.postEmit(this, cellPos);
        break;

    case TouchUp:
        if (m_focusBehavior == VCP_LIST_MENU_FOCUS_BEHAVIOR_SEMI)
        {
            getLayout()->clearFocusItem();
        }

        m_signalItemTouchedUp.postEmit(this, cellPos);
        break;

    case TouchTap:
        m_signalItemTappedInt.emit(cellPos);
        m_signalItemTapped.postEmit(this, cellPos);
        break;

    case TouchLongTap:
        m_signalItemLongTapped.postEmit(this, cellPos);
        break;

    default:
        break;
    }
}


void VcpGroupListMenu::onFocusIndexChange(VcpMenuPos focusItem, VcpMenuPos previousFocusItem)
{
    VcpBaseListMenu::onFocusIndexChange(focusItem, previousFocusItem);
    m_signalFocusChanged.postEmit(this, focusItem, previousFocusItem);
    m_signalFocusChangedInt.postEmit(focusItem, previousFocusItem);
}

void VcpGroupListMenu::setGroupHeaderHidden(VfxBool isHidden, VfxBool isAmin)
{
    if (m_isGroupHeaderHidden == isHidden)
    {
        return;
    }

    m_isGroupHeaderHidden = isHidden;

    updateLayout();
}

VfxBool VcpGroupListMenu::getGroupHeaderHidden()
{
    return m_isGroupHeaderHidden;
}

VfxBool VcpGroupListMenu::hasGroupHeader(VfxS32 group)
{
    if (m_isGroupHeaderHidden)
    {
        return VFX_FALSE;
    }
    else 
    {
        if (m_contentProvider)
        {
            return m_contentProvider->hasGroupHeader(group);
        }
        else
        {
            return VFX_FALSE;
        }
    }
}

void VcpGroupListMenu::onCmdButtonClickedInt(VcpMenuPos pos)
{
    m_signalCmdButtonClicked.postEmit(this, pos);
}

void VcpGroupListMenu::onItemStateChangedInt(VcpMenuPos pos, VcpListMenuItemStateEnum newState)
{
    m_signalItemSelectionStateChanged.postEmit(this, pos, newState);
}


/***************************************************************************** 
 * Class VcpGroupListMenuLayout
 *****************************************************************************/

void VcpGroupListMenuLayout::onInit()
{
    VcpBaseListMenuLayout::onInit();

    m_cellHeight = getListMenu()->getItemHeight(); 

    m_headerHeight = getListMenu()->getHeaderHeight(); 
}


VfxS32 VcpGroupListMenuLayout::getGroupCount()
{
    if (getListMenu()->getContentProvider())
    {
        if (getListMenu()->getGroupHeaderHidden())
        {
            return 1;
        }
        else
        {
            return (VfxS32)getListMenu()->getContentProvider()->getGroupCount();
        }
    }
    else
    {
        return 0;
    }
}





VfxS32 VcpGroupListMenuLayout::getCellCount(VfxS32 group) 
{
    if (group < 0)
    {
        return 0;
    }

    if (getListMenu()->getContentProvider())
    {
        return (VfxS32)getListMenu()->getContentProvider()->getCount(group);
    }
    else
    {
        return 0;
    }
}

VcpMenuPos VcpGroupListMenuLayout::queryPosByPt(const VfxPoint& pt) 
{
    VcpMenuPos p;
    VfxU32 groupCount = getGroupCount();
    VfxU32 i;
    VfxS32 height = 0;
    VfxS32 y = pt.y - getMarginLength(VCP_BASE_MENU_MARGIN_AREA_TOP) - getFirstHeaderTopMargin();

    p.group = -1;
    p.pos = -1;

    for (i = 0; i < groupCount; i++)
    {
        if (getListMenu()->hasGroupHeader(i))
        {
            height += m_headerHeight;

            if (height > y)
            {
                p.group = i;
                p.pos = -1;
                break;
            }
        }

        if (height + (getCellCount(i) * m_cellHeight) > y)
        {
            p.group = i;
            p.pos = (y - height) / m_cellHeight;
            break;
        }

        height += getCellCount(i) * m_cellHeight;
    }

    if (i == groupCount)
    {
        p.group = i - 1;
        p.pos = getCellCount(i - 1) - 1;
    }

    return p;
}

void VcpGroupListMenuLayout::getPreferFocusMargin(VfxS32 margin[4])
{
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
    VcpBaseListMenuLayout::getPreferFocusMargin(margin);
#endif
}

/***************************************************************************** 
 * Class VcpGroupListMenuHeader
 *****************************************************************************/

VfxBool VcpGroupListMenuHeader::getText(VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    switch (fieldType)
    {
        case VCP_LIST_MENU_FIELD_GROUP_HEADER_TEXT:
            text = m_textFrame1->getString();
            break;
    }

    return VFX_TRUE;
}

void VcpGroupListMenuHeader::onInit()
{
    VfxControl::onInit();

    VFX_OBJ_CREATE(m_textFrame1, VfxTextFrame, this);

    m_textFrame1->setFont(VfxFontDesc(VCP_LIST_MENU_FONT_SIZE_SMALL, VFX_FE1_9));
    m_textFrame1->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
    m_textFrame1->setAnchor(0.0f, 0.5f);
    m_textFrame1->setFullLineHeightMode(VFX_FALSE);
    
#if defined(__MMI_VUI_COSMOS_CP__)    
    m_textFrame1->setColor(VFX_COLOR_RES(VCP_COL_LIST_MENU_HEADER_TEXT));

#endif 


    update();

    m_signalBoundsChanged.connect(this, &VcpGroupListMenuHeader::onBoundsValueChanged);

    setImgContent(VfxImageSrc(VCP_IMG_LIST_MENU_GROUP_HEADER_BG));

    setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);

    setAutoAnimate(VFX_TRUE);
}

void VcpGroupListMenuHeader::onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds)
{
    VfxS32 maxWidth = getSize().width;
    VfxS32 maxHeight = getSize().height;

    m_textFrame1->setPos(GAP, (maxHeight + 1)/ 2);
    m_textFrame1->setSize(maxWidth - GAP * 2, m_textFrame1->getSize().height);

}

VcpBaseListMenu* VcpGroupListMenuHeader::getMenu()
{
    if (getParentFrame() && getParentFrame()->getParentFrame())
    {
        return VFX_STATIC_CAST(getParentFrame()->getParentFrame(), VcpBaseListMenu*);
    }
    
    return NULL;
}

IVcpListMenuContentProviderInt* VcpGroupListMenuHeader::getContentProvider()
{
    VcpBaseListMenu *menu = getMenu();

    if (menu)
    {
        return menu->getContentProviderInt();
    }

    return NULL;
}


void VcpGroupListMenuHeader::onUpdate()
{
    update();
}


void VcpGroupListMenuHeader::update()
{
    IVcpListMenuContentProviderInt* contentProvider = getContentProvider();

    if (contentProvider)
    {
        VfxWString headerText;
        VcpListMenuTextColorEnum textColor;

        if (contentProvider->getItemText(VcpMenuPos(m_group, -1), VCP_LIST_MENU_FIELD_GROUP_HEADER_TEXT, headerText, textColor))
        {
            m_textFrame1->setString(headerText);
            m_textFrame1->forceUpdate();
        }       
    }
}


/***************************************************************************** 
 * Class VcpListMenuCell
 *****************************************************************************/

VcpListMenuCell::VcpListMenuCell(VcpListMenuCellStyleEnum style, VcpMenuPos pos) : 
    m_cellStyle(style),
    m_pos(pos),
    m_isHighlight(VFX_FALSE),
    m_prevHighlight(VFX_FALSE),
    m_headControl(NULL),
    m_tailControl(NULL),
    m_clientFrame(NULL),
    m_headMarginWidth(0),
    m_tailMarginWidth(0),
    m_dragging(VFX_FALSE),
    m_dragPt(VFX_POINT_ZERO),
    m_moveTimer(NULL),
    m_movePt(VFX_POINT_ZERO),
    m_headControlType(VCP_LIST_MENU_CELL_CONTROL_TYPE_NONE),
    m_tailControlType(VCP_LIST_MENU_CELL_CONTROL_TYPE_NONE),
    m_topSeparatorLine(NULL),
    m_bottomSeparatorLine(NULL),
    m_headControlMode(CONTROL_MODE_TYPE_NONE),
    m_tailControlMode(CONTROL_MODE_TYPE_NONE),
#if defined(__MMI_VUI_COSMOS_CP__)
    m_topShadow(NULL),
#endif
    m_isCustomClientFrame(VFX_FALSE),
    m_disabledForground(NULL),
    m_isHeadControlClosing(VFX_FALSE),
    m_isTailControlClosing(VFX_FALSE),
    m_delayTimer(NULL)
{
}

VcpBaseListMenu* VcpListMenuCell::getMenu()
{
    if (getParentFrame() && getParentFrame()->getParentFrame())
    {
        return VFX_STATIC_CAST(getParentFrame()->getParentFrame(), VcpBaseListMenu*);
    }
    
    return NULL;
}


IVcpListMenuContentProviderInt* VcpListMenuCell::getContentProvider()
{
    VcpBaseListMenu *menu = getMenu();

    if (menu)
    {
        return menu->getContentProviderInt();
    }

    return NULL;
}

void VcpListMenuCell::updatePos(const VfxRect& r, VfxBool isAnim)
{
    VfxS32 reducedWidth = m_headMarginWidth + m_tailMarginWidth, moved_x = m_headMarginWidth;
    VfxS32 reducedTail = m_tailMarginWidth, reducedHead = m_headMarginWidth;

    if (m_dragging)
        return;

#ifdef __MAUI_SOFTWARE_LA__
            SLA_CustomLogging("LUp", SA_start);
#endif  
    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(!isAnim);

    setPos(VfxPoint(r.getMidX(), r.getMidY()));
    setBounds(VfxRect(VfxPoint(0, 0), r.size));
    
    setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE,
                            VFX_FRAME_ALIGNER_MODE_NONE,
                            VFX_FRAME_ALIGNER_MODE_SIDE,
                            VFX_FRAME_ALIGNER_MODE_NONE);

    VfxAutoAnimate::commit();

    if (m_tailControl && m_tailControlMode != CONTROL_MODE_TYPE_NONE)
    {
        VfxS32 controlWidth = m_tailControl->getBounds().getWidth();
        
        m_tailControl->setAnchor(VfxFPoint(1, 0.5));

        m_tailControl->setPos(r.getMaxX() - reducedTail - TAIL_CONTROL_RIGHT_GAPS, getSize().height / 2);

        m_tailControl->setAlignParent(VFX_FRAME_ALIGNER_MODE_NONE,
                                      VFX_FRAME_ALIGNER_MODE_NONE,
                                      VFX_FRAME_ALIGNER_MODE_SIDE,
                                      VFX_FRAME_ALIGNER_MODE_NONE);

        reducedWidth += (TAIL_CONTROL_LEFT_GAPS + TAIL_CONTROL_RIGHT_GAPS + controlWidth);
    }

    if (m_headControl && m_headControlMode != CONTROL_MODE_TYPE_NONE)
    {
        VfxS32 controlWidth = 0;

        if (m_headControlType == VCP_LIST_MENU_CELL_CONTROL_TYPE_CUSTOM)
        {
            controlWidth = m_headControl->getBounds().getWidth();
        }

        if (controlWidth == 0)
        {
            controlWidth = HEAD_CONTROL_MAX_WIDTH;
        }
        
        m_headControl->setAnchor(VfxFPoint(0, 0.5));

        m_headControl->setPos(HEAD_CONTROL_LEFT_GAPS + reducedHead, getSize().height / 2);

        m_headControl->setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE,
                                      VFX_FRAME_ALIGNER_MODE_NONE,
                                      VFX_FRAME_ALIGNER_MODE_NONE,
                                      VFX_FRAME_ALIGNER_MODE_NONE);

        m_headControl->setSize(VfxSize(controlWidth, r.getHeight() - HEAD_CONTROL_TOP_GAPS - HEAD_CONTROL_BOTTOM_GAPS));

        reducedWidth += (HEAD_CONTROL_LEFT_GAPS + HEAD_CONTROL_RIGHT_GAPS + controlWidth);
        
        moved_x += (HEAD_CONTROL_LEFT_GAPS + HEAD_CONTROL_RIGHT_GAPS + controlWidth);
    }
    else if (m_headControlMode != CONTROL_MODE_TYPE_NONE)
    {
        reducedWidth += (HEAD_CONTROL_LEFT_GAPS + HEAD_CONTROL_RIGHT_GAPS + HEAD_CONTROL_MAX_WIDTH);
        
        moved_x += (HEAD_CONTROL_LEFT_GAPS + HEAD_CONTROL_RIGHT_GAPS + HEAD_CONTROL_MAX_WIDTH);
    }

    if (m_clientFrame)
    {
        m_clientFrame->setRect(VfxRect(moved_x, 0, 
                                       r.getWidth() - reducedWidth, 
                                       r.getHeight()));

        m_clientFrame->setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE,
                                      VFX_FRAME_ALIGNER_MODE_NONE,
                                      VFX_FRAME_ALIGNER_MODE_SIDE,
                                      VFX_FRAME_ALIGNER_MODE_NONE);
    }

#if defined(__MMI_VUI_COSMOS_CP__)
    if (m_topSeparatorLine)
    {
        m_topSeparatorLine->setRect(0, 0, 0, 0);
    }

    if (m_bottomSeparatorLine)
    {
        m_bottomSeparatorLine->setRect(0, (getBounds().getMaxY() - m_bottomSeparatorLine->getSize().height + 1), getBounds().getWidth(), m_bottomSeparatorLine->getSize().height);
    }
#else /* defined(__MMI_VUI_COSMOS_CP__) */
    if (m_topSeparatorLine)
    {
        m_topSeparatorLine->setRect(VfxRect(VfxPoint(0, 0), VfxSize(getBounds().getWidth(), 1)));
    }

    if (m_bottomSeparatorLine)
    {
        m_bottomSeparatorLine->setRect(VfxRect(VfxPoint(0, getBounds().getMaxY()), VfxSize(getBounds().getWidth(), 1)));
    }
#endif /* defined(defined(__MMI_VUI_COSMOS_CP__) */
#ifdef __MAUI_SOFTWARE_LA__
        SLA_CustomLogging("LUp", SA_stop);
#endif  
}


void VcpListMenuCell::showControl(ControlModeTyepEnum controlModeType, VfxBool isAnim)
{
#ifdef __MAUI_SOFTWARE_LA__
              SLA_CustomLogging("LSc", SA_start);
#endif

    if (m_headControlMode == controlModeType || m_isHeadControlClosing)
    {
        closeHeadControl();
    }

    if (m_tailControlMode == controlModeType || m_isTailControlClosing)
    {
        closeTailControl();
    }

    createControls();

    if (m_disabledForground)
    {
        m_disabledForground->bringToFront();
    }

    if (m_headControlMode == controlModeType)
    {
        showHeadControl(isAnim);
    }

    if (m_tailControlMode == controlModeType)
    {
        showTailControl(isAnim);
    }

#ifdef __MAUI_SOFTWARE_LA__
              SLA_CustomLogging("LSc", SA_stop);
#endif    
}


void VcpListMenuCell::hideControl(ControlModeTyepEnum controlModeType, VfxBool isAnim)
{
#ifdef __MAUI_SOFTWARE_LA__
              SLA_CustomLogging("LHc", SA_start);
#endif
    if (m_headControlMode == controlModeType)
    {
        hideHeadControl(isAnim);
    }

    if (m_tailControlMode == controlModeType)
    {
        hideTailControl(isAnim);
    }


#ifdef __MAUI_SOFTWARE_LA__
              SLA_CustomLogging("LHc", SA_stop);
#endif
}


void VcpListMenuCell::showHeadControl(VfxBool isAnim)
{
#ifdef __MAUI_SOFTWARE_LA__
                  SLA_CustomLogging("LSh", SA_start);
#endif
    if (isAnim)
    {
        if (m_headControl)
        {
            VfxS32 controlWidth = 0;

            if (m_headControlType == VCP_LIST_MENU_CELL_CONTROL_TYPE_CUSTOM)
            {
                controlWidth = m_headControl->getBounds().getWidth();
            }

            if (controlWidth == 0)
            {
                controlWidth = HEAD_CONTROL_MAX_WIDTH;
            }
            
            m_headControl->setAnchor(VfxFPoint(0, 0.5));
            
            m_headControl->setPos(-controlWidth, getSize().height / 2);
            
            m_headControl->setSize(controlWidth, getSize().height - HEAD_CONTROL_TOP_GAPS - HEAD_CONTROL_BOTTOM_GAPS);
            
            VfxS32Timeline *hideTimeLine = NULL;
        
            VFX_OBJ_CREATE(hideTimeLine, VfxS32Timeline, m_headControl);

            hideTimeLine->setTarget(m_headControl);
            hideTimeLine->setTargetPropertyId(VRT_FRAME_PROPERTY_ID_POS_X);
            hideTimeLine->setAutoReversed(VFX_FALSE);
            hideTimeLine->setIsFromCurrent(VFX_FALSE);
            hideTimeLine->setFromValue(m_headControl->getPos().x);
            hideTimeLine->setToValue(HEAD_CONTROL_LEFT_GAPS + m_headMarginWidth);
            hideTimeLine->setDurationTime(250);
            hideTimeLine->setRepeatCount(1);
            hideTimeLine->start();
        }
    }
#ifdef __MAUI_SOFTWARE_LA__
                  SLA_CustomLogging("LSh", SA_stop);
#endif    
}

void VcpListMenuCell::hideHeadControl(VfxBool isAnim)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LHh", SA_start);
#endif


    if (!isAnim || !m_headControl)
    {
        closeHeadControl();
    }
    else
    {
        VfxS32Timeline *hideTimeLine = NULL;
        
        VFX_OBJ_CREATE(hideTimeLine, VfxS32Timeline, m_headControl);

        hideTimeLine->setTarget(m_headControl);
        hideTimeLine->setTargetPropertyId(VRT_FRAME_PROPERTY_ID_POS_X);
        hideTimeLine->setAutoReversed(VFX_FALSE);
        hideTimeLine->setIsFromCurrent(VFX_FALSE);
        hideTimeLine->setFromValue(m_headControl->getPos().x);
        hideTimeLine->setToValue(-m_headControl->getSize().width);
        hideTimeLine->setDurationTime(250);
        hideTimeLine->setRepeatCount(1);
        hideTimeLine->m_signalStopped.connect(this, &VcpListMenuCell::onHideHeadControlTimeLineStopped);
        hideTimeLine->start();

        m_headControlMode = CONTROL_MODE_TYPE_NONE;
        m_isHeadControlClosing = VFX_TRUE;
    }
#ifdef __MAUI_SOFTWARE_LA__
        SLA_CustomLogging("LHh", SA_stop);
#endif    
}


void VcpListMenuCell::onHideHeadControlTimeLineStopped(VfxBaseTimeline *timeline, VfxBool isCompleted)
{
    closeHeadControl();

    VcpBaseListMenu *menu = getMenu();

    if (menu)
    {
        menu->updateLayout();
    }
}


void VcpListMenuCell::showTailControl(VfxBool isAnim)
{
#ifdef __MAUI_SOFTWARE_LA__
                      SLA_CustomLogging("LSt", SA_start);
#endif

    if (isAnim)
    {
        if (m_tailControl)
        {
            VfxS32 controlWidth = m_tailControl->getBounds().getWidth();
            
            m_tailControl->setAnchor(VfxFPoint(1, 0.5));
            
            m_tailControl->setPos(getSize().width + controlWidth, getSize().height / 2);           

            VfxS32Timeline *hideTimeLine = NULL;
        
            VFX_OBJ_CREATE(hideTimeLine, VfxS32Timeline, m_tailControl);

            hideTimeLine->setTarget(m_tailControl);
            hideTimeLine->setTargetPropertyId(VRT_FRAME_PROPERTY_ID_POS_X);
            hideTimeLine->setAutoReversed(VFX_FALSE);
            hideTimeLine->setIsFromCurrent(VFX_FALSE);
            hideTimeLine->setFromValue(m_tailControl->getPos().x);
            hideTimeLine->setToValue(getSize().width - 1 - m_tailMarginWidth - TAIL_CONTROL_RIGHT_GAPS);
            hideTimeLine->setDurationTime(250);
            hideTimeLine->setRepeatCount(1);
            hideTimeLine->start();
        }
    }
#ifdef __MAUI_SOFTWARE_LA__
                      SLA_CustomLogging("LSt", SA_stop);
#endif    
}

void VcpListMenuCell::hideTailControl(VfxBool isAnim)
{
#ifdef __MAUI_SOFTWARE_LA__
                          SLA_CustomLogging("LHt", SA_start);
#endif

    if (!isAnim || !m_tailControl)
    {
        closeTailControl();
    }
    else
    {
        VfxS32Timeline *hideTimeLine = NULL;
        
        VFX_OBJ_CREATE(hideTimeLine, VfxS32Timeline, m_tailControl);

        hideTimeLine->setTarget(m_tailControl);
        hideTimeLine->setTargetPropertyId(VRT_FRAME_PROPERTY_ID_POS_X);
        hideTimeLine->setAutoReversed(VFX_FALSE);
        hideTimeLine->setIsFromCurrent(VFX_FALSE);
        hideTimeLine->setFromValue(m_tailControl->getPos().x);
        hideTimeLine->setToValue(getSize().width - 1 + m_tailControl->getSize().width);
        hideTimeLine->setDurationTime(250);
        hideTimeLine->setRepeatCount(1);
        hideTimeLine->m_signalStopped.connect(this, &VcpListMenuCell::onHideTailControlTimeLineStopped);
        hideTimeLine->start();

        m_tailControlMode = CONTROL_MODE_TYPE_NONE;
        m_isTailControlClosing = VFX_TRUE;
    }

#ifdef __MAUI_SOFTWARE_LA__
                          SLA_CustomLogging("LHt", SA_stop);
#endif    
}


void VcpListMenuCell::onHideTailControlTimeLineStopped(VfxBaseTimeline *timeline, VfxBool isCompleted)
{
    closeTailControl();

    VcpBaseListMenu *menu = getMenu();

    if (menu)
    {
        menu->updateLayout();
    }
}


void VcpListMenuCell::onCellDrag(VfxPenEvent &event)
{
    m_dragging = VFX_TRUE;
    m_dragPt = event.getRelDownPos(this);

    setOpacity(0.75);
    bringToFront();

    VfxPoint origin = getBounds().origin;
    VfxSize  size = getBounds().size;

    origin.y -= VCP_LIST_MENU_REORDER_ITEM_BG_SHADOW_HEIGHT;

    size.height += 2 * VCP_LIST_MENU_REORDER_ITEM_BG_SHADOW_HEIGHT;

    setBounds(VfxRect(origin, size));

    setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
    setImgContent(VfxImageSrc(VCP_IMG_LIST_MENU_REORDERING_ITEM_BACKGROUND));

    if (m_topSeparatorLine)
    {
        m_topSeparatorLine->setHidden(VFX_TRUE);
    }

    if (m_bottomSeparatorLine)
    {
        m_bottomSeparatorLine->setHidden(VFX_TRUE);
    }

#if defined(__MMI_VUI_COSMOS_CP__)
    updateShadow(VFX_TRUE);
#endif

    m_moveTimer->stop();
}


void VcpListMenuCell::onCellMoveInt(VfxPoint &point)
{
    VfxPoint parentPt = getParentFrame()->convertPointFrom(point, this);
    VfxSize sz = getBounds().size;
    VfxPoint origin = getBounds().origin;
    
    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(VFX_TRUE);
    
    setPos(VfxPoint(getPos().x, parentPt.y - m_dragPt.y + sz.height/2 + origin.y));

    VfxAutoAnimate::commit();
    
    getMenu()->startDragCell(m_pos, this);

#if defined(__MMI_VUI_COSMOS_CP__)
    updateShadow(VFX_TRUE);
#endif
}


void VcpListMenuCell::onCellMove(VfxPenEvent &event)
{
    VfxPoint p = event.getRelPos(this);

    m_movePt = event.pos;
    onCellMoveInt(p);

    m_moveTimer->stop();
    m_moveTimer->start();
}


void VcpListMenuCell::onMoveTimeOutFunc(VfxTimer *t)
{
    VfxPenEvent event;
    event.pos = m_movePt;

    VfxPoint p = event.getRelPos(this);
    onCellMoveInt(p);
    m_moveTimer->start();
}

void VcpListMenuCell::onDelayedHighlight(VfxTimer *t)
{
    VFX_UNUSED(t);
    
    VFX_OBJ_CLOSE(m_delayTimer);          
    VfxBool isDisplayHighlight = VFX_FALSE;
    
    if (getMenu() && !getMenu()->getItemHighlightHidden() &&
        getContentProvider() && getContentProvider()->getItemIsHighlightable(m_pos))
    {
        isDisplayHighlight = VFX_TRUE;
    }
    
    if (isDisplayHighlight)
    {
        VfxAutoAnimate::begin();
        VfxAutoAnimate::setDisable(VFX_TRUE);
    
        if (m_isHighlight)
        {
            setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
            setImgContent(VfxImageSrc(VCP_IMG_LIST_MENU_HIGHLIGHT_ITEM_BACKGROUND));
        }
        else
        {
            setImgContent(VFX_IMAGE_SRC_NULL);
            setBgColor(getBgColor());
        }            
    
        m_clientFrame->update(VFX_FALSE);
    
        m_prevHighlight = m_isHighlight;
        
    
        if (m_headControl)
        {
            m_headControl->setHighlight(m_isHighlight);
        }
    
        if (m_tailControl)
        {
            m_tailControl->setHighlight(m_isHighlight);
        }
        
        updateSeparators();
    
        VfxAutoAnimate::commit();
    }

    

#if defined(__MMI_VUI_COSMOS_CP__)
    updateShadow(m_isHighlight);
#endif    
}

void VcpListMenuCell::onCellDrop(VfxPenEvent &event)
{
    VfxPoint origin = getBounds().origin;
    VfxSize  size = getBounds().size;

    origin.y += VCP_LIST_MENU_REORDER_ITEM_BG_SHADOW_HEIGHT;

    size.height -= 2 * VCP_LIST_MENU_REORDER_ITEM_BG_SHADOW_HEIGHT;

    setBounds(VfxRect(origin, size));

    setImgContent(VFX_IMAGE_SRC_NULL);
    
    getMenu()->endDragCell(m_pos, this);
    m_dragging = VFX_FALSE;
    setOpacity(1);

    if (m_topSeparatorLine)
    {
        m_topSeparatorLine->setHidden(VFX_FALSE);
    }

    if (m_bottomSeparatorLine)
    {
        m_bottomSeparatorLine->setHidden(VFX_FALSE);
    }

#if defined(__MMI_VUI_COSMOS_CP__)
    updateShadow(VFX_FALSE);
#endif 

    m_moveTimer->stop();
}


void VcpListMenuCell::setHighlight(VfxBool isHighlight, VfxBool isAnim)
{
    if (m_isHighlight != isHighlight)
    {
        m_isHighlight = isHighlight;

        if (m_isHighlight)
        {
            onDelayedHighlight(NULL);
        }
        else
        {
            VFX_OBJ_CLOSE(m_delayTimer);
            VFX_OBJ_CREATE(m_delayTimer, VfxTimer, this);
            m_delayTimer->m_signalTick.connect(this, &VcpListMenuCell::onDelayedHighlight);
            m_delayTimer->setStartDelay(100);
            m_delayTimer->start();
        }

    }
}


VfxColor VcpListMenuCell::getTextColor(VcpListMenuTextColorEnum colorStyle)
{
    VcpListMenuThemeStruct menuThemeData = getMenu()->getThemeData();

    VfxBool isDisplayHighlight = VFX_FALSE;

    if (getMenu() && !getMenu()->getItemHighlightHidden() &&
        getContentProvider() && getContentProvider()->getItemIsHighlightable(m_pos))
    {
        isDisplayHighlight = VFX_TRUE;
    }

    if (m_isHighlight && isDisplayHighlight)
    {
        switch(colorStyle)
        {
        case VCP_LIST_MENU_TEXT_COLOR_NORMAL:
            return VfxColor(menuThemeData.focusNormalTextColor);
            //break;
            
        case VCP_LIST_MENU_TEXT_COLOR_HIGHLIGHT:
            return VfxColor(menuThemeData.focusHighlightTextColor);
            //break;
            
        case VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT:
            return VfxColor(menuThemeData.focusLowlightTextColor);
            //break;
            
        case VCP_LIST_MENU_TEXT_COLOR_DISABLED:
            return VfxColor(menuThemeData.focusDisabledTextColor);
            //break;

        default:
            VFX_ASSERT(0);
            break;
        }
    }
    else
    {
        switch(colorStyle)
        {
        case VCP_LIST_MENU_TEXT_COLOR_NORMAL:
            return VfxColor(menuThemeData.normalTextColor);
            //break;
            
        case VCP_LIST_MENU_TEXT_COLOR_HIGHLIGHT:
            return VfxColor(menuThemeData.highlightTextColor);
            //break;
            
        case VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT:
            return VfxColor(menuThemeData.lowlightTextColor);
            //break;
            
        case VCP_LIST_MENU_TEXT_COLOR_DISABLED:
            return VfxColor(menuThemeData.disabledTextColor);
            //break;

        default:
            VFX_ASSERT(0);
            break;
        }
    }

    return VfxColor(0, 0, 0, 0);
}

#if defined(__MMI_VUI_COSMOS_CP__)
void VcpListMenuCell::updateShadow(VfxBool isHidden)
{
    if (!m_topShadow)
    {
        if (m_pos.pos == 0 && m_pos.group == 0 && !getMenu()->getShadowIsDisabled())
        {
            VFX_OBJ_CREATE(m_topShadow, VfxImageFrame, this); 

            m_topShadow->sendToBack();

            VfxImageSrc shadowImageSrc(VCP_IMG_LIST_MENU_TOP_SHADOW_D);

            m_topShadow->setImgContent(shadowImageSrc);

            VfxS32 shadowY = 0;

            IVcpListMenuContentProviderInt *contentProvider = getContentProvider();

            if (contentProvider)
            {
                if (contentProvider->hasGroupHeader(m_pos.group))
                {
                    VfxRect headerRect = getMenu()->getLayout()->queryGroupHeaderRect(m_pos.group);

                    shadowY -= headerRect.getHeight();
                }
            }

            m_topShadow->setRect(0, shadowY, getBounds().getWidth(), shadowImageSrc.getSize().height);

            m_topShadow->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
            m_topShadow->setIsUnhittable(VFX_TRUE);
        }
    }
    else 
    {
        if (m_pos.pos != 0 || m_pos.group != 0)
        {
            VFX_OBJ_CLOSE(m_topShadow);

            m_topShadow = NULL;
        }
    }

    if (m_topShadow)
    {   
        VfxBool isDisplayHighlight = VFX_FALSE;

        if (getMenu() && !getMenu()->getItemHighlightHidden() &&
            getContentProvider() && getContentProvider()->getItemIsHighlightable(m_pos))
        {
            isDisplayHighlight = VFX_TRUE;
        }

        if (isDisplayHighlight)
        {
            m_topShadow->setHidden(isHidden);
        }
    }
}
#endif /* #if defined(__MMI_VUI_COSMOS_CP__) */


void VcpListMenuCell::updateDisabledForground()
{
    if (getContentProvider())
    {
        if (getContentProvider()->getItemIsDisabled(m_pos))
        {
            if (!m_disabledForground)
            {
                VFX_OBJ_CREATE(m_disabledForground, VfxFrame, this);
#if defined(__MMI_VUI_COSMOS_CP__)
                m_disabledForground->setBgColor(VFX_COLOR_RES(VCP_COL_LIST_MENU_DISABLE_FG));
                m_disabledForground->setOpacity(0.5f);
#else /* defined(__MMI_VUI_COSMOS_CP__) */
                m_disabledForground->setBgColor(VCP_LIST_MENU_DISABLED_CELL_FORGROUND_COLOR);
#endif /* defined(__MMI_VUI_COSMOS_CP__) */
                m_disabledForground->setRect(0, 0, getBounds().getWidth(), getBounds().getHeight());
            }
            VcpBaseMenuLayout *layout = getMenu()->getLayout();
            if (layout && m_pos == layout->getFocusItem())
            {
                layout->clearFocusItem();
                getMenu()->updateFocus();                
            }
        }
        else if (m_disabledForground)
        {
            VFX_OBJ_CLOSE(m_disabledForground);
            m_disabledForground = NULL;
        }
    }

    if (m_disabledForground)
    {
        m_disabledForground->bringToFront();
    }
}



void VcpListMenuCell::onInit()
{
#ifdef __MAUI_SOFTWARE_LA__
        SLA_CustomLogging("LIC", SA_start);
#endif 
    VfxControl::onInit();

#if defined(__MMI_VUI_COSMOS_CP__)
    updateShadow(VFX_FALSE);
#endif
    
    sendToBack();
    setAnchor(VfxFPoint(0.5, 0.5));
    setIsCached(VFX_TRUE);

    m_dragging = VFX_FALSE;
    VFX_OBJ_CREATE(m_moveTimer, VfxTimer, this);
    m_moveTimer->m_signalTick.connect(this, &VcpListMenuCell::onMoveTimeOutFunc);
    m_moveTimer->setStartDelay(250);

    m_headControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_NONE;

    m_tailControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_NONE;

    createClientFrame();

    m_headControlMode = CONTROL_MODE_TYPE_NONE;

    m_tailControlMode = CONTROL_MODE_TYPE_NONE;

    createControls();
    
    updateSeparators();
    
    updateDisabledForground();
    
    setAutoAnimate(VFX_TRUE);
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LIC", SA_stop);
#endif      
}


void VcpListMenuCell::setBounds(const VfxRect &value)
{
    VfxControl::setBounds(value);

#if defined(__MMI_VUI_COSMOS_CP__)
    if (m_topShadow)
    {
        m_topShadow->setRect(0, 0, getBounds().getWidth(), m_topShadow->getBounds().getHeight());
    }
#endif

    if (m_disabledForground)
    {
        m_disabledForground->setRect(0, 0, getBounds().getWidth(), getBounds().getHeight());
    }
}

void VcpListMenuCell::onDeinit()
{
    closeControls();

    if (m_isCustomClientFrame)
    {
        if (getContentProvider())
        {
            getContentProvider()->closeItemCustomContentFrame(m_pos, m_clientFrame);
        }
        else
        {
            VFX_DEV_ASSERT(0); /* Maybe app doesn't close the custom content frame */
        }
    }
    else
    {
        VFX_OBJ_CLOSE(m_clientFrame);
    }
    
    VfxControl::onDeinit();
}


void VcpListMenuCell::onUpdate()
{
    m_clientFrame->update(VFX_FALSE);

    if (m_headControl)
    {
        m_headControl->update(VFX_FALSE);
    }

    if (m_tailControl)
    {
        m_tailControl->update(VFX_FALSE);
    }

    updateDisabledForground();

    updateSeparators();
    onDelayedHighlight(NULL);
}

void VcpListMenuCell::updateControls()
{
    if (m_headControl)
    {
        m_headControl->update(VFX_FALSE);
    }

    if (m_tailControl)
    {
        m_tailControl->update(VFX_FALSE);
    }
}



void VcpListMenuCell::createClientFrame()
{
    m_isCustomClientFrame = VFX_FALSE;

    if (getContentProvider())
    {
        m_clientFrame = getContentProvider()->getItemCustomContentFrame(m_pos, (VfxFrame *)this);

        if (m_clientFrame)
        {
            m_isCustomClientFrame = VFX_TRUE;
        }
    }

    if (m_cellStyle == VCP_LIST_MENU_CELL_STYLE_CUSTOM)
    {
        VFX_ASSERT(m_clientFrame);
    }

    if (!m_clientFrame)
    {
        switch(m_cellStyle)
        {
        case VCP_LIST_MENU_CELL_STYLE_SINGLE_TEXT:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellSingleTextFrame, this);
            break;
            
        case VCP_LIST_MENU_CELL_STYLE_MULTI_TEXT:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellMultiTextFrame, this);
            break;

        case VCP_LIST_MENU_CELL_STYLE_MULTI_TEXT_EX:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellMultiTextFrameEx, this);
            break;

        case VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellTripleTextFrame, this);
            break;

        case VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT_EX:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellTripleTextFrameEx, this);
            break;
            
        case VCP_LIST_MENU_CELL_STYLE_QUADRUPLE_TEXT:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellQuadTextFrameEx, this);
            break;
            
        case VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellIconSingleTextFrame, this);
            break;

        case VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT_EX:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellIconSingleTextFrameEx, this);
            break;

        case VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT_EX2:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellIconSingleTextFrameEx2, this);
            break;

        case VCP_LIST_MENU_CELL_STYLE_ICON_MULTI_TEXT_EX:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellIconMultiTextExFrame, this);
            break;

        case VCP_LIST_MENU_CELL_STYLE_ICON_MULTI_TEXT:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellIconMultiTextFrame, this);
            break;
        
        case VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellIconTripleTextFrame, this);
            break;

        case VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT_EX:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellIconTripleTextFrameEx, this);
            break;

        case VCP_LIST_MENU_CELL_STYLE_ICON_QUADRUPLE_TEXT:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellIconQuadTextFrame, this);
            break;
            
        case VCP_LIST_MENU_CELL_STYLE_ICON_QUINTUPLE_TEXT:
            VFX_OBJ_CREATE(m_clientFrame, VcpListMenuCellIconQuintTextFrame, this);
            break;

        default:
            break;
        }
    }
}

void VcpListMenuCell::closeHeadControl()
{
#ifdef __MAUI_SOFTWARE_LA__
              SLA_CustomLogging("LOh", SA_start);
#endif
    if (m_headControl)
    {
        if (m_headControlType == VCP_LIST_MENU_CELL_CONTROL_TYPE_CUSTOM)
        {
            if (getContentProvider())
            {
                getContentProvider()->closeItemCustomControl(
                    m_pos, 
                    VCP_LIST_MENU_CELL_CONTROL_LOCATION_TYPE_HEAD, 
                    m_headControl);
            }
        }
        else
        {
            VFX_OBJ_CLOSE(m_headControl);
        }

        m_headControl = NULL;
        m_headControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_NONE;
    }

    m_headControlMode = CONTROL_MODE_TYPE_NONE;
    m_isHeadControlClosing = VFX_FALSE;
#ifdef __MAUI_SOFTWARE_LA__
              SLA_CustomLogging("LOh", SA_stop);
#endif
}

void VcpListMenuCell::closeTailControl()
{
#ifdef __MAUI_SOFTWARE_LA__
              SLA_CustomLogging("LOt", SA_start);
#endif
    if (m_tailControl)
    {
        if (m_tailControlType == VCP_LIST_MENU_CELL_CONTROL_TYPE_CUSTOM)
        {
            if (getContentProvider())
            {
                getContentProvider()->closeItemCustomControl(
                    m_pos, 
                    VCP_LIST_MENU_CELL_CONTROL_LOCATION_TYPE_TAIL, 
                    m_tailControl);
            }
        }
        else
        {
            VFX_OBJ_CLOSE(m_tailControl);
        }
    
        m_tailControl = NULL;
        m_tailControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_NONE;
    }

    m_tailControlMode = CONTROL_MODE_TYPE_NONE;
    m_isTailControlClosing = VFX_FALSE;
#ifdef __MAUI_SOFTWARE_LA__
              SLA_CustomLogging("LOt", SA_stop);
#endif    
}


void VcpListMenuCell::closeControls()
{
    closeHeadControl();
    closeTailControl();
}


void VcpListMenuCell::createControls()
{
    VcpBaseListMenu *menu = getMenu();

    if (!menu)
    {
        return;
    }

    IVcpListMenuContentProviderInt* contentProvider = getContentProvider();

    if (contentProvider == NULL)
    {
        return;
    }
#ifdef __MAUI_SOFTWARE_LA__
                  SLA_CustomLogging("LCc", SA_start);
#endif

    if (!m_headControl && m_headControlMode == CONTROL_MODE_TYPE_NONE)
    {
        m_headControl = contentProvider->getItemCustomControl(m_pos, VCP_LIST_MENU_CELL_CONTROL_LOCATION_TYPE_HEAD, this);

        if (m_headControl)
        {
            VFX_ASSERT(m_headControl->getParentFrame() == this);

            m_headControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_CUSTOM;
            
            m_headControlMode = CONTROL_MODE_TYPE_CUSTOM;
        }
    }

    if (!m_tailControl && m_tailControlMode == CONTROL_MODE_TYPE_NONE)
    {
        m_tailControl = contentProvider->getItemCustomControl(m_pos, VCP_LIST_MENU_CELL_CONTROL_LOCATION_TYPE_TAIL, this);

        if (m_tailControl)
        {
            VFX_ASSERT(m_tailControl->getParentFrame() == this);

            m_tailControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_CUSTOM;
            
            m_tailControlMode = CONTROL_MODE_TYPE_CUSTOM;
        }
    }
    
    switch(menu->getMenuMode())
    {
    case VCP_LIST_MENU_MODE_REORDER:

        if (m_headControlMode != CONTROL_MODE_TYPE_NONE || m_headControl)
            break;
        
        VFX_OBJ_CREATE(m_headControl, VcpListMenuCellThumb, this);
        m_headControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_REORDER_THUMB;
        m_headControlMode = CONTROL_MODE_TYPE_MENU_MODE;
        break;

    case VCP_LIST_MENU_MODE_SINGLE_SELECTION:

        if (m_headControlMode != CONTROL_MODE_TYPE_NONE || m_headControl)
            break;

        if (contentProvider)
        {
            if (contentProvider->getItemState(m_pos) != VCP_LIST_MENU_ITEM_STATE_NONE)
            {
                VFX_OBJ_CREATE(m_headControl, VcpListMenuRadioButton, this);
                m_headControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_RADIO_BUTTON;
            }
        }

        m_headControlMode = CONTROL_MODE_TYPE_MENU_MODE;

        break;

    case VCP_LIST_MENU_MODE_MULTI_SELECTION:

        if (m_headControlMode != CONTROL_MODE_TYPE_NONE || m_headControl)
            break;

        if (contentProvider)
        {
            if (contentProvider->getItemState(m_pos) != VCP_LIST_MENU_ITEM_STATE_NONE)
            {
                VFX_OBJ_CREATE(m_headControl, VcpListMenuCheckBox, this);
                m_headControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_CHECK_BOX;
            }
        }

        m_headControlMode = CONTROL_MODE_TYPE_MENU_MODE;

        break;

    case VCP_LIST_MENU_MODE_HEAD_SINGLE_CHECK_MARK:

        if (m_headControlMode != CONTROL_MODE_TYPE_NONE || m_headControl)
            break;
        
        if (contentProvider)
        {
            if (contentProvider->getItemState(m_pos) != VCP_LIST_MENU_ITEM_STATE_NONE)
            {
                VFX_OBJ_CREATE_EX(m_headControl, VcpListMenuCheckMark, this, (VFX_FALSE));
                m_headControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_CHECK_MARK;
            }
        }

        m_headControlMode = CONTROL_MODE_TYPE_MENU_MODE;
        break;

    case VCP_LIST_MENU_MODE_HEAD_MULTI_CHECK_MARK:

        if (m_headControlMode != CONTROL_MODE_TYPE_NONE || m_headControl)
            break;
        
        if (contentProvider)
        {
            if (contentProvider->getItemState(m_pos) != VCP_LIST_MENU_ITEM_STATE_NONE)
            {
                VFX_OBJ_CREATE_EX(m_headControl, VcpListMenuCheckMark, this, (VFX_TRUE));
                m_headControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_CHECK_MARK;
            }
        }

        m_headControlMode = CONTROL_MODE_TYPE_MENU_MODE;
        break;

    case VCP_LIST_MENU_MODE_TAIL_SINGLE_CHECK_MARK:

        if (m_tailControlMode != CONTROL_MODE_TYPE_NONE || m_tailControl)
            break;
        
        if (contentProvider)
        {
            if (contentProvider->getItemState(m_pos) != VCP_LIST_MENU_ITEM_STATE_NONE)
            {
                VFX_OBJ_CREATE_EX(m_tailControl, VcpListMenuCheckMark, this, (VFX_FALSE));
                m_tailControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_CHECK_MARK;
            }
        }

        m_tailControlMode = CONTROL_MODE_TYPE_MENU_MODE;
        break;

    case VCP_LIST_MENU_MODE_TAIL_MULTI_CHECK_MARK:

        if (m_tailControlMode != CONTROL_MODE_TYPE_NONE || m_tailControl)
            break;
        
        if (contentProvider)
        {
            if (contentProvider->getItemState(m_pos) != VCP_LIST_MENU_ITEM_STATE_NONE)
            {
                VFX_OBJ_CREATE_EX(m_tailControl, VcpListMenuCheckMark, this, (VFX_TRUE));
                m_tailControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_CHECK_MARK;
            }
        }

        m_tailControlMode = CONTROL_MODE_TYPE_MENU_MODE;
        break;
        
    default:
        break;
    }

    switch(menu->getMenuControlMode())
    {
    case VCP_LIST_MENU_CONTROL_MODE_CMD_BUTTON:

        if (m_tailControlMode != CONTROL_MODE_TYPE_NONE || m_tailControl)
            break;

        VFX_ASSERT(!m_tailControl);

        if (contentProvider)
        {
#ifdef __MAUI_SOFTWARE_LA__
                          SLA_CustomLogging("LC0", SA_start);
#endif    

            VfxImageSrc normal, pressed, disabled, highlight;
            
            if (contentProvider->getItemImage(m_pos, VCP_LIST_MENU_FIELD_CMD_BUT_IMG_NORMAL, normal))
            {
                if (contentProvider->getItemImage(m_pos, VCP_LIST_MENU_FIELD_CMD_BUT_IMG_PRESSED, pressed))
                {
                    if (contentProvider->getItemImage(m_pos, VCP_LIST_MENU_FIELD_CMD_BUT_IMG_DISABLED, disabled))
                    {
                        if (contentProvider->getItemImage(m_pos, VCP_LIST_MENU_FIELD_CMD_BUT_IMG_HIGHLIGHT, highlight))
                        {
#ifdef __MAUI_SOFTWARE_LA__
                            SLA_CustomLogging("LC1", SA_start);
#endif    
                            VcpStateImage stateImage;

                            stateImage.setImage(normal, pressed, disabled, highlight);
#ifdef __MAUI_SOFTWARE_LA__
                          SLA_CustomLogging("LC1", SA_stop);
#endif                                

#ifdef __MAUI_SOFTWARE_LA__
                            SLA_CustomLogging("LC2", SA_start);
#endif    

                            VFX_OBJ_CREATE_EX(m_tailControl, VcpListMenuCmdButton, this, (stateImage));
#ifdef __MAUI_SOFTWARE_LA__
                             SLA_CustomLogging("LC2", SA_stop);
#endif    

#ifdef __MAUI_SOFTWARE_LA__
                            SLA_CustomLogging("LC3", SA_start);
#endif    

                            ((VcpListMenuCmdButton*)m_tailControl)->updateState();    
                            m_tailControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_CMD_BUTTON;
#ifdef __MAUI_SOFTWARE_LA__
                             SLA_CustomLogging("LC3", SA_stop);
#endif    
                        }
                    }    
                }
            }
        }

        m_tailControlMode = CONTROL_MODE_TYPE_CONTROL_MODE;

#ifdef __MAUI_SOFTWARE_LA__
        SLA_CustomLogging("LC0", SA_stop);
#endif    
        break;

    case VCP_LIST_MENU_CONTROL_MODE_DISCLOSURE:

        if (m_tailControlMode != CONTROL_MODE_TYPE_NONE || m_tailControl)
            break;
        
        VFX_ASSERT(!m_tailControl);

        if (contentProvider)
        {
            VfxImageSrc image;
            
            if (contentProvider->getItemImage(m_pos, VCP_LIST_MENU_FIELD_DISCLOSURE_IMG, image))
            {
                VFX_OBJ_CREATE_EX(m_tailControl, VcpListMenuDisclosure, this, (image));
                m_tailControlType = VCP_LIST_MENU_CELL_CONTROL_TYPE_DISCLOSURE;
            }
        }

        m_tailControlMode = CONTROL_MODE_TYPE_CONTROL_MODE;
        break;

    default:
        break;
    }
#ifdef __MAUI_SOFTWARE_LA__
              SLA_CustomLogging("LCc", SA_stop);
#endif    
}


void VcpListMenuCell::updateSeparators()
{
    if (!getMenu()->getItemSeparatorHidden())
    {
#if defined(__MMI_VUI_COSMOS_CP__)
        if (!m_topSeparatorLine)
        {
            // We only need bottom separator line with image
            // create here only to avoid warning and make consitance with SHELL and MRE
            VFX_OBJ_CREATE(m_topSeparatorLine, VfxFrame, this);
        }

        if (!m_bottomSeparatorLine)
        {
            VFX_OBJ_CREATE(m_bottomSeparatorLine, VfxFrame, this);
            m_bottomSeparatorLine->setImgContent(VfxImageSrc(IMG_COSMOS_SEPARATOR_LINE));
            m_bottomSeparatorLine->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);
            m_bottomSeparatorLine->setSize(m_bottomSeparatorLine->getImgContent().getSize());
        }
#else /* defined(__MMI_VUI_COSMOS_CP__) */
        if (!m_topSeparatorLine)
        {
            VFX_OBJ_CREATE(m_topSeparatorLine, VfxFrame, this);
            m_topSeparatorLine->setBgColor(VRT_COLOR_MAKE(30, 128, 128, 128));
        }

        if (!m_bottomSeparatorLine)
        {
            VFX_OBJ_CREATE(m_bottomSeparatorLine, VfxFrame, this);
            m_bottomSeparatorLine->setBgColor(VRT_COLOR_MAKE(80, 128, 128, 128));
        }
#endif /* defined(__MMI_VUI_COSMOS_CP__) */

        /* sepcial handling for group separate line */
        IVcpListMenuContentProviderInt *contentProvider = getContentProvider();

        if (contentProvider)
        {
            if (contentProvider->hasGroupHeader(m_pos.group))
            {
                if (m_pos.pos == 0)
                {
                    if (m_topSeparatorLine)
                    {
                        m_topSeparatorLine->setHidden(VFX_TRUE);
                    }
                }
            }

            if ((contentProvider->hasGroupHeader(m_pos.group + 1)) &&
                (m_pos.group + 1 != contentProvider->getGroupCount()))
            {
                if (m_pos.pos == (contentProvider->getCount(m_pos.group) - 1))
                {
                    if (m_bottomSeparatorLine)
                    {
                        m_bottomSeparatorLine->setHidden(VFX_TRUE);
                    }
                }
            }
        }
    }
    else
    {
        if (m_topSeparatorLine)
        {
            VFX_OBJ_CLOSE(m_topSeparatorLine);
            m_topSeparatorLine = NULL;
        }

        if (m_bottomSeparatorLine)
        {
            VFX_OBJ_CLOSE(m_bottomSeparatorLine);
            m_bottomSeparatorLine = NULL;
        }
    }
}


/***************************************************************************** 
 * Class VcpListMenuCellClientFrame
 *****************************************************************************/
 
void VcpListMenuCellClientBaseFrame::update(VfxBool isAnim)
{
    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(!isAnim);
    
    onUpdateElements();

    layout(isAnim);

    VfxAutoAnimate::commit();
}


void VcpListMenuCellClientBaseFrame::onInit()
{
    VfxFrame::onInit();

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LCE", SA_start);
#endif
    onCreateElements();
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LCE", SA_stop);
#endif

#ifdef __MAUI_SOFTWARE_LA__
        SLA_CustomLogging("LUE", SA_start);
#endif
    onUpdateElements();
#ifdef __MAUI_SOFTWARE_LA__
        SLA_CustomLogging("LUE", SA_stop);
#endif

    m_signalBoundsChanged.connect(this, &VcpListMenuCellClientBaseFrame::onBoundsValueChanged);

    setAutoAnimate(VFX_TRUE);
}


void VcpListMenuCellClientBaseFrame::onDeinit()
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LOE", SA_start);
#endif    
    onCloseElements();
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LOE", SA_stop);
#endif
    
    VfxFrame::onDeinit();
}


void VcpListMenuCellClientBaseFrame::layout(VfxBool isAnim)
{
    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(!isAnim);
    
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LLE", SA_start);
#endif     
    onLayoutElements();
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("LLE", SA_stop);
#endif

    VfxAutoAnimate::commit();
}


VcpListMenuCell* VcpListMenuCellClientBaseFrame::getCell()
{
    return VFX_STATIC_CAST(getParentFrame(), VcpListMenuCell*);
}


VcpBaseListMenu* VcpListMenuCellClientBaseFrame::getMenu()
{
    VcpListMenuCell* cell = getCell();

    if (cell)
    {
        return cell->getMenu();
    }
    else
    {
        return NULL;
    }
}


IVcpListMenuContentProviderInt* VcpListMenuCellClientBaseFrame::getContentProvider()
{
    VcpBaseListMenu *menu = getMenu();

    if (menu)
    {
        IVcpListMenuContentProviderInt *provider = menu->getContentProviderInt();
        
        return provider;
    }
    
    return NULL;
}

VfxFrame *VcpListMenuCellClientBaseFrame::createItemTextFrameInt(VcpListMenuFieldEnum fieldType)
{
#ifdef __MAUI_SOFTWARE_LA__
        SLA_CustomLogging("LTI", SA_start);
#endif 
    IVcpListMenuContentProviderInt *contentProvider = getContentProvider();

    if (contentProvider)
    {
        VfxWString string;
        VfxTextFrame *textFrame;
        VcpTextView *textView;
        VcpListMenuTextColorEnum textColor = VCP_LIST_MENU_TEXT_COLOR_NORMAL;

        // default text color setting
        switch(m_style)
        {
            case VCP_LIST_MENU_CELL_STYLE_MULTI_TEXT:
            case VCP_LIST_MENU_CELL_STYLE_ICON_MULTI_TEXT:
                if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
                {
                    textColor = VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT;
                }
                break;

            case VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT:
            case VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT_EX:
            case VCP_LIST_MENU_CELL_STYLE_QUADRUPLE_TEXT:
            case VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT:
            case VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT_EX:
                if ((fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1) || (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT2))
                {
                    textColor = VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT;
                }

            case VCP_LIST_MENU_CELL_STYLE_ICON_QUADRUPLE_TEXT:
            case VCP_LIST_MENU_CELL_STYLE_ICON_QUINTUPLE_TEXT:
                if ((fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1) || (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT3))
                {
                    textColor = VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT;
                }
                break;

            default:
                break;
        }

        VcpListMenuCell *cell = getCell();
        if (contentProvider->getItemText(cell->m_pos, fieldType, string, textColor))
        {
            VcpRichText textFormat;
            
            if (contentProvider->getItemTextFormat(cell->m_pos, fieldType, textFormat))
            {
                VFX_OBJ_CREATE(textView, VcpTextView, this);

                textView->setIsUnhittable(VFX_TRUE);

                textView->setLineMode(VCP_TEXT_LINE_MODE_SINGLE);

                onUpdateTextViewStyle(fieldType, textView);
                
                textView->setText(string, VFX_FALSE, &textFormat);

                textView->setColor(VCP_TEXT_NORMAL_TEXT_COLOR, cell->getTextColor(textColor));
                
                textView->forceUpdate();
                textView->setAttachProperty(0x2F0F0, &textColor, sizeof(VcpListMenuTextColorEnum));
                
                textView->setAutoAnimate(VFX_TRUE);
#ifdef __MAUI_SOFTWARE_LA__
                SLA_CustomLogging("LTI", SA_stop);
#endif                 
                
                return textView;
            }
            else
            {
                VFX_OBJ_CREATE(textFrame, VfxTextFrame, this);
                
                onUpdateTextFrameStyle(fieldType, textFrame);
                
                textFrame->setString(string);
                textFrame->setColor(cell->getTextColor(textColor));

                // call back user to update text font, color, etc.
                contentProvider->getItemTextFrameFormat(cell->m_pos, fieldType, textFrame);

                textFrame->forceUpdate();

                textFrame->setAutoResized(VFX_FALSE);                
                textFrame->setAutoAnimate(VFX_TRUE);

                textFrame->setAttachProperty(0x2F0F0, &textColor, sizeof(VcpListMenuTextColorEnum));
#ifdef __MAUI_SOFTWARE_LA__
                SLA_CustomLogging("LTI", SA_stop);
#endif                 
                return textFrame;
            }
        }
    }
#ifdef __MAUI_SOFTWARE_LA__
                SLA_CustomLogging("LTI", SA_stop);
#endif 

    return NULL;
}

void VcpListMenuCellClientBaseFrame::createItemTextFrameHelper(VfxFrame *& textFrame, VcpListMenuFieldEnum fieldType)
{
    IVcpListMenuContentProviderInt *contentProvider = getContentProvider();
    if (contentProvider == NULL)
    {
        return;
    }

    if (getCell()->m_prevHighlight != getCell()->m_isHighlight)
    {
        if (textFrame)
        {
            updateTextColorInt(textFrame, fieldType);
        }
    }
    else
    {
        VfxFrame *tempTextFrame = NULL;

        VFX_OBJ_CLOSE(textFrame); // Must close previous text object

        tempTextFrame = createItemTextFrameInt(fieldType);

        if (tempTextFrame)
        {
            textFrame = tempTextFrame;
        }
    }
}

void VcpListMenuCellClientBaseFrame::resetImageContentHelper(VfxImageFrame *& imageFrame, VcpListMenuFieldEnum fieldType)
{
    IVcpListMenuContentProviderInt *contentProvider = getContentProvider();
    if (contentProvider == NULL)
    {
        return;
    }

    VfxImageSrc img;
    if (contentProvider->getItemImage(getCell()->m_pos, fieldType, img))
    {
        if (imageFrame == NULL)
        {
            VFX_OBJ_CREATE(imageFrame, VfxImageFrame, this);
        }
        imageFrame->setImgContent(img);
    }
    else
    {
        VFX_OBJ_CLOSE(imageFrame);
        imageFrame = NULL;
    }
}

void VcpListMenuCellClientBaseFrame::closeElementHelper(VfxImageFrame * imageFrame, VcpListMenuFieldEnum fieldType)
{
    IVcpListMenuContentProviderInt * provider = getContentProvider();
    if (provider && imageFrame)
    {
        VfxImageSrc img = imageFrame->getImgContent();
    
        provider->closeItemImage(getCell()->m_pos, fieldType, img);
    }
}

void VcpListMenuCellClientBaseFrame::updateTextColorInt(VfxFrame* target,VcpListMenuFieldEnum fieldType)    
{
    IVcpListMenuContentProviderInt *contentProvider = getContentProvider();

    if (contentProvider)
    {

        VcpListMenuTextColorEnum textColor = VCP_LIST_MENU_TEXT_COLOR_NORMAL;
        // default text color setting
        switch(m_style)
        {
            case VCP_LIST_MENU_CELL_STYLE_MULTI_TEXT:
            case VCP_LIST_MENU_CELL_STYLE_ICON_MULTI_TEXT:
                if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
                {
                    textColor = VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT;
                }
                break;

            case VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT:
            case VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT_EX:
            case VCP_LIST_MENU_CELL_STYLE_QUADRUPLE_TEXT:
            case VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT:
            case VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT_EX:
                if ((fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1) || (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT2))
                {
                    textColor = VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT;
                }

            case VCP_LIST_MENU_CELL_STYLE_ICON_QUADRUPLE_TEXT:
            case VCP_LIST_MENU_CELL_STYLE_ICON_QUINTUPLE_TEXT:
                if ((fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1) || (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT3))
                {
                    textColor = VCP_LIST_MENU_TEXT_COLOR_LOWLIGHT;
                }
                break;

            default:
                break;
        }

        
        VcpListMenuTextColorEnum *prty = (VcpListMenuTextColorEnum *)(target->getAttachProperty(0x2F0F0, sizeof(VcpListMenuTextColorEnum)));
        if (prty)
        {
            textColor = *prty;
        }        

        VfxTextFrame *textFrame = VFX_OBJ_DYNAMIC_CAST(target, VfxTextFrame);
        if (textFrame)
        {
            onUpdateTextFrameStyle(fieldType, textFrame);                
            textFrame->setColor(getCell()->getTextColor(textColor));

            // call back user to update text font, color, etc.
            contentProvider->getItemTextFrameFormat(getCell()->m_pos, fieldType, textFrame);        
        }

        VcpTextView *textView = VFX_OBJ_DYNAMIC_CAST(target, VcpTextView);
        if (textView)
        {
            VcpRichText textFormat;
            if (contentProvider->getItemTextFormat(getCell()->m_pos, fieldType, textFormat))
            {
                onUpdateTextViewStyle(fieldType, textView);
                
                textView->setTextFormat(&textFormat);
                textView->setColor(VCP_TEXT_NORMAL_TEXT_COLOR, getCell()->getTextColor(textColor));
            }
        }
    }
}




VfxBool VcpListMenuCellClientBaseFrame::getTextInt(VfxFrame *textFrame, VfxWString &text)
{
    if (textFrame)
    {
        if (textFrame->isKindOf(VFX_OBJ_CLASS_INFO(VfxTextFrame)))
        {
            text = ((VfxTextFrame *)textFrame)->getString();
            
            return VFX_TRUE;
        }
        else if (textFrame->isKindOf(VFX_OBJ_CLASS_INFO(VcpTextView)))
        {
            text.loadFromMem(((VcpTextView *)textFrame)->getText());

            return VFX_TRUE;
        }
    }
    
    return VFX_FALSE;
}


void VcpListMenuCellClientBaseFrame::onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds)
{
    onLayoutElements();
}

void VcpListMenuCellClientBaseFrame::setTextRect(VfxFrame *txt, VfxRect rect)
{
    VFX_ASSERT(txt);

    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(VFX_TRUE);

    //txt->setSize(rect.size);
    txt->setBounds(VfxRect(VFX_POINT_ZERO, rect.size)); //for better performance

    VfxAutoAnimate::commit();

    txt->setPos(rect.getX(), rect.getY());
}

void vcpListMenuCellHelperSetTextRect(VfxFrame * textFrame, const VfxRect & rect)
{
    VFX_ASSERT(textFrame);

    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(VFX_TRUE);

//    textFrame->setSize(rect.size);
    textFrame->setBounds(VfxRect(VFX_POINT_ZERO, rect.size)); //for better performance


    VfxAutoAnimate::commit();

    textFrame->setPos(rect.getX(), rect.getY());
}

// List Menu Cell Helper
void vcpListMenuCellHelperAlignParentSide(VfxFrame * frame)
{
    frame->setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE,
                          VFX_FRAME_ALIGNER_MODE_SIDE,
                          VFX_FRAME_ALIGNER_MODE_SIDE,
                          VFX_FRAME_ALIGNER_MODE_SIDE);
}

void vcpListMenuCellHelperAlignParentLeft(VfxFrame * frame)
{
    frame->setAlignParent(VFX_FRAME_ALIGNER_MODE_SIDE,
                          VFX_FRAME_ALIGNER_MODE_SIDE,
                          VFX_FRAME_ALIGNER_MODE_NONE,
                          VFX_FRAME_ALIGNER_MODE_SIDE);
}

void vcpListMenuCellHelperAlignParentRight(VfxFrame * frame)
{
    frame->setAlignParent(VFX_FRAME_ALIGNER_MODE_NONE,
                          VFX_FRAME_ALIGNER_MODE_SIDE,
                          VFX_FRAME_ALIGNER_MODE_SIDE,
                          VFX_FRAME_ALIGNER_MODE_SIDE);
}

void vcpListMenuCellHelperPlaceMiddleLeftIcon(VcpListMenuCellClientBaseFrame * cell, VfxImageFrame * imageFrame, VfxS32 left, VfxS32 width)
{
    if (imageFrame)
    {
        VfxSize csize = cell->getSize();        
        VfxSize size = imageFrame->getSize();     
        imageFrame->setRect(VfxRect(left, 
                                    (csize.height - size.height) / 2,
                                    width,
                                    size.height));
        vcpListMenuCellHelperAlignParentLeft(imageFrame);
    }
}

void vcpListMenuCellHelperPlaceMiddleRightIcon(VcpListMenuCellClientBaseFrame * cell, VfxImageFrame * imageFrame, VfxS32 rightGaps, VfxS32 width)
{
    if (imageFrame)
    {
        VfxSize csize = cell->getSize();        
        VfxSize size = imageFrame->getSize();                
        
        imageFrame->setRect(VfxRect(csize.width - 1 - rightGaps - size.width, 
                                    (csize.height - size.height) / 2,
                                    width,
                                    size.height));

        vcpListMenuCellHelperAlignParentRight(imageFrame);
    }
}

void vcpListMenuCellHelperPlaceTopRightIcon(VcpListMenuCellClientBaseFrame * cell, VfxImageFrame * imageFrame, VfxS32 rightGaps, VfxS32 top)
{
    if (imageFrame)
    {
        VfxSize csize = cell->getSize();        
        VfxSize size = imageFrame->getSize();  
        imageFrame->setRect(VfxRect(csize.width - 1 - rightGaps - size.width, 
                                    top,
                                    size.width,
                                    size.height));

        vcpListMenuCellHelperAlignParentRight(imageFrame);
    }
}

void vcpListMenuCellHelperPlaceMiddleTextImp(VcpListMenuCellClientBaseFrame * cell, VfxFrame * textFrame, VfxS32 left, VfxS32 width)
{
    VfxSize csize = cell->getSize();        
    VfxSize size = textFrame->getSize(); 
    
    vcpListMenuCellHelperSetTextRect(
            textFrame, VfxRect(left, 
                               (csize.height - size.height) / 2,
                               width,
                               size.height));
}

void vcpListMenuCellHelperPlaceMiddleText(VcpListMenuCellClientBaseFrame * cell, VfxFrame * textFrame, VfxS32 left, VfxS32 width)
{
    if (textFrame)
    {
        vcpListMenuCellHelperPlaceMiddleTextImp(cell, textFrame, left, width);
        vcpListMenuCellHelperAlignParentSide(textFrame);
    }
}

void vcpListMenuCellHelperPlaceMiddleLeftText(VcpListMenuCellClientBaseFrame * cell, VfxFrame * textFrame, VfxS32 left, VfxS32 width)
{
    if (textFrame)
    {
        vcpListMenuCellHelperPlaceMiddleTextImp(cell, textFrame, left, width);
        vcpListMenuCellHelperAlignParentLeft(textFrame);
    }
}

void vcpListMenuCellHelperPlaceMiddleRightText(VcpListMenuCellClientBaseFrame * cell, VfxFrame * textFrame, VfxS32 rightGaps)
{
    if (textFrame)
    {
        VfxSize csize = cell->getSize();        
        VfxSize size = textFrame->getSize(); 
    
        vcpListMenuCellHelperPlaceMiddleTextImp(cell, textFrame,
                csize.width - 1 - rightGaps - size.width,
                size.width);
        vcpListMenuCellHelperAlignParentRight(textFrame);
    }
}

void vcpListMenuCellHelperPlaceTopTextImp(VfxFrame * textFrame, VfxS32 left, VfxS32 top, VfxS32 width)
{
    vcpListMenuCellHelperSetTextRect(
            textFrame, VfxRect(left, 
                               top,
                               width,
                               textFrame->getSize().height));
}

void vcpListMenuCellHelperPlaceTopText(VfxFrame * textFrame, VfxS32 left, VfxS32 top, VfxS32 width)
{
    if (textFrame)
    {
        vcpListMenuCellHelperPlaceTopTextImp(textFrame, left, top, width);
        vcpListMenuCellHelperAlignParentSide(textFrame);
    }
}

void vcpListMenuCellHelperPlaceTopLeftText(VfxFrame * textFrame, VfxS32 left, VfxS32 top, VfxS32 width)
{
    if (textFrame)
    {
        vcpListMenuCellHelperPlaceTopTextImp(textFrame, left, top, width);
        vcpListMenuCellHelperAlignParentLeft(textFrame);
    }
}

void vcpListMenuCellHelperPlaceTopInnerText(VfxFrame * textFrame, VfxS32 left, VfxS32 top)
{
    if (textFrame)
    {
        vcpListMenuCellHelperPlaceTopTextImp(textFrame, left, top, textFrame->getSize().width);
        textFrame->setAlignParent(VFX_FRAME_ALIGNER_MODE_NONE,
                                  VFX_FRAME_ALIGNER_MODE_SIDE,
                                  VFX_FRAME_ALIGNER_MODE_NONE,
                                  VFX_FRAME_ALIGNER_MODE_SIDE);
    }
}

void vcpListMenuCellHelperPlaceTopRightText(VcpListMenuCellClientBaseFrame * cell, VfxFrame * textFrame, VfxS32 rightGaps, VfxS32 top)
{
    if (textFrame)
    {
        VfxSize csize = cell->getSize();        
        VfxSize size = textFrame->getSize(); 
        vcpListMenuCellHelperPlaceTopTextImp(textFrame,
                csize.width - 1 - rightGaps - size.width,
                top,
                size.width);
        vcpListMenuCellHelperAlignParentRight(textFrame);
    }
}

void vcpListMenuCellHelperPlaceBottomTextImp(VcpListMenuCellClientBaseFrame * cell, VfxFrame * textFrame, VfxS32 left, VfxS32 bottomGaps, VfxS32 width)
{
    VfxSize csize = cell->getSize();        
    VfxSize size = textFrame->getSize(); 
    vcpListMenuCellHelperSetTextRect(
            textFrame, VfxRect(left, 
                          csize.height - 1 - bottomGaps - size.height,
                          width,
                          size.height));
}

void vcpListMenuCellHelperPlaceBottomText(VcpListMenuCellClientBaseFrame * cell, VfxFrame * textFrame, VfxS32 left, VfxS32 bottomGaps, VfxS32 width)
{
    if (textFrame)
    {
        vcpListMenuCellHelperPlaceBottomTextImp(cell, textFrame, left, bottomGaps, width);
        vcpListMenuCellHelperAlignParentSide(textFrame);
    }
}

void vcpListMenuCellHelperPlaceBottomLeftText(VcpListMenuCellClientBaseFrame * cell, VfxFrame * textFrame, VfxS32 left, VfxS32 bottomGaps, VfxS32 width)
{
    if (textFrame)
    {
        vcpListMenuCellHelperPlaceBottomTextImp(cell, textFrame, left, bottomGaps, width);
        vcpListMenuCellHelperAlignParentLeft(textFrame);
    }
}

void vcpListMenuCellHelperPlaceBottomRightText(VcpListMenuCellClientBaseFrame * cell, VfxFrame * textFrame, VfxS32 rightGaps, VfxS32 bottomGaps)
{
    if (textFrame)
    {
        vcpListMenuCellHelperPlaceBottomTextImp(cell, textFrame, cell->getRect().getWidth() - 1 - rightGaps - textFrame->getRect().getWidth(), bottomGaps, textFrame->getRect().getWidth());
        vcpListMenuCellHelperAlignParentRight(textFrame);
    }
}

VfxS32 vcpListMenuCellHelperGetTextMaxWidth(VfxFrame * frame)
{
    VfxS32 maxW = 0;

    VfxTextFrame *textFrame = VFX_OBJ_DYNAMIC_CAST(frame, VfxTextFrame);
    if (textFrame)
    {
        textFrame->setAutoResized(VFX_TRUE);
        // reset text frame to get string width
        textFrame->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_NONE);
        //textFrame->setSize(0, 0);
        textFrame->forceUpdate();
        textFrame->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
        maxW = textFrame->getBounds().getWidth();

        textFrame->setAutoResized(VFX_FALSE);
    }

    VcpTextView *textView = VFX_OBJ_DYNAMIC_CAST(frame, VcpTextView);
    if (textView)
    {
        // reset text view to get string width
        textView->setTruncateMode(VCP_TEXT_TRUNCATE_MODE_NONE);
        //textView->setSize(0, 0);
        textView->forceUpdate();
        textView->setTruncateMode(VCP_TEXT_TRUNCATE_MODE_END);
        maxW = textView->getBounds().getWidth();
    }

    return maxW;
}

void vcpListMenuCellHelperLimitFrameHeight(VfxFrame * frame, VfxS32 maxHeight)
{
    maxHeight = (maxHeight < 0) ? 0 : maxHeight;

    if (frame)
    {
        VfxSize size = frame->getSize();
        if (size.height > maxHeight)
        {
            frame->setSize(size.width, maxHeight);
            frame->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE_ASPECT);
        }        
    }
}

void vcpListMenuCellHelperOnUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame)
{
    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        frame->setFont(VfxFontDesc(VCP_LIST_MENU_FONT_SIZE_MEDIUM));
        frame->setAlignMode(VfxTextFrame::ALIGN_MODE_LEFT);
        frame->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        frame->setFont(VfxFontDesc(VCP_LIST_MENU_FONT_SIZE_SMALL));
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT2)
    {
        frame->setFont(VfxFontDesc(VCP_LIST_MENU_FONT_SIZE_SMALL));
        frame->setAlignMode(VfxTextFrame::ALIGN_MODE_RIGHT);
        frame->setAutoResized(VFX_TRUE);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT3)
    {
        frame->setFont(VfxFontDesc(VCP_LIST_MENU_FONT_SIZE_SMALL));
        frame->setAlignMode(VfxTextFrame::ALIGN_MODE_RIGHT);
        frame->setAutoResized(VFX_TRUE);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_TAIL_TEXT)
    {
        frame->setFont(VfxFontDesc(VCP_LIST_MENU_FONT_SIZE_MEDIUM));
        frame->setAlignMode(VfxTextFrame::ALIGN_MODE_LEFT);
        frame->setAutoResized(VFX_TRUE);
    }
}

void vcpListMenuCellHelperOnUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame)
{
    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        frame->setFont(VfxFontDesc(VCP_LIST_MENU_FONT_SIZE_MEDIUM));
        frame->setAlignMode(VCP_TEXT_ALIGN_MODE_LEFT);
        frame->setTruncateMode(VCP_TEXT_TRUNCATE_MODE_END);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        frame->setFont(VfxFontDesc(VCP_LIST_MENU_FONT_SIZE_SMALL));
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT2)
    {
        frame->setFont(VfxFontDesc(VCP_LIST_MENU_FONT_SIZE_SMALL));
        frame->setAlignMode(VCP_TEXT_ALIGN_MODE_RIGHT);
        frame->setAutoResized(VFX_TRUE);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT3)
    {
        frame->setFont(VfxFontDesc(VCP_LIST_MENU_FONT_SIZE_SMALL));
        frame->setAlignMode(VCP_TEXT_ALIGN_MODE_RIGHT);
        frame->setAutoResized(VFX_TRUE);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_TAIL_TEXT)
    {
        frame->setFont(VfxFontDesc(VCP_LIST_MENU_FONT_SIZE_MEDIUM));
        frame->setAlignMode(VCP_TEXT_ALIGN_MODE_LEFT);
        frame->setAutoResized(VFX_TRUE);
    }
}

void vcpListMenuCellHelperTextFrameSetAlignLeft(VfxTextFrame *frame)
{
    frame->setAlignMode(VfxTextFrame::ALIGN_MODE_LEFT);
    frame->setTruncateMode(VfxTextFrame::TRUNCATE_MODE_END);
}

void vcpListMenuCellHelperTextFrameSetAlignRight(VfxTextFrame *frame)
{
    frame->setAlignMode(VfxTextFrame::ALIGN_MODE_RIGHT);
    frame->setAutoResized(VFX_TRUE);
}

void vcpListMenuCellHelperTextViewSetAlignLeft(VcpTextView *frame)
{
    frame->setAlignMode(VCP_TEXT_ALIGN_MODE_LEFT);
    frame->setTruncateMode(VCP_TEXT_TRUNCATE_MODE_END);
}

void vcpListMenuCellHelperTextViewSetAlignRight(VcpTextView *frame)
{
    frame->setAlignMode(VCP_TEXT_ALIGN_MODE_RIGHT);
    frame->setAutoResized(VFX_TRUE);
}

void vcpListMenuCellHelperPlaceOnCenter(VfxFrame * child, VfxFrame * parent)
{
    VfxSize psize = parent->getSize();
    VfxSize csize = child->getSize();
    child->setPos(VfxPoint((psize.width - csize.width)/2,
                           (psize.height - csize.height)/2));
}

/***************************************************************************** 
 * Class VcpListMenuCellSingleTextFrame
 *****************************************************************************/

VcpListMenuCellSingleTextFrame::VcpListMenuCellSingleTextFrame() :
    m_textFrame(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_SINGLE_TEXT;
}

void VcpListMenuCellSingleTextFrame::onCreateElements()
{
}

void VcpListMenuCellSingleTextFrame::onCloseElements()
{
}

void VcpListMenuCellSingleTextFrame::onLayoutElements()
{
    vcpListMenuCellHelperPlaceMiddleText(this, m_textFrame, LEFT_GAPS, getRect().getWidth() - LEFT_GAPS - RIGHT_GAPS);
}

void VcpListMenuCellSingleTextFrame::onUpdateElements()
{
    createItemTextFrameHelper(m_textFrame, VCP_LIST_MENU_FIELD_TEXT);
}

void VcpListMenuCellSingleTextFrame::onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextFrameStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextFrameStyle(fieldType, frame);
}

void VcpListMenuCellSingleTextFrame::onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextViewStyle(fieldType, frame);
    
    vcpListMenuCellHelperOnUpdateTextViewStyle(fieldType, frame);
}


VfxBool VcpListMenuCellSingleTextFrame::getText(VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    if (m_textFrame && fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        return getTextInt(m_textFrame, text);
    }
    else
    {
        return VcpListMenuCellClientBaseFrame::getText(fieldType, text);
    }
}

/***************************************************************************** 
 * Class VcpListMenuCellMultiTextFrame
 *****************************************************************************/

VcpListMenuCellMultiTextFrame::VcpListMenuCellMultiTextFrame() : 
    m_textFrame1(NULL),
    m_textFrame2(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_MULTI_TEXT;
}


void VcpListMenuCellMultiTextFrame::onCreateElements()
{

}


void VcpListMenuCellMultiTextFrame::onLayoutElements()
{
    VfxS32 textFrame1Width = getRect().getWidth() - TEXT1_LEFT_GAPS - TEXT1_RIGHT_GAPS;

    /* vertical center alignment text 1 if no text 2 */
    if (m_textFrame2)
    {
        vcpListMenuCellHelperPlaceTopText(m_textFrame1, TEXT1_LEFT_GAPS, TEXT1_TOP_GAPS, textFrame1Width);
    }
    else
    {
        vcpListMenuCellHelperPlaceMiddleText(this, m_textFrame1, TEXT1_LEFT_GAPS, textFrame1Width);
    }
    
    vcpListMenuCellHelperPlaceBottomText(this, m_textFrame2, TEXT2_LEFT_GAPS, TEXT2_BOTTOM_GAPS, getRect().getWidth() - TEXT2_LEFT_GAPS - TEXT2_RIGHT_GAPS);
}


void VcpListMenuCellMultiTextFrame::onUpdateElements()
{
    createItemTextFrameHelper(m_textFrame1, VCP_LIST_MENU_FIELD_TEXT);
    createItemTextFrameHelper(m_textFrame2, VCP_LIST_MENU_FIELD_SUB_TEXT1);
}

void VcpListMenuCellMultiTextFrame::onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextFrameStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextFrameStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextFrameSetAlignLeft(frame);
    }
}

void VcpListMenuCellMultiTextFrame::onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextViewStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextViewStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextViewSetAlignLeft(frame);
    }
}

VfxBool VcpListMenuCellMultiTextFrame::getText(VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        return getTextInt(m_textFrame1, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        return getTextInt(m_textFrame2, text);
    }
    else
    {
        return VcpListMenuCellClientBaseFrame::getText(fieldType, text);
    }
}


/***************************************************************************** 
 * Class VcpListMenuCellMultiTextFrameEx
 *****************************************************************************/

VcpListMenuCellMultiTextFrameEx::VcpListMenuCellMultiTextFrameEx() : 
    m_textFrame1(NULL),
    m_textFrame2(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_MULTI_TEXT_EX;
}


void VcpListMenuCellMultiTextFrameEx::onLayoutElements()
{   
    VfxS32 textFrame2AreaWidth = 0;

    if (m_textFrame2)
    {
        textFrame2AreaWidth = (TEXT2_LEFT_GAPS + m_textFrame2->getRect().getWidth() + TEXT2_RIGHT_GAPS);
    }

    vcpListMenuCellHelperPlaceMiddleLeftText(this, m_textFrame1, TEXT1_LEFT_GAPS, getRect().getWidth() - TEXT1_LEFT_GAPS - TEXT1_RIGHT_GAPS - textFrame2AreaWidth);

    vcpListMenuCellHelperPlaceMiddleRightText(this, m_textFrame2,
            TEXT2_RIGHT_GAPS);
}


void VcpListMenuCellMultiTextFrameEx::onUpdateElements()
{
    createItemTextFrameHelper(m_textFrame1, VCP_LIST_MENU_FIELD_TEXT);
    createItemTextFrameHelper(m_textFrame2, VCP_LIST_MENU_FIELD_SUB_TEXT1);
}


void VcpListMenuCellMultiTextFrameEx::onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextFrameStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextFrameStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextFrameSetAlignRight(frame);
    }
}

void VcpListMenuCellMultiTextFrameEx::onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextViewStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextViewStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextViewSetAlignRight(frame);
    }
}


VfxBool VcpListMenuCellMultiTextFrameEx::getText(VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        return getTextInt(m_textFrame1, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        return getTextInt(m_textFrame2, text);
    }
    else
    {
        return VcpListMenuCellClientBaseFrame::getText(fieldType, text);
    }
}

/***************************************************************************** 
 * Class VcpListMenuCellTripleTextFrame
 *****************************************************************************/

VcpListMenuCellTripleTextFrame::VcpListMenuCellTripleTextFrame() : 
    m_textFrame1(NULL),
    m_textFrame2(NULL),
    m_textFrame3(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT;
}



void VcpListMenuCellTripleTextFrame::onLayoutElements()
{
    vcpListMenuCellHelperPlaceTopLeftText(m_textFrame1, TEXT1_LEFT_GAPS, TEXT1_TOP_GAPS, getRect().getWidth() - TEXT1_LEFT_GAPS - TEXT1_RIGHT_GAPS);

    VfxS32 textFrame3AreaWidth = 0;

    if (m_textFrame3)
    {
        textFrame3AreaWidth = TEXT3_LEFT_GAPS + m_textFrame3->getRect().getWidth() + TEXT3_RIGHT_GAPS;
    }

    vcpListMenuCellHelperPlaceBottomLeftText(this, m_textFrame2, TEXT2_LEFT_GAPS, TEXT2_BOTTOM_GAPS, getRect().getWidth() - TEXT2_LEFT_GAPS - TEXT2_RIGHT_GAPS - textFrame3AreaWidth);

    vcpListMenuCellHelperPlaceBottomRightText(this, m_textFrame3, TEXT3_RIGHT_GAPS, TEXT3_BOTTOM_GAPS);
}


void VcpListMenuCellTripleTextFrame::onUpdateElements()
{
    createItemTextFrameHelper(m_textFrame1, VCP_LIST_MENU_FIELD_TEXT);
    createItemTextFrameHelper(m_textFrame2, VCP_LIST_MENU_FIELD_SUB_TEXT1);
    createItemTextFrameHelper(m_textFrame3, VCP_LIST_MENU_FIELD_SUB_TEXT2);
}



void VcpListMenuCellTripleTextFrame::onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextFrameStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextFrameStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextFrameSetAlignLeft(frame);
    }
}

void VcpListMenuCellTripleTextFrame::onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextViewStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextViewStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextViewSetAlignLeft(frame);
    }
}


VfxBool VcpListMenuCellTripleTextFrame::getText(VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        return getTextInt(m_textFrame1, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        return getTextInt(m_textFrame2, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT2)
    {
        return getTextInt(m_textFrame3, text);
    }
    else
    {
        return VcpListMenuCellClientBaseFrame::getText(fieldType, text);
    }
}


/***************************************************************************** 
 * Class VcpListMenuCellTripleTextFrameEx
 *****************************************************************************/

VcpListMenuCellTripleTextFrameEx::VcpListMenuCellTripleTextFrameEx() : 
    m_extraImgFrame1(NULL),
    m_extraImgFrame2(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_TRIPLE_TEXT_EX;
}


void VcpListMenuCellTripleTextFrameEx::onCloseElements()
{
    VcpListMenuCellTripleTextFrame::onCloseElements();

    closeElementHelper(m_extraImgFrame1, VCP_LIST_MENU_FIELD_ICON_EXTRA1);
    closeElementHelper(m_extraImgFrame2, VCP_LIST_MENU_FIELD_ICON_EXTRA2);
}


void VcpListMenuCellTripleTextFrameEx::onLayoutElements()
{
    VfxS32 imgWidth = 0;

    VcpListMenuCellTripleTextFrame::onLayoutElements();

    if (m_textFrame3)
    {
        VfxS32 maxIconHeight = 0;
        VfxS32 bottomGap = 2;

        maxIconHeight = m_textFrame3->getRect().getMinY() - IMG_EX2_TOP_GAPS - bottomGap;

        vcpListMenuCellHelperLimitFrameHeight(m_extraImgFrame1, maxIconHeight);
        vcpListMenuCellHelperLimitFrameHeight(m_extraImgFrame2, maxIconHeight);
    }

    if (m_extraImgFrame2)
    {
        vcpListMenuCellHelperPlaceTopRightIcon(this, m_extraImgFrame2, IMG_EX2_RIGHT_GAPS, IMG_EX2_TOP_GAPS);

        imgWidth += IMG_EX2_LEFT_GAPS + m_extraImgFrame2->getRect().getWidth() + IMG_EX2_RIGHT_GAPS;
    }

    if (m_extraImgFrame1)
    {
		vcpListMenuCellHelperPlaceTopRightIcon(this, m_extraImgFrame1, IMG_EX1_RIGHT_GAPS + imgWidth, IMG_EX1_TOP_GAPS);

        imgWidth += IMG_EX1_LEFT_GAPS + m_extraImgFrame1->getRect().getWidth() + IMG_EX1_RIGHT_GAPS;
    }

    vcpListMenuCellHelperPlaceTopLeftText(m_textFrame1,
            TEXT1_LEFT_GAPS,
            TEXT1_TOP_GAPS,
            getRect().getWidth() - TEXT1_LEFT_GAPS - TEXT1_RIGHT_GAPS - imgWidth);
}


void VcpListMenuCellTripleTextFrameEx::onUpdateElements()
{
    VcpListMenuCellTripleTextFrame::onUpdateElements();
    
    resetImageContentHelper(m_extraImgFrame1, VCP_LIST_MENU_FIELD_ICON_EXTRA1);
    resetImageContentHelper(m_extraImgFrame2, VCP_LIST_MENU_FIELD_ICON_EXTRA2);
}


/***************************************************************************** 
 * Class VcpListMenuCellQuadTextFrameEx
 *****************************************************************************/

VcpListMenuCellQuadTextFrameEx::VcpListMenuCellQuadTextFrameEx() : 
    m_textFrame4(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_QUADRUPLE_TEXT;
}


void VcpListMenuCellQuadTextFrameEx::onCloseElements()
{
}


void VcpListMenuCellQuadTextFrameEx::onLayoutElements()
{
    VcpListMenuCellTripleTextFrameEx::onLayoutElements();

    VfxS32 maxText1Width;
    VfxS32 iconWidth = 0;

    if (m_extraImgFrame1)
    {
        iconWidth += IMG_EX1_LEFT_GAPS + m_extraImgFrame1->getBounds().getWidth() + IMG_EX1_RIGHT_GAPS;
    }

    if (m_extraImgFrame2)
    {
        iconWidth += IMG_EX2_LEFT_GAPS + m_extraImgFrame2->getBounds().getWidth() + IMG_EX2_RIGHT_GAPS;
    }
    
    VfxS32 textFrame4AreaWidth = 0;

    if (m_textFrame4)
    {
        textFrame4AreaWidth = TEXT4_LEFT_GAPS + m_textFrame4->getRect().getWidth() + TEXT4_RIGHT_GAPS;
    }

    maxText1Width = getRect().getWidth() - TEXT1_LEFT_GAPS - TEXT1_RIGHT_GAPS - iconWidth - textFrame4AreaWidth;

    if (m_textFrame1)
    {   
        VfxS32 maxW = vcpListMenuCellHelperGetTextMaxWidth(m_textFrame1);

        vcpListMenuCellHelperPlaceTopLeftText(m_textFrame1,
                TEXT1_LEFT_GAPS,
                TEXT1_TOP_GAPS, (maxW > maxText1Width) ? maxText1Width : maxW);
    }

    VfxS32 textFrame1MaxX = TEXT1_LEFT_GAPS;

    if (m_textFrame1)
    {
        textFrame1MaxX = m_textFrame1->getRect().getMaxX();
    }

    vcpListMenuCellHelperPlaceTopInnerText(m_textFrame4,
            textFrame1MaxX + TEXT4_LEFT_GAPS, TEXT4_TOP_GAPS);
}


void VcpListMenuCellQuadTextFrameEx::onUpdateElements()
{
    VcpListMenuCellTripleTextFrameEx::onUpdateElements();
    
    createItemTextFrameHelper(m_textFrame4, VCP_LIST_MENU_FIELD_TAIL_TEXT);
}
            

void VcpListMenuCellQuadTextFrameEx::onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame)
{
    VcpListMenuCellTripleTextFrameEx::onUpdateTextFrameStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextFrameStyle(fieldType, frame);
}


void VcpListMenuCellQuadTextFrameEx::onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame)
{
    VcpListMenuCellTripleTextFrameEx::onUpdateTextViewStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextViewStyle(fieldType, frame);
}



VfxBool VcpListMenuCellQuadTextFrameEx::getText(VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    if (fieldType == VCP_LIST_MENU_FIELD_TAIL_TEXT)
    {
        return getTextInt(m_textFrame4, text);
    }
    else
    {
        return VcpListMenuCellTripleTextFrameEx::getText(fieldType, text);
    }
}

/***************************************************************************** 
 * Class VcpListMenuCellIconSingleTextFrame
 *****************************************************************************/


VcpListMenuCellIconSingleTextFrame::VcpListMenuCellIconSingleTextFrame() : 
    m_textFrame(NULL),
    m_imageFrame(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT;
}


void VcpListMenuCellIconSingleTextFrame::onCreateElements()
{
    VFX_OBJ_CREATE(m_imageFrame, VfxImageFrame, this);
}


void VcpListMenuCellIconSingleTextFrame::onCloseElements()
{
    closeElementHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}

void VcpListMenuCellIconSingleTextFrame::onLayoutElements()
{
    vcpListMenuCellHelperPlaceMiddleLeftIcon(this, m_imageFrame, IMG_LEFT_GAPS, IMG_MAX_WIDTH);
    
    vcpListMenuCellHelperPlaceMiddleText(this, m_textFrame,
            TEXT_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH,
            getRect().getWidth() - TEXT_LEFT_GAPS - TEXT_RIGHT_GAPS - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH));
}


void VcpListMenuCellIconSingleTextFrame::onUpdateElements()
{
    createItemTextFrameHelper(m_textFrame, VCP_LIST_MENU_FIELD_TEXT);
    resetImageContentHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}


void VcpListMenuCellIconSingleTextFrame::onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextFrameStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextFrameStyle(fieldType, frame);
}

void VcpListMenuCellIconSingleTextFrame::onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextViewStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextViewStyle(fieldType, frame);
}


VfxBool VcpListMenuCellIconSingleTextFrame::getText(VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        return getTextInt(m_textFrame, text);
    }
    else
    {
        return VcpListMenuCellClientBaseFrame::getText(fieldType, text);
    }
}

/***************************************************************************** 
 * Class VcpListMenuCellIconSingleTextFrameEx
 *****************************************************************************/
VcpListMenuCellIconSingleTextFrameEx::VcpListMenuCellIconSingleTextFrameEx() : 
    m_imageFrame(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT_EX;
}

void VcpListMenuCellIconSingleTextFrameEx::onCreateElements()
{
    VcpListMenuCellSingleTextFrame::onCreateElements();

    VFX_OBJ_CREATE(m_imageFrame, VfxImageFrame, this);
}

void VcpListMenuCellIconSingleTextFrameEx::onCloseElements()
{
    closeElementHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
    
    VcpListMenuCellSingleTextFrame::onCloseElements();
}

void VcpListMenuCellIconSingleTextFrameEx::onLayoutElements()
{
    vcpListMenuCellHelperPlaceMiddleText(this, m_textFrame,
            LEFT_GAPS,
            getRect().getWidth() - LEFT_GAPS - RIGHT_GAPS - IMG_LEFT_GAPS - IMG_RIGHT_GAPS - IMG_MAX_WIDTH);

    if (m_imageFrame)
    {
        vcpListMenuCellHelperPlaceMiddleRightIcon(this, m_imageFrame, IMG_RIGHT_GAPS, m_imageFrame->getRect().getWidth());
    }
}

void VcpListMenuCellIconSingleTextFrameEx::onUpdateElements()
{
    VcpListMenuCellSingleTextFrame::onUpdateElements();

    resetImageContentHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}

/***************************************************************************** 
 * Class VcpListMenuCellIconSingleTextFrameEx2
 *****************************************************************************/
VcpListMenuCellIconSingleTextFrameEx2::VcpListMenuCellIconSingleTextFrameEx2() : 
    m_imageFrameEx(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_ICON_SINGLE_TEXT_EX2;
}

void VcpListMenuCellIconSingleTextFrameEx2::onCloseElements()
{
    closeElementHelper(m_imageFrameEx, VCP_LIST_MENU_FIELD_ICON_EXTRA1);
    
    VcpListMenuCellIconSingleTextFrame::onCloseElements();
}


void VcpListMenuCellIconSingleTextFrameEx2::onLayoutElements()
{
    VcpListMenuCellIconSingleTextFrame::onLayoutElements();
    
    vcpListMenuCellHelperPlaceMiddleRightIcon(this, m_imageFrameEx, IMG_EX_RIGHT_GAPS, IMG_EX_MAX_WIDTH);

    if (m_textFrame)
    {
        vcpListMenuCellHelperPlaceTopText(m_textFrame, m_textFrame->getPos().x, m_textFrame->getPos().y, m_textFrame->getRect().getWidth() - (IMG_EX_LEFT_GAPS + IMG_EX_RIGHT_GAPS + IMG_EX_MAX_WIDTH));
    }
}

void VcpListMenuCellIconSingleTextFrameEx2::onUpdateElements()
{
    VcpListMenuCellIconSingleTextFrame::onUpdateElements();

    resetImageContentHelper(m_imageFrameEx, VCP_LIST_MENU_FIELD_ICON_EXTRA1);
}

/***************************************************************************** 
 * Class VcpListMenuCellIconMultiTextFrame
 *****************************************************************************/

VcpListMenuCellIconMultiTextFrame::VcpListMenuCellIconMultiTextFrame() : 
    m_textFrame1(NULL),
    m_textFrame2(NULL),
    m_imageFrame(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_ICON_MULTI_TEXT;
}


void VcpListMenuCellIconMultiTextFrame::onCreateElements()
{
    VFX_OBJ_CREATE(m_imageFrame, VfxImageFrame, this);
}


void VcpListMenuCellIconMultiTextFrame::onCloseElements()
{
    closeElementHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}


void VcpListMenuCellIconMultiTextFrame::onLayoutElements()
{
    vcpListMenuCellHelperPlaceMiddleLeftIcon(this, m_imageFrame, IMG_LEFT_GAPS, IMG_MAX_WIDTH);

    VfxS32 leftGaps = TEXT1_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH;
    VfxS32 textFrame1Width = getRect().getWidth() - TEXT1_LEFT_GAPS - TEXT1_RIGHT_GAPS - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH);

    if (m_textFrame2)
    {
        vcpListMenuCellHelperPlaceTopText(m_textFrame1, leftGaps, TEXT1_TOP_GAPS, textFrame1Width);
    }
    else
    {
        /* vertical center alignment text 1 if no text 2 */
        vcpListMenuCellHelperPlaceMiddleText(this, m_textFrame1, leftGaps, textFrame1Width);
    }

    vcpListMenuCellHelperPlaceBottomText(this, m_textFrame2,
            TEXT2_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH,
            TEXT2_BOTTOM_GAPS,
            getRect().getWidth() - TEXT2_LEFT_GAPS - TEXT2_RIGHT_GAPS - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH));
}


void VcpListMenuCellIconMultiTextFrame::onUpdateElements()
{
    createItemTextFrameHelper(m_textFrame1, VCP_LIST_MENU_FIELD_TEXT);
    createItemTextFrameHelper(m_textFrame2, VCP_LIST_MENU_FIELD_SUB_TEXT1);

    resetImageContentHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}


void VcpListMenuCellIconMultiTextFrame::onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextFrameStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextFrameStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextFrameSetAlignLeft(frame);
    }
}

void VcpListMenuCellIconMultiTextFrame::onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextViewStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextViewStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextViewSetAlignLeft(frame);
    }
}

VfxBool VcpListMenuCellIconMultiTextFrame::getText(VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        return getTextInt(m_textFrame1, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
         return getTextInt(m_textFrame2, text);
    }
    else
    {
        return VcpListMenuCellClientBaseFrame::getText(fieldType, text);
    }
}


/***************************************************************************** 
 * Class VcpListMenuCellIconMultiTextExFrame
 *****************************************************************************/

VcpListMenuCellIconMultiTextExFrame::VcpListMenuCellIconMultiTextExFrame() : 
    m_textFrame1(NULL),
    m_textFrame2(NULL),
    m_imageFrame(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_ICON_MULTI_TEXT_EX;
}


void VcpListMenuCellIconMultiTextExFrame::onCreateElements()
{
    VFX_OBJ_CREATE(m_imageFrame, VfxImageFrame, this);
}


void VcpListMenuCellIconMultiTextExFrame::onCloseElements()
{
    closeElementHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}


void VcpListMenuCellIconMultiTextExFrame::onLayoutElements()
{
    vcpListMenuCellHelperPlaceMiddleLeftIcon(this, m_imageFrame, IMG_LEFT_GAPS, IMG_MAX_WIDTH);

    VfxS32 textFrame2AreaWidth = 0;

    if (m_textFrame2)
    {
        textFrame2AreaWidth = TEXT2_LEFT_GAPS + m_textFrame2->getRect().getWidth() + TEXT2_RIGHT_GAPS;
    }
    
    vcpListMenuCellHelperPlaceMiddleLeftText(this, m_textFrame1,
            TEXT1_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH,
            getRect().getWidth() - TEXT1_LEFT_GAPS - TEXT1_RIGHT_GAPS - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH) - textFrame2AreaWidth);

    vcpListMenuCellHelperPlaceMiddleRightText(this, m_textFrame2,
            TEXT2_RIGHT_GAPS);
}


void VcpListMenuCellIconMultiTextExFrame::onUpdateElements()
{
    createItemTextFrameHelper(m_textFrame1, VCP_LIST_MENU_FIELD_TEXT);
    createItemTextFrameHelper(m_textFrame2, VCP_LIST_MENU_FIELD_SUB_TEXT1);

    resetImageContentHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}


void VcpListMenuCellIconMultiTextExFrame::onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextFrameStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextFrameStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextFrameSetAlignRight(frame);
    }
}

void VcpListMenuCellIconMultiTextExFrame::onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextViewStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextViewStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextViewSetAlignRight(frame);
    }
}


VfxBool VcpListMenuCellIconMultiTextExFrame::getText(VcpListMenuFieldEnum fieldType, VfxWString &text)
{    
    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        return getTextInt(m_textFrame1, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        return getTextInt(m_textFrame2, text);
    }
    else
    {
        return VcpListMenuCellClientBaseFrame::getText(fieldType, text);
    }
}


/***************************************************************************** 
 * Class VcpListMenuCellIconTripleTextFrame
 *****************************************************************************/

VcpListMenuCellIconTripleTextFrame::VcpListMenuCellIconTripleTextFrame() : 
    m_textFrame1(NULL),
    m_textFrame2(NULL),
    m_textFrame3(NULL),
    m_imageFrame(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT;
}


void VcpListMenuCellIconTripleTextFrame::onCreateElements()
{
    VFX_OBJ_CREATE(m_imageFrame, VfxImageFrame, this);
}


void VcpListMenuCellIconTripleTextFrame::onCloseElements()
{
    closeElementHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}


void VcpListMenuCellIconTripleTextFrame::onLayoutElements()
{
    vcpListMenuCellHelperPlaceMiddleLeftIcon(this, m_imageFrame, IMG_LEFT_GAPS, IMG_MAX_WIDTH);

    vcpListMenuCellHelperPlaceTopLeftText(m_textFrame1,
            TEXT1_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH,
            TEXT1_TOP_GAPS,
            getRect().getWidth() - TEXT1_LEFT_GAPS - TEXT1_RIGHT_GAPS - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH));

    VfxS32 textFrame3AreaWidth = 0;

    if (m_textFrame3)
    {
        textFrame3AreaWidth = TEXT3_LEFT_GAPS + m_textFrame3->getRect().getWidth() + TEXT3_RIGHT_GAPS;
    }

    vcpListMenuCellHelperPlaceBottomLeftText(this, m_textFrame2,
            TEXT2_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH,
            TEXT2_BOTTOM_GAPS,
            getRect().getWidth() - TEXT2_LEFT_GAPS - TEXT2_RIGHT_GAPS - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH) - textFrame3AreaWidth);

    vcpListMenuCellHelperPlaceBottomRightText(this, m_textFrame3,
            TEXT3_RIGHT_GAPS,
            TEXT3_BOTTOM_GAPS);
}


void VcpListMenuCellIconTripleTextFrame::onUpdateElements()
{
    createItemTextFrameHelper(m_textFrame1, VCP_LIST_MENU_FIELD_TEXT);
    createItemTextFrameHelper(m_textFrame2, VCP_LIST_MENU_FIELD_SUB_TEXT1);
    createItemTextFrameHelper(m_textFrame3, VCP_LIST_MENU_FIELD_SUB_TEXT2);

    resetImageContentHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}


void VcpListMenuCellIconTripleTextFrame::onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextFrameStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextFrameStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextFrameSetAlignLeft(frame);
    }
}

void VcpListMenuCellIconTripleTextFrame::onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextViewStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextViewStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextViewSetAlignLeft(frame);
    }
}


VfxBool VcpListMenuCellIconTripleTextFrame::getText(VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        return getTextInt(m_textFrame1, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        return getTextInt(m_textFrame2, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT2)
    {
        return getTextInt(m_textFrame3, text);
    }
    else
    {
        return VcpListMenuCellClientBaseFrame::getText(fieldType, text);
    }
}


/***************************************************************************** 
 * Class VcpListMenuCellIconTripleTextFrameEx
 *****************************************************************************/

VcpListMenuCellIconTripleTextFrameEx::VcpListMenuCellIconTripleTextFrameEx() : 
    m_extraImgFrame1(NULL),
    m_extraImgFrame2(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_ICON_TRIPLE_TEXT_EX;
}


void VcpListMenuCellIconTripleTextFrameEx::onCloseElements()
{
    VcpListMenuCellIconTripleTextFrame::onCloseElements();

    closeElementHelper(m_extraImgFrame1, VCP_LIST_MENU_FIELD_ICON_EXTRA1);
    closeElementHelper(m_extraImgFrame2, VCP_LIST_MENU_FIELD_ICON_EXTRA2);
}


void VcpListMenuCellIconTripleTextFrameEx::onLayoutElements()
{
    VfxS32 imgWidth = 0;

    VcpListMenuCellIconTripleTextFrame::onLayoutElements();

    if (m_textFrame3)
    {
        VfxS32 maxIconHeight = 0;
        VfxS32 bottomGap = 2;

        maxIconHeight = m_textFrame3->getRect().getMinY() - IMG_EX2_TOP_GAPS - bottomGap;

        vcpListMenuCellHelperLimitFrameHeight(m_extraImgFrame1, maxIconHeight);
        vcpListMenuCellHelperLimitFrameHeight(m_extraImgFrame2, maxIconHeight);
    }

    if (m_extraImgFrame2)
    {
        vcpListMenuCellHelperPlaceTopRightIcon(this, m_extraImgFrame2, IMG_EX2_RIGHT_GAPS, IMG_EX2_TOP_GAPS);

        imgWidth += IMG_EX2_LEFT_GAPS + m_extraImgFrame2->getRect().getWidth() + IMG_EX2_RIGHT_GAPS;
    }

    if (m_extraImgFrame1)
    {
        vcpListMenuCellHelperPlaceTopRightIcon(this, m_extraImgFrame1, imgWidth + IMG_EX1_RIGHT_GAPS, IMG_EX1_TOP_GAPS);

        imgWidth += IMG_EX1_LEFT_GAPS + m_extraImgFrame1->getRect().getWidth() + IMG_EX1_RIGHT_GAPS;
    }

    vcpListMenuCellHelperPlaceTopLeftText(m_textFrame1,
            TEXT1_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH,
            TEXT1_TOP_GAPS,
            getRect().getWidth() - TEXT1_LEFT_GAPS - TEXT1_RIGHT_GAPS - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH) - imgWidth);
}


void VcpListMenuCellIconTripleTextFrameEx::onUpdateElements()
{
    VcpListMenuCellIconTripleTextFrame::onUpdateElements();
    
    resetImageContentHelper(m_extraImgFrame1, VCP_LIST_MENU_FIELD_ICON_EXTRA1);
    resetImageContentHelper(m_extraImgFrame2, VCP_LIST_MENU_FIELD_ICON_EXTRA2);
}

/***************************************************************************** 
 * Class VcpListMenuCellIconQuadTextFrame
 *****************************************************************************/

VcpListMenuCellIconQuadTextFrame::VcpListMenuCellIconQuadTextFrame() : 
    m_textFrame1(NULL),
    m_textFrame2(NULL),
    m_textFrame3(NULL),
    m_textFrame4(NULL),
    m_imageFrame(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_ICON_QUADRUPLE_TEXT;
}


void VcpListMenuCellIconQuadTextFrame::onCreateElements()
{
    VFX_OBJ_CREATE(m_imageFrame, VfxImageFrame, this);
}


void VcpListMenuCellIconQuadTextFrame::onCloseElements()
{
    closeElementHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}


void VcpListMenuCellIconQuadTextFrame::onLayoutElements()
{
    vcpListMenuCellHelperPlaceMiddleLeftIcon(this, m_imageFrame, IMG_LEFT_GAPS, IMG_MAX_WIDTH);

    VfxS32 textFrame3AreaWidth = 0;

    if (m_textFrame3)
    {
        textFrame3AreaWidth = TEXT3_LEFT_GAPS + m_textFrame3->getRect().getWidth() + TEXT3_RIGHT_GAPS;
    }
    
    vcpListMenuCellHelperPlaceTopLeftText(m_textFrame1,
            TEXT1_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH,
            TEXT1_TOP_GAPS,
            getRect().getWidth() - TEXT1_LEFT_GAPS - TEXT1_RIGHT_GAPS - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH) - textFrame3AreaWidth);

    VfxS32 textFrame4AreaWidth = 0;

    if (m_textFrame4)
    {
        textFrame4AreaWidth = TEXT4_LEFT_GAPS + m_textFrame4->getRect().getWidth() + TEXT4_RIGHT_GAPS;
    }

    vcpListMenuCellHelperPlaceBottomLeftText(this, m_textFrame2,
            TEXT2_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH,
            TEXT2_BOTTOM_GAPS,
            getRect().getWidth() - TEXT2_LEFT_GAPS - TEXT2_RIGHT_GAPS - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH) - textFrame4AreaWidth);

    vcpListMenuCellHelperPlaceTopRightText(this, m_textFrame3,
            TEXT3_RIGHT_GAPS,
            TEXT3_TOP_GAPS);
    
    vcpListMenuCellHelperPlaceBottomRightText(this, m_textFrame4,
            TEXT4_RIGHT_GAPS,
            TEXT4_BOTTOM_GAPS);
}


void VcpListMenuCellIconQuadTextFrame::onUpdateElements()
{
    createItemTextFrameHelper(m_textFrame1, VCP_LIST_MENU_FIELD_TEXT);
    createItemTextFrameHelper(m_textFrame2, VCP_LIST_MENU_FIELD_SUB_TEXT1);
    createItemTextFrameHelper(m_textFrame3, VCP_LIST_MENU_FIELD_SUB_TEXT2);
    createItemTextFrameHelper(m_textFrame4, VCP_LIST_MENU_FIELD_SUB_TEXT3);

    resetImageContentHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}


void VcpListMenuCellIconQuadTextFrame::onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextFrameStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextFrameStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextFrameSetAlignLeft(frame);
    }
}

void VcpListMenuCellIconQuadTextFrame::onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextViewStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextViewStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextViewSetAlignLeft(frame);
    }
}


VfxBool VcpListMenuCellIconQuadTextFrame::getText(VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        return getTextInt(m_textFrame1, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        return getTextInt(m_textFrame2, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT2)
    {
        return getTextInt(m_textFrame3, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT3)
    {
        return getTextInt(m_textFrame4, text);
    }
    else
    {
        return VcpListMenuCellClientBaseFrame::getText(fieldType, text);
    }
}

/***************************************************************************** 
 * Class VcpListMenuCellIconQuintTextFrame
 *****************************************************************************/

VcpListMenuCellIconQuintTextFrame::VcpListMenuCellIconQuintTextFrame() : 
    m_textFrame1(NULL),
    m_textFrame2(NULL),
    m_textFrame3(NULL),
    m_textFrame4(NULL),
    m_textFrame5(NULL),
    m_imageFrame(NULL)
{
    m_style = VCP_LIST_MENU_CELL_STYLE_ICON_QUINTUPLE_TEXT;
}


void VcpListMenuCellIconQuintTextFrame::onCreateElements()
{
    VFX_OBJ_CREATE(m_imageFrame, VfxImageFrame, this);
}


void VcpListMenuCellIconQuintTextFrame::onCloseElements()
{
    closeElementHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}


void VcpListMenuCellIconQuintTextFrame::onLayoutElements()
{
    vcpListMenuCellHelperPlaceMiddleLeftIcon(this, m_imageFrame, IMG_LEFT_GAPS, IMG_MAX_WIDTH);

    VfxS32 textFrame4AreaWidth = 0;

    if (m_textFrame4)
    {
        textFrame4AreaWidth = TEXT4_LEFT_GAPS + m_textFrame4->getRect().getWidth() + TEXT4_RIGHT_GAPS;
    }

    VfxS32 textFrame2AreaWidth = 0;

    if (m_textFrame2)
    {
        textFrame2AreaWidth = TEXT2_LEFT_GAPS + m_textFrame2->getRect().getWidth() + TEXT2_RIGHT_GAPS;
    }

    VfxS32 maxText1Width = getRect().getWidth() - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH) - TEXT1_LEFT_GAPS - TEXT1_RIGHT_GAPS - textFrame4AreaWidth - textFrame2AreaWidth;

    if (m_textFrame1)
    {
        VfxS32 maxW = vcpListMenuCellHelperGetTextMaxWidth(m_textFrame1);

        vcpListMenuCellHelperPlaceTopLeftText(m_textFrame1,
                TEXT1_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH,
                TEXT1_TOP_GAPS,
                (maxW > maxText1Width) ? maxText1Width : maxW);
    }

    VfxS32 textFrame1MaxX = TEXT1_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH;

    if (m_textFrame1)
    {
        textFrame1MaxX = m_textFrame1->getRect().getMaxX();
    }
    
    vcpListMenuCellHelperPlaceTopInnerText(m_textFrame2,
            textFrame1MaxX + TEXT1_RIGHT_GAPS + TEXT2_LEFT_GAPS,
            TEXT2_TOP_GAPS);

    VfxS32 textFrame5AreaWidth = 0;

    if (m_textFrame5)
    {
        textFrame5AreaWidth = TEXT5_LEFT_GAPS + m_textFrame5->getRect().getWidth() + TEXT5_RIGHT_GAPS;
    }

    vcpListMenuCellHelperPlaceBottomLeftText(this, m_textFrame3,
            TEXT3_LEFT_GAPS + IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH,
            TEXT3_BOTTOM_GAPS,
            getRect().getWidth() - TEXT3_LEFT_GAPS - TEXT3_RIGHT_GAPS - (IMG_LEFT_GAPS + IMG_RIGHT_GAPS + IMG_MAX_WIDTH) - textFrame5AreaWidth);

    vcpListMenuCellHelperPlaceTopRightText(this, m_textFrame4, 
            TEXT4_RIGHT_GAPS,
            TEXT4_TOP_GAPS);

    vcpListMenuCellHelperPlaceBottomRightText(this, m_textFrame5,
            TEXT5_RIGHT_GAPS,
            TEXT5_BOTTOM_GAPS);
}


void VcpListMenuCellIconQuintTextFrame::onUpdateElements()
{
    createItemTextFrameHelper(m_textFrame1, VCP_LIST_MENU_FIELD_TEXT);
    createItemTextFrameHelper(m_textFrame2, VCP_LIST_MENU_FIELD_TAIL_TEXT);
    createItemTextFrameHelper(m_textFrame3, VCP_LIST_MENU_FIELD_SUB_TEXT1);
    createItemTextFrameHelper(m_textFrame4, VCP_LIST_MENU_FIELD_SUB_TEXT2);
    createItemTextFrameHelper(m_textFrame5, VCP_LIST_MENU_FIELD_SUB_TEXT3);

    resetImageContentHelper(m_imageFrame, VCP_LIST_MENU_FIELD_ICON);
}


void VcpListMenuCellIconQuintTextFrame::onUpdateTextFrameStyle(VcpListMenuFieldEnum fieldType, VfxTextFrame *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextFrameStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextFrameStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextFrameSetAlignLeft(frame);
    }
}

void VcpListMenuCellIconQuintTextFrame::onUpdateTextViewStyle(VcpListMenuFieldEnum fieldType, VcpTextView *frame)
{
    VcpListMenuCellClientBaseFrame::onUpdateTextViewStyle(fieldType, frame);

    vcpListMenuCellHelperOnUpdateTextViewStyle(fieldType, frame);

    if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        vcpListMenuCellHelperTextViewSetAlignLeft(frame);
    }
}


VfxBool VcpListMenuCellIconQuintTextFrame::getText(VcpListMenuFieldEnum fieldType, VfxWString &text)
{
    if (fieldType == VCP_LIST_MENU_FIELD_TEXT)
    {
        return getTextInt(m_textFrame1, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_TAIL_TEXT)
    {
        return getTextInt(m_textFrame2, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT1)
    {
        return getTextInt(m_textFrame3, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT2)
    {
        return getTextInt(m_textFrame4, text);
    }
    else if (fieldType == VCP_LIST_MENU_FIELD_SUB_TEXT3)
    {
        return getTextInt(m_textFrame5, text);
    }
    else
    {
        return VcpListMenuCellClientBaseFrame::getText(fieldType, text);
    }
}


/***************************************************************************** 
 * Class VcpListMenuCellBaseControl
 *****************************************************************************/

void VcpListMenuCellBaseControl::onInit()
{
    VfxControl::onInit();

    m_signalBoundsChanged.connect(this, &VcpListMenuCellBaseControl::onBoundsValueChanged);
}

VcpListMenuCell* VcpListMenuCellBaseControl::getCell()
{
    return VFX_STATIC_CAST(getParentControl(), VcpListMenuCell*);
}


VcpBaseListMenu* VcpListMenuCellBaseControl::getMenu()
{
    VcpListMenuCell* cell = getCell();

    if (cell)
    {
        return cell->getMenu();
    }
    else
    {
        return NULL;
    }
}


IVcpListMenuContentProviderInt* VcpListMenuCellBaseControl::getContentProvider()
{
    VcpBaseListMenu *menu = getMenu();

    if (menu)
    {
        IVcpListMenuContentProviderInt *provider = menu->getContentProviderInt();
       
        return provider;
    }
    
    return NULL;
}


/***************************************************************************** 
 * Class VcpListMenuCellThumb
 *****************************************************************************/

VcpListMenuCellThumb::VcpListMenuCellThumb() :
    m_thumbIcon(NULL),
    m_isDragging(VFX_FALSE)
{
    m_type = VCP_LIST_MENU_CELL_CONTROL_TYPE_REORDER_THUMB;
}


void VcpListMenuCellThumb::onInit()
{
    VcpListMenuCellBaseControl::onInit();
    
    VFX_OBJ_CREATE(m_thumbIcon, VfxImageFrame, this);

    m_thumbIcon->setResId(VCP_IMG_LIST_MENU_REORDER_THUMB);

    setAutoAnimate(VFX_TRUE);
    setFuzzy(VFX_TRUE);
}


VfxBool VcpListMenuCellThumb::onPenAbortAccepted(VfxControl *aborter, VfxPenAbortReasonEnum reason)
{
    if (m_isDragging)
    {
        return VFX_FALSE;
    }

    return VcpListMenuCellBaseControl::onPenAbortAccepted(aborter, reason);
}


VfxBool VcpListMenuCellThumb::onPenInput(VfxPenEvent &event)
{
    switch (event.type)
    {
        case VFX_PEN_EVENT_TYPE_DOWN:
#if !defined(__MMI_VUI_COSMOS_CP__)
            gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
#endif /* !defined(__MMI_VUI_COSMOS_CP__) */
            m_isDragging = VFX_TRUE;
            getCell()->onCellDrag(event);
            return VFX_TRUE;
        case VFX_PEN_EVENT_TYPE_MOVE:
            getCell()->onCellMove(event);
            return VFX_TRUE;
        case VFX_PEN_EVENT_TYPE_UP:
        case VFX_PEN_EVENT_TYPE_ABORT:
            getCell()->onCellDrop(event);
            m_isDragging = VFX_FALSE;
            return VFX_TRUE;
    };
    return VFX_TRUE;
}

void VcpListMenuCellThumb::onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds)
{
    vcpListMenuCellHelperPlaceOnCenter(m_thumbIcon, this);
}


/***************************************************************************** 
 * Class VcpListMenuCmdButton
 *****************************************************************************/

VcpListMenuCmdButton::VcpListMenuCmdButton(VcpStateImage stateImage)
{
    m_stateImage.setImage(
        stateImage.getImageNormal(),
        stateImage.getImagePressed(),
        stateImage.getImageDisabled(),
        stateImage.getImageHighlight());

    setSize(stateImage.getImageNormal().getSize());
    m_type = VCP_LIST_MENU_CELL_CONTROL_TYPE_CMD_BUTTON;
}


void VcpListMenuCmdButton::onInit()
{
    VcpListMenuCellBaseControl::onInit();
    
    VFX_OBJ_CREATE(m_imageButton, VcpImageButton, this);

    m_imageButton->setImage(m_stateImage);

    VfxSize imgSize = m_stateImage.getImageNormal().getSize();

    m_imageButton->setRect(VfxRect(VfxPoint(0, 0), imgSize));

    m_imageButton->m_signalClicked.connect(this, &VcpListMenuCmdButton::onButtonClicked);
    
    setAutoAnimate(VFX_TRUE);                
}


VfxBool VcpListMenuCmdButton::onContainPoint(const VfxPoint &point) const
{
    if (m_imageButton)
    {
        return m_imageButton->containPoint(point, VFX_TRUE);
    }
    else
    {
        return VcpListMenuCellBaseControl::onContainPoint(point);
    }
}


void VcpListMenuCmdButton::onButtonClicked(VfxObject *source, VfxId id)
{
    VcpBaseListMenu *menu = getMenu();

    if (menu)
    {
        menu->m_signalCmdButtonClickedInt.postEmit(getCell()->m_pos);
    }
}


void VcpListMenuCmdButton::onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds)
{
    vcpListMenuCellHelperPlaceOnCenter(m_imageButton, this);
}


void VcpListMenuCmdButton::updateState()
{
    if (m_imageButton)
    {
        IVcpListMenuContentProviderInt* contentProvider = getContentProvider();

        if (contentProvider)
        {
            VcpListMenuCmdStateEnum state = contentProvider->getItemCmdState(getCell()->m_pos);

            switch(state)
            {
                case VCP_LIST_MENU_CMD_STATE_NORMAL:
                    m_imageButton->setIsDisabled(VFX_FALSE);
                    m_imageButton->setIsHighlight(VFX_FALSE);
                    break;

                case VCP_LIST_MENU_CMD_STATE_DISABLED:
                    m_imageButton->setIsDisabled(VFX_TRUE);
                    break;

                case VCP_LIST_MENU_CMD_STATE_HIGHLIGHT:
                    m_imageButton->setIsHighlight(VFX_TRUE);
                    break;

                default:
                    break;
            }
        }
    }
}


void VcpListMenuCmdButton::update(VfxBool isAnim)
{
    IVcpListMenuContentProviderInt* contentProvider = getContentProvider();

    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(!isAnim);
    
    if (contentProvider)
    {
        VfxImageSrc normal, pressed, disabled, highlight;
        
        if (contentProvider->getItemImage(getCell()->m_pos, VCP_LIST_MENU_FIELD_CMD_BUT_IMG_NORMAL, normal))
        {
            if (contentProvider->getItemImage(getCell()->m_pos, VCP_LIST_MENU_FIELD_CMD_BUT_IMG_PRESSED, pressed))
            {
                if (contentProvider->getItemImage(getCell()->m_pos, VCP_LIST_MENU_FIELD_CMD_BUT_IMG_DISABLED, disabled))
                {
                    if (contentProvider->getItemImage(getCell()->m_pos, VCP_LIST_MENU_FIELD_CMD_BUT_IMG_HIGHLIGHT, highlight))
                    {
                        m_stateImage.setImage(normal, pressed, disabled, highlight);

                        m_imageButton->setImage(m_stateImage);
                    }
                }    
            }
        }
    }

    updateState();

    VfxAutoAnimate::commit();
}

/***************************************************************************** 
 * Class VcpListMenuSelectable
 *****************************************************************************/
VcpListMenuSelectable::VcpListMenuSelectable() : 
    m_imageFrame(NULL),
    m_isSelected(VFX_FALSE)
{
}

void VcpListMenuSelectable::setSelection(VfxBool isSelected)
{
    if (m_isSelected != isSelected)
    {
        VcpListMenuItemStateEnum newState;
        
        newState = isSelected ? VCP_LIST_MENU_ITEM_STATE_SELECTED : VCP_LIST_MENU_ITEM_STATE_UNSELECTED;
        
        IVcpListMenuContentProviderInt* contentProvider = getContentProvider();
        
        if (contentProvider && contentProvider->getItemStateValidation(getCell()->m_pos, newState))
        {
            m_isSelected = isSelected;
            
            VcpBaseListMenu *menu = getMenu();

            if (menu)
            {
                menu->m_signalItemSelectionStateChangedInt.emit(getCell()->m_pos, newState);
            }
        }
    }
    
    if (m_isSelected)
    {
        setImgContent(VfxImageSrc(VCP_IMG_LIST_MENU_RADIO_BUTTON_ON));
    }
    else
    {
        setImgContent(VfxImageSrc(VCP_IMG_LIST_MENU_RADIO_BUTTON_OFF));
    }
}

void VcpListMenuSelectable::update(VfxBool isAnim)
{
    IVcpListMenuContentProviderInt* contentProvider = getContentProvider();

    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(!isAnim);
    
    if (contentProvider)
    {
        if (contentProvider->getItemState(getCell()->m_pos) == VCP_LIST_MENU_ITEM_STATE_SELECTED)
        {
            setSelection(VFX_TRUE);
        }
        else
        {
            setSelection(VFX_FALSE);
        }
    }

    VfxAutoAnimate::commit();
}

void VcpListMenuSelectable::onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds)
{
    vcpListMenuCellHelperPlaceOnCenter(m_imageFrame, this);
}

void VcpListMenuSelectable::onInit()
{
    VcpListMenuCellBaseControl::onInit();

    VFX_OBJ_CREATE(m_imageFrame, VfxImageFrame, this);

    VcpBaseListMenu *menu = getMenu();

    if (menu)
    {
        menu->m_signalItemTappedInt.connect(this, &VcpListMenuSelectable::cellSelected);
        
        menu->m_signalItemSelectedInt.connect(this, &VcpListMenuSelectable::cellSelected);
    }

    IVcpListMenuContentProviderInt* contentProvider = getContentProvider();

    if (contentProvider)
    {
        if (contentProvider->getItemState(getCell()->m_pos) == VCP_LIST_MENU_ITEM_STATE_SELECTED)
        {
            m_isSelected = VFX_TRUE;
        }
        else
        {
            m_isSelected = VFX_FALSE;
        }
    }

    setSelection(m_isSelected);
    
    setAutoAnimate(VFX_TRUE);                
}

void VcpListMenuSelectable::cellSelected(VcpMenuPos pos)
{
    IVcpListMenuContentProviderInt* contentProvider = getContentProvider();

    if (contentProvider)
    {
        if (contentProvider->getItemState(pos) == VCP_LIST_MENU_ITEM_STATE_NONE) 
        {
            return; // The tapped item state can't be changed, so the state of other item can't be changed too
        }
    }

    onCellSelected(pos);
}

/***************************************************************************** 
 * Class VcpListMenuRadioButton
 *****************************************************************************/

VcpListMenuRadioButton::VcpListMenuRadioButton()
{
    m_type = VCP_LIST_MENU_CELL_CONTROL_TYPE_RADIO_BUTTON;
}

void VcpListMenuRadioButton::setSelection(VfxBool isSelected)
{
    VcpListMenuSelectable::setSelection(isSelected);
    
    if (m_isSelected)
    {
        setImgContent(VfxImageSrc(VCP_IMG_LIST_MENU_RADIO_BUTTON_ON));
    }
    else
    {
        setImgContent(VfxImageSrc(VCP_IMG_LIST_MENU_RADIO_BUTTON_OFF));
    }
}

void VcpListMenuRadioButton::onCellSelected(VcpMenuPos pos)
{
    if (pos == getCell()->m_pos)
    {
        setSelection(VFX_TRUE);
    }
    else 
    {
        setSelection(VFX_FALSE);
    }
}


/***************************************************************************** 
 * Class VcpListMenuCheckBox
 *****************************************************************************/

VcpListMenuCheckBox::VcpListMenuCheckBox()
{
    m_type = VCP_LIST_MENU_CELL_CONTROL_TYPE_CHECK_BOX;
}

void VcpListMenuCheckBox::setSelection(VfxBool isSelected)
{
    VcpListMenuSelectable::setSelection(isSelected);

    if (m_isSelected)
    {
        setImgContent(VfxImageSrc(VCP_IMG_LIST_MENU_CHECK_BOX_ON));
    }
    else
    {
        setImgContent(VfxImageSrc(VCP_IMG_LIST_MENU_CHECK_BOX_OFF));
    }
}

void VcpListMenuCheckBox::onCellSelected(VcpMenuPos pos)
{
    if (pos == getCell()->m_pos)
    {
        setSelection(!m_isSelected);
    }
}

/***************************************************************************** 
 * Class VcpListMenuDisclosure
 *****************************************************************************/

VcpListMenuDisclosure::VcpListMenuDisclosure(VfxImageSrc img) :
    m_imageFrame(NULL),
    m_image(img)
{
    m_type = VCP_LIST_MENU_CELL_CONTROL_TYPE_DISCLOSURE;
}


void VcpListMenuDisclosure::onInit()
{
    VcpListMenuCellBaseControl::onInit();
    
    VFX_OBJ_CREATE(m_imageFrame, VfxImageFrame, this);
    
    m_imageFrame->setImgContent(m_image);
    setSize(m_imageFrame->getSize());
    
    setAutoAnimate(VFX_TRUE);                
}


void VcpListMenuDisclosure::setHighlight(VfxBool isHighlight)
{
    IVcpListMenuContentProviderInt* contentProvider = getContentProvider();
    VfxImageSrc image;

    if (isHighlight)
    {
        if (contentProvider->getItemImage(getCell()->m_pos, VCP_LIST_MENU_FIELD_HIGHLIGHT_DISCLOSURE_IMG, image))
        {
            m_image = image;

            m_imageFrame->setImgContent(m_image);
        }
        else
        {
            if (m_image.getResId() != VFX_RES_ID_NULL &&
                m_image.getResId() == VCP_IMG_LIST_MENU_DEFAULT_DISCLOSURE)
            {
                m_image.setResId(VCP_IMG_LIST_MENU_DEFAULT_HIGHLIGHT_DISCLOSURE);
                m_imageFrame->setImgContent(m_image);
            }
        }
    }
    else
    {
        if (contentProvider->getItemImage(getCell()->m_pos, VCP_LIST_MENU_FIELD_DISCLOSURE_IMG, image))
        {
            m_image = image;
            m_imageFrame->setImgContent(m_image);
        }
    }
}


void VcpListMenuDisclosure::onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds)
{
    vcpListMenuCellHelperPlaceOnCenter(m_imageFrame, this);
}

/***************************************************************************** 
 * Class VcpListMenuCheckBox
 *****************************************************************************/

VcpListMenuCheckMark::VcpListMenuCheckMark(VfxBool isMultiSelect) : 
    m_isMultiSelect(isMultiSelect)
{
    m_type = VCP_LIST_MENU_CELL_CONTROL_TYPE_CHECK_MARK;
}

void VcpListMenuCheckMark::setSelection(VfxBool isSelected)
{
    VcpListMenuSelectable::setSelection(isSelected);
    
    if (m_isSelected)
    {
        setImgContent(VfxImageSrc(VCP_IMG_LIST_MENU_CHECK_MARK));
        setHidden(VFX_FALSE);
    }
    else
    {
        setHidden(VFX_TRUE);
    }
}

void VcpListMenuCheckMark::onCellSelected(VcpMenuPos pos)
{
    if (m_isMultiSelect)
    {
        if (pos == getCell()->m_pos)
        {
            setSelection(!m_isSelected);
        }
    }
    else if (pos == getCell()->m_pos)
    {
        setSelection(VFX_TRUE);
    }
    else 
    {
        setSelection(VFX_FALSE);
    }
}


/***************************************************************************** 
 * Class VcpListMenuSearchBar
 *****************************************************************************/
 
#define VCP_LIST_MENU_SEARCH_BAR_DEFAULT_MAX_TEXT_LENGTH 20

VcpListMenuSearchBar::VcpListMenuSearchBar() : 
    m_textEditor(NULL), 
    m_searchButton(NULL),
    m_leftMarginWidth(0),
    m_rightMarginWidth(0),
    m_maxSearchLength(VCP_LIST_MENU_SEARCH_BAR_DEFAULT_MAX_TEXT_LENGTH),
    m_textBuf(NULL)
{
}


void VcpListMenuSearchBar::updateLayout()
{
    m_shadow->setSize(getBounds().getWidth(), m_shadow->getBounds().getHeight());
    m_shadow->setPos(0, getBounds().getHeight() - m_shadow->getBounds().getHeight());

    /* assume the top, bottom and right margin are the same as left one */
    m_textEditor->setRect(m_leftMarginWidth, TOP_BOTTOM_MARGIN,
        getBounds().getWidth() - (m_leftMarginWidth * 2 + m_rightMarginWidth),
        getBounds().getHeight() - TOP_BOTTOM_MARGIN * 2);
}


void VcpListMenuSearchBar::setLeftMarginWidth(VfxU32 width)
{
    m_leftMarginWidth = width;
}


void VcpListMenuSearchBar::setRightMarginWidth(VfxU32 width)
{
    m_rightMarginWidth = width;
}


void VcpListMenuSearchBar::onInit()
{
    VfxControl::onInit();

    VFX_OBJ_CREATE(m_shadow, VfxImageFrame, this);

    VfxImageSrc shadowImageSrc(VCP_IMG_LIST_MENU_TOP_SHADOW_U);

    m_shadow->setImgContent(shadowImageSrc);

    m_shadow->setRect(0, 0, getBounds().getWidth(), shadowImageSrc.getSize().height);

    m_shadow->setContentPlacement(VFX_FRAME_CONTENT_PLACEMENT_TYPE_RESIZE);

    VFX_OBJ_CREATE(m_textEditor, VcpTextEditor, this);

    VFX_ALLOC_MEM(m_textBuf, sizeof(VfxWChar)*m_maxSearchLength, this);

    memset(m_textBuf, 0, sizeof(VfxWChar)*m_maxSearchLength);

    //m_textEditor->setBounds(VfxRect(0, 0, VCP_LIST_MENU_SEARCH_BAR_DEFAULT_EDITOR_WIDTH, VCP_LIST_MENU_SEARCH_BAR_DEFAULT_EDITOR_HEIGHT));

    m_textEditor->setText(m_textBuf, 
        VCP_LIST_MENU_SEARCH_BAR_DEFAULT_MAX_TEXT_LENGTH);

    m_textEditor->setLineMode(VCP_TEXT_LINE_MODE_SINGLE);

    m_textEditor->setHint(STR_GLOBAL_SEARCH);

    m_textEditor->setDeleteButton(VFX_TRUE);

    m_textEditor-> setAutoActivateByKey(VFX_TRUE);
    
    VFX_OBJ_CREATE(m_searchIcon, VfxImageFrame, this);

    m_searchIcon->setImgContent(VfxImageSrc(VCP_IMG_LIST_MENU_SEARCH));

    m_textEditor->setMarginFrame(VCP_TEXT_MARGIN_FRAME_LEFT, m_searchIcon);

    m_textEditor->setAutoAnimate(VFX_TRUE);

    m_signalBoundsChanged.connect(this, &VcpListMenuSearchBar::onBoundsValueChanged);
}

void VcpListMenuSearchBar::onDeinit()
{
    VFX_FREE_MEM(m_textBuf);

    VfxControl::onDeinit();
}

void VcpListMenuSearchBar::setMaxSearchLength(VfxS32 length)
{
    if (length == m_maxSearchLength)
    {
        return;
    }
    
    if (length > m_maxSearchLength)
    {
        VfxWChar *newBuf;

        VFX_ALLOC_MEM(newBuf, sizeof(VfxWChar)*length, this);

        memset(newBuf, 0, sizeof(VfxWChar)*length);

        memcpy(newBuf, m_textBuf, sizeof(VfxWChar)*m_maxSearchLength);

        VFX_FREE_MEM(m_textBuf);

        m_textBuf = newBuf;
    }

    m_textEditor->setText(m_textBuf, length);

    m_maxSearchLength = length;
}

void VcpListMenuSearchBar::onBoundsValueChanged(VfxFrame *source, const VfxRect &oldBounds)
{
    updateLayout();
}
