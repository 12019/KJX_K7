/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2008
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES. ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vfx_mmi.cpp
 *
 * Project:
 * --------
 *  Venus UI
 *
 * Description:
 * ------------
 *  Description
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * Include
 *****************************************************************************/

#include "vfx_mmi.h"

#include "vfx_cpp_base.h"
#include "vfx_system.h"
#include "vfx_object.h"
#include "vfx_async_signal.h"
#include "vfx_renderer.h"
#include "vfx_timer.h"
#include "vrt_canvas.h"
#include "vfx_logger.h"
#include "vfx_adp_device.h"

#if defined(__COSMOS_MMI__)
#include "vcp_frame_effect.h"
#include "vfx_top_level.h"
#endif

#include "vadp_sys_trc.h"
extern "C"
{
//#include "MMIDataType.h"
// for gdi_lcd_get_hw_update() and gdi_waiting_blt_finish()
#include "gdi_include.h"
}


/***************************************************************************** 
 * Pre-Declaration
 *****************************************************************************/

//extern "C" void mmi_frm_pen_reset_context_for_new_screen(void);


/***************************************************************************** 
 * Define
 *****************************************************************************/

#ifdef __MTK_TARGET__
//#define __MAUI_SOFTWARE_LA__
#endif

#if defined(VFX_CFG_SOFTWARE_LA)
#undef __MAUI_SOFTWARE_LA__
#define __MAUI_SOFTWARE_LA__
#endif

#ifdef __MAUI_SOFTWARE_LA__
extern "C"
{
#include "SST_sla.h"
}
#endif


/***************************************************************************** 
 * Global function
 *****************************************************************************/

void vfx_mmi_sys_init()
{
    if (vfx_sys_get_canvas_state() != VFX_SYS_STATE_UNKNOWN)
    {
        // Venus engine has been initialized, do nothing.
        //  In some case, init function may be called more than once.
        return;
    }

    VFX_LOG(VFX_INFO, VFX_MMI_INIT);

    vfx_sys_init();
}


void vfx_mmi_onidle(void)
{
    // It is the timing that there is no primitive now.
    vfx_mmi_update_scene();
}


static void vfx_mmi_update_scene_ex(VfxBool forceCommit, VfxRendererCommitActionEnum commitAction)
{
    if (vfx_sys_get_canvas_state() == VFX_SYS_STATE_UNKNOWN)
    {
        // The venus engine is not init yet.
        return;
    }

    VfxBool commitToVrt = forceCommit ?
        VFX_TRUE : 
        (vfx_adp_sleep_mode_get_state() == VFX_ADP_SLEEP_MODE_STATE_ENABLE);

    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    VfxAsyncSignalQueue *queue = VFX_OBJ_GET_INSTANCE(VfxAsyncSignalQueue);
    VfxBool emitAnyTimer = VFX_FALSE;
    do
    {
        // Process Post Event
        queue->processEmit();
        
        VfxMsec currentTime = renderer->updateScene(commitToVrt, commitAction);

        renderer->processBlockNextCommit(currentTime);

        // Commit all timers
        //  it will also callback the zero timer
        VfxTimerManager *timerManager = VFX_OBJ_GET_INSTANCE(VfxTimerManager);
        emitAnyTimer = timerManager->processCommit(currentTime, !commitToVrt);

        VFX_LOG(VFX_INFO3, VFX_MMI_UPDATE_SCENE_COMMIT, currentTime);    
    } while (!queue->isEmpty() || emitAnyTimer);
}


void vfx_mmi_update_scene(void)
{
    vfx_mmi_update_scene_ex(VFX_FALSE, VFX_RENDERER_COMMIT_ACTION_KEEP);
}


void vfx_mmi_update_scene_and_suspend(void)
{
    vfx_mmi_update_scene_ex(VFX_FALSE, VFX_RENDERER_COMMIT_ACTION_FORCE_SUSPEND);
}


void vfx_mmi_update_scene_and_resume(void)
{
    vfx_mmi_update_scene_ex(VFX_FALSE, VFX_RENDERER_COMMIT_ACTION_FORCE_RESUME);
}


void vfx_mmi_check_update(void)
{
    // It is the timing that we handled a primitive or input.
    // We should process post event now.

    if (vfx_sys_get_canvas_state() == VFX_SYS_STATE_UNKNOWN)
    {
        // The venus engine is not init yet.
        return;
    }

    // Process Post Event
    VfxAsyncSignalQueue *queue = VFX_OBJ_GET_INSTANCE(VfxAsyncSignalQueue);
    queue->processEmit();

    // The primitive has must show next, so commit scene graph
    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    if (renderer->needCommitSoon())
    {
        vfx_mmi_update_scene_ex(VFX_FALSE, VFX_RENDERER_COMMIT_ACTION_KEEP);
    }

//#if defined(__MMI_TOUCH_SCREEN__) && defined(__MTK_TARGET__)
//    // Reset pen event if the screen has been changed
//    if (vfx_sys_get_canvas_state() != VFX_SYS_STATE_ENTRY)
//    {
//        mmi_frm_pen_reset_context_for_new_screen();
//    }                
//#endif
}


void vfx_mmi_before_process_msg(void)
{
    // It is the timing before process any primitive.
}

extern "C"
mmi_ret vfx_mmi_lcd_backlight_off_handler(void)
{
    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    renderer->beforeSleepIn();

    if (vfx_sys_get_canvas_state() != VFX_SYS_STATE_ENTRY)
    {
        // if not venus currently, return directly
        return MMI_RET_OK;
    }

    /*
     * Backlight off animation
     */
#if defined(__COSMOS_MMI__)

    // get hw updating or not
    kal_bool isHwUpdate;
    gdi_lcd_get_hw_update(&isHwUpdate);
    
    if (isHwUpdate)
    {
        // if it's hw updating now, not to play backlight off animation.
        // because the animation frame rate will be very low while camera/video
        return MMI_RET_OK;
    }

    /* Power off animation is apply on top level,
     * thus there are some region is not covered by any frame on the screen.
     * So we have to set bg color. Otherwise it may show unpredictable color on screen.
     */
    // set the background color to black
    vrt_canvas_set_background_color(VFX_COLOR_BLACK);

    vrt_canvas_disable_freeze(VRT_TRUE);

    // set cache mode of TopLevel
    VfxTopLevel *topLevel = VFX_OBJ_GET_INSTANCE(VfxTopLevel);
    VfxCacheModeEnum oriCachemode = topLevel->getCacheMode();
    topLevel->setCacheMode(VFX_CACHE_MODE_FREEZE);

    // apply TVCLOSE effect animation on Top Level
    VcpFrameEffect *pwrOffAnim;
    VFX_OBJ_CREATE(pwrOffAnim, VcpFrameEffect, topLevel);
    pwrOffAnim->applyEffect(topLevel, VCP_EFFECT_TVCLOSE, 350);

    // block MMI task until the animation finishing.
    renderer->blockAfterNextCommit(350);
    vfx_mmi_update_scene();

    // close the effect object after animation finishing
    VFX_OBJ_CLOSE(pwrOffAnim);

    // restore bg color to 0. It means no bg color.
    vrt_canvas_set_background_color(0);

    vrt_canvas_disable_freeze(VRT_FALSE);

    // restore cache mode of TopLevel
    topLevel->setCacheMode(oriCachemode);
#endif

    return MMI_RET_OK;
}


extern "C"
mmi_ret vfx_mmi_lcd_sleepout_handler(mmi_event_struct *evt)
{
    VFX_LOG(VFX_INFO, VFX_MMI_LCD_SLEEPOUT, vrt_get_current_frame_time());

    vrt_canvas_power_on();
    
    VfxTimerManager *timerManager = VFX_OBJ_GET_INSTANCE(VfxTimerManager);
    timerManager->sleepOut();

    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);   
    renderer->beforeSleepOut();
    
    vfx_mmi_update_scene_ex(VFX_TRUE, VFX_RENDERER_COMMIT_ACTION_FORCE_RESUME);

    renderer->afterSleepOut();

    // must wait blt finish before turning on the backlight; otherwise LCM may be half refreshed.
    gdi_waiting_blt_finish();

    return MMI_RET_OK;
}


extern "C"
mmi_ret vfx_mmi_lcd_sleepin_handler(mmi_event_struct *evt)
{
    VFX_LOG(VFX_INFO, VFX_MMI_LCD_SLEEPIN, vrt_get_current_frame_time());

    VfxTimerManager *timerManager = VFX_OBJ_GET_INSTANCE(VfxTimerManager);
    timerManager->sleepIn();

    vfx_mmi_update_scene_ex(VFX_TRUE, VFX_RENDERER_COMMIT_ACTION_FORCE_SUSPEND);

    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);   
    renderer->afterSleepIn();

    vrt_canvas_power_off();
    
    return MMI_RET_OK;
}


extern "C"
void vfx_mmi_screen_entered(void)
{
    if (vfx_sys_get_canvas_state() != VFX_SYS_STATE_ENTRY)
    {      
        return;
    }

    VFX_LOG(VFX_INFO, VFX_MMI_SCREEN_ENTERED, vrt_get_current_frame_time());
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("XSE", SA_start);
#endif

    vfx_sys_entry_canvas_entered();

#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("XSE", SA_stop);
#endif

    if (vfx_adp_sleep_mode_get_state() == VFX_ADP_SLEEP_MODE_STATE_DISABLE)
    {
        return;
    }
    
    vrt_canvas_resume();
    VFX_LOG(VFX_INFO, VFX_MMI_CANVAS_RESUMED);
}

