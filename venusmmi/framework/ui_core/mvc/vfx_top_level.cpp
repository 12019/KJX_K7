/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vfx_top_level.cpp
 *
 * Project:
 * --------
 *  Venus
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * Include
 *****************************************************************************/

#include "vfx_top_level.h"

#include "vfx_adp_device.h"

#include "vfx_input_event.h"
#include "vfx_animation.h"
#include "vfx_renderer.h"
#include "vfx_control.h"
#include "vfx_screen.h"
#include "vfx_base_popup.h"
#include "vfx_debug_panel.h"
#include "vfx_profiling_panel.h"
#include "vadp_sys_trc.h"

#include "vfx_cpp_base.h"
#include "vfx_object.h"
#include "vfx_sys_memory.h"
#include "vfx_class_info.h"
#include "vfx_datatype.h"
#include "vfx_system.h"
#include "vrt_datatype.h"
#include "vrt_system.h"
#include "vfx_basic_type.h"
#include "vrt_canvas.h"
#include "vfx_auto_animate.h"
#include "vrt_debug.h"
#include "vfx_signal.h"
#include "vfx_context.h"
#include "vfx_logger.h"
#include "vfx_pen.h"
#include "vfx_shelter.h"

extern "C"
{
#include "MMI_features.h"
#include "mmi_frm_mem_gprot.h"
#include "gdi_const.h"
#include "gdi_datatype.h"
#include "gdi_include.h"
#include "gdi_image_9slice.h"
}

extern "C"
{
#include "vrt_logger_rsp_time.h"
}

#include <float.h>


/***************************************************************************** 
 * define
 *****************************************************************************/

#define VFX_TOP_LEVEL_Z_DBGFRM  (-FLT_MAX)
#define VFX_TOP_LEVEL_Z_SCREEN  10000
#define VFX_TOP_LEVEL_Z_BG_SCR  11000


/***************************************************************************** 
 * Class VfxMainBaseLayer
 *****************************************************************************/

VFX_IMPLEMENT_CLASS("VfxMainBaseLayer", VfxMainBaseLayer, VfxFrame);

VfxMainBaseLayer::VfxMainBaseLayer() :
    m_rotateType(VFX_SCR_ROTATE_TYPE_NORMAL)
{
}


void VfxMainBaseLayer::onInit()
{
    VfxFrame::onInit();

    m_rotateType = (VfxScrRotateTypeEnum)vrt_sys_get_pre_screen_rotation();
    
    VfxU8 *bufPtr;
    VfxS32 width, height;
    gdi_color_format colorFormat;
    VfxS32 bpp;

    gdi_handle baseLayer;
    gdi_layer_get_base_handle(&baseLayer);

    // Get all layer information
    gdi_layer_push_and_set_active(baseLayer);
    gdi_layer_get_buffer_ptr(&bufPtr);
#if 0
/* under construction !*/
#else
    if (m_rotateType == VFX_SCR_ROTATE_TYPE_90 ||
        m_rotateType == VFX_SCR_ROTATE_TYPE_270)
    {
        width = GDI_LCD_HEIGHT;
        height = GDI_LCD_WIDTH;
    }
    else
    {
        width = GDI_LCD_WIDTH;
        height = GDI_LCD_HEIGHT;
    }
#endif
    gdi_layer_get_color_format(&colorFormat);
    bpp = gdi_layer_get_bit_per_pixel();
    gdi_layer_pop_and_restore_active();

    // Config image buffer
    VfxImageBuffer imgBuf;
    imgBuf.ptr          = bufPtr;
    imgBuf.pitchBytes   = bpp * width / 8;
    imgBuf.width        = width;
    imgBuf.height       = height;
    switch (colorFormat)
    {
        case GDI_COLOR_FORMAT_16:
            imgBuf.colorFormat = VRT_COLOR_TYPE_RGB565;
            break;
        case GDI_COLOR_FORMAT_32:
            imgBuf.colorFormat = VRT_COLOR_TYPE_ARGB8888;
            break;
        case GDI_COLOR_FORMAT_32_PARGB:
            imgBuf.colorFormat = VRT_COLOR_TYPE_PARGB8888;
            break;
        default:
            VFX_DEV_ASSERT(0);
            imgBuf.colorFormat = VRT_COLOR_TYPE_UNKNOWN;
            break;
    };

    // Update this frame
    setBounds(0, 0, width, height);
    setImgContent(VfxImageSrc(imgBuf));
    setOpaqueMode(VFX_FRAME_OPAQUE_MODE_FULLY_OPAQUE);
}


/***************************************************************************** 
 * Class VfxTopLevel
 *****************************************************************************/
 
VFX_IMPLEMENT_CLASS(VFX_TOP_LEVEL_CLASS_NAME, VfxTopLevel, VfxControl);
VFX_OBJ_IMPLEMENT_SINGLETON_CLASS(VfxTopLevel);


VfxTopLevel::VfxTopLevel() : 
    m_enterScreenLevel(0),
    m_backgroundFrame(NULL),
    m_bgContainerFrame(NULL),
    m_debugFrame(NULL), 
    m_profilingFrame(NULL),
    m_activeScrPtr(NULL),
    m_shelter(NULL),
    m_activeScrCacheMode(VFX_CACHE_MODE_END_OF_ENUM),
    m_activePopupPtr(NULL),
    m_activeImeScr(NULL),
    m_focusCaptured(VFX_FALSE),
    m_prevFocusFrame(NULL),
    m_activeScrState(VFX_TOP_LEVEL_ACTIVE_SCREEN_STATE_EXITED)
{
}


void VfxTopLevel::startup()
{
    VFX_LOG(VFX_INFO, VFX_TOPLEVEL_STARTUP);
    
    // Reset top level size to LCD screen size (may rotate)
    vrt_size_struct mainScreenSize;
    vrt_sys_get_main_screen_info(&mainScreenSize, NULL);
    setRect(VfxRect(0, 0, mainScreenSize.width, mainScreenSize.height));

    if (vfx_debug_panel_get_enable())
    {
        if (m_debugFrame == NULL)
        {
            VFX_OBJ_CREATE(m_debugFrame, VfxDebugPanel, this);
            m_debugFrame->setPosZ(VFX_TOP_LEVEL_Z_DBGFRM);
        }
    }
    else
    {
        VFX_OBJ_CLOSE(m_debugFrame);
    }

    if (vfx_profiling_panel_get_enable())
    {
        if (m_profilingFrame == NULL)
        {
            VFX_OBJ_CREATE(m_profilingFrame, VfxProfilingPanel, this);
            m_profilingFrame->setPosZ(VFX_TOP_LEVEL_Z_DBGFRM);
        }

        m_profilingFrame->registerProfilingCallback();
    }
    else
    {
        VFX_OBJ_CLOSE(m_profilingFrame);
    }

    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    renderer->setRootFrame(this);
}


void VfxTopLevel::shutdown()
{
    VFX_LOG(VFX_INFO, VFX_TOPLEVEL_SHUTDOWN);

    if (m_profilingFrame != NULL)
    {
        m_profilingFrame->unregisterProfilingCallback();
    }

    if (m_focusChildFrame)
    {
        m_focusChildFrame->setFocused(VFX_FALSE);
    }
    m_focusCaptured = VFX_FALSE;
    m_prevFocusFrame = NULL;
    m_captureFocusFrames.clear();

    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    renderer->setRootFrame(NULL);
}


void VfxTopLevel::showPopup(VfxBasePopup *popup, VfxBool isAnim)
{
    VFX_LOG_FUNC;
    VFX_LOG(VFX_INFO, VFX_TOPLEVEL_SHOW_POPUP, popup, isAnim);
    
    VFX_DEV_ASSERT(popup != NULL);

    VfxBasePopup *currentPopup = m_activePopupPtr.get();
    if (popup != NULL && currentPopup == popup)
    {
        // The popup is already the current popup, do nothing
        return;
    }

    // Reset the pen event
    VfxPen *pen = VFX_OBJ_GET_INSTANCE(VfxPen);
    vfxPostInvoke0(pen, &VfxPen::reset);

    // Assign current popup
    m_activePopupPtr = popup;

    // Switch the popup to be top level's child frame
    addChildFrame(popup);
    //popup->setPosZ(VFX_TOP_LEVEL_Z_POPUP); // Change to base popup assign the Z value

    // Let debug penal on the front of the popup
    if (m_debugFrame != NULL)
    {
        m_debugFrame->bringToFront();
    }

    // Let profiling penal on the front of the popup
    if (m_profilingFrame != NULL)
    {
        m_profilingFrame->bringToFront();
    }

    // Switch focus to the popup
    if (popup->getCatchFocus())
    {
        if (m_focusCaptured)
        {
            captureFocus(popup);
        }
        else
        {
            popup->setFocused(VFX_TRUE);
        }
    }

    // Callback
    popup->processEnter(isAnim, m_activeScrState == VFX_TOP_LEVEL_ACTIVE_SCREEN_STATE_ENTERED);

    m_signalActivePopupEnter.postEmit(popup);

    // Set rotate type
    VfxScreenRotateParam param;
    param.rotateFrom = popup->getRotateType();
    param.rotateTo   = getScreenRotateType();
    param.durTime    = 0;
    if (param.rotateFrom != param.rotateTo)
    {
        VfxAutoAnimate::begin();
        VfxAutoAnimate::setDisable(VFX_TRUE);
        popup->processRotate(param);
        VfxAutoAnimate::commit();
    }
}


void VfxTopLevel::leavePopup(VfxBasePopup *popup, VfxBool isAnim, VfxBool changeFocus)
{
    VFX_LOG_FUNC;
    VFX_LOG(VFX_INFO, VFX_TOPLEVEL_LEAVE_POPUP, popup, isAnim);

    VfxBasePopup *currentPopup = m_activePopupPtr.get();
    if (popup == NULL)
    {
        return;
    }
    if (currentPopup != popup)
    {
        // popup already leave
        popup->processLeavedPopup();
        return;
    }

    m_signalActivePopupExit.postEmit(popup);
    
    popup->processExit(isAnim, m_activeScrState == VFX_TOP_LEVEL_ACTIVE_SCREEN_STATE_ENTERED);

    // Reset current popup
    m_activePopupPtr = NULL;

    // Change focus
    if (changeFocus && currentPopup->getCatchFocus())
    {
        if (m_focusCaptured)
        {
            releaseFocus(currentPopup);
        }

        VfxScreen *activeScr = m_activeScrPtr.get();
        if (activeScr)
        {
            activeScr->setFocused(VFX_TRUE);
        }
        else
        {
            // no one focused
            currentPopup->setFocused(VFX_FALSE);
        }
    }
}


void VfxTopLevel::showBackground()
{
    VFX_DEV_ASSERT(m_bgContainerFrame == NULL);
    VFX_DEV_ASSERT(m_backgroundFrame == NULL);

    VFX_OBJ_CREATE(m_bgContainerFrame, VfxFrame, this);
    m_bgContainerFrame->sendToBack();
    m_bgContainerFrame->setPosZ(VFX_TOP_LEVEL_Z_BG_SCR);
    
    VFX_OBJ_CREATE(m_backgroundFrame, VfxMainBaseLayer, m_bgContainerFrame);
    m_backgroundFrame->setAnchor(0.5f, 0.5f);

    rotateBackground(getScreenRotateType(), 0);
}


void VfxTopLevel::exitBackground()
{
    exitShelter();
    m_backgroundFrame = NULL;
    VFX_OBJ_CLOSE(m_bgContainerFrame);
}


void VfxTopLevel::rotateBackground(VfxScrRotateTypeEnum rotateType, VfxMsec time)
{
    if (m_bgContainerFrame == NULL)
    {
        // There is no background frame, set background color to black for a while
        if (time != 0)
        {
            setBgColor(VFX_COLOR_BLACK);
        }
        return;
    }

    VFX_DEV_ASSERT(m_bgContainerFrame != NULL && m_backgroundFrame != NULL);

    m_bgContainerFrame->setSize(getSize());
    m_backgroundFrame->setPos(m_bgContainerFrame->getBounds().getMidPoint());

    VfxScrRotateTypeEnum bgRotateType = m_backgroundFrame->getRotateType();
    VfxTransform bgTransform;
    bgTransform.data.affine.rz = VFX_DEG_TO_RAD(90.0f) * 
        (((VfxU32)rotateType - (VfxU32)bgRotateType + 4) % 4);
    m_backgroundFrame->setTransform(bgTransform);
}


void VfxTopLevel::showShelter(VfxFrame *frame, VfxBool isAnim, VfxBool isStatic)
{
    VfxFrame *bg = m_bgContainerFrame == NULL ? m_activeScrPtr.get() : m_bgContainerFrame;
    VFX_ASSERT(bg != NULL);
       

    if (m_shelter == NULL)
    {
        m_signalShelterExist.emit(VFX_TRUE);            
        VFX_OBJ_CREATE(m_shelter, VfxShelter, this);   
    }
    
VFX_LOG(VFX_INFO, VFX_TOPLEVEL_SHOW_SHELTER, m_shelter, isStatic, bg, isAnim, frame);           
    
#ifdef __COSMOS_3D_V10_SHELTER__
    if(isStatic && m_activeScrCacheMode == VFX_CACHE_MODE_END_OF_ENUM) //ownerdraw
    {
        m_activeScrCacheMode = m_activeScrPtr->getCacheMode();
        m_activeScrPtr->setCacheMode(VFX_CACHE_MODE_FREEZE);
    }

    m_shelter->setShelterContent(bg);
    m_shelter->setIsStatic(isStatic);

#endif /* __COSMOS_3D_V10_SHELTER__ */    

    
    m_shelter->show(frame, isAnim);

    

}


void VfxTopLevel::hideShelter(VfxBool isAnim)
{
    if (m_shelter)
    {
        m_shelter->hide(isAnim);
    }
}


void VfxTopLevel::exitShelter()
{
#ifdef __COSMOS_3D_V10_SHELTER__
    if(m_activeScrPtr.get() != NULL && m_activeScrCacheMode != VFX_CACHE_MODE_END_OF_ENUM)
    {
        m_activeScrPtr.get()->setCacheMode(m_activeScrCacheMode);
        m_activeScrCacheMode = VFX_CACHE_MODE_END_OF_ENUM;
    }
#endif /* __COSMOS_3D_V10_SHELTER__ */

    if (m_shelter)
    {
        m_shelter->exit();
        VFX_OBJ_CLOSE(m_shelter);
        m_signalShelterExist.emit(VFX_FALSE);
    }
}


void VfxTopLevel::processScreenRotate(VfxScrRotateTypeEnum newRotateType, VfxBool noAnimation)
{
    VFX_LOG_FUNC;
    VFX_ASSERT(newRotateType < VFX_SCR_ROTATE_TYPE_END_OF_ENUM);

    VfxScreen *activeScr = m_activeScrPtr.get();
    if (activeScr == NULL)
    {
        // There is no active screen, do nothing
        return;
    }

    // Query the current rotate type
    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    VfxScrRotateTypeEnum currentRotateType = activeScr->getRotateType();

    // Prepare parameter
    VfxScreenRotateParam param;
    param.rotateFrom    = currentRotateType;
    param.rotateTo      = newRotateType;
    param.durTime       = VFX_TIMELINE_DEFAULT_DUR_TIME;
    activeScr->queryRotate(param);
    
    if (param.rotateTo == currentRotateType)
    {
        if (renderer->getPreScreenRotateType() != 
            renderer->getScreenRotateType())
        {
            VfxAutoAnimate::begin();
            VfxAutoAnimate::setDisable(VFX_TRUE);
            
            m_signalRotated.emit(param);
            
            VfxAutoAnimate::commit();
        }

        return;
    }

    m_signalBeforeRotate.emit(param);

    // Rotate the LCD to want type
    renderer->setScreenRotateType(param.rotateTo);

    // Reset the pen event
    VfxPen *pen = VFX_OBJ_GET_INSTANCE(VfxPen);
    pen->reset();

    // Reset top level size to LCD screen size
    vrt_size_struct mainScreenSize;
    vrt_sys_get_main_screen_info(&mainScreenSize, NULL);
    setSize(mainScreenSize.width, mainScreenSize.height);

    // Do rotate background if needed
    rotateBackground(param.rotateTo, param.durTime);
    VfxBasePopup *activePopup = m_activePopupPtr.get();

#ifdef __COSMOS_3D_V10_SHELTER__
    if(m_shelter != NULL && activePopup!= NULL && activePopup->getIsStaticShelter())
    {
        noAnimation = VFX_TRUE;
    }
#endif /* __COSMOS_3D_V10_SHELTER__ */

    if (noAnimation)
    {
        param.durTime = 0;
    }

    // Begin and config auto-animation
    VfxAutoAnimate::begin();
    VfxAutoAnimate::setDisable(noAnimation);    
    VfxAutoAnimate::setDuration(param.durTime);

    // Do rotate screen
    activeScr->processRotate(param);

   
    // Do rotate popup
    if (activePopup != NULL)
    {
        activePopup->processRotate(param);
    }

    // Do rotate shelter 
    if (m_shelter != NULL)
    {
        VfxAutoAnimate::begin();
        VfxAutoAnimate::setDisable(VFX_TRUE);    
        m_shelter->processRotate(param);
        m_shelter->setBounds(getBounds());
        VfxAutoAnimate::commit();        
    }

    // Emit rotate signal
    m_signalRotated.postEmit(param);

    VfxAutoAnimate::commit();

#if defined(GDI_9SLICE_USING_DITHERING)
    // TODO: Work around solution, need to move to VRT commit
    gdi_image_9slice_set_dither(KAL_FALSE);
#endif

    // Block MMI in rotate statge
    VfxRenderer *render = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    render->blockAfterNextCommit(param.durTime, VfxCallback0(this, &VfxTopLevel::processScreenAfterRotate));
}


void VfxTopLevel::processScreenAfterRotate()
{
    // Reset all setting
    setBgColor(VFX_COLOR_TRANSPARENT);

#if defined(GDI_9SLICE_USING_DITHERING)
    // TODO:Work around solution, need to move to VRT commit
    gdi_image_9slice_set_dither(KAL_TRUE);
#endif
}


void VfxTopLevel::setScreenRotateType(VfxScrRotateTypeEnum newRotateType, VfxBool noAnimation)
{
    processScreenRotate(newRotateType, noAnimation);
}


VfxScrRotateTypeEnum VfxTopLevel::getScreenRotateType() const
{
    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    return renderer->getScreenRotateType();
}


void VfxTopLevel::setIMElayout(VfxRect &imeRect, VfxFrame *imeOwner)
{
    if (m_activeImeScr == NULL)
    {
        VfxFrame *f = NULL;

        for (f = imeOwner; f != NULL; f = (VfxFrame*)f->getParentFrame())
        {
            if (f->isKindOf(VFX_OBJ_CLASS_INFO(VfxScreen)) || f->isKindOf(VFX_OBJ_CLASS_INFO(VfxBasePopup)))
            {
                break;
            }
        }

        m_activeImeScr = f;
    }

    if (m_activeImeScr != NULL)
    {
        do
        {
            VfxBasePopup *p = VFX_OBJ_DYNAMIC_CAST(m_activeImeScr.get(), VfxBasePopup);
            if (p)
            {
                p->setIMElayout(imeRect, imeOwner);
                break;
            }

            VfxScreen *s = VFX_OBJ_DYNAMIC_CAST(m_activeImeScr.get(), VfxScreen);
            if (s)
            {
                s->setIMElayout(imeRect, imeOwner);
                break;
            }
        } while (0);
    }
}


void VfxTopLevel::resetIMElayout()
{
    if (m_activeImeScr != NULL)
    {
        do
        {
            VfxBasePopup *p = VFX_OBJ_DYNAMIC_CAST(m_activeImeScr.get(), VfxBasePopup);
            if (p)
            {
                p->resetIMElayout();
                break;
            }

            VfxScreen *s = VFX_OBJ_DYNAMIC_CAST(m_activeImeScr.get(), VfxScreen);
            if (s)
            {
                s->resetIMElayout();
                break;
            }
        } while (0);
    }

    m_activeImeScr = NULL;
}


vrt_allocator_handle VfxTopLevel::getAllocator()
{
    return vfx_sys_mem_get_global_allocator();
}


void VfxTopLevel::onInit()
{
    VfxControl::onInit();
    
    setCacheMode(VFX_CACHE_MODE_PREVENT);
    setIsOpaque(VFX_TRUE);
    setOpaqueMode(VFX_FRAME_OPAQUE_MODE_FULLY_OPAQUE);

    // Enable z sort
    setIsZSortChild(VFX_TRUE);
}


VfxBool VfxTopLevel::onPreviewPenInput(VfxPenEvent &event)
{
    if (event.type == VFX_PEN_EVENT_TYPE_DOWN && m_activeScrState == VFX_TOP_LEVEL_ACTIVE_SCREEN_STATE_ENTERING && !(VFX_OBJ_GET_INSTANCE(VfxPen))->isPenDownByFramework())
    {
        return VFX_TRUE;
    }

    VfxDebugPanel::DisplayPlace debugPanelPlace = VfxDebugPanel::DISPLAY_PLACE_UNKNOWN;
    if (m_debugFrame != NULL)
    {
        m_debugFrame->handlePenEvent(event);
        m_debugFrame->handlePenEvent2(event);
        debugPanelPlace = m_debugFrame->getDisplayPlace();
    }

    if (m_profilingFrame != NULL)
    {
        if (debugPanelPlace == VfxDebugPanel::DISPLAY_PLACE_LEFT_TOP)
        {
            m_profilingFrame->setDisplayPlace(VfxProfilingPanel::DISPLAY_PLACE_BOTTOM);
        }
        else
        {
            m_profilingFrame->setDisplayPlace(VfxProfilingPanel::DISPLAY_PLACE_TOP);
        }
    }    

    return VfxControl::onPreviewPenInput(event);
}


VfxBool VfxTopLevel::onPenInput(VfxPenEvent &event)
{
    // Filter all pen input when has a popup
    if (m_activePopupPtr != NULL)
    {
        m_activePopupPtr->onPenInputOnOutside(event);
        return VFX_TRUE;
    }

    return VfxControl::onPenInput(event);
}


VfxBool VfxTopLevel::queryFocusChange(VfxFrame *childFrame)
{
    if (m_activeScrState == VFX_TOP_LEVEL_ACTIVE_SCREEN_STATE_ENTERING)
    {
        return VFX_FALSE;
    }
    else if (m_activePopupPtr != NULL)
    {
        if (m_activePopupPtr.get() == childFrame)
        {
            return VFX_TRUE;
        }
        else
        {
            return VFX_FALSE;
        }
    }
    else if (m_activeScrPtr != NULL && m_activeScrPtr->getIsSnapshotDrawing())
    {
        return VFX_FALSE;
    }
    else if (m_focusCaptured && getFocusChildFrame() != childFrame)
    {
        return VFX_FALSE;
    }
    else
    {
        return VFX_TRUE;
    }
}


void VfxTopLevel::onObjectNotify(VfxId id, void *userData)
{
    switch (id)
    {
        case VFX_FRAME_NOTIFY_ID_QUERY_FOCUS_CHANGE:
        {
            VfxFrameQueryFocusChangeData *para = (VfxFrameQueryFocusChangeData *)userData;
            para->ret = queryFocusChange(para->childFrame);
            return;
        }
        default:
        {
            VfxControl::onObjectNotify(id, userData);
            return;
        }
    }
}


VfxBool VfxTopLevel::processFocusKey(VfxKeyEvent &event)
{
    // Special implementation for ShellAPP
    //  Routing END key to active popup and active screen
#if defined(__MMI_VUI_SHELL_MULTI_PAGE__)
    if (event.keyCode == VFX_KEY_CODE_END)
    {
        VfxBool ret = VFX_FALSE;

        if (m_activePopupPtr != NULL)
        {
            ret = m_activePopupPtr->processFocusKey(event);
        }

        if (!ret && m_activeScrPtr != NULL)
        {
            ret = m_activeScrPtr->processFocusKey(event);
        }

        if (!ret)
        {
            ret = onKeyInput(event);
        }

        return ret;
    }
#endif

    return VfxControl::processFocusKey(event);
}


void VfxTopLevel::enterToScreen(VfxScreen *screen, VfxBool isBackward)
{
    VFX_LOG_FUNC;

    VfxScreen *origActiveScr = m_activeScrPtr.get();
    if (screen == origActiveScr)
    {
        // Do nothing.
        return;
    }

    VFX_LOG(VFX_INFO, VFX_TOPLEVEL_ENTER_TO_SCREEN, screen, origActiveScr);
    
    processActiveScreenExit(isBackward);
    processActiveScreenAfterExit(isBackward);

    processScreenBeforeEnter(screen, isBackward);
    processScreenEnter(screen, isBackward);
}


void VfxTopLevel::setNextScreenIsVenus()
{
    if (m_activeScrPtr == NULL)
    {
        return;
    }

    m_activeScrPtr->setNextIsVenus();
}


VfxBool VfxTopLevel::isActiveScreenCustomRotate()
{
    if (m_activeScrPtr != NULL)
    {
        return m_activeScrPtr->isCustomRotate();
    }

    return VFX_FALSE;
}


void VfxTopLevel::processActiveScreenExit(VfxBool isBackward)
{
    VFX_LOG_FUNC;

    if (m_activeScrPtr == NULL)
    {
        return;
    }

    m_activeScrState = VFX_TOP_LEVEL_ACTIVE_SCREEN_STATE_EXITING;

    if (m_debugFrame != NULL)
    {
        m_debugFrame->setMonitorContext(NULL);
    }

    m_activeScrPtr->processBeforeExit(isBackward);

    m_signalActiveScreenExit.postEmit(m_activeScrPtr.get());

    // Ask the active screen to do leave
    m_activeScrPtr->processExit(isBackward);

    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    renderer->processMustShowTime();
}


void VfxTopLevel::processActiveScreenAfterExit(VfxBool isBackward)
{
    VFX_LOG_FUNC;

    if (m_activeScrPtr == NULL)
    {
        return;
    }
    
    m_activeScrState = VFX_TOP_LEVEL_ACTIVE_SCREEN_STATE_EXITED;

    // Keep the screen pointer to avoid m_activeScrPtr has been changed
    VfxWeakPtr <VfxScreen> screenPtr(m_activeScrPtr);
    
    if (screenPtr != NULL)
    {
        // Remove the original screen from top level
        screenPtr->removeFromParentFrame();
    }

    m_activeScrPtr = NULL;

    exitBackground();
    
    // Ask screen to handle after exit
    if (screenPtr != NULL)
    {
        screenPtr->processAfterExit(isBackward);
    }

    // Disable screen rotate sensor 
    vfx_adp_srs_disable();

    m_enterScreenLevel--;
    VFX_DEV_ASSERT(m_enterScreenLevel >= 0);
}


void VfxTopLevel::processScreenBeforeEnter(VfxScreen *screen, VfxBool isBackward)
{
    VFX_LOG_FUNC;

    VFX_DEV_ASSERT(m_activeScrPtr == NULL);

    if (screen == NULL)
    {
        return;
    }

    VFX_OBJ_ASSERT_VALID(screen);

    /* vrt_log_rsp_time_logging_var(4001); */
    vrt_log_rsp_time_set_event(VRT_LOG_RSP_TIME_EVENT_SCR_ENTRY);

    m_enterScreenLevel++;
    // NOTE: May enter screen recursivly?
    VFX_DEV_ASSERT(m_enterScreenLevel < 10);
    if (m_enterScreenLevel >= 2)
    {
        VFX_TRACE(("[VfxTopLevel::processScreenBeforeEnter] level = %d\n", m_enterScreenLevel));
    }
    
    // Enable screen rotate sensor 
    vfx_adp_srs_enable();

    // Rotate the LCD to this new screen
    VfxRenderer *renderer = VFX_OBJ_GET_INSTANCE(VfxRenderer);
    renderer->setScreenRotateType(screen->getRotateType());

    // Update size of top level
    vrt_size_struct mainScreenSize;
    vrt_sys_get_main_screen_info(&mainScreenSize, NULL);
    setSize(mainScreenSize.width, mainScreenSize.height);

    // To be the active screen
    m_activeScrPtr = screen;

    // Setup canvas engine (VRT)
    VfxScreen::processBeforeEnter(screen, isBackward);

    // Resize the screen as the LCD size
    screen->setRect(getBounds());

    // screen always be the first child of topLevel       
    addChildFrame(screen);
    screen->sendToBack();
    screen->setPosZ(VFX_TOP_LEVEL_Z_SCREEN);

    m_signalActiveScreenBeforeEnter.postEmit(screen);
}


void VfxTopLevel::processScreenEnter(VfxScreen *screen, VfxBool isBackward)
{
    VFX_LOG_FUNC;

    VFX_DEV_ASSERT(m_activeScrPtr == screen);

    if (screen == NULL)
    {
        return;
    }

    m_activeScrState = VFX_TOP_LEVEL_ACTIVE_SCREEN_STATE_ENTERING;

    if (m_debugFrame != NULL)
    {
        m_debugFrame->setMonitorContext(screen->findContext());
    }

    VfxWeakPtr <VfxScreen> screenPtr(screen);

    // Create background for small screen
    if (screenPtr.isValid() && screenPtr->getIsSmallScreen())
    {
        showBackground();
    }
    
    // This is the only callback on processScreenBeforeEnter() and processScreenEnter()
    screen->processEnter(isBackward);

    if (screenPtr.isValid())
    {
        processScreenRotate(vfx_adp_srs_get_value(), VFX_TRUE);
    }

    if (screenPtr.isValid())
    {
        VfxScreen::processAfterEnter(screen, isBackward);
    }
        
    if (screenPtr.isValid())
    {
        m_signalActiveScreenEnter.postEmit(screen);
    }
}


void VfxTopLevel::processScreenAfterEnter(VfxScreen *screen, VfxBool isBackward)
{
    VFX_DEV_ASSERT(screen != NULL);
    
    if (m_activeScrPtr != screen)
    {
        return;
    }

    m_activeScrState = VFX_TOP_LEVEL_ACTIVE_SCREEN_STATE_ENTERED;

    VfxWeakPtr <VfxScreen> screenPtr(screen);

    // Set focus when screen entered
    if (m_activePopupPtr.get() && m_activePopupPtr->getCatchFocus())
    {
        m_activePopupPtr->setFocused(VFX_TRUE);
    }
    else
    {
        screenPtr->setFocused(VFX_TRUE);
    }

    VfxObjListEntry *entry = m_captureFocusFrames.getValidTail();
    if (entry)
    {
        VfxFrame *frame = (VfxFrame *)entry->get();
        m_prevFocusFrame = getFocusChildFrame();
        frame->setFocused(VFX_TRUE);

        m_focusCaptured = VFX_TRUE;
    }

    screenPtr->processEntered(isBackward);

    if (screenPtr.isValid())
    {
        m_signalActiveScreenEntered.postEmit(screen);
    }
}


void VfxTopLevel::captureFocus(VfxFrame* childFrame)
{
    VFX_OBJ_ASSERT_VALID(childFrame);
    if (m_captureFocusFrames.contains(childFrame))
    {
        // already captured
        return;
    }

    m_captureFocusFrames.append(childFrame);
    if (m_activeScrState == VFX_TOP_LEVEL_ACTIVE_SCREEN_STATE_ENTERING)
    {
        // cannot capture focus until entered
        return;
    }

    if (!m_focusCaptured)
    {
        // Save original focused frame
        m_prevFocusFrame = getFocusChildFrame();
    }

    m_focusCaptured = VFX_FALSE;
    childFrame->setFocused(VFX_TRUE);
    m_focusCaptured = VFX_TRUE;
}


void VfxTopLevel::releaseFocus(VfxFrame* childFrame)
{
    VFX_OBJ_ASSERT_VALID(childFrame);
    m_captureFocusFrames.removeOne(childFrame);
    if (m_activeScrState == VFX_TOP_LEVEL_ACTIVE_SCREEN_STATE_ENTERING)
    {
        return;
    }

    VfxObjListEntry *entry = m_captureFocusFrames.getValidTail();
    if (!entry)
    {
        // Restore previous focused frame
        m_focusCaptured = VFX_FALSE;
        m_captureFocusFrames.clear();
        if (m_prevFocusFrame.get())
        {
            m_prevFocusFrame->setFocused(VFX_TRUE);
            m_prevFocusFrame = NULL;
        }
        else
        {
            childFrame->setFocused(VFX_FALSE);
        }
    }
    else
    {
        // Someone still will hold the focus
        VfxFrame* frame = (VfxFrame*)entry->get();

        m_focusCaptured = VFX_FALSE;
        frame->setFocused(VFX_TRUE);
        m_focusCaptured = VFX_TRUE;
    }
}


/***************************************************************************** 
 * Global Function
 *****************************************************************************/

void vfx_adp_srs_on_rotate(VfxScrRotateTypeEnum rotate_type)
{
    VFX_LOG_STATIC_FUNC;
    VfxTopLevel *topLevel = VFX_OBJ_GET_INSTANCE(VfxTopLevel);
    topLevel->setScreenRotateType(rotate_type);
}

