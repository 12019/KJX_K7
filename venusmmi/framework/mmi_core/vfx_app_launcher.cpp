/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2008
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES. ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vfx_app_launcher.cpp
 *
 * Project:
 * --------
 *  Venus FW
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 *  
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#include "vfx_app_launcher.h"
#include "vfx_cui.h"
#include "vadp_sys_trc.h"
#include "vfx_adp_sse.h"
#include "vadp_asm.h"
#include "vfx_logger.h"

extern "C"
{
#include <string.h>
#include "MMIDataType.h"
#include "kal_general_types.h"
#include "kal_public_api.h"
#include "kal_trace.h"
#include "GlobalResDef.h"
#include "mmi_frm_scenario_gprot.h"
#include "mmi_frm_mem_gprot.h"
#include "app_mem.h"
#include "wgui_categories.h" // for ShowCategoryDummyScreen()
}

#include "vrt_datatype.h"
#include "vfx_datatype.h"
#include "vfx_cpp_base.h"
#include "vfx_object.h"
#include "vfx_sys_memory.h"
#include "vfx_class_info.h"
#include "vfx_system.h"
#include "vfx_app.h"
#include "vfx_context.h"
#include "vfx_top_level.h"
#include "vfx_mmi.h"


////////////////////////////////////////////////////////////////
// only for test, should be app's own resource base.

extern "C" {
#include "CustDataRes.h"
#include "mmi_frm_mem_gprot.h"
} /* extern "C" */

// resource related above
////////////////////////////////////////////////////////////////

#ifdef __MTK_TARGET__
//#define __MAUI_SOFTWARE_LA__
#endif

#if defined(VFX_CFG_SOFTWARE_LA)
#undef __MAUI_SOFTWARE_LA__
#define __MAUI_SOFTWARE_LA__
#endif

#ifdef __MAUI_SOFTWARE_LA__
extern "C"
{
#include "SST_sla.h"
}
#endif

static void vfx_app_launcher_entry_dummy_screen(void);
static mmi_ret vfx_app_launcher_dummy_proc(mmi_event_struct *evt);

/***************************************************************************** 
 * Class VfxAppLauncherParam
 *****************************************************************************/

#define VFX_APP_LAUNCHER_PARAM_FLAG_DO_PREPARE      (1<<0)
#define VFX_APP_LAUNCHER_PARAM_FLAG_FORCE_PREPARE   (1<<1)
#define VFX_APP_LAUNCHER_PARAM_FLAG_CONTEXT_LOG     (1<<2)
#define VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_IN_ACTIVE_SWITCH     (1<<3)
#define VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_IN_HIDDEN_SWITCH     (1<<4)
#define VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_DISABLE     (1<<5)

#define VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_MASK ( VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_IN_ACTIVE_SWITCH| \
                                                    VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_IN_HIDDEN_SWITCH| \
                                                    VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_DISABLE )
#define SLMM_POOL_MIN_SIZE (3*1024)  /*the min pool size to use slmm */

VfxAppLauncherParam::VfxAppLauncherParam(mmi_id appBaseId, const VfxClassInfo *classInfo, mmi_id callerId):
    m_appBaseId(appBaseId),
    m_callerId(callerId),
    m_classInfo(classInfo),
    m_heap(NULL),
    m_heapSize(0),
    m_callback(NULL),
    m_callbackData(NULL),
    m_launcherResultCb(NULL),
    m_launcherResultUserData(NULL),
    m_context(NULL),
    m_arg(NULL),
    m_argSize(0),
    m_HeapOffset(0),
	m_MemPriority(MMI_FRM_APP_MEM_PRIORITY_DEFAULT),
    m_placement(VFX_APP_LAUNCHER_PLACE_DEFAULT),
    m_placehint(GRP_ID_INVALID),
    m_flags(0)
{
}

void VfxAppLauncherParam::setMemSource(VfxContext *context, VfxBool doPrepare /*= VFX_FALSE*/)
{
    m_heapSize = 0;
    m_heap = NULL;
    m_context = context;
    if (doPrepare)
    {
        m_flags |= VFX_APP_LAUNCHER_PARAM_FLAG_DO_PREPARE;
    }
}

void VfxAppLauncherParam::setMemSource(void *buffer, VfxU32 bufferSize, VfxAppContextCbType callback, void *userData)
{
    m_heapSize = bufferSize;
    m_heap = buffer;
    m_context = NULL;
    m_callback = callback;
    m_callbackData = userData;
}

void VfxAppLauncherParam::setMemSource(VfxU32 heapSize)
{
    m_heapSize = heapSize;
    m_heap = NULL;
    m_context = NULL;
}

void VfxAppLauncherParam::setPlacement(VfxAppLauncherPlacementEnum placement, mmi_id hint)
{
    if(placement == VFX_APP_LAUNCHER_PLACE_BEFORE ||
        placement == VFX_APP_LAUNCHER_PLACE_AFTER)
    {
        // skip the setup if param is invalid
        if(hint == GRP_ID_INVALID)
            return;
    }

    m_placement = placement;
    m_placehint = hint;   
}

void VfxAppLauncherParam::setArgument(void *arg, VfxU32 argSize)
{
    m_arg = arg;
    m_argSize = argSize;
}


void VfxAppLauncherParam::setHeapOffset(VfxU32 HeapOffset)
{    
    m_HeapOffset = HeapOffset;
}

void VfxAppLauncherParam::setMemPriority(VfxU32 MemPriority)
{    
    m_MemPriority = MemPriority;
}

void VfxAppLauncherParam::setForcePrepare(VfxBool value)
{
    if(value)
        m_flags |= VFX_APP_LAUNCHER_PARAM_FLAG_FORCE_PREPARE;
    else
        m_flags &= ~VFX_APP_LAUNCHER_PARAM_FLAG_FORCE_PREPARE;
}

void VfxAppLauncherParam::setContextLogging(VfxBool value)
{
    if(value)
        m_flags |= VFX_APP_LAUNCHER_PARAM_FLAG_CONTEXT_LOG;
    else
        m_flags &= ~VFX_APP_LAUNCHER_PARAM_FLAG_CONTEXT_LOG;
}

void VfxAppLauncherParam::setDynHeap(VfxAppLauncherDynHeapEnum flag)
{
#if defined(__MMI_USE_MMV2__)
    if( flag & VFX_APP_LAUNCHER_DYNAMIC_HEAP_DISABLE )
        m_flags |= VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_DISABLE;
    else
    {
        if( flag & VFX_APP_LAUNCHER_DYNAMIC_HEAP_AT_INACTIVE )
            m_flags |= VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_IN_ACTIVE_SWITCH;
        if( flag & VFX_APP_LAUNCHER_DYNAMIC_HEAP_AT_HIDDEN )
            m_flags |= VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_IN_HIDDEN_SWITCH;
    }
#else
    VFX_ASSERT(0);
#endif
}

void VfxAppLauncherParam::setLauncherResultCb(VfxAppLauncherResult cb, void* userData)
{
    m_launcherResultCb = cb;
    m_launcherResultUserData = userData;
}

/***************************************************************************** 
 * Class VfxAppLauncher
 *****************************************************************************/

VFX_IMPLEMENT_CLASS("VfxAppLauncher", VfxAppLauncher, VfxObject);

#define AUTO_HEAP_SIZE   (0)

mmi_id VfxAppLauncher::launch(mmi_id appBaseId, VfxClassInfo *classInfo, mmi_id callerId, void *arg, VfxU32 argSize, VfxBool contextLogFlag )
{  
    VFX_LOG_STATIC_FUNC1("%d", appBaseId);

    VfxAppLauncherParam p(appBaseId, classInfo, callerId);
    p.setArgument(arg, argSize);
    p.setContextLogging(contextLogFlag);
    return VfxAppLauncher::static_launchByMem(p);
}


mmi_id VfxAppLauncher::launchWithAsmSize(mmi_id appBaseId, VfxClassInfo *classInfo, mmi_id callerId, VfxU32 heapSize, void *arg, VfxU32 argSize, VfxBool contextLogFlag)
{
    VFX_LOG_STATIC_FUNC1("%d", appBaseId);
    VFX_ASSERT(heapSize > 0);

    VfxAppLauncherParam p(appBaseId, classInfo, callerId);
    p.setArgument(arg, argSize);
    p.setMemSource(heapSize);
    p.setContextLogging(contextLogFlag);
    return VfxAppLauncher::static_launchByMem(p);
}


mmi_id VfxAppLauncher::launchWithMem(mmi_id appBaseId, VfxClassInfo *classInfo, mmi_id callerId, void *heap, VfxU32 heapSize, VfxAppContextCbType callback, void *userData, void *arg, VfxU32 argSize, VfxBool contextLogFlag)
{
    VFX_LOG_STATIC_FUNC1("%d", appBaseId);
    VFX_ASSERT(heap && (heapSize > 0));

    VfxAppLauncherParam p(appBaseId, classInfo, callerId);
    p.setArgument(arg, argSize);
    p.setMemSource(heap, heapSize, callback, userData);
    p.setContextLogging(contextLogFlag);
    return VfxAppLauncher::static_launchByMem(p);
}

mmi_id VfxAppLauncher::launchWithCtx(mmi_id appBaseId, VfxClassInfo *classInfo, mmi_id callerId, VfxContext *ctx, void *arg, VfxU32 argSize)
{
    VFX_LOG_STATIC_FUNC1("%d", appBaseId);
    VFX_ASSERT(ctx->isKindOf(VFX_OBJ_CLASS_INFO(VfxContext)));

    VfxAppLauncherParam p(appBaseId, classInfo, callerId);
    p.setMemSource(ctx);
    p.setArgument(arg, argSize);
    return VfxAppLauncher::static_launchByContext(p);
}

mmi_id VfxAppLauncher::launchEx(const VfxAppLauncherParam& param)
{
    VFX_LOG_STATIC_FUNC1("%d", param.m_appBaseId);
    if(param.m_context)
    {
        VFX_ASSERT(param.m_context->isKindOf(VFX_OBJ_CLASS_INFO(VfxContext)));
        
        return static_launchByContext(param);
    }
    else
    {
        return static_launchByMem(param);
    }
}

void VfxAppLauncher::terminate(mmi_id gid)
{    
    VFX_LOG_STATIC_FUNC1("%d", gid);
    VfxObject *obj = VfxAppLauncher::getObject(gid);

    VFX_LOG(VFX_INFO, VFX_APPLAUNCHER_TERMINATE, gid, obj);

    if (obj)
    {
        VFX_ASSERT(obj->isKindOf(VFX_OBJ_CLASS_INFO(VfxAppLauncher)) || obj->isKindOf(VFX_OBJ_CLASS_INFO(VfxApp)));
        if (obj->isKindOf(VFX_OBJ_CLASS_INFO(VfxApp)))
        {
            ((VfxApp *)obj)->exit();
        }
        else
        {
            mmi_frm_group_close(gid);
        }
    }
}

VfxObject *VfxAppLauncher::getObject(mmi_id gid)
{
    return VfxObject::handleToObject((VfxObjHandle)mmi_frm_group_get_user_data(gid));
}

VfxApp *VfxAppLauncher::findApp(mmi_id appBaseId, const VfxClassInfo *classInfo, VfxAppLauncherFindAppFlag flag, VfxS32 skipN /*= 0*/)
{
    mmi_id max = mmi_res_get_app_max(appBaseId);
    mmi_id cur;
    VfxApp *app;

    if(flag & VFX_APP_LAUNACHER_FIND_APP_NORMAL_FLAG)
    {
        // traverse top-level history top down
        cur = mmi_frm_scrn_get_neighbor_id(
                GRP_ID_ROOT, 
                GRP_ID_INVALID, 
                MMI_FRM_NODE_AT_LATEST_FLAG);
        while(cur != GRP_ID_INVALID)
        {
            if(cur >= appBaseId && cur < max)
            {
                app = VFX_OBJ_DYNAMIC_CAST(VfxAppLauncher::getObject(cur), VfxApp);
                if(app && (!classInfo || app->isKindOf(classInfo)))
                {
                    if(skipN)
                        skipN--;
                    else
                        return app;
                }
            }

            cur = mmi_frm_scrn_get_neighbor_id(
                    GRP_ID_ROOT, 
                    cur, 
                    MMI_FRM_NODE_BEFORE_FLAG);
        }
    }
    if(flag & VFX_APP_LAUNACHER_FIND_APP_BG_FLAG)
    {
        // traverse top-level history top down
        cur = mmi_frm_scrn_get_neighbor_id(
                GRP_ID_BK, 
                GRP_ID_INVALID, 
                MMI_FRM_NODE_AT_LATEST_FLAG);
        while(cur != GRP_ID_INVALID)
        {
            if(cur >= appBaseId && cur < max)
            {
                app = VFX_OBJ_DYNAMIC_CAST(VfxAppLauncher::getObject(cur), VfxApp);
                if(app && (!classInfo || app->isKindOf(classInfo)))
                {
                    if(skipN)
                        skipN--;
                    else
                        return app;
                }
            }

            cur = mmi_frm_scrn_get_neighbor_id(
                    GRP_ID_BK, 
                    cur, 
                    MMI_FRM_NODE_BEFORE_FLAG);
        }
    }

    return NULL;
}

void VfxAppLauncher::killApp(mmi_id appBaseId, const VfxClassInfo *classInfo, VfxAppLauncherFindAppFlag flag)
{
    mmi_id max = mmi_res_get_app_max(appBaseId);
    mmi_id gid;
    VfxApp *app;
    VfxAppLauncher *launcher;
    VfxS32 i;
	VfxS32 skipN;

    /* Delete VfxAppLauncher objects */
    for (i = 0; i < (VfxS32)s_firstEmptyIdxBeyondUsed; i++)
    {
        gid = s_allocatedId[i];
        
        if ((gid != 0) && (gid >= appBaseId) && (gid < max))
        {
            launcher = VFX_OBJ_DYNAMIC_CAST(VfxAppLauncher::getObject(gid), VfxAppLauncher);
            
            if (launcher && (!classInfo || launcher->m_classInfo->isKindOf(classInfo)))
            {
                VfxAppLauncher::terminate(gid);
            }
        }
    }

    /* Delete VfxApp objects */
    skipN = 0;
    
    do
    { 
        app = VfxAppLauncher::findApp(appBaseId, classInfo, flag, skipN);

        if (app)
        {
            VfxAppLauncher::terminate(app->m_groupId);
            skipN++;
        }
        
    } while (app);
}

mmi_id VfxAppLauncher::createCui(mmi_id appBaseId, VfxClassInfo *classInfo, mmi_id parentId, void *arg, VfxU32 argSize, VfxBool contextLogFlag)
{
    VFX_LOG_STATIC_FUNC1("%d", appBaseId);
    VFX_ASSERT(argSize || (!arg && !argSize));

    VfxAppLauncherParam param(appBaseId, classInfo, parentId);    
    param.setArgument(arg, argSize);
    param.setContextLogging(contextLogFlag);
    return VfxAppLauncher::static_create(param);                                
}

mmi_id VfxAppLauncher::createCuiEx(const VfxAppLauncherParam& param)
{		    
    VFX_ASSERT(param.m_argSize || (!param.m_arg && !param.m_argSize));
    return VfxAppLauncher::static_create(param);     
}

void VfxAppLauncher::runCui(mmi_id groupId)
{
    VFX_LOG_STATIC_FUNC1("%d", groupId);
    VfxAppLauncher::static_run(groupId, VFX_TRUE);
}


VfxU32 VfxAppLauncher::s_firstEmptyIdxBeyondUsed = 0;
mmi_id VfxAppLauncher::s_allocatedId[VFX_APP_LAUNCHER_RES_ID_MAX] = {0};


VfxAppLauncher::VfxAppLauncher() : 
    m_groupId(GRP_ID_INVALID), 
    m_dummyGroupId(GRP_ID_INVALID),
    m_classInfo(NULL), 
    m_arg(NULL), m_argSize(0), 
    m_heap(NULL), m_heapSize(0), m_HeapOffset(0), m_MemPriority(MMI_FRM_APP_MEM_PRIORITY_DEFAULT),
    m_freeContextMemCb(NULL), m_freeContextMemUserData(NULL),
    m_placement(VFX_APP_LAUNCHER_PLACE_DEFAULT), m_placeHint(GRP_ID_INVALID),
    m_flags(0)
{
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("XAL", SA_start);
#endif
}

VfxAppLauncher::~VfxAppLauncher()
{
    VFX_TRACE(("===> [AppLauncher] (0x%x) destructor\n", this));

    mmi_group_node_struct nodeInfo;
    mmi_id groupId = getGroupId();

    /* cancel launcher related prepare */
    mmi_frm_asm_cancel_prepare(groupId, static_proc, getObjHandle()); 

    /* only clear launcher context ptr in user_data when still in launch phase */
    mmi_frm_group_get_info(groupId, &nodeInfo);
    if (nodeInfo.proc == static_proc)
    {
        mmi_frm_group_set_proc_data(groupId, static_proc, NULL);
    }
    
    if (m_arg)
    {
        VFX_FREE_MEM(m_arg);
    }
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("XAL", SA_stop);
#endif
}


void VfxAppLauncher::onContextAllocationFail(mmi_frm_appmem_event_type_enum reason)
{
    VFX_UNUSED(reason);
    VfxAppLauncher::terminate(m_groupId);
}


mmi_id VfxAppLauncher::static_launchByMem(const VfxAppLauncherParam &param)
{
    VfxAppLauncher *launcher;
    mmi_id gid = GRP_ID_INVALID;

    /* create obj from global */
    VFX_OBJ_CREATE(launcher, VfxAppLauncher, VFX_SYS_GLOBAL_CONTEXT);

    // create group first, since APP should return gid after launch
    // but we don't register proc/userData since it should be VfxAPP's
    launcher->saveLaunchParam(param.m_classInfo, param.m_arg, param.m_argSize);
    launcher->m_freeContextMemCb        = param.m_callback ? param.m_callback : VfxAppLauncher::static_freeContextMemCb;
    launcher->m_freeContextMemUserData  = param.m_callbackData;
    launcher->m_launcherResultCb        = param.m_launcherResultCb;
    launcher->m_launcherResultUserData  = param.m_launcherResultUserData;
    launcher->m_HeapOffset = param.m_HeapOffset;
	launcher->m_MemPriority = param.m_MemPriority;

    launcher->m_heap      = param.m_heap;
    if (param.m_heapSize == AUTO_HEAP_SIZE)
    {
        // if heap size is not configured, use base size instead.
        launcher->m_heapSize = launcher->getHeapSize(param.m_appBaseId);
    }
    else
    {
        launcher->m_heapSize  = param.m_heapSize;
    }
    launcher->m_flags = param.m_flags;

    gid = launcher->m_groupId = mmi_frm_group_create(GRP_ID_ROOT, static_genId(param.m_appBaseId), (mmi_proc_func)VfxAppLauncher::static_proc, launcher->getObjHandle());
    mmi_frm_group_set_caller(launcher->m_groupId, param.m_callerId);
	//print trace.
	MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_APP_LAUNCHER_LAUNCH_BY_MEM,gid, launcher->m_heapSize);
    MMI_PRINT(
        MOD_MMI_FW,
        MMI_FW_TRC_G1_FRM,
        "[APP]launch %s app",
        param.m_classInfo->getClassName());


#ifdef  __MMI_ASM_OOM_AUTO_KILL__
	mmi_frm_asm_set_app_priority(gid, launcher->m_MemPriority);
#endif

    VFX_LOG(VFX_INFO, VFX_APPLAUNCHER_LAUNCH_BY_MEM, gid, param.m_classInfo, param.m_callerId, param.m_heap, param.m_heapSize, param.m_callback, param.m_callbackData, param.m_arg, param.m_argSize);

    if(mmi_frm_is_in_backward_scenario())
    {
        // at backward scenario, post the launch
        mmi_event_struct evt;
        MMI_FRM_INIT_EVENT(&evt, 0);
        mmi_frm_post_event(&evt, &VfxAppLauncher::static_postLaunch, (void*)launcher->getObjHandle());
        return gid;
    }

    // enter a dummy screen to force FG release.
    vfx_app_launcher_entry_dummy_screen();
    
    // default reserve
    if (param.m_heap == NULL)
    {
        VadpAsmProperty p;
        VadpAsm::getProperty(gid, p);
        p.f_prepare_w_reserve = 1;
        if (param.m_heapSize > launcher->getHeapSize(param.m_appBaseId))
        {
            p.f_skip_size_checking = 1;
        }
        VadpAsm::setProperty(gid, p);
    }
    
    launcher->createContext();
    return gid;
}


mmi_id VfxAppLauncher::static_launchByContext(const VfxAppLauncherParam &param)
{
    VfxAppLauncher *launcher;
    mmi_id gid = GRP_ID_INVALID;

    /* create obj from global */
    VFX_OBJ_CREATE(launcher, VfxAppLauncher, VFX_SYS_GLOBAL_CONTEXT);

    launcher->saveLaunchParam(VFX_CONST_CAST(param.m_classInfo, VfxClassInfo*), param.m_arg, param.m_argSize);
    gid = launcher->m_groupId = mmi_frm_group_create(GRP_ID_ROOT, static_genId(param.m_appBaseId), (mmi_proc_func)VfxAppLauncher::static_proc, launcher->getObjHandle());
    mmi_frm_group_set_caller(launcher->m_groupId, param.m_callerId);

    launcher->m_placement = param.m_placement;
    launcher->m_placeHint = param.m_placehint;
    launcher->m_launcherResultCb        = param.m_launcherResultCb;
    launcher->m_launcherResultUserData  = param.m_launcherResultUserData;
    launcher->m_context = param.m_context;
	launcher->m_flags = param.m_flags;
    launcher->m_HeapOffset = param.m_HeapOffset;
	launcher->m_MemPriority = param.m_MemPriority;
	//print trace.
	MMI_TRACE(MMI_FW_TRC_G1_FRM, MMI_FRM_APP_LAUNCHER_LAUNCH_BY_CONTEXT,gid);
    MMI_PRINT(
        MOD_MMI_FW,
        MMI_FW_TRC_G1_FRM,
        "%s",
        param.m_classInfo->getClassName());

#ifdef  __MMI_ASM_OOM_AUTO_KILL__
	mmi_frm_asm_set_app_priority(gid, launcher->m_MemPriority);
#endif

    VFX_LOG(VFX_INFO, VFX_APPLAUNCHER_LAUNCH_BY_CTX, gid, param.m_classInfo, param.m_callerId, param.m_context, param.m_arg, param.m_argSize);

    if(mmi_frm_is_in_backward_scenario())
    {
        // at backward scenario, post the launch
        mmi_event_struct evt;
        MMI_FRM_INIT_EVENT(&evt, 0);
        mmi_frm_post_event(&evt, &VfxAppLauncher::static_postLaunchCtx, (void*)launcher->getObjHandle());
        return gid;
    }
 
    // enter a dummy screen to force FG release.
    vfx_app_launcher_entry_dummy_screen();

    launcher->launchCtxSizePrepare(launcher->m_context, 0);
    return gid;
}


mmi_ret VfxAppLauncher::static_launchByContext_proc(mmi_event_struct *evt)
{
    VfxAppLauncher *launcher = (VfxAppLauncher *)VfxObject::handleToObject((VfxObjHandle)evt->user_data);

    if (!launcher)
        return MMI_RET_OK;

    VFX_DEV_ASSERT(launcher->isKindOf(VFX_OBJ_CLASS_INFO(VfxAppLauncher)));
    
    switch(evt->evt_id)
    {
    case EVT_ID_MEM_IS_ENOUGH:
        {
            VFX_LOG(VFX_INFO, VFX_APPLAUNCHER_ASM_READY, launcher->m_groupId);

            VfxContext *pContext = (VfxContext*)launcher->m_freeContextMemUserData;
            VFX_ASSERT(pContext->isKindOf(VFX_OBJ_CLASS_INFO(VfxContext)));
        #if defined(__MMI_USE_MMV2__)
            if (launcher->m_heap == (void*)'HEAP')
                launcher->launchCtxSizePrepare(pContext, 0);
            else
                launcher->onContextReady(pContext, VFX_FALSE, VFX_FALSE);
        #else
            launcher->onContextReady(pContext, VFX_FALSE, VFX_FALSE);
        #endif
        }
        break;
        
    case EVT_ID_MEM_CANCELED:
        {
            mmi_frm_appmem_asm_evt_struct *asm_evt = (mmi_frm_appmem_asm_evt_struct *)evt;
        #if defined(__MMI_USE_MMV2__)
            VFX_ASSERT(launcher->m_heap != (void *)'HEAP');
        #endif
            if (asm_evt->arg.cancel_reason != MMI_FRM_ASM_CANCEL_BY_DEMAND)
            {
                // notify fail/cancel reason
                VFX_LOG(VFX_INFO, VFX_APPLAUNCHER_ASM_CANCEL, launcher->m_groupId, asm_evt->arg.cancel_reason);

                // close dummy group if created.
                if(launcher->m_dummyGroupId != GRP_ID_INVALID)
                {
                    mmi_frm_group_close(launcher->m_dummyGroupId);
                    launcher->m_dummyGroupId = GRP_ID_INVALID;
                }

                if (launcher->m_launcherResultCb)
                {
                    launcher->m_launcherResultCb(VFX_APP_LAUNCHER_RESULT_CANCEL, launcher->m_launcherResultUserData);
					launcher->m_launcherResultCb = NULL;
                }
                launcher->onContextAllocationFail(asm_evt->arg.cancel_reason);
            }
        }
        break;
    }
    return MMI_RET_OK;
}


void VfxAppLauncher::saveLaunchParam(const VfxClassInfo *classInfo, void *arg, VfxU32 argSize)
{
    m_classInfo = classInfo;
 
    /* save arguments for app */
    if (argSize)
    {
        m_argSize = argSize;
        VFX_ALLOC_MEM(m_arg, argSize, this);
        if (arg)
            memcpy(m_arg, arg, argSize);
    }
}


VfxBool VfxAppLauncher::createContext(VfxBool isCui)
{  
    VfxAppContext *context;
    VfxU32 fgSize, baseSize, heapSize, sizeToCheck;
    VFX_DEV_ASSERT(m_heapSize);

    /* get configured size */
    fgSize      = getFgSize(m_groupId);
    baseSize    = getBaseSize(m_groupId);
    heapSize    = getHeapSize(m_groupId);
    sizeToCheck = fgSize + baseSize - heapSize;

    if (!m_heap)
        sizeToCheck += m_heapSize;

    mmi_frm_asm_prepare_flag_type prepareFlags = MMI_FRM_ASM_F_NONE;
    VfxBool logFlag = VFX_FALSE;
    if(m_flags & VFX_APP_LAUNCHER_PARAM_FLAG_FORCE_PREPARE)
        prepareFlags = MMI_FRM_ASM_F_FORCE_PREPARE;
    if(m_flags & VFX_APP_LAUNCHER_PARAM_FLAG_CONTEXT_LOG)
        logFlag = VFX_TRUE;
    
    if (sizeToCheck)
    {           
        // if extra size is larger than 0, check if it's enough    
        if ( !mmi_frm_asm_check_enough_with_subsize(getGroupId(), sizeToCheck, baseSize-heapSize+fgSize) )
        {
            VFX_LOG(VFX_INFO, VFX_APPLAUNCHER_CTX_MEM_NOT_ENOUGH_1, m_groupId, m_heapSize, sizeToCheck);
            // if mem. is not enough, trigger OOM and create context when mem. is enough
            if (!isCui)
            {
                mmi_frm_asm_cancel_prepare(m_groupId, static_proc, getObjHandle());   /* cancel existing prepare */
                mmi_frm_asm_prepare_w_subsize(m_groupId, sizeToCheck, baseSize-heapSize+fgSize,
                                               static_proc, getObjHandle(), prepareFlags);
            }
            return VFX_FALSE;
        }
    }

    /* heap is for SW usage w/ non-continuous memory atrtribute, size check in above check is enough */
    if ((!m_heap) 
#if defined(__MMI_USE_MMV2__)
        && (m_heapSize < SLMM_POOL_MIN_SIZE)
#endif
        )
    {
#if !defined(__MMI_USE_MMV2__)    
        void * pHeapOffset = NULL;     
        if(m_HeapOffset > 0)
        {
            if((pHeapOffset = mmi_frm_asm_alloc_r(m_groupId, m_HeapOffset)) == NULL)
            {/* check size previous, impossible */
                ASSERT(0);
            }
        }
#endif 
        // no dependent mem. required, just allocate for APP's heap
        if ((m_heap = mmi_frm_asm_alloc_r(m_groupId, m_heapSize)) == NULL)
        {
            VFX_LOG(VFX_INFO, VFX_APPLAUNCHER_CTX_MEM_NOT_ENOUGH_2, m_groupId, m_heapSize);
            if (!isCui)
            {
                mmi_frm_asm_cancel_prepare(m_groupId, static_proc, getObjHandle());   /* cancel existing prepare */
                mmi_frm_asm_prepare(m_groupId, m_heapSize, static_proc, getObjHandle(), prepareFlags);
            }
            return VFX_FALSE;
        }
        
#if !defined(__MMI_USE_MMV2__)
        if(m_HeapOffset > 0 && pHeapOffset)
        {    	
            mmi_frm_asm_free_r(m_groupId, pHeapOffset);
            pHeapOffset = NULL;
        }
#endif	
    }
    
    VFX_OBJ_CREATE(context, VfxAppContext, VFX_SYS_GLOBAL_CONTEXT);   // use VfxAppContext since we should notify to free mem later
    
    if (m_freeContextMemCb == &VfxAppLauncher::static_freeContextMemCb)
        m_freeContextMemUserData = (void *)m_groupId;
    
    context->setFreeContextMemCallback(m_freeContextMemCb, m_freeContextMemUserData);
#if defined(__MMI_USE_MMV2__)
    if (!m_heap)
        context->assignPoolWithSlmm(m_groupId, m_heapSize, logFlag);
    else
        context->assignPool(m_groupId, (VfxU8 *)m_heap, m_heapSize, logFlag);
#else
    context->assignPool(m_groupId, (VfxU8 *)m_heap, m_heapSize, logFlag);
#endif
    onContextReady(context, isCui, VFX_TRUE);
    return VFX_TRUE;
}

void VfxAppLauncher::launchCtxSizePrepare(VfxContext *context, U32 flag)
{
#if defined(__MMI_USE_MMV2__)
    if (m_heap != (void*)'HEAP')
    {
        m_freeContextMemUserData = (void*)context;
        m_heap = (void*)'HEAP'; /*callabck is called for heap enlarging*/
		
		if(!context->checkEnlargeHeapPrepare())
		{
			context->enlargeHeapSize(m_groupId, static_launchByContext_proc, 
                                     getObjHandle(),VFX_SYS_MEM_POOL_SLMM_ENLARGE_FLAG_IF_ENOUGH);
		}
        else if (0 == context->enlargeHeapSize(m_groupId, static_launchByContext_proc, 
                                     getObjHandle(),VFX_SYS_MEM_POOL_SLMM_ENLARGE_FLAG_NO_OOM))
        {
            return;
        }
    }
    else
    {
        m_heap = (void*)'DONE'; 
    }
#endif

    if (m_flags & VFX_APP_LAUNCHER_PARAM_FLAG_DO_PREPARE)
    {
        // turn on reserve
        VadpAsmProperty p;
        VadpAsm::getProperty(m_groupId, p);
        p.f_prepare_w_reserve = 1;
        VadpAsm::setProperty(m_groupId, p);

        // if size is larger than 0, check if it's enough    
        VfxU32 totalSize = getBaseSize(m_groupId) + getFgSize(m_groupId);
        if (totalSize > 0 && !mmi_frm_asm_check_enough(m_groupId, totalSize))
        {
            VFX_LOG(VFX_INFO, VFX_APPLAUNCHER_CTX_MEM_NOT_ENOUGH_1, m_groupId, -1, totalSize);
            m_freeContextMemUserData = (void*)context;
            mmi_frm_asm_cancel_prepare(m_groupId, static_launchByContext_proc, getObjHandle());   /* cancel existing prepare */
            mmi_frm_asm_prepare(m_groupId, totalSize, static_launchByContext_proc, getObjHandle(), MMI_FRM_ASM_F_NONE);
            return;
        }
    }
    
    onContextReady(context, VFX_FALSE, VFX_FALSE);
}

void VfxAppLauncher::onContextReady(VfxContext *context, VfxBool isCui, VfxBool needToFreeCtx)
{
    VFX_LOG_FUNC;
    VfxApp *app = (VfxApp *)m_classInfo->createObject(context);
    VFX_DEV_ASSERT(app->isKindOf(VFX_OBJ_CLASS_INFO(VfxApp)));

    VFX_LOG(VFX_INFO, VFX_APPLAUNCHER_CTX_READY, m_groupId, context, app);

    app->m_launcher = this;
    app->m_groupId  = m_groupId;
    app->m_needToFreeCtx = needToFreeCtx;
    app->m_logContext = (m_flags & VFX_APP_LAUNCHER_PARAM_FLAG_CONTEXT_LOG) ? VFX_TRUE : VFX_FALSE;
    
#if defined(__MMI_USE_MMV2__)
    if ( context->getShrinkSize(m_groupId) == VFX_CONTEXT_SIZE_NO_CHANGE
        || context->getShrinkSize(m_groupId) == context->getBufSize())
    {
        app->m_DynHeapSetting = VFX_APP_NO_DYN_HEAP;
    }
    else
    {   /*here means there is dynamic heap size defined in app's res file*/
        if (m_flags & VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_MASK )
        {
            if( m_flags & VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_DISABLE )
                app->m_DynHeapSetting = VFX_APP_NO_DYN_HEAP;
            else
            {
                if( m_flags & VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_IN_ACTIVE_SWITCH )
                    app->m_DynHeapSetting = app->m_DynHeapSetting | VFX_APP_DYN_HEAP_IN_ACTIVE_SWITCH;
                if( m_flags & VFX_APP_LAUNCHER_PARAM_FLAG_DYN_HEAP_IN_HIDDEN_SWITCH )
                    app->m_DynHeapSetting |= VFX_APP_DYN_HEAP_IN_HIDDEN_SWITCH;
            }
        }
        else
        {   /*Dynamic heap default switch-timing: VFX_APP_DYN_HEAP_IN_ACTIVE_SWITCH*/
            app->m_DynHeapSetting |= (U32)VFX_APP_DYN_HEAP_IN_ACTIVE_SWITCH;
        }
    }
#endif    
    mmi_frm_group_set_proc_data(m_groupId, (mmi_proc_func)VfxApp::static_group_proc, app->getObjHandle());  

    if (!isCui)
        static_run(m_groupId, VFX_FALSE);
}


VfxU32 VfxAppLauncher::getHeapSize(mmi_id appId)
{
    VfxU32 heapSize = mmi_res_get_app_heap_size(appId);   
    if (!heapSize)
        heapSize = getBaseSize(appId);
#if defined(__MMI_USE_MMV2__)
    heapSize -= applib_mem_ap_slmm_get_shrunk_heap_size_by_ID(appId);
#endif
    return heapSize;
}


VfxU32 VfxAppLauncher::getFgSize(mmi_id appId)
{
    VfxU32 fgSize = mmi_res_get_app_fg_mem_size(appId);  
    return fgSize;
}

VfxU32 VfxAppLauncher::getBaseSize(mmi_id appId)
{
    VfxU32 baseSize = mmi_res_get_app_base_mem_size(appId);
    return baseSize;
}


mmi_ret VfxAppLauncher::static_proc(mmi_event_struct *evt)
{
    VfxAppLauncher *launcher = (VfxAppLauncher *)VfxObject::handleToObject((VfxObjHandle)evt->user_data);
    mmi_ret ret = MMI_RET_OK;

    if (!launcher)
        return MMI_RET_OK;

    VFX_DEV_ASSERT(launcher->isKindOf(VFX_OBJ_CLASS_INFO(VfxAppLauncher)));
    
    switch(evt->evt_id)
    {
    case EVT_ID_DELETE_DANGLE_GROUP_REQ:
        /* keep dangle group */
        return MMI_RET_ERR;
            
    case EVT_ID_GROUP_DEINIT:
        VFX_LOG(VFX_INFO2, VFX_APPLAUNCHER_GROUP_DEINIT, launcher->m_groupId);
        static_freeId(launcher->m_groupId);
        if (launcher->m_launcherResultCb)
        {
            launcher->m_launcherResultCb(VFX_APP_LAUNCHER_RESULT_CANCEL, launcher->m_launcherResultUserData);
        }
        VFX_OBJ_CLOSE(launcher);
        break;

    case EVT_ID_MEM_IS_ENOUGH:
        VFX_LOG(VFX_INFO, VFX_APPLAUNCHER_ASM_READY, launcher->m_groupId);
        launcher->createContext();
        break;
        
    case EVT_ID_MEM_CANCELED:
        {
            mmi_frm_appmem_asm_evt_struct *asm_evt = (mmi_frm_appmem_asm_evt_struct *)evt;
            if (asm_evt->arg.cancel_reason != MMI_FRM_ASM_CANCEL_BY_DEMAND)
            {
                // notify fail/cancel reason
                VFX_LOG(VFX_INFO, VFX_APPLAUNCHER_ASM_CANCEL, launcher->m_groupId, asm_evt->arg.cancel_reason);

                // close dummy group if created.
                if(launcher->m_dummyGroupId != GRP_ID_INVALID)
                {
                    mmi_frm_group_close(launcher->m_dummyGroupId);
                    launcher->m_dummyGroupId = GRP_ID_INVALID;
                }
    
                if (launcher->m_launcherResultCb)
                {
                    launcher->m_launcherResultCb(VFX_APP_LAUNCHER_RESULT_CANCEL, launcher->m_launcherResultUserData);
					launcher->m_launcherResultCb = NULL;
                }
                launcher->onContextAllocationFail(asm_evt->arg.cancel_reason);
            }
        }
        break;
        
    default:
        VFX_LOG(VFX_INFO3, VFX_APPLAUNCHER_NON_HANDLED_EVT, launcher->m_groupId, evt->evt_id);
        break;
    }
    return ret;
}

mmi_id VfxAppLauncher::static_create(const VfxAppLauncherParam& param)
{    
    VfxAppLauncher *launcher;
    
    /* create obj from global */
    VFX_OBJ_CREATE(launcher, VfxAppLauncher, VFX_SYS_GLOBAL_CONTEXT);
    
    // create group first, since APP should return gid after launch
    // but we don't register proc/userData since it should be VfxAPP's
    launcher->saveLaunchParam(param.m_classInfo, param.m_arg, param.m_argSize);
    launcher->m_freeContextMemCb = VfxAppLauncher::static_freeContextMemCb;
    launcher->m_freeContextMemUserData = NULL;
    launcher->m_flags = param.m_flags;
    launcher->m_heap      = param.m_heap;
    launcher->m_heapSize  = (param.m_heapSize == AUTO_HEAP_SIZE) ? launcher->getHeapSize(param.m_appBaseId) : param.m_heapSize;
    launcher->m_launcherResultCb       = NULL;
    launcher->m_launcherResultUserData = NULL;
    launcher->m_HeapOffset = param.m_HeapOffset;
    
    /* allocate memory from ASM, check memory config first */    
    if (param.m_heap == 0) 
    {
        VadpAsmProperty p;
        mmi_id rootAppId = mmi_frm_get_root_app(param.m_callerId);

        VadpAsm::getProperty(rootAppId, p);
        if (p.f_skip_size_checking == 0)
        {
            if ((launcher->m_heapSize > launcher->getBaseSize(rootAppId)) ||
                (launcher->getBaseSize(param.m_appBaseId)+launcher->getFgSize(param.m_appBaseId) > launcher->getBaseSize(rootAppId)+launcher->getFgSize(rootAppId)))
            {
                VFX_ASSERT(0);  // memory config is incorrect among APP and CUI, please check it.
            }
        }
    }
    
    launcher->m_groupId = mmi_frm_group_create(param.m_callerId, static_genId(param.m_appBaseId), (mmi_proc_func)VfxAppLauncher::static_proc, launcher->getObjHandle());

    // enter in-group dummy group to force parent release FG memory.
    mmi_id dummyId = mmi_frm_group_create(param.m_callerId, GRP_ID_AUTO_GEN, vfx_app_launcher_dummy_proc, NULL);
    mmi_frm_group_enter(dummyId, MMI_FRM_NODE_NONE_FLAG);

    if (launcher->createContext(VFX_TRUE) == VFX_FALSE)
    {
        mmi_frm_group_close(dummyId); // remove in-group dummy group when fail to allocate

        mmi_frm_group_close(launcher->m_groupId);
        return GRP_ID_INVALID;
    }
        
    launcher->m_dummyGroupId = dummyId;
    VFX_LOG(VFX_INFO, VFX_APPLAUNCHER_CUI_CREATE, launcher->m_groupId, param.m_classInfo, param.m_callerId, param.m_heap, param.m_heapSize, param.m_arg, param.m_argSize);
    return launcher->m_groupId;
}

void VfxAppLauncher::static_run(mmi_id groupId, VfxBool isCui)
{
    VfxApp *app = VfxApp::getObject(groupId);
    VFX_LOG_STATIC_FUNC2("%d, <%X>", groupId, app);

    VfxAppLauncher *launcher = (VfxAppLauncher *)app->m_launcher;
    app->m_launcher = NULL;

    switch(launcher->m_placement)
    {
    case VFX_APP_LAUNCHER_PLACE_AFTER:
        {
            mmi_frm_node_struct group_info;
            group_info.id = launcher->m_groupId;
            group_info.entry_proc = (mmi_proc_func)VfxAppLauncher::static_proc;
            group_info.user_data = launcher->getObjHandle();

            mmi_frm_group_insert(
                GRP_ID_ROOT,
                launcher->m_placeHint,
                &group_info,
                MMI_FRM_NODE_AFTER_FLAG);

            // do not allow group auto-close
            mmi_frm_group_set_attribute (launcher->m_groupId, MMI_FRM_NODE_NONE_FLAG);
        }
        break;

    default:
        mmi_frm_group_enter(launcher->m_groupId, MMI_FRM_NODE_NONE_FLAG); // do not allow group auto-close    
        break;
    }
    //close dummy screen if created
    mmi_frm_scrn_close(GRP_ID_ROOT, SCR_ID_DUMMY);

    // close dummy group if created.
    if(launcher->m_dummyGroupId != GRP_ID_INVALID)
    {
        mmi_frm_group_close(launcher->m_dummyGroupId);
        launcher->m_dummyGroupId = GRP_ID_INVALID;
    }

    vfx_adp_sse_setup_transit(isCui ? VFX_SCR_TRANSIT_TYPE_CUI : VFX_SCR_TRANSIT_TYPE_APP, VFX_TRUE, VFX_SCR_TRANSIT_PRIORITY_APP);
    
    app->processRun(launcher->m_arg, launcher->m_argSize);

    if (launcher->m_launcherResultCb)
    {
        launcher->m_launcherResultCb(VFX_APP_LAUNCHER_RESULT_OK, launcher->m_launcherResultUserData);
    }
    VFX_OBJ_CLOSE(launcher);   
}


mmi_id VfxAppLauncher::static_genId(mmi_id appBaseId)
{
    // TODO: do with better algorithm
    VfxS32 i;
    VfxU32 emptySpace = s_firstEmptyIdxBeyondUsed;
    mmi_id id = appBaseId;
    for (i=0; i<(VfxS32)s_firstEmptyIdxBeyondUsed; i++)
    {
        if (s_allocatedId[i] == id)
        {
            id++;
            i = -1;    // search from begin
            VFX_ASSERT(id < mmi_res_get_app_max(appBaseId));
        }
        else if (s_allocatedId[i] == 0)
        {
            emptySpace = (VfxU32)i;
        }
    }
    if ((emptySpace >= s_firstEmptyIdxBeyondUsed) && (emptySpace < VFX_APP_LAUNCHER_RES_ID_MAX))
        s_firstEmptyIdxBeyondUsed = emptySpace+1;
    s_allocatedId[emptySpace] = id;
    return id;
}

void VfxAppLauncher::static_freeId(mmi_id id)
{
    VfxU32 i;
    for (i=0; i<s_firstEmptyIdxBeyondUsed; i++)
    {
        if (s_allocatedId[i] == id)
        {
            s_allocatedId[i] = 0;
            break;
        }
    }
}

void VfxAppLauncher::static_freeContextMemCb(void *memPtr, void *userData)
{
    mmi_frm_asm_free_r((mmi_id)(VfxU32)userData, memPtr);
}


mmi_ret VfxAppLauncher::static_postLaunch(mmi_event_struct *evt)
{
    VfxAppLauncher *launcher = (VfxAppLauncher*)VfxObject::handleToObject((VfxObjHandle)evt->user_data);
    if(launcher && launcher->isKindOf(VFX_OBJ_CLASS_INFO(VfxAppLauncher)))
    {
        // enter a dummy screen to force FG release.
        vfx_app_launcher_entry_dummy_screen();

        // default reserve
        if (launcher->m_heap == NULL)
        {
            VadpAsmProperty p;
            VadpAsm::getProperty(launcher->m_groupId, p);
            p.f_prepare_w_reserve = 1;
            if (launcher->m_heapSize > launcher->getHeapSize(launcher->m_groupId))
            {
                p.f_skip_size_checking = 1;
            }
            VadpAsm::setProperty(launcher->m_groupId, p);
        }
        
        launcher->createContext();
    }
    return MMI_RET_OK;
}

mmi_ret VfxAppLauncher::static_postLaunchCtx(mmi_event_struct *evt)
{
    VfxAppLauncher *launcher = (VfxAppLauncher*)VfxObject::handleToObject((VfxObjHandle)evt->user_data);
    if(launcher && launcher->isKindOf(VFX_OBJ_CLASS_INFO(VfxAppLauncher)))
    {
        // enter a dummy screen to force FG release.
        vfx_app_launcher_entry_dummy_screen();

        launcher->launchCtxSizePrepare(launcher->m_context, 0);
    }
    return MMI_RET_OK;
}

mmi_id VfxAppLauncher::getGroupId()
{
    return m_groupId;
}


/***************************************************************************** 
*  Class VfxAppContext
*****************************************************************************/

VFX_IMPLEMENT_CLASS("AppContext", VfxAppContext, VfxContext);

void VfxAppContext::setFreeContextMemCallback(VfxAppContextCbType cb, void *userData)
{
    m_freeMemCallback = cb;
    m_userData = userData;
    VFX_LOG(VFX_INFO, VFX_APPCONTEXT_SET_CB, this, cb, userData);
}


void VfxAppContext::onAfterDeinit()
{
    void *heap = getBuf();
           
    VFX_LOG(VFX_INFO, VFX_APPCONTEXT_ON_DEINIT, this, heap, m_freeMemCallback, m_userData);

    // release Pool first, so that callback can safely release the buffer
    deletePool();

    if (heap)
    {
        if (m_freeMemCallback)
            m_freeMemCallback(heap, m_userData);
    }
    VfxContext::onAfterDeinit();
}


void VfxAppContext::onObjectNotify(VfxId id, void *userData)
{
    switch (id)
    {
        case VFX_OBJECT_NOTIFY_ID_AFTER_DEINIT:
        {
            onAfterDeinit();
            return;
        }
        default:
        {
            VfxContext::onObjectNotify(id, userData);
            return;
        }
    }
}


#if defined(__MMI_USE_MMV2__)
VfxU32 VfxAppContext::onGetShrinkSize(mmi_id app_id)
{
    VfxU32 shrinkSize = mmi_res_get_app_heap_shrink_size(app_id);
    return shrinkSize > 0 ? shrinkSize : VFX_CONTEXT_SIZE_NO_CHANGE;
}
#endif

static void vfx_app_launcher_entry_dummy_screen(void)
{
    // Notice top level that next screen is a venus screen
    VfxTopLevel *topLevel = VFX_OBJ_GET_INSTANCE(VfxTopLevel);
    topLevel->setNextScreenIsVenus();
    
    if(mmi_frm_scrn_enter(GRP_ID_ROOT, SCR_ID_DUMMY, NULL, vfx_app_launcher_entry_dummy_screen, MMI_FRM_FULL_SCRN))
    {
        ShowCategoryDummyScreen();
        mmi_frm_scrn_clear_attribute(GRP_ID_ROOT, SCR_ID_DUMMY, MMI_SCRN_ATTRIB_ADD_HISTORY);
        
        // This is to "flush post event queue" triggered by previous app/screen
        vfx_mmi_check_update();
    }
}

static mmi_ret vfx_app_launcher_dummy_proc(mmi_event_struct *evt)
{
    return MMI_RET_OK;
}

